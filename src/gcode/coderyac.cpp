/*******************************************************************************
A parser program in C++, generated by Upgen 0.5.1.
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
typedef unsigned char by_te_t;

class bufbase_t;
typedef bufbase_t *YYPBUFFER;

#include "./coderyac.h"

#line 33 "../meta/coderyac.upg"

/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2016  Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "../main/upgmain.h"
#ifdef UPGEN_TEST_VERSION
#include <iostream>
using std::cerr;
using std::endl;
#endif

#include <iosfwd>
using std::ostream;

#include "../common/common.h"
#include "../common/reporter.h"

#include "../common/strhelper.h"
using common_ns::strhelper_t;
#include "../common/types.h"

#include "../coder/ctoken.h"
using coder_ns::ctoken_t;
#include "../coder/cmacro.h"
#include "../coder/cmcond.h"
#include "../coder/dmmap.h"
#include "../coder/coder.h"
#include "../coder/cmmgr.h"
using coder_ns::coder_t;
using coder_ns::cmacro_mgr_t;
using coder_ns::dmmap_t;
using coder_ns::vterm_t;
using coder_ns::cmacro_t;
using coder_ns::cond_t;
using coder_ns::cond_elemrel_t;
using coder_ns::cond_compound_t;
using coder_ns::cond_item_t;
using coder_ns::mac2cond_pair_t;
using coder_ns::vmac2cond_t;
using coder_ns::cmacro_term_t;


#line 78 "coderyac.cpp"

#define	INC_YYTEXT_SIZE		4096
#define LINESIZE_STACK_LENG	32
#define TABSIZE_STACK_LENG	64
#define END_OF_FILE			256
#define END_OF_ALLFILE		257

// start-condition names
#define INITIAL 0

// number of DFA states of scanner
#define LEX_STATE_COUNT   174

// DFA trap-state of scanner
#define LEX_ERROR_STATE    0

// ID of invalid rule for scanner,
// indicating current string can not be matched by any pattern
#define LEX_ERROR_RULE    -1

// this constant used by computing index of a rule that matches EOF
// for example, in start-condition INITIAL, index of the rule that
// matches EOF is 
//	LEX_EOFRULE_BASE + INITIAL
#define LEX_EOFRULE_BASE   37

// index of the rule that matches EOAF (end of all files, or end of input)
#define LEX_EOAF_RULE   38


// index of symbol `$end' in symbol table
#define PARSE_ENDSYMB_INDEX   0
// index of symbol `error' in symbol table
#define PARSE_ERRORSYMB_INDEX   1
// index of symbol `$undef' in symbol table
#define PARSE_UNDEFSYMB_INDEX   2

// ID of symbol `$end'
#define PARSE_ENDSYMB_ID   0
// ID of symbol `error'
#define PARSE_ERRORSYMB_ID   256
// ID of symbol '$undef'
#define PARSE_UNDEFSYMB_ID   257

// row size(in byte) of non-error bitmap of parse table
#define PARSE_BMAP_ROWSIZE	6
// base address of indexes of types (aka non-terminals or variables)
#define PARSE_TYPE_BASE   43
// number of symbols in parser
#define PARSE_SYMBOL_COUNT   75

// number of symbols in parser
#define PARSE_TOKENMAP_SIZE   291

// start state of parser
#define PARSE_START_STATE   1

// accept state of parser
#define PARSE_ACCEPT_STATE   5

// illegal state for parser
#define PARSE_ERROR_STATE   145

// special ID of invalid rule for parser, indicating current lookahead
// symbol can not be shifted
#define PERROR_RULE   77

#define	MAX_MSG_LENG 		128

// macros for wrapped new operator
#define MYNEW(var, type) {\
	var = new type;\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYNEWS(var, type, size) {\
	var = new type[size];\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYRENEW(var, type, size, osize) {\
	type *p = new type[size];\
	if(!p) {\
		exit_on_oom();\
	}\
	memcpy(p, var, sizeof(type) * osize);\
	delete[] var;\
	var = p;\
}

// error IDs
enum {
	// grammar is accepted by automation
	YYE_ACCEPT =	1,
	// indicate automation is alive
	YYE_ALIVE =	2,
	// run out of all buffers,
	// and token `$end' will be sent to parser
	YYE_EOS =	3,
	// lexical analysis terminated manually,
	// and token `$end' will be sent to parser
	YYE_TERM =	3,
	// syntactic error occurs, and try to error-recover
	YYE_PERROR =	4,

	// can not match any pattern, token `$undef' will
	// be sent to parser
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID,

	// out of memory
	YYE_OOM = 	-1,
	// out of range
	YYE_OOR =	-2,
	// I/O error
	YYE_IO =	-3,
	// parsing aborted
	YYE_ABORT = 	-4,
	YYE_NOINPUT =	-5,
};


template<class INT_TYPE, int STACK_SIZE>
class cycstack_t {

public:
	inline cycstack_t(void)
	: m_nBase(0)
	, m_nTop(0) {
	}
	inline void push(INT_TYPE a_nSize) {
		m_nTop = (m_nTop + 1) % STACK_SIZE;
		m_nElem[m_nTop] = a_nSize;
		if(m_nTop == m_nBase) {
			m_nBase = (m_nTop + 1) % STACK_SIZE;
		}
	}
	inline INT_TYPE pop(void) {
		if(m_nTop != m_nBase) {
			INT_TYPE sz = m_nElem[m_nTop];
			m_nTop = (m_nTop + STACK_SIZE - 1) % STACK_SIZE;
			return sz;
		}
		return 0;
	}
	inline void clear(void) {
		m_nTop = m_nBase;
	}	
private:
	INT_TYPE m_nElem[STACK_SIZE];
	short m_nBase, m_nTop;
};

class bufbase_t {

public:
	virtual ~bufbase_t(void){}
	virtual int get(void) = 0;
	virtual int peek(void) = 0;
	virtual int unget(void) = 0;
	virtual int unget(int num) = 0;
	virtual int put(char) = 0;

	inline void reset(void) {
		xreset();
		stlsz.clear();
		sttsz.clear();
	}
	inline bool iseof(void) const { return gptr == gend;}
	inline bool iseos(void) const { return eos;	}
	inline bool isimod(void) const { return imod;}
	inline void setimod(bool bi) { imod = bi;}
	inline int getlineno(void) const { return line;}
	inline void setlineno(int nline) { line = nline;}
	inline int getcolno(void) const { return col;}
	inline void setcolno(int ncol) { col = ncol;}
	inline int gettabsize(void) const { return tab;}
	inline void settabsize(int ntab) { tab = (ntab > 0)? ntab : 1;}

	inline void* getdata(void) const { return pvoid; }
	inline void setdata(void* pv) { pvoid = pv; }
protected:
	virtual void xreset(void) = 0;

	by_te_t *pbase;
	by_te_t *gptr;
	by_te_t *gend;
	bool eos;
	// interactive mode
	bool imod;
	int line;
	int col;
	int tab;
	
	void *pvoid;

public:
	inline void pushlsz(int nlsize) {
		stlsz.push((short)nlsize);
	}
	inline int poplsz(void) {
		return stlsz.pop();
	}
	inline void pushtsz(int ntsize) {
		sttsz.push((by_te_t)ntsize);
	}
	inline int poptsz(void) {
		return sttsz.pop();
	}
protected:
	cycstack_t<short, LINESIZE_STACK_LENG> stlsz;
	cycstack_t<by_te_t, TABSIZE_STACK_LENG> sttsz;

};

xstype_t coder_lval;
xltype_t coder_lloc;


// program abort due to out of memory
inline static void exit_on_oom(void) {
	exit(-1);
}
static char stext__[24] = "unprintable-char{";
inline static const char* sym_text__(const char* ps) {
	
	by_te_t b = (by_te_t)*ps, i = 17, t;
	if( !ps[1] && (b < 32 || b >= 127)) {
		if((t = b / 100) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 100;
		}
		if((t = b / 10) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 10;
		}
		stext__[i++] = (char)(b + 48);
		stext__[i++] = '}';
		stext__[i] = '\0';
		return stext__;
	}
	return ps;
}

class coder_parser_t {

	friend coder_error_t coder_seterror(coder_error_t);
	friend coder_lex_t coder_setlex(coder_lex_t);

private:

	// class bufmgr_t class define HERE
	class bufmgr_t {

	public:

		enum {
			// half size of buffer
			BUF_HALF_SIZE = 4096,
			// fullsize of buffer
			BUF_FULL_SIZE = BUF_HALF_SIZE * 2
		};

	private:
		class filebuf_t: public bufbase_t {

			friend class bufmgr_t;
		private:

			inline void init(void) {

				gptr = pbase = &buf[BUF_FULL_SIZE - 1];
				gend = &buf[0];
				eos = false;
				bpeeked = false;
			}

		public:

			filebuf_t(FILE* pf = stdin)
			: pfile(pf) {
				imod = (pf == stdin);
				line = 1;
				col = 1;
				tab = 4;
				pvoid = nullptr;
				init();
			}

			virtual ~filebuf_t(void) {

				if(pfile != stdin) {

					fclose(pfile);
				}
			}

			virtual void xreset(void) {

				if(pfile != stdin) {
					fseek(pfile, 0, SEEK_SET);
				}
				init();
			}

			virtual int get(void) {

				if(gptr == gend) {

					eos = true;
					return END_OF_ALLFILE;
				}

				gptr = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(gptr == gend && !bpeeked) {

					fill(gptr);
				}

				bpeeked = false;

				return iseof()? END_OF_FILE: (int)(*gptr);
			}

			virtual int peek(void) {

				if(gptr == gend) {

					return END_OF_ALLFILE;
				}

				by_te_t *p = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(p == gend) {

					fill(p);
				}

				bpeeked = true;

				return (p == gend)? END_OF_FILE: (int)(*p);
			}

			virtual int unget(void) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

			virtual int unget(int num) {

				if(eos || gptr == pbase) {
					return 0;
				}
				int n = ((gptr - pbase) + BUF_FULL_SIZE) % BUF_FULL_SIZE;

				if(n > num) {
					n = num;
				}
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - n) % BUF_FULL_SIZE;

				return n;
			}
		
			virtual int put(char c) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				*gptr = (by_te_t)c;
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

		private:

			int fill(by_te_t *p) {

				int ncnt = 0;
				int vacents = ((pbase + BUF_FULL_SIZE) - gend) % BUF_FULL_SIZE;
				if(stdin != pfile) {
					while((ncnt = fread(p, 1, BUF_HALF_SIZE, pfile)) == 0 && ferror(pfile)) {
						if(errno != EINTR) {
							// IO error
							return 0;
						}
						clearerr(pfile);
						errno = 0;
					}
					gend = buf + (p - buf + ncnt) % BUF_FULL_SIZE;
				}
				else {
					for(int c = 0; '\n' !=  c && ncnt < BUF_HALF_SIZE;
						gend = buf + ((gend - buf) + 1) % BUF_FULL_SIZE, ++ncnt) {

						c = fgetc(stdin);
						*gend = (by_te_t)c;
						if(EOF == c && feof(pfile)) {
							break;
						}
					}
				}
				if(ncnt > vacents) {
					pbase = buf + ((gend - buf) + 1) % BUF_FULL_SIZE;
				}
				return ncnt;
			}

		private:

			bool bpeeked;
			FILE *pfile;
			by_te_t buf[BUF_FULL_SIZE];
		};

	private:

		class strbuf_t: public bufbase_t {

			friend class bufmgr_t;
		public:

			// nSize is length of string including terminating nullptr
			strbuf_t(const char *pchBuf, int nSize)
			: bowner(true) {

				MYNEWS(pbase, by_te_t, nSize);
				memcpy(pbase, pchBuf, sizeof(char)*(nSize - 1));
				pbase[nSize - 1] = '\0';

				gend = pbase + nSize - 1;
				xreset();
				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = nullptr;
			}

			strbuf_t(char *pchBuf, int nSize)
			: bowner(false) {

				pbase = (by_te_t*)pchBuf;
				gend = pbase + nSize - 1;
				xreset();

				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = nullptr;
			}

			virtual ~strbuf_t(void) {
				if(bowner) {
					delete [] pbase;
				}
			}

		public:

			virtual void xreset(void) {

				gptr = pbase - 1;
				eos = false;
			}
			virtual int get(void) {

				if(gptr == gend) {
					eos = true;
					return END_OF_ALLFILE;
				}
				++gptr;

				return (gptr == gend)? END_OF_FILE : (int)(*gptr);
			}

			virtual int peek(void) {

				return (gptr == gend) ? (eos ? END_OF_ALLFILE: END_OF_FILE) : 
					(int)(*(gptr + 1));
			}
			virtual int unget(void) {
				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}
				return (int)(*gptr--);
			}
			virtual int unget(int num) {

				if(eos || (pbase - 1 == gptr)) {
					return 0;
				}
				int n = gptr - pbase + 1;
				if(n > num) {
					n = num;
				}
				gptr -= n;

				return n;
			}

			virtual int put(char c) {

				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);

				*gptr-- = (by_te_t)c;

				return oldc;
			}

		private:
			bool bowner;
		};

	private:

		struct link_t {

			link_t(bufbase_t *pxb, link_t *plnk = nullptr)
			: pxbuf(pxb)
			, plink(plnk){}

			bufbase_t *pxbuf;
			link_t *plink;
		};

	public:

		bufmgr_t(void)
		: phead(nullptr) {

			MYNEW(pstdin, filebuf_t);
			MYNEW(pavail, link_t(pstdin, nullptr));
		}
		~bufmgr_t(void) {

			while(pavail) {

				link_t *p = pavail->plink;

				delete pavail->pxbuf;
				delete pavail;

				pavail = p;
			}			
		}

	public:

		inline int get(void) {
			return phead? phead->pxbuf->get(): END_OF_ALLFILE;
		}
		inline int peek(void) {
			return phead? phead->pxbuf->peek(): END_OF_ALLFILE;
		}
		inline int unget(void) {
			return phead? phead->pxbuf->unget(): END_OF_FILE;
		}
		inline int unget(int num) {
			return phead? phead->pxbuf->unget(num): 0;
		}
		inline int put(char c) {
			return phead? phead->pxbuf->put(c): END_OF_FILE;
		}
		inline bool iseof(void) const {
			return phead? phead->pxbuf->iseof(): true;
		}
		inline bool iseos(void) const {
			return phead? phead->pxbuf->iseos(): true;
		}
		inline bool isimod(void) const {
			return phead? phead->pxbuf->isimod(): false;
		}
		inline int getlineno(void) const {
			 return phead? phead->pxbuf->getlineno(): 0;
		}
		inline void setlineno(int nline) {
			if(phead) {
				phead->pxbuf->setlineno(nline);
			}
		}
		inline int getcolno(void) const {
			return phead? phead->pxbuf->getcolno(): 0;
		}
		inline void setcolno(int ncol) {
			if(phead) {
				phead->pxbuf->setcolno(ncol);
			}
		}
		inline int gettabsize(void) const {
			return phead? phead->pxbuf->gettabsize(): 0;
		}
		inline void settabsize(int ntab) {
			if(phead) {
				phead->pxbuf->settabsize(ntab);
			}
		}
		inline void reset(void) {
			if(phead) {
				phead->pxbuf->reset();
			}
		}
		inline void pushlsz(int nlsize) {
			if(phead) {
				phead->pxbuf->pushlsz(nlsize);
			}
		}
		inline int poplsz(void) {
			if(phead) {
				return phead->pxbuf->poplsz();
			}
			return 0;
		}
		inline void pushtsz(int ntsize) {
			if(phead) {
				phead->pxbuf->pushtsz(ntsize);
			}
		}
		inline int poptsz(void) {
			if(phead) {
				return phead->pxbuf->poptsz();
			}
			return 0;
		}


		inline bufbase_t* current(void) const {
			return phead ? phead->pxbuf : nullptr;
		}

		inline bool empty(void) const {
			return ! phead;
		}

		inline bufbase_t* newbuf(FILE *pfile, bool iMod = false) {

			bufbase_t *p;
			if(pfile == stdin) {
				p = pstdin;
				p->reset();
			}
			else {
				MYNEW(p, filebuf_t(pfile));
				MYNEW(pavail->plink, link_t(p, pavail->plink));
			}
			
			p->setimod(iMod);
			
			return p;
		}
		inline bufbase_t* newbuf(char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		inline bufbase_t* newbuf(const char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		
		inline bufbase_t* switchto(bufbase_t* pbuf) {

			bufbase_t *pold = phead ? phead->pxbuf : nullptr;
			link_t* p = rmwork(pbuf);
			if( ! p) {
				MYNEW(phead, link_t(pbuf, phead));
			}
			else {
				p->plink = phead;
				phead = p;
			}
			
			return pold;
		}
		
		inline bufbase_t* pop(void) {
			
			if(! phead) {
				return nullptr;
			}
			
			link_t *p = phead;
			bufbase_t* pbuf = p->pxbuf;
			phead = phead->plink;
			
			delete p;
			
			return pbuf;
		}

		void destroytop(void) {
			
			bufbase_t *pxb = pop();
			if( pxb && pxb != pstdin) {

				link_t *p = pavail;
				
				while(p->plink && p->plink->pxbuf != pxb) {
					p = p->plink;
				}
				if(p->plink) {
					link_t *q = p->plink;
					p->plink = q->plink;

					delete pxb;
					delete q;
				}
			}
		}
		
		void destroyall(void) {

			while(pavail->plink) {
				link_t *p = pavail->plink;
				pavail->plink = p->plink;
				if(p->pxbuf) {
					delete p->pxbuf;
				}
				delete p;
			}
			
			phead = nullptr;
		}

	private:

		link_t* rmwork(bufbase_t* pxb) {

			link_t *p = phead;
			// then check if @pxb is in the list, if so, then remove it
			if(p) {

				if(pxb == phead->pxbuf) {
					phead = phead->plink;
					return p;
				}
				else {
					while(p->plink && p->plink->pxbuf != pxb) {
						p = p->plink;
					}
					if(p->plink) {
						link_t *q = p->plink;
						p->plink = q->plink;
						return q;
					}
				}
			}

			return nullptr;
		}

	private:

		// working buffer stack
		link_t *phead;
		// available buffer stack
		link_t *pavail;
		// stdin buffer
		bufbase_t *pstdin;
	};


	template<class ElemType, int INIT_SIZE = 4096, int INC_SIZE = 1024>
	class sstack_t {
	private:
		ElemType *pbase;
		int size;
		int ntop;

	public:
		inline sstack_t(void)
		: pbase(nullptr)
		, size(INIT_SIZE)
		, ntop(-1) {
			MYNEWS(pbase, ElemType, INIT_SIZE);
		}
		inline ~sstack_t(void) {
			if(pbase) {
				delete[] pbase;
			}
		}

		inline void push(void) {
			if(ntop == size - 1) {
				MYRENEW(pbase, ElemType, INC_SIZE + size, size);
				size += INC_SIZE;
			}
			++ntop;
		}
		inline void push(const ElemType &e) {
			if(ntop == size - 1) {
				MYRENEW(pbase, ElemType, INC_SIZE + size, size);
				size += INC_SIZE;
			}
			pbase[++ntop] = e;
		}
		inline ElemType& top(void) {
			return pbase[ntop];
		}
		inline const ElemType& top(void) const {
			return pbase[ntop];
		}
		inline void pop(int n) {
			ntop -= n;
		}
		inline ElemType& operator[](int down) {
			return pbase[ntop - down];
		}
		inline const ElemType& operator[](int down) const {
			return pbase[ntop - down];
		}

		inline bool empty(void) const {
			return ntop < 0;
		}

		inline int count(void) const {
			return ntop + 1;
		}

		inline void clear(void) {
			ntop = -1;
		}
	};


private:

	inline void renew_text__(void) {

		MYRENEW(yytext, char, INC_YYTEXT_SIZE + yysize__, yysize__);
		yysize__ += INC_YYTEXT_SIZE;
		yytext[yysize__ - 1] = '\0';
	}

	inline bool yylex_is_running__(void) const {
		return yyecode__ == YYE_ALIVE;
	}
	inline int yyget_lexrule__(int s) const{
		return yydaccpt[s];
	}

	int yynext_lexstate__(int s, int c) const {

		int d = yydcmap[c];
		while(s < LEX_STATE_COUNT && yydchk[ yydbase[s] + d] != s) {
			s = yyddef[s];
		}

		if(s > LEX_STATE_COUNT) {
			return yydchk[yydbase[s] + yydmeta[d]] == s?
				yydnxt[ yydbase[s] + yydmeta[d]] : LEX_ERROR_STATE;
		}
		else {
			return yydnxt[ yydbase[s] + d];
		}
	}

	inline static void yyemit_error__(const char *s, coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
		fprintf(stderr, "%s\n", s);
	}

private:

	inline void YYACCEPT(void) {
		yyecode__ = YYE_ACCEPT;
	}
	inline void YYABORT(void) {
		yyecode__ = YYE_ABORT;
	}
	inline void yyerrok(void) {
		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;
	}

	inline bool yyparse_is_running__(int s) const {
		return yyecode__ > YYE_ACCEPT && s != PARSE_ACCEPT_STATE;
	}
	inline int yyget_defrule(int s) const {
		if(0 == yyparn[s] && is_valid_prule__(yyget_prule__(yyparv[s])) ) {
			return yyget_prule__(yyparv[s]);
		}
		return PERROR_RULE;
	}
	inline bool is_valid_pstate__(int s) const {
		return s < PARSE_ERROR_STATE;
	}
	inline bool is_valid_prule__(int r) const {
		return r >= 0 && r < PERROR_RULE;
	}
	inline int yyget_prule__(int s) const {
		return s - (PARSE_ERROR_STATE + 1);
	}
	inline void yydiscard__(xstype_t &yydval, xltype_t  &yydloc, int yydsymb) {
	
	}
	inline int yynext_pstate__(int s, int t) const {
		if(yyvbmap[s * PARSE_BMAP_ROWSIZE + t / 8] & (1 << (t % 8))) {
			if(yyparn[s] < yypcn[t]) {
				return yyparv[s];
			}
			else if(yyparn[s] > yypcn[t]) {
				return yypcv[t];
			}
			return yypact[yypabase[s] + t];
		}
		return PARSE_ERROR_STATE;
	}
	inline int yynext_goto__(int s, int t) const {
		if(yypgrn[s] < yypcn[PARSE_TYPE_BASE + t]) {
			return yypgrv[s];
		}
		else if(yypgrn[s] > yypcn[PARSE_TYPE_BASE + t]) {
			return yypcv[PARSE_TYPE_BASE + t];
		}
		return yypgoto[yypgbase[s] + t];
	}

public:

	inline coder_parser_t(coder_lex_t plex = nullptr)
	: yyecode__(YYE_ALIVE)
	, yysize__(0)
	, yystart__(INITIAL)
	, yymore_flag__(false)
	, yyat_bol__(true)
	, yytext(nullptr)
	, yyleng(0)
	, yylaleng(0)
	, yyerr_flag__(false)
	, yyltok(PARSE_UNDEFSYMB_ID)
	, yylexer(plex)
	, yyerror(yyemit_error__) {

	}
	~coder_parser_t(void) {

		if(yytext) {
			delete[] yytext;
		}

	}

	inline bool yylexinit__(const char *pchFile, bool bi) {

		YYPBUFFER pbuf = yy_new_filebuf(pchFile, bi);
		if( !pbuf ) {
			return false;
		}
		
		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(const char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_cstrbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_strbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	int yylex__(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
		
		if( !yy_has_buffer()) {yyecode__ = YYE_EOS; return 0;}

		int yylstate__ = LEX_ERROR_STATE;
		int yylrule__ = LEX_ERROR_RULE;
		int yyaccleng__ = 0;
		int yycchar__ = END_OF_FILE;
		bool yylast_at_bol__ = yyat_bol__;
		bool bwrap__ = false;
		
#line 97 "../meta/coderyac.upg"

	int c;

#line 1107 "coderyac.cpp"

		yymore_flag__ = false;
		yyecode__ = YYE_ALIVE;
		
		yyleng = 0;
		yylaleng = 0;
		yytext[0] = '\0';

		

		if(yyat_bol__) {
			yylstate__ = yydsc[yystart__];
		}
		else {
			yylstate__ = yydsc[yystart__ + 1];
		}

		while(yylex_is_running__()) {

			yycchar__ = yybufmgr__.get();
			yylstate__ = yynext_lexstate__(yylstate__, yycchar__);

			if(LEX_ERROR_STATE != yylstate__) {

				if(yylaleng >= yysize__ - 1) {
					renew_text__();
				}
				yytext[yylaleng] = (char)yycchar__;

				++yylaleng;

				if(yyget_lexrule__(yylstate__) != LEX_ERROR_RULE) {

					yylrule__ = yyget_lexrule__(yylstate__);
					yyaccleng__ = yylaleng;
				}
			}

			if(LEX_ERROR_STATE == yylstate__ || (yybufmgr__.isimod() 
					&& ('\n' == yycchar__ || END_OF_FILE == yycchar__))) {
				if(LEX_ERROR_RULE == yylrule__) {
					if(yylaleng == yyleng) {
						if(yycchar__ == END_OF_FILE) {
							yylrule__ = LEX_EOFRULE_BASE + yystart__ / 2;
						}
						else if(yycchar__ == END_OF_ALLFILE) {
							yylrule__ = LEX_EOAF_RULE;
						}
					}
				}
				else {
					if( LEX_ERROR_STATE == yylstate__) {
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);
					}
					yylaleng = yyaccleng__;
					yytext[yylaleng] = '\0';
				 yyleng = yylaleng;
				}

				if(LEX_ERROR_RULE != yylrule__) {
					if(yyleng > 0) yyat_bol__ = (yytext[yyleng - 1] == '\n');{
				int nline = yyget_lineno();
				int ncol = yyget_colno() - 1;
				int nt = yyget_tabsize();
				int ts, yyt1__;
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {
					if(yytext[yyt1__] == '\t') {

						ts = nt - ncol % nt;
						yybufmgr__.pushtsz(ts);
						ncol += ts;
					}
					else if(yytext[yyt1__] == '\n') {
						yybufmgr__.pushlsz(ncol + 1);
						ncol = 0;
						++nline;
					}
					else {
						++ncol;
					}
				}
				coder_lloc.firstLine = yyget_lineno();
				coder_lloc.firstColumn = yyget_colno();
				coder_lloc.lastLine  = nline;
				coder_lloc.lastColumn = (ncol < 0)?0: ncol;
				yyset_lineno(nline);
				yyset_colno(ncol + 1);
			}
				}

	bwrap__ = (yylrule__ >= LEX_EOFRULE_BASE
		&& yylrule__ < LEX_EOAF_RULE
		&& yywrap__());

	if(!bwrap__) {
				switch(yylrule__) {
				
case 0:
{
	
#line 146 "../meta/coderyac.upg"
		{
		
		if(coder.isThrowAway()) {
		
			coder_lval.m_textVal = nullptr;
			
			while((c = yyinput()) != END_OF_FILE) {
			
				switch(c) {

				case ']':
				
					if((c = yyinput()) == ']') {
						if((c = yyinput()) == '>') {
							c = END_OF_FILE;
						}
						else {
							yyunput(c);
						}
					}
					else {
						yyunput(c);
					}
					
					break;
					
				default:
	
					break;
				}
				
				if(END_OF_FILE == c) {
					break;
				}
			}
		}
		else {
			
			coder_lval.m_textVal = new int2pstr_t;
			coder_lval.m_textVal->second = new string;
			coder_lval.m_textVal->first = 0;
			c = yyinput();
			
			while(END_OF_FILE != c) {
			
				if(']' == c) {
				
					c = yyinput();
					if(']' == c) {
						c = yyinput();
						if(c != '>') {
							(*coder_lval.m_textVal->second) += ']';
							(*coder_lval.m_textVal->second) += ']';
						}
						else {
							break;
						}
					}
					else {
						(*coder_lval.m_textVal->second) += ']';
					}
				}
				else if('&' == c) {
					c = yyinput();
					switch(c) {
					case '&':
						c = yyinput();
						switch(c) {
						case 'g':
							c = yyinput();
							if('t' == c) {
								c = yyinput();
								if(';' == c) {
									(*coder_lval.m_textVal->second) += "&gt;";
								}
								else {
									(*coder_lval.m_textVal->second) += "&&gt";
								}
							}
							else {
								(*coder_lval.m_textVal->second) += "&&g";
							}
							break;
						case 'l':
							c = yyinput();
							if('t' == c) {
								c = yyinput();
								if(';' == c) {
									(*coder_lval.m_textVal->second) += "&lt;";
								}
								else {
									(*coder_lval.m_textVal->second) += "&&lt";
								}
							}
							else {
								(*coder_lval.m_textVal->second) += "&&l";
							}
							break;
						default:
							(*coder_lval.m_textVal->second) += "&&";
							break;
						}
						break;
					case 'g':
						c = yyinput();
						if('t' == c) {
							c = yyinput();
							if(';' == c) {
								(*coder_lval.m_textVal->second) += '>';
								c = yyinput();
							}
							else {
								(*coder_lval.m_textVal->second) += "&gt";
							}
						}
						else {
							(*coder_lval.m_textVal->second) += "&g";
						}
						break;
					case 'l':
						c = yyinput();
						if('t' == c) {
							c = yyinput();
							if(';' == c) {
								(*coder_lval.m_textVal->second) += '<';
								c = yyinput();
							}
							else {
								(*coder_lval.m_textVal->second) += "&lt";
							}
						}
						else {
							(*coder_lval.m_textVal->second) += "&l";
						}
						break;
					default:
						(*coder_lval.m_textVal->second) += '&';
						break;
					}
				}
				
				if(END_OF_FILE != c) {
					if(']' != c && '&' != c) {
						if('\n' == c) {
							++coder_lval.m_textVal->first;
						}
						(*coder_lval.m_textVal->second) += c;
						c = yyinput();
					}
				}
			}
		}

		return PLAIN_TEXT;
	}
	

#line 1366 "coderyac.cpp"

	}
	break;
	
case 1:
{
	
#line 302 "../meta/coderyac.upg"
		return yytext[0];


#line 1378 "coderyac.cpp"

	}
	break;
	
case 2:
{
	
#line 304 "../meta/coderyac.upg"
			return LBL_HAS;


#line 1390 "coderyac.cpp"

	}
	break;
	
case 3:
{
	
#line 306 "../meta/coderyac.upg"
			return LBL_EMPTY;


#line 1402 "coderyac.cpp"

	}
	break;
	
case 4:
{
	
#line 308 "../meta/coderyac.upg"
			return LBL_EQUAL;


#line 1414 "coderyac.cpp"

	}
	break;
	
case 5:
{
	
#line 310 "../meta/coderyac.upg"
		return LBL_UNEQUAL;


#line 1426 "coderyac.cpp"

	}
	break;
	
case 6:
{
	
#line 312 "../meta/coderyac.upg"
			return LBL_END;


#line 1438 "coderyac.cpp"

	}
	break;
	
case 7:
{
	
#line 314 "../meta/coderyac.upg"
			return 	LBL_LAST;


#line 1450 "coderyac.cpp"

	}
	break;
	
case 8:
{
	
#line 316 "../meta/coderyac.upg"
			return LBL_MORE;


#line 1462 "coderyac.cpp"

	}
	break;
	
case 9:
{
	
#line 318 "../meta/coderyac.upg"
	return LBL_GROUPFIRST;


#line 1474 "coderyac.cpp"

	}
	break;
	
case 10:
{
	
#line 320 "../meta/coderyac.upg"
		return LBL_GROUP;


#line 1486 "coderyac.cpp"

	}
	break;
	
case 11:
{
	
#line 322 "../meta/coderyac.upg"
			return LBL_MOD;


#line 1498 "coderyac.cpp"

	}
	break;
	
case 12:
{
	
#line 324 "../meta/coderyac.upg"
			return LBL_TRUE;


#line 1510 "coderyac.cpp"

	}
	break;
	
case 13:
{
	
#line 326 "../meta/coderyac.upg"
			return LBL_FALSE;


#line 1522 "coderyac.cpp"

	}
	break;
	
case 14:
{
	
#line 328 "../meta/coderyac.upg"
		return LBL_SCALAR;
	

#line 1534 "coderyac.cpp"

	}
	break;
	
case 15:
{
	
#line 330 "../meta/coderyac.upg"
		return LBL_SETUPHEAD;
	

#line 1546 "coderyac.cpp"

	}
	break;
	
case 16:
{
	
#line 332 "../meta/coderyac.upg"
		return LBL_MSHEAD;
	

#line 1558 "coderyac.cpp"

	}
	break;
	
case 17:
{
	
#line 334 "../meta/coderyac.upg"
		return LBL_MSTAIL;
	

#line 1570 "coderyac.cpp"

	}
	break;
	
case 18:
{
	
#line 336 "../meta/coderyac.upg"
			return LBL_MACRO;
	

#line 1582 "coderyac.cpp"

	}
	break;
	
case 19:
{
	
#line 338 "../meta/coderyac.upg"
		return LBL_DEFAULTHEAD;
	

#line 1594 "coderyac.cpp"

	}
	break;
	
case 20:
{
	
#line 340 "../meta/coderyac.upg"
	return LBL_DEFAULTTAIL;


#line 1606 "coderyac.cpp"

	}
	break;
	
case 21:
{
	
#line 342 "../meta/coderyac.upg"
			return LBL_CASEHEAD;


#line 1618 "coderyac.cpp"

	}
	break;
	
case 22:
{
	
#line 344 "../meta/coderyac.upg"
		return LBL_CASETAIL;


#line 1630 "coderyac.cpp"

	}
	break;
	
case 23:
{
	
#line 346 "../meta/coderyac.upg"
			return LBL_IFHEAD;


#line 1642 "coderyac.cpp"

	}
	break;
	
case 24:
{
	
#line 348 "../meta/coderyac.upg"
			return LBL_IFTAIL;
	

#line 1654 "coderyac.cpp"

	}
	break;
	
case 25:
{
	
#line 350 "../meta/coderyac.upg"
		return LBL_ELSEHEAD;


#line 1666 "coderyac.cpp"

	}
	break;
	
case 26:
{
	
#line 352 "../meta/coderyac.upg"
		return LBL_ELSETAIL;


#line 1678 "coderyac.cpp"

	}
	break;
	
case 27:
{
	
#line 354 "../meta/coderyac.upg"
	return LBL_DECLARE;


#line 1690 "coderyac.cpp"

	}
	break;
	
case 28:
{
	
#line 356 "../meta/coderyac.upg"
		return LBL_DEFINE;


#line 1702 "coderyac.cpp"

	}
	break;
	
case 29:
{
	
#line 358 "../meta/coderyac.upg"
		return LBL_PHEAD;


#line 1714 "coderyac.cpp"

	}
	break;
	
case 30:
{
	
#line 360 "../meta/coderyac.upg"
	return LBL_PTAIL;


#line 1726 "coderyac.cpp"

	}
	break;
	
case 31:
{
	
#line 362 "../meta/coderyac.upg"
		{
		if( ! coder.isThrowAway()) {
			yytext[yyleng - 1] = '\0';
			coder_lval.m_pstrVal = new string(&yytext[1]);
		}
		else {
			coder_lval.m_pstrVal = nullptr;
		}
		return QUOTEDSTR;
	}

#line 1746 "coderyac.cpp"

	}
	break;
	
case 32:
{
	
#line 372 "../meta/coderyac.upg"
		{
		if( ! coder.isThrowAway()) {		
			coder_lval.m_pstrVal = new string(yytext);
		}
		else {
			coder_lval.m_pstrVal = nullptr;
		}
		return CID;
	}

#line 1765 "coderyac.cpp"

	}
	break;
	
case 33:
{
	
#line 381 "../meta/coderyac.upg"
		{
		
		strhelper_t::toSnum(yytext, coder_lval.m_nVal);

		return INTEGER;
	}

#line 1781 "coderyac.cpp"

	}
	break;
	
case 34:
{
	
#line 387 "../meta/coderyac.upg"



#line 1793 "coderyac.cpp"

	}
	break;
	
case 35:
{
	
#line 388 "../meta/coderyac.upg"



#line 1805 "coderyac.cpp"

	}
	break;
	
case 36:
{
	
#line 389 "../meta/coderyac.upg"


	

#line 1818 "coderyac.cpp"

	}
	break;
	
case 37:
{
	
#line 0 "../meta/coderyac.upg"

#line 1828 "coderyac.cpp"

	}
	break;
	

				case LEX_EOAF_RULE:
					yy_delete_buffer();
					yyecode__ = YYE_EOS;
					break;
				default:
					if(yyleng > 0)
						yyat_bol__ = (yytext[yyleng - 1] == '\n');
			
					YYMSG_UNMATCHED[28] = yycchar__;
					yyecode__ = YYE_UNMATCHED;
					if(yyerror)
						yyerror(YYMSG_UNMATCHED, coder, dmap, cmmgr);
				
					break;
				}
	}
				if(yylex_is_running__()) {

					yylast_at_bol__ = yyat_bol__;

					if(yyat_bol__) {
						yylstate__ = yydsc[yystart__];
					}
					else {
						yylstate__ = yydsc[yystart__ + 1];
					}

					yylrule__ = LEX_ERROR_RULE;

					if( ! yymore_flag__) {
						yyaccleng__ = 0;
						yylaleng = 0;
						yyleng = 0;
						yytext[yylaleng] = '\0';
					}
					else {
						yymore_flag__ = false;
					}
				}
			}
		}

		return (yyecode__ == YYE_EOS)? 0 : yyecode__;
	}

	int yyparse__(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {

		if( ! yylexer) {
			return YYE_ABORT;
		}

		yyecode__ = YYE_ALIVE;
		sstack_t<xstype_t> yys_sv__;
		xstype_t yyval;

		sstack_t<xltype_t> yys_loc__;

		xltype_t yyloc;
		sstack_t<int> yys_stt__;
		sstack_t<int> yys_symb__;

		int yyrplen__;
		bool yyreducing__;

		int yypstate__ = PARSE_START_STATE;
		int yyprule__ = PERROR_RULE;
		int yysidx__ = PARSE_UNDEFSYMB_INDEX;
		int yytok__ = PARSE_UNDEFSYMB_ID;
		

		yyltok = PARSE_UNDEFSYMB_ID;
		yyerr_flag__ = false;


		yys_stt__.push(yypstate__);

		while( ! yys_stt__.empty() && yyparse_is_running__(yypstate__)) {
			yyprule__ = yyget_defrule(yypstate__);
			if(is_valid_prule__(yyprule__)) {
				yyreducing__ = true;
			}
			else {
				if(PARSE_UNDEFSYMB_ID == yytok__) {
					if(PARSE_UNDEFSYMB_ID == yyltok) {
						yytok__ = (yylexer)(coder, dmap, cmmgr);
					}
					else  {
						yytok__ = yyltok;
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yysidx__ = (yytok__ < 0 || yytok__ >= PARSE_TOKENMAP_SIZE) ? PARSE_UNDEFSYMB_INDEX
						: yyptmap[yytok__];
				}


				yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);

				if(is_valid_pstate__(yypstate__)) {


					yys_symb__.push(yysidx__);
					yys_stt__.push(yypstate__);
					yys_sv__.push(coder_lval);

					yys_loc__.push(coder_lloc);
 
					yytok__ = PARSE_UNDEFSYMB_ID;
					yyreducing__ = false;
				}
				else {
					yyprule__ = yyget_prule__(yypstate__);
					yyreducing__ = true;
				}
			}

			if(yyreducing__) {
				switch(yyprule__) {
				
	case 0:
	{
#line 394 "../meta/coderyac.upg"

#line 1956 "coderyac.cpp"

	}
	break;
	
	case 1:
	{
#line 394 "../meta/coderyac.upg"


			YYACCEPT();
		
#line 1968 "coderyac.cpp"

	}
	break;
	
	case 2:
	{
#line 400 "../meta/coderyac.upg"

			
			if( ! coder.openStream(dmap)) {
				YYABORT();
			}
		
#line 1982 "coderyac.cpp"

	}
	break;
	
	case 3:
	{
#line 408 "../meta/coderyac.upg"

			
			if( ! coder.addSetupItem(*(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal))) {
				
				string strMsg = " description: setting item `";
				strMsg += *(yys_sv__[2].m_pstrVal);
				strMsg += "\' already exists, this setting is discarded.";
				_WARNING(strMsg);
			}
			
			delete (yys_sv__[2].m_pstrVal);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2003 "coderyac.cpp"

	}
	break;
	
	case 4:
	{
#line 421 "../meta/coderyac.upg"


			if( ! coder.addSetupItem(*(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal))) {
				
				string strMsg = " description: setting item `";
				strMsg += *(yys_sv__[2].m_pstrVal);
				strMsg += "\' already exists, this setting is discarded.";
				_WARNING(strMsg);
			}
			
			delete (yys_sv__[2].m_pstrVal);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2024 "coderyac.cpp"

	}
	break;
	
	case 5:
	{
#line 436 "../meta/coderyac.upg"

#line 2033 "coderyac.cpp"

	}
	break;
	
	case 6:
	{
#line 437 "../meta/coderyac.upg"

#line 2042 "coderyac.cpp"

	}
	break;
	
	case 7:
	{
#line 437 "../meta/coderyac.upg"

#line 2051 "coderyac.cpp"

	}
	break;
	
	case 8:
	{
#line 439 "../meta/coderyac.upg"


			(yyval.m_pMac) = cmmgr.newMacro(*(yys_sv__[2].m_pstrVal));
			for(int i = 0; i < (int)(yys_sv__[1].m_pvmac2Cond)->size(); ++i) {
			
				(yyval.m_pMac)->addTerms((*(yys_sv__[1].m_pvmac2Cond))[i]->first, (*(yys_sv__[1].m_pvmac2Cond))[i]->second);
				delete (*(yys_sv__[1].m_pvmac2Cond))[i];
			}
			
			delete (yys_sv__[1].m_pvmac2Cond);
			delete (yys_sv__[2].m_pstrVal);
	
#line 2071 "coderyac.cpp"

	}
	break;
	
	case 9:
	{
#line 451 "../meta/coderyac.upg"

	
		(yyval.m_pMac) = cmmgr.newMacro(*(yys_sv__[2].m_pstrVal));
		
		(yyval.m_pMac)->addTerms((yys_sv__[1].m_pvmTerms));
		
		delete (yys_sv__[2].m_pstrVal);
	
#line 2087 "coderyac.cpp"

	}
	break;
	
	case 10:
	{
#line 461 "../meta/coderyac.upg"

			
			(yyval.m_pstrVal) = (yys_sv__[1].m_pstrVal);
		
#line 2099 "coderyac.cpp"

	}
	break;
	
	case 11:
	{
#line 466 "../meta/coderyac.upg"

#line 2108 "coderyac.cpp"

	}
	break;
	
	case 12:
	{
#line 468 "../meta/coderyac.upg"

			
			(yyval.m_pvmac2Cond) = new vmac2cond_t;
			(yyval.m_pvmac2Cond)->push_back((yys_sv__[0].m_pmac2Cond));
		
#line 2121 "coderyac.cpp"

	}
	break;
	
	case 13:
	{
#line 473 "../meta/coderyac.upg"

		
			(yyval.m_pvmac2Cond) = (yys_sv__[1].m_pvmac2Cond);
			(yyval.m_pvmac2Cond)->push_back((yys_sv__[0].m_pmac2Cond));
		
#line 2134 "coderyac.cpp"

	}
	break;
	
	case 14:
	{
#line 479 "../meta/coderyac.upg"

		
			(yyval.m_pmac2Cond) = new mac2cond_pair_t;
			(yyval.m_pmac2Cond)->first = (yys_sv__[1].m_pvmTerms);
			(yyval.m_pmac2Cond)->second = nullptr;
		
#line 2148 "coderyac.cpp"

	}
	break;
	
	case 15:
	{
#line 485 "../meta/coderyac.upg"

		
			(yyval.m_pmac2Cond) = new mac2cond_pair_t;
			(yyval.m_pmac2Cond)->first = (yys_sv__[1].m_pvmTerms);
			(yyval.m_pmac2Cond)->second = (yys_sv__[2].m_pCpdcond);
		
#line 2162 "coderyac.cpp"

	}
	break;
	
	case 16:
	{
#line 493 "../meta/coderyac.upg"


			(yyval.m_pCpdcond) = (yys_sv__[1].m_pCpdcond);
		
#line 2174 "coderyac.cpp"

	}
	break;
	
	case 17:
	{
#line 499 "../meta/coderyac.upg"

			
			assert((yys_sv__[0].m_pmTerm));
			(yyval.m_pvmTerms) = new vterm_t;
			(yyval.m_pvmTerms)->push_back((yys_sv__[0].m_pmTerm));
		
#line 2188 "coderyac.cpp"

	}
	break;
	
	case 18:
	{
#line 505 "../meta/coderyac.upg"

		
			assert((yys_sv__[1].m_pvmTerms));
			(yyval.m_pvmTerms) = (yys_sv__[1].m_pvmTerms);
			(yyval.m_pvmTerms)->push_back((yys_sv__[0].m_pmTerm));			
			
		
#line 2203 "coderyac.cpp"

	}
	break;
	
	case 19:
	{
#line 513 "../meta/coderyac.upg"

			if((yys_sv__[0].m_textVal) && (yys_sv__[0].m_textVal)->second) {
				(yyval.m_pmTerm) = cmmgr.newTextTerm(*((yys_sv__[0].m_textVal)->second), (yys_sv__[0].m_textVal)->first);
				delete (yys_sv__[0].m_textVal)->second;
				delete (yys_sv__[0].m_textVal);
			}
		
#line 2218 "coderyac.cpp"

	}
	break;
	
	case 20:
	{
#line 520 "../meta/coderyac.upg"

		
			if((yys_sv__[0].m_pmacRef)->second) {
				
				(yyval.m_pmTerm) = cmmgr.newMacroTerm(*(yys_sv__[0].m_pmacRef)->first, *(yys_sv__[0].m_pmacRef)->second);
				delete (yys_sv__[0].m_pmacRef)->second;
			}
			else {
			
				(yyval.m_pmTerm) = cmmgr.newMacroTerm(*(yys_sv__[0].m_pmacRef)->first);
			}
			delete (yys_sv__[0].m_pmacRef)->first;
			delete (yys_sv__[0].m_pmacRef);
		
#line 2240 "coderyac.cpp"

	}
	break;
	
	case 21:
	{
#line 534 "../meta/coderyac.upg"

			
			string strVal;
			if(dmap.getString(*(yys_sv__[2].m_pstrVal), strVal)) {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm(strVal, 0);
			}
			else {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm("", 0);
			}
			delete (yys_sv__[2].m_pstrVal);
		
#line 2261 "coderyac.cpp"

	}
	break;
	
	case 22:
	{
#line 547 "../meta/coderyac.upg"

			
			string strVal;
			if(dmap.getString(*(yys_sv__[2].m_pstrVal), strVal)) {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm(strVal, 0);
			}
			else {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm("", 0);
			}
			delete (yys_sv__[2].m_pstrVal);
		
#line 2282 "coderyac.cpp"

	}
	break;
	
	case 23:
	{
#line 561 "../meta/coderyac.upg"


			(yyval.m_pCpdcond) = cmmgr.newCompoundCond();
			(yyval.m_pCpdcond)->addCondItem((yys_sv__[0].m_pcondItem));
		
#line 2295 "coderyac.cpp"

	}
	break;
	
	case 24:
	{
#line 566 "../meta/coderyac.upg"

		
			(yyval.m_pCpdcond) = (yys_sv__[1].m_pCpdcond);
			(yyval.m_pCpdcond)->addCondItem((yys_sv__[0].m_pcondItem));
		
#line 2308 "coderyac.cpp"

	}
	break;
	
	case 25:
	{
#line 572 "../meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_nVal));
			delete (yys_sv__[2].m_pstrVal);
		
#line 2321 "coderyac.cpp"

	}
	break;
	
	case 26:
	{
#line 577 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[0].m_pstrVal), true);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2334 "coderyac.cpp"

	}
	break;
	
	case 27:
	{
#line 582 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_bVal));
			delete (yys_sv__[2].m_pstrVal);
		
#line 2347 "coderyac.cpp"

	}
	break;
	
	case 28:
	{
#line 587 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal));
			delete (yys_sv__[2].m_pstrVal);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2361 "coderyac.cpp"

	}
	break;
	
	case 29:
	{
#line 593 "../meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_EQ, (yys_sv__[0].m_nVal));
		
#line 2373 "coderyac.cpp"

	}
	break;
	
	case 30:
	{
#line 597 "../meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_NE, (yys_sv__[0].m_nVal));	
		
#line 2385 "coderyac.cpp"

	}
	break;
	
	case 31:
	{
#line 601 "../meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_EQ, (yys_sv__[0].m_bVal));
		
#line 2397 "coderyac.cpp"

	}
	break;
	
	case 32:
	{
#line 605 "../meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_NE, (yys_sv__[0].m_bVal));	
		
#line 2409 "coderyac.cpp"

	}
	break;
	
	case 33:
	{
#line 609 "../meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_EQ, *(yys_sv__[0].m_pstrVal));
			delete (yys_sv__[0].m_pstrVal);
		
#line 2422 "coderyac.cpp"

	}
	break;
	
	case 34:
	{
#line 614 "../meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_NE, *(yys_sv__[0].m_pstrVal));
			delete (yys_sv__[0].m_pstrVal);		
		
#line 2435 "coderyac.cpp"

	}
	break;
	
	case 35:
	{
#line 619 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getHasCond();
		
#line 2447 "coderyac.cpp"

	}
	break;
	
	case 36:
	{
#line 623 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getEmptyCond();
		
#line 2459 "coderyac.cpp"

	}
	break;
	
	case 37:
	{
#line 627 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getEndCond();
		
#line 2471 "coderyac.cpp"

	}
	break;
	
	case 38:
	{
#line 631 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getLastCond();
		
#line 2483 "coderyac.cpp"

	}
	break;
	
	case 39:
	{
#line 635 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getMoreCond();
		
#line 2495 "coderyac.cpp"

	}
	break;
	
	case 40:
	{
#line 639 "../meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.getGroupCond();
		
#line 2507 "coderyac.cpp"

	}
	break;
	
	case 41:
	{
#line 643 "../meta/coderyac.upg"

			(yyval.m_pcondItem) = cmmgr.getGroupFirstCond();
		
#line 2518 "coderyac.cpp"

	}
	break;
	
	case 42:
	{
#line 646 "../meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newModCond((yys_sv__[0].m_nVal));
		
#line 2530 "coderyac.cpp"

	}
	break;
	
	case 43:
	{
#line 651 "../meta/coderyac.upg"

		
			(yyval.m_bVal) = true;
		
#line 2542 "coderyac.cpp"

	}
	break;
	
	case 44:
	{
#line 655 "../meta/coderyac.upg"

		
			(yyval.m_bVal) = false;
		
#line 2554 "coderyac.cpp"

	}
	break;
	
	case 45:
	{
#line 660 "../meta/coderyac.upg"

			
			(yyval.m_pmacRef) = new pstr2pvn_t;
			(yyval.m_pmacRef)->first = (yys_sv__[2].m_pstrVal);
			(yyval.m_pmacRef)->second = nullptr;
		
#line 2568 "coderyac.cpp"

	}
	break;
	
	case 46:
	{
#line 666 "../meta/coderyac.upg"

		
			(yyval.m_pmacRef) = new pstr2pvn_t;
			(yyval.m_pmacRef)->first = (yys_sv__[3].m_pstrVal);;
			(yyval.m_pmacRef)->second = (yys_sv__[2].m_pvnVal);
		
#line 2582 "coderyac.cpp"

	}
	break;
	
	case 47:
	{
#line 674 "../meta/coderyac.upg"


			(yyval.m_pvnVal) = new vint_t;
			(yyval.m_pvnVal)->push_back((yys_sv__[0].m_nVal));
		
#line 2595 "coderyac.cpp"

	}
	break;
	
	case 48:
	{
#line 679 "../meta/coderyac.upg"

		
			(yyval.m_pvnVal) = (yys_sv__[2].m_pvnVal);
			(yyval.m_pvnVal)->push_back((yys_sv__[0].m_nVal));
		
#line 2608 "coderyac.cpp"

	}
	break;
	
	case 49:
	{
#line 685 "../meta/coderyac.upg"


			if( ! coder.isThrowAway()) {
				(yyval.m_pvstrVal) = new vstr_t;
				(yyval.m_pvstrVal)->push_back(*(yys_sv__[0].m_pstrVal));
			}
			else {
				(yyval.m_pvstrVal) = nullptr;
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2630 "coderyac.cpp"

	}
	break;
	
	case 50:
	{
#line 699 "../meta/coderyac.upg"

		
			(yyval.m_pvstrVal) = (yys_sv__[1].m_pvstrVal);
			if( ! coder.isThrowAway()) {
				(yyval.m_pvstrVal)->push_back(*(yys_sv__[0].m_pstrVal));
			}
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2648 "coderyac.cpp"

	}
	break;
	
	case 52:
	{
#line 711 "../meta/coderyac.upg"


			coder.switchToDef();
		
#line 2660 "coderyac.cpp"

	}
	break;
	
	case 51:
	{
#line 714 "../meta/coderyac.upg"


			coder.flush();
		
#line 2672 "coderyac.cpp"

	}
	break;
	
	case 53:
	{
#line 720 "../meta/coderyac.upg"

#line 2681 "coderyac.cpp"

	}
	break;
	
	case 54:
	{
#line 720 "../meta/coderyac.upg"

#line 2690 "coderyac.cpp"

	}
	break;
	
	case 55:
	{
#line 723 "../meta/coderyac.upg"

			
			if((yys_sv__[0].m_textVal) && (yys_sv__[0].m_textVal)->second) {
				coder.getStream() << *((yys_sv__[0].m_textVal)->second);
				dmap.addSrcLineNo((yys_sv__[0].m_textVal)->first);
				
				delete (yys_sv__[0].m_textVal)->second;
				delete (yys_sv__[0].m_textVal);
			}
		
#line 2708 "coderyac.cpp"

	}
	break;
	
	case 56:
	{
#line 733 "../meta/coderyac.upg"

#line 2717 "coderyac.cpp"

	}
	break;
	
	case 57:
	{
#line 734 "../meta/coderyac.upg"

#line 2726 "coderyac.cpp"

	}
	break;
	
	case 58:
	{
#line 735 "../meta/coderyac.upg"

#line 2735 "coderyac.cpp"

	}
	break;
	
	case 59:
	{
#line 738 "../meta/coderyac.upg"


			if( ! coder.isThrowAway()) {
				cmmgr.expandWithStack(*(yys_sv__[3].m_pstrVal), dmap, *(yys_sv__[2].m_pvstrVal), coder.getStream());
			}
			if((yys_sv__[3].m_pstrVal)) {
				delete (yys_sv__[3].m_pstrVal);
			}
			if((yys_sv__[2].m_pvstrVal)) {
				delete (yys_sv__[2].m_pvstrVal);
			}
		
#line 2755 "coderyac.cpp"

	}
	break;
	
	case 60:
	{
#line 750 "../meta/coderyac.upg"

			
			if( ! coder.isThrowAway()) {
				cmmgr.expandWithStack(*(yys_sv__[2].m_pstrVal), dmap, cmmgr.getEmptyParam(), coder.getStream());
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
		
#line 2772 "coderyac.cpp"

	}
	break;
	
	case 61:
	{
#line 761 "../meta/coderyac.upg"


		if( ! coder.isThrowAway()) {
				coder.switchToDecl();
			}
		
#line 2786 "coderyac.cpp"

	}
	break;
	
	case 62:
	{
#line 767 "../meta/coderyac.upg"


			if( coder.isCondTrue()) {
				coder.switchToDef();
			}
		
#line 2800 "coderyac.cpp"

	}
	break;
	
	case 63:
	{
#line 775 "../meta/coderyac.upg"

#line 2809 "coderyac.cpp"

	}
	break;
	
	case 65:
	{
#line 776 "../meta/coderyac.upg"

			coder.addIPCond( ! (yys_sv__[1].m_bVal));
		
#line 2820 "coderyac.cpp"

	}
	break;
	
	case 64:
	{
#line 779 "../meta/coderyac.upg"

			coder.subIPCond( ! (yys_sv__[4].m_bVal));
		
#line 2831 "coderyac.cpp"

	}
	break;
	
	case 67:
	{
#line 784 "../meta/coderyac.upg"


			coder.addIPCond((yys_sv__[1].m_bVal));
		
#line 2843 "coderyac.cpp"

	}
	break;
	
	case 66:
	{
#line 788 "../meta/coderyac.upg"

			coder.subIPCond((yys_sv__[4].m_bVal));
			(yyval.m_bVal) = (yys_sv__[4].m_bVal);
		
#line 2855 "coderyac.cpp"

	}
	break;
	
	case 68:
	{
#line 794 "../meta/coderyac.upg"


			(yyval.m_bVal) = (yys_sv__[0].m_bVal);
		
#line 2867 "coderyac.cpp"

	}
	break;
	
	case 69:
	{
#line 798 "../meta/coderyac.upg"

			(yyval.m_bVal) = (yys_sv__[1].m_bVal) && (yys_sv__[0].m_bVal);
		
#line 2878 "coderyac.cpp"

	}
	break;
	
	case 70:
	{
#line 803 "../meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[0].m_pstrVal), true);
			}
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}			
		
#line 2898 "coderyac.cpp"

	}
	break;
	
	case 71:
	{
#line 815 "../meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = ! cmmgr.testCond(dmap, *(yys_sv__[0].m_pstrVal), true);
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2919 "coderyac.cpp"

	}
	break;
	
	case 72:
	{
#line 828 "../meta/coderyac.upg"


			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_nVal));
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
		
#line 2939 "coderyac.cpp"

	}
	break;
	
	case 73:
	{
#line 840 "../meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_bVal));			
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
		
#line 2959 "coderyac.cpp"

	}
	break;
	
	case 74:
	{
#line 852 "../meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal));
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2982 "coderyac.cpp"

	}
	break;
	
	case 75:
	{
#line 867 "../meta/coderyac.upg"

			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testHas(dmap, *(yys_sv__[0].m_pstrVal));
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 3002 "coderyac.cpp"

	}
	break;
	
	case 76:
	{
#line 879 "../meta/coderyac.upg"

			
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testEmpty(dmap, *(yys_sv__[0].m_pstrVal));
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 3023 "coderyac.cpp"

	}
	break;
	
				default:

					if( ! yyerr_flag__ || PARSE_ENDSYMB_ID == yytok__) {
						if(! yyerr_flag__) {
							if(yyerror) {

char yycc[MAX_MSG_LENG];
sprintf(yycc, "Error: syntax error at %d:%d.", coder_lloc.firstLine, coder_lloc.firstColumn);
yyerror(yycc, coder, dmap, cmmgr);
				}

							yyecode__ = YYE_PERROR;
						}
						else {
							yyecode__ = YYE_NOINPUT;
						}
						
						yyerr_flag__ = true;
						yyltok = yytok__;
					}
					else {
					
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yytok__ = PARSE_ERRORSYMB_ID;
					yysidx__ = PARSE_ERRORSYMB_INDEX;

					while(! yys_sv__.empty())  {
						yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);
						if(is_valid_pstate__(yypstate__)) {
							break;
						}
			

						yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top());
						yys_loc__.pop(1);


						yys_symb__.pop(1);
						yys_sv__.pop(1);
						yys_stt__.pop(1);
					}

					if( yys_sv__.empty()) {
						yys_stt__.pop(1);
					}

					break;
				}

				if(is_valid_prule__(yyprule__) || YYE_ACCEPT == yyecode__) {
					yyrplen__ = yyprnum[yyprule__];
					yypstate__ = yynext_goto__(yys_stt__[yyrplen__], yyplid[yyprule__]);


					if(YYE_ACCEPT != yyecode__) {
						yys_stt__.pop(yyrplen__);
						yys_symb__.pop(yyrplen__);
						yys_sv__.pop(yyrplen__);

						if(yyrplen__ == 0) {
							yyloc.firstLine = yyloc.lastLine = yys_loc__[0].lastLine;
							yyloc.firstColumn = yyloc.lastColumn = yys_loc__[0].lastColumn;
						}
						else {
							yyloc.firstLine = yys_loc__[yyrplen__ - 1].firstLine;
							yyloc.lastLine = yys_loc__[0].lastLine;
							yyloc.firstColumn = yys_loc__[yyrplen__ - 1].firstColumn;
							yyloc.lastColumn = yys_loc__[0].lastColumn;
						}
						yys_loc__.pop(yyrplen__);
						yys_loc__.push(yyloc);

						yys_stt__.push(yypstate__);
						yys_symb__.push(yyplid[yyprule__] + PARSE_TYPE_BASE);
						yys_sv__.push(yyval);
					}
				}
			}
		}

		while( ! yys_sv__.empty()) {

			yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top());

			yys_sv__.pop(1);
			yys_symb__.pop(1);
		}

		if(YYE_ACCEPT == yyecode__) {


			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE);

			yyecode__ = YYE_ACCEPT;
		}

		return (yyecode__ == YYE_ACCEPT)? 0: yyecode__;
	}

public:
	inline void yyclearall__(void) {
		yyecode__ = YYE_ALIVE;
		yystart__ = INITIAL;		
		yymore_flag__ = false;
		yyat_bol__ = true;
		
		yyleng = 0;
		yylaleng = 0;
		if(yytext) {
			yytext[0] = '\0';
		}
		yybufmgr__.destroyall();

		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;

	}

private:

	// user interfaces
	// easy way to print matched string
	inline void YYECHO(void) const {
		ECHO();
	}
	inline void ECHO(void) const {
		fprintf(stdout, "%s", yytext);
	}

	// start-condition operations
	// switch start-condition
	inline void YYBEGIN(int sc) {
		BEGIN(sc);
	}
	inline void BEGIN(int sc) {
		yystart__ = sc;
	}
	// return current start-condition
	inline int YYSTART(void) const {
		return yystart__;
	}
	// save current start-condition and switch to new start-condition
	inline void yy_push_state(int nsc) {
		yyscstk__.push(yystart__);
		yystart__ = nsc;
	}
	// switch to last saved start-condition
	inline bool yy_pop_state(void) {

		if(yyscstk__.empty()) {
			return false;
		}
		yystart__ = yyscstk__.top();
		yyscstk__.pop(1);
		return true;
	}
	// return last saved start-condition
	inline int yy_top_state(void) {

		if(yyscstk__.empty()) {
			return INITIAL;
		}
		return yyscstk__.top();
	}

	// get/set flag of beginning-of-line
	inline bool yy_get_bol(void) const {
		return yyat_bol__;
	}
	inline void yy_set_bol(bool b) {
		yyat_bol__ = b;
	}

	// buffer operations
	inline YYPBUFFER yy_current_buffer(void) const {
		return yybufmgr__.current();
	}
	// 
	inline bool yy_has_buffer(void) const {
		return ! yybufmgr__.empty();
	}
	inline void yy_push_buffer(YYPBUFFER pbuffer) {
		yybufmgr__.switchto(pbuffer);
	}
	inline YYPBUFFER yy_pop_buffer(void) {
		return yybufmgr__.pop();
	}
	inline YYPBUFFER yy_new_filebuf(const char *strfile, bool bi = false) {
		if( !strfile ) {
			return yybufmgr__.newbuf(stdin, bi);
		}

	 	FILE *pfile = fopen(strfile, "r");
	 	if( !pfile) return nullptr;
		return yybufmgr__.newbuf(pfile);
	}

	inline YYPBUFFER yy_new_cstrbuf(const char *cstrbuffer, int size) {
		if( ! cstrbuffer || size < 1) {
			return nullptr;
		}
		return yybufmgr__.newbuf(cstrbuffer, size);
	}
	inline YYPBUFFER yy_new_strbuf(char *strbuffer, int size) {
		if( ! strbuffer || size < 1) {
			return nullptr;
		}
		return yybufmgr__.newbuf(strbuffer, size);
	}
	inline void yy_delete_buffer(void) {
		yybufmgr__.destroytop();
	}
	inline void yy_switch_buffer(YYPBUFFER buf) {
		yybufmgr__.switchto(buf);
	}
	inline void yyrestart(void) {

		yystart__ = INITIAL;
		yyecode__ = YYE_ALIVE;
		yymore_flag__ = false;
		
		yyleng = 0;
		yylaleng = 0;
		if( yytext ) {
			yytext[0] = '\0';
		}

		yyscstk__.clear();
		yybufmgr__.reset();
	}

	inline void yymore(void) {

		yymore_flag__ = true;
		yylaleng = yyleng;
	}
	inline int yyless(int n) {

		if(n > 0 && n < yyleng) {

			yytext[n] = '\0';
			n = yyleng - n;
			yyleng -= n;
			yylaleng = yyleng;
			return yybufmgr__.unget(n);
		}
		yylaleng = yyleng;
		yytext[yylaleng] = '\0';

		return 0;
	}

	inline int yyinput(void) {

		int c = yybufmgr__.get();
		if(c < END_OF_FILE) {
			if(c == '\t') {
				int nt = yyget_tabsize();
				nt -= (yyget_colno() + nt - 1) % nt;
				yybufmgr__.pushtsz(nt);
				yyadd_colno(nt);
			}
			else if(c == '\n') {
				yybufmgr__.pushlsz(yyget_colno());
				yyset_colno(1);
				yyadd_lineno(1);
			}
			else {
				yyadd_colno(1);
			}
		}	
		return c;
	}
	inline bool yyunput(char c) {
		int oldc = yybufmgr__.put(c);
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;
	}
	inline bool yyunget(void) {
		int oldc = yybufmgr__.unget();
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;		
	}
	inline void yyterminate(void) {
		yyecode__ = YYE_TERM;
	}
	inline void yyadd_lineno(int nline) {
		yybufmgr__.setlineno(yybufmgr__.getlineno() + nline);
	}
	inline void yyadd_colno(int ncol) {
		yybufmgr__.setcolno(yybufmgr__.getcolno() + ncol);
	}
	inline int yyget_lineno(void) const {
		return yybufmgr__.getlineno();
	}
	inline void yyset_lineno(int nline) {
		yybufmgr__.setlineno(nline);
	}
	inline int yyget_colno(void) const {
		return yybufmgr__.getcolno();
	}
	inline void yyset_colno(int ncol) {
		yybufmgr__.setcolno(ncol);
	}
	inline int yyget_tabsize(void) const {
		return yybufmgr__.gettabsize();
	}
	inline void yyset_tabsize(int ntab) {
		yybufmgr__.settabsize(ntab);
	}
	bool yywrap__(void) {
		
			return false;
	}


private:

	int yyecode__;


	// buffer manager
	bufmgr_t yybufmgr__;
	// start-condition stack
	sstack_t<int, 32, 16> yyscstk__;
	int yysize__;
	int yystart__;

	bool yymore_flag__;
	bool yyat_bol__;

	char *yytext;
	int yyleng;
	int yylaleng;

	
	bool yyerr_flag__;
	int yyltok;
	coder_lex_t yylexer;

	coder_error_t yyerror;
	
private:
	

///////////////////////////////////////////////////////////////////////////
	// lexical tables
	// start states of DFAs
	static const int yydsc[2];

	// @yydcmap is a char map: char -> transition-label,
	// that is, chars are grouped, transition label is
	// representation of equivalent class of chars
	static const int yydcmap[258];

	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,
	// that is, transition-label in @yydcmap are further grouped in order to save space
	static const int yydmeta[47];

	// use next-check-base-default scheme to store DFAs
	// 
	static const int yydbase[197];
	static const int yyddef[197];
	// next table is an indeed transition table
	static const int yydnxt[283];
	static const int yydchk[283];
	static const int yydaccpt[174];
	
	static char YYMSG_UNMATCHED[];

///////////////////////////////////////////////////////////////////////////////
	// LALR parse tables
	// token map: token ID --> token index in token ID table
	// in fact, it acts like inverse table of token ID table
	static const int yyptmap[291];
	// token ID table, which contains token IDs
	//static const int yyptid[43];
	// number of symbols in a grammar rule
	static const int yyprnum[77];
	// index of left symbol in a grammar rule
	static const int yyplid[77];
	// parse action table
	static const int yypact[109];

	// base array for parse action table
	// which is used to determine the base location of the entries
	// for each state stored in the yypack table
	static const int yypabase[145];
	static const int yypgoto[23];
	static const int yypgbase[145];

	// check table for parse action table
	static const by_te_t yyvbmap[870];
	static const int yyparv[145];
	static const int yyparn[145];

	static const int yypcv[75];
	static const int yypcn[75];
	static const int yypgrv[145];
	static const int yypgrn[145];

///////////////////////////////////////////////////////////////////////////////////
	// optional tables, they are available only under certain conditions

	// lookahead distant table, only available when there are some lookahead patterns
	// each pattern has its entry of the table
	

};


char coder_parser_t::YYMSG_UNMATCHED[] = "Error: unmatched character ` \'.";

const int coder_parser_t::yydsc[2] = {
173,	173
};

const int coder_parser_t::yydcmap[258] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	1,	2,	0,	0,	3,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	1,	4,	5,	6,	7,	0,	0,	0,
	0,	0,	0,	8,	0,	8,	0,	9,
	10,	10,	10,	10,	10,	10,	10,	10,
	10,	10,	0,	0,	11,	6,	12,	13,
	0,	7,	7,	14,	15,	16,	17,	18,
	19,	20,	7,	7,	21,	22,	7,	7,
	23,	7,	7,	24,	25,	26,	7,	7,
	7,	7,	7,	27,	0,	0,	0,	7,
	0,	28,	7,	29,	30,	31,	32,	33,
	7,	34,	7,	7,	35,	36,	37,	38,
	39,	40,	41,	42,	43,	44,	7,	7,
	7,	45,	7,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	46,	46
};

const int coder_parser_t::yydmeta[47] = {
0,	0,	1,	1,	0,	0,	0,	2,
	0,	0,	2,	0,	0,	0,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	0,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	3
};

const int coder_parser_t::yydbase[197] = {
236,	236,	236,	236,	236,	236,	236,	236,
	236,	236,	236,	236,	236,	236,	236,	236,
	236,	236,	236,	236,	236,	236,	236,	236,
	236,	236,	236,	236,	236,	236,	236,	236,
	236,	236,	236,	236,	236,	236,	188,	184,
	179,	181,	176,	172,	165,	204,	194,	191,
	158,	169,	172,	168,	170,	168,	165,	168,
	189,	158,	164,	163,	159,	151,	144,	149,
	142,	143,	182,	142,	147,	139,	142,	169,
	168,	6,	149,	135,	137,	132,	144,	140,
	129,	158,	127,	130,	132,	135,	134,	131,
	119,	124,	120,	132,	128,	127,	124,	112,
	118,	126,	141,	111,	112,	108,	137,	120,
	106,	115,	110,	103,	108,	114,	98,	131,
	108,	102,	125,	93,	124,	123,	119,	116,
	113,	18,	17,	11,	3,	2,	88,	80,
	91,	86,	81,	88,	83,	77,	0,	87,
	73,	85,	84,	92,	82,	79,	83,	71,
	63,	57,	60,	48,	54,	51,	46,	58,
	50,	53,	63,	50,	40,	35,	43,	33,
	33,	30,	23,	27,	10,	32,	27,	26,
	25,	17,	0,	29,	19,	0,	236,	233,
	232,	231,	230,	229,	228,	227,	226,	225,
	224,	223,	222,	221,	220,	219,	218,	217,
	216,	215,	213,	214,	211
};

const int coder_parser_t::yyddef[197] = {
174,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	165,	165,
	165,	165,	165,	165,	165,	165,	165,	165,
	165,	165,	165,	165,	165,	56,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	195,	194,	192,	191,	190,	189,	188,	187,
	186,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	181,	193,	184,	181,	193,	184,	181,	182,
	180,	182,	182,	183,	182,	0,	183,	0,
	180,	180,	178,	180,	178,	178,	180,	182,
	185,	177,	183,	182,	178,	180,	179,	178,
	177,	183,	177,	185,	179,	175,	176,	176,
	176,	176,	175,	0,	0,	196,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0
};

const int coder_parser_t::yydnxt[283] = {
1,	73,	21,	66,	20,	56,	20,	45,
	116,	20,	117,	172,	20,	20,	14,	15,
	170,	137,	157,	155,	118,	158,	164,	39,
	166,	160,	148,	1,	171,	16,	17,	167,
	38,	41,	40,	43,	133,	153,	169,	42,
	150,	74,	44,	50,	51,	68,	144,	163,
	162,	49,	32,	52,	67,	36,	32,	32,
	151,	32,	35,	32,	32,	136,	135,	32,
	131,	32,	62,	32,	32,	32,	32,	159,
	32,	32,	64,	142,	63,	32,	149,	32,
	32,	32,	154,	28,	32,	146,	129,	32,
	32,	27,	140,	134,	32,	26,	32,	32,
	32,	32,	32,	95,	32,	130,	60,	32,
	61,	96,	165,	32,	84,	32,	57,	143,
	32,	152,	156,	168,	139,	32,	22,	24,
	161,	59,	25,	121,	120,	18,	23,	32,
	11,	30,	32,	19,	32,	71,	72,	138,
	88,	13,	122,	123,	124,	125,	126,	127,
	109,	110,	111,	112,	113,	12,	114,	9,
	103,	8,	104,	105,	106,	107,	119,	47,
	48,	76,	77,	100,	99,	98,	7,	97,
	94,	93,	6,	92,	91,	90,	102,	101,
	89,	53,	71,	46,	87,	86,	82,	83,
	21,	85,	128,	145,	58,	33,	34,	147,
	132,	31,	2,	5,	115,	75,	78,	79,
	80,	81,	108,	10,	4,	45,	70,	69,
	3,	65,	141,	55,	54,	29,	37,	32,
	37,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0
};

const int coder_parser_t::yydchk[283] = {
173,	173,	173,	173,	173,	173,	173,	73,
	173,	173,	173,	173,	173,	173,	125,	124,
	173,	173,	173,	173,	123,	173,	173,	172,
	173,	173,	173,	173,	172,	122,	121,	134,
	172,	172,	172,	172,	170,	170,	164,	172,
	170,	172,	172,	171,	171,	171,	169,	161,
	164,	171,	169,	171,	171,	162,	168,	167,
	166,	169,	168,	167,	166,	163,	163,	160,
	162,	168,	167,	166,	165,	165,	159,	158,
	165,	161,	160,	159,	157,	156,	155,	157,
	154,	158,	156,	153,	152,	152,	151,	150,
	149,	147,	150,	148,	147,	149,	153,	155,
	148,	146,	145,	143,	142,	145,	146,	151,
	144,	143,	154,	144,	141,	139,	140,	141,
	138,	137,	136,	135,	133,	136,	132,	131,
	130,	129,	128,	127,	126,	120,	142,	140,
	119,	138,	137,	118,	135,	117,	116,	139,
	115,	114,	113,	112,	111,	110,	109,	108,
	107,	106,	105,	104,	103,	102,	101,	100,
	99,	98,	97,	96,	95,	94,	93,	92,
	91,	90,	89,	88,	87,	86,	85,	84,
	83,	82,	81,	80,	79,	78,	77,	76,
	75,	74,	72,	71,	70,	69,	68,	67,
	66,	65,	64,	63,	62,	61,	60,	59,
	58,	57,	56,	55,	54,	53,	52,	51,
	50,	49,	48,	47,	46,	45,	44,	43,
	42,	41,	40,	39,	38,	196,	195,	194,
	195,	193,	192,	191,	190,	189,	188,	187,
	186,	185,	184,	183,	182,	181,	180,	179,
	178,	177,	176,	175,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174
};

const int coder_parser_t::yydaccpt[174] = {
-1,	36,	31,	23,	33,	0,	24,	21,
	25,	15,	22,	26,	16,	17,	19,	28,
	29,	20,	30,	27,	1,	34,	5,	7,
	8,	12,	2,	14,	6,	32,	3,	4,
	32,	18,	13,	10,	11,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	35,	33,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	36,	32,	32,	32,	32,	32,	32,	32,
	32,	-1,	36,	-1,	-1,	-1,	-1,	33,
	33,	35,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	36,	33,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	-1,	32,	-1,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	9,	32,	32,
	32,	32,	32,	-1,	1,	-1
};

// token map: token ID --> token index in token ID table
// in fact, it acts like inverse table of token ID table
const int coder_parser_t::yyptmap[291] = {
0,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	42,	2,	41,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	36,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	39,	38,	37,	40,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	1,	2,	3,	4,	5,	6,	7,	8,
	9,	10,	11,	12,	13,	14,	15,	16,
	17,	18,	19,	20,	21,	22,	23,	24,
	25,	26,	27,	28,	29,	30,	31,	32,
	33,	34,	35
};
/*
// token ID table, containing token IDs
const int coder_parser_t::yyptid[43] = {
0,	256,	257,	258,	259,	260,	261,	262,
	263,	264,	265,	266,	267,	268,	269,	270,
	271,	272,	273,	274,	275,	276,	277,	278,
	279,	280,	281,	282,	283,	284,	285,	286,
	287,	288,	289,	290,	47,	62,	61,	60,
	63,	35,	33
};
*/
// prnum table, its element is number of symbols in right part of corresponding grammar rule
const int coder_parser_t::yyprnum[77] = {
2,	3,	4,	4,	3,	3,	1,	2,
	3,	3,	4,	4,	1,	2,	3,	3,
	3,	1,	2,	1,	1,	5,	5,	1,
	2,	3,	1,	3,	3,	3,	3,	3,
	3,	3,	3,	1,	1,	1,	1,	1,
	1,	1,	3,	1,	1,	4,	5,	2,
	3,	1,	2,	4,	0,	1,	2,	1,
	1,	1,	1,	5,	4,	1,	1,	1,
	5,	0,	6,	0,	1,	2,	1,	2,
	3,	3,	3,	3,	3
};

// plid table, its element is the index of left part of corresponding grammar rule in token ID table
const int coder_parser_t::yyplid[77] = {
17,	2,	18,	21,	21,	19,	22,	22,
	11,	11,	13,	23,	12,	12,	14,	14,
	1,	10,	10,	9,	9,	9,	9,	7,
	7,	8,	8,	8,	8,	8,	8,	8,
	8,	8,	8,	8,	8,	8,	8,	8,
	8,	8,	8,	0,	0,	15,	15,	6,
	6,	16,	16,	20,	25,	24,	24,	26,
	26,	26,	26,	27,	27,	28,	28,	29,
	29,	30,	3,	31,	4,	4,	5,	5,
	5,	5,	5,	5,	5
};

// parse action table
const int coder_parser_t::yypact[109] = {
11,	32,	41,	10,	93,	92,	33,	42,
	53,	54,	55,	56,	57,	58,	59,	60,
	32,	32,	75,	76,	32,	33,	33,	61,
	62,	68,	41,	63,	32,	32,	223,	42,
	71,	33,	33,	83,	223,	77,	53,	54,
	55,	56,	57,	58,	59,	60,	78,	94,
	223,	223,	223,	104,	96,	61,	62,	105,
	113,	63,	223,	109,	223,	84,	172,	172,
	172,	172,	172,	172,	172,	172,	75,	76,
	216,	216,	223,	223,	116,	172,	172,	114,
	119,	172,	123,	117,	132,	172,	89,	124,
	133,	77,	223,	216,	223,	97,	131,	216,
	101,	129,	78,	41,	216,	41,	41,	41,
	42,	223,	42,	42,	42
};

// base array for parse action table
// which is used to determine the base location of the entries
// for each state stored in the yypack table
const int coder_parser_t::yypabase[145] = {
0,	0,	0,	0,	0,	0,	-33,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	-33,	0,	0,	0,	-32,	0,
	0,	0,	0,	-6,	-18,	-17,	0,	-14,
	0,	0,	0,	0,	0,	-8,	4,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	24,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	48,
	0,	-6,	-5,	0,	-1,	0,	-28,	11,
	0,	0,	56,	0,	0,	58,	0,	0,
	19,	0,	0,	0,	0,	0,	0,	24,
	44,	48,	0,	0,	0,	0,	0,	46,
	0,	0,	0,	0,	0,	62,	0,	52,
	0,	0,	65,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	67,	0,
	0,	0,	0,	0,	0,	0,	0,	68,
	0,	0,	0,	0,	0,	69,	0,	0,
	0
};

const int coder_parser_t::yypgoto[23] = {
34,	31,	51,	34,	65,	30,	34,	66,
	69,	223,	223,	49,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	67
};

const int coder_parser_t::yypgbase[145] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	-9,	0,	0,	0,	0,	0,
	0,	0,	-12,	0,	-6,	-3,	0,	-1,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0
};

const by_te_t coder_parser_t::yyvbmap[870] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	4,	0,	0,	1,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	2,	0,
	8,	0,	0,	0,	0,	0,	1,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	18,	0,	0,	0,	0,	0,	64,	0,
	0,	0,	0,	1,	0,	0,	0,	0,
	0,	0,	128,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	0,	0,	64,	0,
	0,	0,	0,	0,	1,	0,	1,	0,
	0,	0,	0,	0,	0,	4,	0,	24,
	132,	0,	16,	0,	0,	0,	128,	0,
	32,	0,	0,	0,	0,	0,	16,	0,
	0,	0,	128,	0,	64,	1,	0,	0,
	132,	0,	8,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	1,	0,	0,	0,
	0,	0,	18,	0,	0,	4,	0,	24,
	132,	0,	0,	0,	0,	1,	0,	0,
	16,	0,	0,	0,	128,	0,	0,	0,
	0,	0,	1,	0,	64,	1,	0,	0,
	128,	0,	0,	192,	63,	96,	2,	0,
	0,	0,	0,	0,	132,	0,	0,	0,
	0,	0,	132,	0,	64,	1,	0,	0,
	128,	0,	0,	0,	0,	0,	132,	0,
	128,	2,	0,	0,	132,	0,	0,	0,
	0,	128,	2,	0,	128,	2,	0,	0,
	132,	0,	128,	2,	0,	0,	132,	0,
	0,	0,	0,	0,	18,	0,	0,	4,
	0,	26,	132,	0,	0,	192,	0,	0,
	2,	4,	0,	44,	0,	26,	132,	0,
	0,	44,	0,	26,	132,	0,	0,	44,
	0,	26,	132,	0,	0,	0,	0,	0,
	2,	0,	0,	60,	0,	26,	132,	0,
	0,	44,	0,	26,	132,	0,	0,	44,
	0,	26,	132,	0,	0,	44,	0,	26,
	132,	0,	0,	44,	0,	26,	132,	0,
	0,	0,	0,	0,	32,	0,	16,	0,
	0,	0,	128,	0,	0,	0,	0,	0,
	16,	0,	64,	1,	0,	0,	128,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	0,	0,	0,
	0,	1,	0,	192,	63,	96,	34,	0,
	0,	192,	63,	96,	34,	0,	0,	0,
	0,	0,	0,	1,	0,	0,	0,	0,
	0,	1,	0,	192,	63,	96,	98,	0,
	0,	192,	63,	96,	34,	0,	0,	2,
	0,	0,	132,	0,	128,	0,	0,	0,
	132,	0,	16,	0,	0,	0,	128,	0,
	0,	0,	0,	128,	18,	0,	128,	2,
	0,	0,	132,	0,	0,	0,	0,	0,
	3,	0,	0,	0,	0,	0,	16,	2,
	1,	0,	0,	0,	0,	0,	0,	44,
	0,	26,	132,	0,	0,	192,	0,	0,
	34,	4,	0,	0,	0,	0,	0,	1,
	0,	0,	0,	0,	0,	1,	0,	192,
	0,	0,	98,	4,	0,	0,	0,	0,
	2,	0,	0,	192,	0,	0,	34,	4,
	0,	0,	0,	0,	17,	0,	0,	4,
	0,	24,	132,	0,	64,	1,	0,	0,
	132,	0,	32,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	132,	0,	0,	192,
	63,	96,	34,	0,	0,	0,	0,	0,
	8,	0,	0,	0,	192,	0,	9,	0,
	0,	0,	192,	0,	9,	0,	0,	0,
	192,	0,	9,	0,	64,	1,	0,	0,
	128,	0,	64,	1,	0,	0,	128,	0,
	0,	0,	0,	0,	16,	0,	0,	0,
	0,	0,	16,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	0,	0,	16,	2,
	0,	0,	0,	0,	8,	0,	0,	4,
	0,	24,	132,	0,	0,	192,	0,	0,
	34,	4,	0,	0,	0,	0,	1,	0,
	0,	0,	0,	0,	1,	0,	0,	0,
	192,	0,	9,	0,	0,	192,	0,	0,
	34,	4,	0,	0,	0,	0,	17,	0,
	0,	0,	0,	0,	17,	0,	0,	0,
	0,	0,	32,	0,	0,	4,	0,	24,
	132,	0,	0,	0,	0,	0,	32,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	4,
	0,	192,	63,	96,	34,	4,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	0,	32,	0,	128,	2,	0,	0,
	132,	0,	0,	0,	0,	0,	32,	0,
	0,	0,	0,	0,	8,	0,	0,	0,
	0,	0,	16,	2,	0,	4,	0,	24,
	132,	0,	0,	192,	0,	0,	34,	4,
	0,	192,	0,	0,	34,	4,	0,	192,
	0,	0,	34,	4,	0,	192,	0,	0,
	34,	4,	0,	192,	0,	0,	34,	4,
	0,	0,	0,	0,	17,	0,	0,	0,
	0,	0,	32,	0,	0,	44,	0,	26,
	132,	0,	0,	36,	0,	24,	132,	0,
	16,	0,	0,	0,	128,	0,	128,	2,
	0,	0,	132,	0,	128,	2,	0,	0,
	132,	0,	128,	2,	0,	0,	132,	0,
	0,	0,	0,	0,	16,	2,	0,	12,
	0,	24,	132,	0,	0,	44,	0,	26,
	132,	0,	0,	44,	0,	26,	132,	0,
	0,	60,	0,	26,	132,	0
};

const int coder_parser_t::yyparv[145] = {
223,	3,	5,	7,	9,	146,	223,	12,
	14,	16,	19,	20,	21,	147,	198,	16,
	25,	152,	223,	148,	36,	150,	223,	151,
	153,	48,	50,	223,	223,	223,	158,	223,
	165,	71,	163,	166,	149,	223,	223,	207,
	208,	201,	80,	209,	199,	202,	203,	204,
	82,	154,	83,	159,	223,	182,	181,	183,
	184,	185,	86,	186,	187,	87,	88,	223,
	169,	223,	223,	155,	223,	164,	223,	223,
	197,	200,	223,	99,	100,	223,	102,	214,
	223,	211,	156,	107,	162,	170,	108,	223,
	223,	223,	160,	161,	120,	121,	122,	223,
	125,	213,	215,	127,	128,	223,	217,	223,
	195,	134,	223,	136,	188,	175,	177,	189,
	190,	179,	176,	178,	180,	171,	173,	174,
	137,	138,	191,	139,	140,	193,	223,	222,
	221,	218,	219,	220,	196,	142,	206,	223,
	157,	167,	168,	192,	194,	223,	205,	210,
	212
};


const int coder_parser_t::yyparn[145] = {
32,	0,	0,	0,	0,	0,	32,	0,
	0,	0,	0,	0,	0,	0,	0,	2,
	0,	0,	32,	0,	0,	0,	32,	0,
	0,	0,	2,	32,	32,	32,	0,	32,
	0,	2,	0,	0,	0,	32,	32,	0,
	0,	0,	0,	2,	0,	0,	0,	0,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	32,
	0,	32,	32,	0,	32,	0,	32,	32,
	0,	0,	32,	0,	0,	32,	0,	0,
	32,	0,	0,	0,	0,	0,	0,	32,
	32,	32,	0,	0,	0,	0,	0,	32,
	0,	0,	0,	0,	0,	32,	0,	32,
	0,	0,	32,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	32,	0,
	0,	0,	0,	0,	0,	0,	0,	32,
	0,	0,	0,	0,	0,	32,	0,	0,
	0
};

const int coder_parser_t::yypcv[75] = {
223,	223,	223,	223,	23,	223,	27,	91,
	28,	90,	38,	144,	81,	143,	223,	223,
	223,	223,	223,	223,	223,	223,	111,	112,
	223,	72,	223,	39,	40,	223,	223,	70,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	29,	2,	43,	74,
	79,	223,	52,	64,	223,	223,	223,	26,
	18,	223,	35,	223,	223,	4,	223,	223,
	223,	15,	223,	223,	223,	44,	45,	46,
	47,	223,	223
};

const int coder_parser_t::yypcn[75] = {
32,	32,	32,	32,	1,	32,	1,	1,
	1,	1,	3,	3,	1,	3,	32,	32,
	32,	32,	32,	32,	32,	32,	1,	1,
	32,	3,	32,	3,	3,	32,	32,	1,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	1,	1,	1,	1,
	1,	32,	1,	1,	32,	32,	32,	1,
	1,	32,	1,	32,	32,	1,	32,	32,
	32,	1,	32,	32,	32,	3,	1,	1,
	1,	32,	32
};


const int coder_parser_t::yypgrv[145] = {
223,	223,	223,	6,	8,	223,	223,	223,
	13,	17,	223,	223,	223,	223,	22,	24,
	223,	223,	223,	223,	223,	223,	37,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	73,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	85,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	69,	69,	223,	223,	223,	223,	95,
	223,	223,	98,	223,	223,	223,	223,	223,
	103,	106,	223,	223,	223,	223,	223,	110,
	115,	118,	223,	223,	223,	223,	223,	223,
	223,	126,	223,	223,	223,	130,	223,	223,
	223,	223,	135,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	141,	223,
	223,	223,	223,	223,	223,	223,	223,	73,
	223,	223,	223,	223,	223,	73,	223,	223,
	223
};

const int coder_parser_t::yypgrn[145] = {
32,	32,	32,	0,	0,	32,	32,	32,
	0,	2,	32,	32,	32,	32,	0,	2,
	32,	32,	32,	32,	32,	32,	4,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	2,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	0,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	2,	2,	32,	32,	32,	32,	0,
	32,	32,	0,	32,	32,	32,	32,	32,
	0,	0,	32,	32,	32,	32,	32,	0,
	0,	0,	32,	32,	32,	32,	32,	32,
	32,	0,	32,	32,	32,	0,	32,	32,
	32,	32,	4,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	4,	32,
	32,	32,	32,	32,	32,	32,	32,	2,
	32,	32,	32,	32,	32,	2,	32,	32,
	32
};


// get global parser object,
// it's invisiable to user
static coder_parser_t& getTheParser(void) {

	static coder_parser_t yyp(coder_lex);
	return yyp;
}

// assign new error-reporter and return the old one
coder_error_t coder_seterror(coder_error_t perror) {

	coder_parser_t& yyp = getTheParser();
	coder_error_t pold = yyp.yyerror;
	yyp.yyerror = perror;

	return pold;
}

// reset all (both scanner and parser, if they are available)
void coder_clearall(void) {
	getTheParser().yyclearall__();
}


// initializing file buffer before parsing or patter-matching
int coder_lexfile(const char* pchFile, bool iMod) {
	
	return getTheParser().yylexinit__(pchFile, iMod)? 0: -1;
}
// initializing string buffer before parsing or patter-matching
int coder_lexstr(char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}
// initializing const string buffer before parsing or patter-matching
int coder_lexcstr(const char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}

// generated scanner, can be replaced
int coder_lex(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {

	return getTheParser().yylex__(coder, dmap, cmmgr);
} 

// assign new scanner and return the old one 
coder_lex_t coder_setlex(coder_lex_t plex) {
	
	coder_parser_t& yyp = getTheParser();
	coder_lex_t pold = yyp.yylexer;
	yyp.yylexer = plex;

	return pold;
}

// generated parser, it should not be replaced
int coder_parse(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
	return getTheParser().yyparse__(coder, dmap, cmmgr);
}
#line 894 "../meta/coderyac.upg"



#line 4120 "coderyac.cpp"


