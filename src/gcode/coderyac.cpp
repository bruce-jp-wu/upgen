/*******************************************************************************
A parser program in C++, generated by Upgen 0.5.4.
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
// update 14/12/17
#include <vector>
#include <unordered_map>
#include <string>

namespace coder_nsx {
typedef unsigned char by_te_t;
}
namespace coder_nsx {

class bufbase_t;
typedef bufbase_t *YYPBUFFER;
}

#include "./coderyac.h"

#line 33 "meta/coderyac.upg"

/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2009-2018 Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "../main/upgmain.h"
#ifdef UPGEN_TEST_VERSION
#include <iostream>
using std::cerr;
using std::endl;
#endif

#include <iosfwd>
using std::ostream;

#include "../common/common.h"
#include "../common/reporter.h"

#include "../common/strhelper.h"
using common_ns::strhelper_t;
#include "../common/types.h"

#include "../coder/ctoken.h"
using coder_ns::ctoken_t;
#include "../coder/cmacro.h"
#include "../coder/cmcond.h"
#include "../coder/dmmap.h"
#include "../coder/coder.h"
#include "../coder/cmmgr.h"
using coder_ns::coder_t;
using coder_ns::cmacro_mgr_t;
using coder_ns::dmmap_t;
using coder_ns::vterm_t;
using coder_ns::cmacro_t;
using coder_ns::cond_t;
using coder_ns::cond_elemrel_t;
using coder_ns::cond_compound_t;
using coder_ns::cond_item_t;
using coder_ns::mac2cond_pair_t;
using coder_ns::vmac2cond_t;
using coder_ns::cmacro_term_t;


#line 87 "gcode/coderyac.cpp"
namespace coder_nsx {
enum {
INC_YYTEXT_SIZE = 4096,
END_OF_FILE = 256,
END_OF_ALLFILE = 257,

// start-condition names
INITIAL = 0,

// number of DFA states of scanner
LEX_STATE_COUNT = 174,

// DFA trap-state of scanner
LEX_ERROR_STATE = 0,

// ID of invalid rule for scanner,
// indicating current string can not be matched by any pattern
LEX_ERROR_RULE = -1,

// this constant used by computing index of a rule that matches EOF
// for example, in start-condition INITIAL, index of the rule that
// matches EOF is 
//	LEX_EOFRULE_BASE + INITIAL
LEX_EOFRULE_BASE = 37,

// index of the rule that matches EOAF (end of all files, or end of input)
LEX_EOAF_RULE = 38,


// index of symbol `$end' in symbol table
PARSE_ENDSYMB_INDEX = 0,
// index of symbol `error' in symbol table
PARSE_ERRORSYMB_INDEX = 1,
// index of symbol `$undef' in symbol table
PARSE_UNDEFSYMB_INDEX = 2,

// ID of symbol `$end'
PARSE_ENDSYMB_ID = 0,
// ID of symbol `error'
PARSE_ERRORSYMB_ID = 256,
// ID of symbol '$undef'
PARSE_UNDEFSYMB_ID = 257,

// row size(in byte) of non-error bitmap of parse table
PARSE_BMAP_ROWSIZE = 6,
// base address of indexes of types (aka non-terminals or variables)
PARSE_TYPE_BASE = 43,
// number of symbols in parser
PARSE_SYMBOL_COUNT = 75,

// number of symbols in parser
PARSE_TOKENMAP_SIZE = 291,

// start state of parser
PARSE_START_STATE = 1,

// accept state of parser
PARSE_ACCEPT_STATE = 5,

// illegal state for parser
PARSE_ERROR_STATE  = 145,

// special ID of invalid rule for parser, indicating current lookahead
// symbol can not be shifted
PERROR_RULE = 77,


MAX_MSG_LENG = 128,
};

// macros for wrapped new operator
#define MYNEW(var, type) {\
	var = new type;\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYNEWS(var, type, size) {\
	var = new type[size];\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYRENEW(var, type, size, osize) {\
	type *p = new type[size];\
	if(!p) {\
		exit_on_oom();\
	}\
	memcpy(p, var, sizeof(type) * osize);\
	delete[] var;\
	var = p;\
}

// error IDs
enum {
	// grammar is accepted by automation
	YYE_ACCEPT =	1,
	// indicate automation is alive
	YYE_ALIVE =	2,
	// run out of all buffers,
	// and token `$end' will be sent to parser
	YYE_EOS =	3,
	// lexical analysis terminated manually,
	// and token `$end' will be sent to parser
	YYE_TERM =	3,
	// syntactic error occurs, and try to error-recover
	YYE_PERROR =	4,

	// can not match any pattern, token `$undef' will
	// be sent to parser
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID,

	// out of memory
	YYE_OOM = 	-1,
	// out of range
	YYE_OOR =	-2,
	// I/O error
	YYE_IO =	-3,
	// parsing aborted
	YYE_ABORT = 	-4,
	YYE_NOINPUT =	-5,
};

class bufbase_t;
typedef bufbase_t *YYPBUFFER;

class bufbase_t {

public:
	virtual ~bufbase_t(void){}
	virtual int get(void) = 0;
	virtual int peek(void) = 0;
	virtual int unget(void) = 0;
	virtual int unget(int num) = 0;
	virtual int put(char) = 0;

	inline void reset(void) {
		xreset();
		stlsz.clear();
		sttsz.clear();
	}
	inline bool iseof(void) const { return gptr == gend;}
	inline bool iseos(void) const { return eos;	}
	inline bool isimod(void) const { return imod;}
	inline void setimod(bool bi) { imod = bi;}
	inline int getlineno(void) const { return line;}
	inline void setlineno(int nline) { line = nline;}
	inline int getcolno(void) const { return col;}
	inline void setcolno(int ncol) { col = ncol;}
	inline int gettabsize(void) const { return tab;}
	inline void settabsize(int ntab) { tab = (ntab > 0)? ntab : 1;}

	inline void* getdata(void) const { return pvoid; }
	inline void setdata(void* pv) { pvoid = pv; }
protected:
	virtual void xreset(void) = 0;

	by_te_t *pbase;
	by_te_t *gptr;
	by_te_t *gend;
	bool eos;
	// interactive mode
	bool imod;
	int line;
	int col;
	int tab;
	
	void *pvoid;

public:
    // update 14/12/17
    inline void pushlsz(int nlsize) {
        stlsz.push_back(nlsize);
    }
    inline int poplsz(void) {
        if(stlsz.empty()) {
            return 0;
        }
        auto n = stlsz.back();
        stlsz.pop_back();
        return n;
    }

    inline void pushtsz(int ntsize) {
        // update 14/12/17
        sttsz.push_back(ntsize);
    }
    inline int poptsz(void) {
        if(sttsz.empty()) {
            return 0;
        }
        auto n = sttsz.back();
        sttsz.pop_back();
        return n;
    }
protected:
    // update 14/12/17
    std::vector<int> stlsz;
    std::vector<int> sttsz;

};

xstype_t coder_lval;
xltype_t coder_lloc;


// program abort due to out of memory
inline static void exit_on_oom(void) {
	exit(-1);
}
static char stext__[24] = "unprintable-char{";
inline static const char* sym_text__(const char* ps) {
	
	by_te_t b = (by_te_t)*ps, i = 17, t;
	if( !ps[1] && (b < 32 || b >= 127)) {
		if((t = b / 100) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 100;
		}
		if((t = b / 10) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 10;
		}
		stext__[i++] = (char)(b + 48);
		stext__[i++] = '}';
		stext__[i] = '\0';
		return stext__;
	}
	return ps;
}

static void yyemit_error__(const char *s, coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr);

class coder_parser_t {

	friend void coder_setstream(FILE *poutput, FILE *plogger);
	friend coder_error_t coder_seterror(coder_error_t);
	friend coder_lex_t coder_setlex(coder_lex_t);

private:

	// class bufmgr_t class define HERE
	class bufmgr_t {

	public:

		enum {
			// half size of buffer
			BUF_HALF_SIZE = 4096,
			// fullsize of buffer
			BUF_FULL_SIZE = BUF_HALF_SIZE * 2
		};

	private:
		class filebuf_t: public bufbase_t {

			friend class bufmgr_t;
		private:

			inline void init(void) {

				gptr = pbase = &buf[BUF_FULL_SIZE - 1];
				gend = &buf[0];
				eos = false;
				bpeeked = false;
			}

		public:

			filebuf_t(FILE* pf = stdin)
			: pfile(pf) {
				imod = (pf == stdin);
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
				init();
			}

			virtual ~filebuf_t(void) {

				if(pfile != stdin) {

					fclose(pfile);
				}
			}

			virtual void xreset(void) {

				if(pfile != stdin) {
					fseek(pfile, 0, SEEK_SET);
				}
				init();
			}

			virtual int get(void) {

				if(gptr == gend) {

					eos = true;
					return END_OF_ALLFILE;
				}

				gptr = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(gptr == gend && !bpeeked) {

					fill(gptr);
				}

				bpeeked = false;

				return iseof()? END_OF_FILE: (int)(*gptr);
			}

			virtual int peek(void) {

				if(gptr == gend) {

					return END_OF_ALLFILE;
				}

				by_te_t *p = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(p == gend) {

					fill(p);
				}

				bpeeked = true;

				return (p == gend)? END_OF_FILE: (int)(*p);
			}

			virtual int unget(void) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

			virtual int unget(int num) {

				if(eos || gptr == pbase) {
					return 0;
				}
				int n = ((gptr - pbase) + BUF_FULL_SIZE) % BUF_FULL_SIZE;

				if(n > num) {
					n = num;
				}
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - n) % BUF_FULL_SIZE;

				return n;
			}
		
			virtual int put(char c) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				*gptr = (by_te_t)c;
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

		private:

			int fill(by_te_t *p) {

				int ncnt = 0;
				int vacents = ((pbase + BUF_FULL_SIZE) - gend) % BUF_FULL_SIZE;
				if(stdin != pfile) {
					while((ncnt = fread(p, 1, BUF_HALF_SIZE, pfile)) == 0 && ferror(pfile)) {
						if(errno != EINTR) {
							// IO error
							return 0;
						}
						clearerr(pfile);
						errno = 0;
					}
					gend = buf + (p - buf + ncnt) % BUF_FULL_SIZE;
				}
				else {
					for(int c = 0; '\n' !=  c && ncnt < BUF_HALF_SIZE;
						gend = buf + ((gend - buf) + 1) % BUF_FULL_SIZE, ++ncnt) {

						c = fgetc(stdin);
						*gend = (by_te_t)c;
						if(EOF == c && feof(pfile)) {
							break;
						}
					}
				}
				if(ncnt > vacents) {
					pbase = buf + ((gend - buf) + 1) % BUF_FULL_SIZE;
				}
				return ncnt;
			}

		private:

			bool bpeeked;
			FILE *pfile;
			by_te_t buf[BUF_FULL_SIZE];
		};

	private:

		class strbuf_t: public bufbase_t {

			friend class bufmgr_t;
		public:

			// nSize is length of string including terminating NULL
			strbuf_t(const char *pchBuf, int nSize)
			: bowner(true) {

				MYNEWS(pbase, by_te_t, nSize);
				memcpy(pbase, pchBuf, sizeof(char)*(nSize - 1));
				pbase[nSize - 1] = '\0';

				gend = pbase + nSize - 1;
				xreset();
				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
			}

			strbuf_t(char *pchBuf, int nSize)
			: bowner(false) {

				pbase = (by_te_t*)pchBuf;
				gend = pbase + nSize - 1;
				xreset();

				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
			}

			virtual ~strbuf_t(void) {
				if(bowner) {
					delete [] pbase;
				}
			}

		public:

			virtual void xreset(void) {

				gptr = pbase - 1;
				eos = false;
			}
			virtual int get(void) {

				if(gptr == gend) {
					eos = true;
					return END_OF_ALLFILE;
				}
				++gptr;

				return (gptr == gend)? END_OF_FILE : (int)(*gptr);
			}

			virtual int peek(void) {

				return (gptr == gend) ? (eos ? END_OF_ALLFILE: END_OF_FILE) : 
					(int)(*(gptr + 1));
			}
			virtual int unget(void) {
				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}
				return (int)(*gptr--);
			}
			virtual int unget(int num) {

				if(eos || (pbase - 1 == gptr)) {
					return 0;
				}
				int n = gptr - pbase + 1;
				if(n > num) {
					n = num;
				}
				gptr -= n;

				return n;
			}

			virtual int put(char c) {

				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);

				*gptr-- = (by_te_t)c;

				return oldc;
			}

		private:
			bool bowner;
		};

	private:

		struct link_t {

			link_t(bufbase_t *pxb, link_t *plnk = NULL)
			: pxbuf(pxb)
			, plink(plnk){}

			bufbase_t *pxbuf;
			link_t *plink;
		};

	public:

		bufmgr_t(void)
		: phead(NULL) {

			MYNEW(pstdin, filebuf_t);
			MYNEW(pavail, link_t(pstdin, NULL));
		}
		~bufmgr_t(void) {

			while(pavail) {

				link_t *p = pavail->plink;

				delete pavail->pxbuf;
				delete pavail;

				pavail = p;
			}			
		}

	public:

		inline int get(void) {
			return phead? phead->pxbuf->get(): END_OF_ALLFILE;
		}
		inline int peek(void) {
			return phead? phead->pxbuf->peek(): END_OF_ALLFILE;
		}
		inline int unget(void) {
			return phead? phead->pxbuf->unget(): END_OF_FILE;
		}
		inline int unget(int num) {
			return phead? phead->pxbuf->unget(num): 0;
		}
		inline int put(char c) {
			return phead? phead->pxbuf->put(c): END_OF_FILE;
		}
		inline bool iseof(void) const {
			return phead? phead->pxbuf->iseof(): true;
		}
		inline bool iseos(void) const {
			return phead? phead->pxbuf->iseos(): true;
		}
		inline bool isimod(void) const {
			return phead? phead->pxbuf->isimod(): false;
		}
		inline int getlineno(void) const {
			 return phead? phead->pxbuf->getlineno(): 0;
		}
		inline void setlineno(int nline) {
			if(phead) {
				phead->pxbuf->setlineno(nline);
			}
		}
		inline int getcolno(void) const {
			return phead? phead->pxbuf->getcolno(): 0;
		}
		inline void setcolno(int ncol) {
			if(phead) {
				phead->pxbuf->setcolno(ncol);
			}
		}
		inline int gettabsize(void) const {
			return phead? phead->pxbuf->gettabsize(): 0;
		}
		inline void settabsize(int ntab) {
			if(phead) {
				phead->pxbuf->settabsize(ntab);
			}
		}
		inline void reset(void) {
			if(phead) {
				phead->pxbuf->reset();
			}
		}
		inline void pushlsz(int nlsize) {
			if(phead) {
				phead->pxbuf->pushlsz(nlsize);
			}
		}
		inline int poplsz(void) {
			if(phead) {
				return phead->pxbuf->poplsz();
			}
			return 0;
		}
		inline void pushtsz(int ntsize) {
			if(phead) {
				phead->pxbuf->pushtsz(ntsize);
			}
		}
		inline int poptsz(void) {
			if(phead) {
				return phead->pxbuf->poptsz();
			}
			return 0;
		}


		inline bufbase_t* current(void) const {
			return phead ? phead->pxbuf : NULL;
		}

		inline bool empty(void) const {
			return ! phead;
		}

		inline bufbase_t* newbuf(FILE *pfile, bool iMod = false) {

			bufbase_t *p;
			if(pfile == stdin) {
				p = pstdin;
				p->reset();
			}
			else {
				MYNEW(p, filebuf_t(pfile));
				MYNEW(pavail->plink, link_t(p, pavail->plink));
			}
			
			p->setimod(iMod);
			
			return p;
		}
		inline bufbase_t* newbuf(char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		inline bufbase_t* newbuf(const char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		
		inline bufbase_t* switchto(bufbase_t* pbuf) {

			bufbase_t *pold = phead ? phead->pxbuf : NULL;
			link_t* p = rmwork(pbuf);
			if( ! p) {
				MYNEW(phead, link_t(pbuf, phead));
			}
			else {
				p->plink = phead;
				phead = p;
			}
			
			return pold;
		}
		
		inline bufbase_t* pop(void) {
			
			if(! phead) {
				return NULL;
			}
			
			link_t *p = phead;
			bufbase_t* pbuf = p->pxbuf;
			phead = phead->plink;
			
			delete p;
			
			return pbuf;
		}

		void destroytop(void) {
			
			bufbase_t *pxb = pop();
			if( pxb && pxb != pstdin) {

				link_t *p = pavail;
				
				while(p->plink && p->plink->pxbuf != pxb) {
					p = p->plink;
				}
				if(p->plink) {
					link_t *q = p->plink;
					p->plink = q->plink;

					delete pxb;
					delete q;
				}
			}
		}
		
		void destroyall(void) {

			while(pavail->plink) {
				link_t *p = pavail->plink;
				pavail->plink = p->plink;
				if(p->pxbuf) {
					delete p->pxbuf;
				}
				delete p;
			}
			
			phead = NULL;
		}

	private:

		link_t* rmwork(bufbase_t* pxb) {

			link_t *p = phead;
			// then check if @pxb is in the list, if so, then remove it
			if(p) {

				if(pxb == phead->pxbuf) {
					phead = phead->plink;
					return p;
				}
				else {
					while(p->plink && p->plink->pxbuf != pxb) {
						p = p->plink;
					}
					if(p->plink) {
						link_t *q = p->plink;
						p->plink = q->plink;
						return q;
					}
				}
			}

			return NULL;
		}

	private:

		// working buffer stack
		link_t *phead;
		// available buffer stack
		link_t *pavail;
		// stdin buffer
		bufbase_t *pstdin;
	};


    template<class ElemType, int INIT_SIZE = 4096>
    class sstack_t {
    public:
        inline sstack_t(void) {

        }

        inline void push(void) {
            mStk.push_back(ElemType());
        }
        inline void push(const ElemType &e) {
            mStk.push_back(e);
        }
        inline ElemType& top(void) {
            return mStk.back();
        }
        inline const ElemType& top(void) const {
            return mStk.back();
        }
        inline void pop(int n) {
            while(n > 0 && !mStk.empty()) {
                mStk.pop_back();
                n--;
            }
        }
        inline ElemType& operator[](int down) {
            const auto sz = (int) mStk.size();
            return mStk[sz - 1 - down];
        }
        inline const ElemType& operator[](int down) const {
            const auto sz = (int) mStk.size();
            return mStk[sz - 1 - down];
        }

        inline bool empty(void) const {
            return mStk.empty();
        }

        inline int count(void) const {
            return (int)mStk.size();
        }

        inline void clear(void) {
            mStk.clear();
        }
    private:
        std::vector<ElemType> mStk;
    };


private:

	inline void renew_text__(void) {

		MYRENEW(yytext, char, INC_YYTEXT_SIZE + yysize__, yysize__);
		yysize__ += INC_YYTEXT_SIZE;
		yytext[yysize__ - 1] = '\0';
	}

	inline bool yylex_is_running__(void) const {
		return yyecode__ == YYE_ALIVE;
	}
	inline int yyget_lexrule__(int s) const{
		return yydaccpt[s];
	}

	int yynext_lexstate__(int s, int c) const {

		int d = yydcmap[c];
		while(s < LEX_STATE_COUNT && yydchk[ yydbase[s] + d] != s) {
			s = yyddef[s];
		}

		if(s > LEX_STATE_COUNT) {
			return yydchk[yydbase[s] + yydmeta[d]] == s?
				yydnxt[ yydbase[s] + yydmeta[d]] : LEX_ERROR_STATE;
		}
		else {
			return yydnxt[ yydbase[s] + d];
		}
	}

	friend void yyemit_error__(const char *s, coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr);

private:
	// update 16/12/17
    int YYSTOKEN(const std::string& lexeme) const {
		if(lexeme.size() == 1) {
			return (int)lexeme[0];
		}
        auto cit = yyslexemID.find(lexeme);
        if(cit == yyslexemID.cend()) {
			return PARSE_UNDEFSYMB_ID;
		}
        return cit->second;
	}

	inline void YYACCEPT(void) {
		yyecode__ = YYE_ACCEPT;
	}
	inline void YYABORT(void) {
		yyecode__ = YYE_ABORT;
	}
	inline void yyerrok(void) {
		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;
	}

	inline bool yyparse_is_running__(int s) const {
		return yyecode__ > YYE_ACCEPT && s != PARSE_ACCEPT_STATE;
	}
	inline int yyget_defrule(int s) const {
		if(0 == yyparn[s] && is_valid_prule__(yyget_prule__(yyparv[s])) ) {
			return yyget_prule__(yyparv[s]);
		}
		return PERROR_RULE;
	}
	inline bool is_valid_pstate__(int s) const {
		return s < PARSE_ERROR_STATE;
	}
	inline bool is_valid_prule__(int r) const {
		return r >= 0 && r < PERROR_RULE;
	}
	inline int yyget_prule__(int s) const {
		return s - (PARSE_ERROR_STATE + 1);
	}
	inline void yydiscard__(xstype_t &yydval, xltype_t  &yydloc, int yydsymb, coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
	
	}
	inline int yynext_pstate__(int s, int t) const {
		if(yyvbmap[s * PARSE_BMAP_ROWSIZE + t / 8] & (1 << (t % 8))) {
			if(yyparn[s] < yypcn[t]) {
				return yyparv[s];
			}
			else if(yyparn[s] > yypcn[t]) {
				return yypcv[t];
			}
			return yypact[yypabase[s] + t];
		}
		return PARSE_ERROR_STATE;
	}
	inline int yynext_goto__(int s, int t) const {
		if(yypgrn[s] < yypcn[PARSE_TYPE_BASE + t]) {
			return yypgrv[s];
		}
		else if(yypgrn[s] > yypcn[PARSE_TYPE_BASE + t]) {
			return yypcv[PARSE_TYPE_BASE + t];
		}
		return yypgoto[yypgbase[s] + t];
	}

public:

	inline coder_parser_t(coder_lex_t plex = NULL)
	: yyecode__(YYE_ALIVE)
	, yysize__(0)
	, yystart__(INITIAL)
	, yymore_flag__(false)
	, yyat_bol__(true)
	, yytext(NULL)
	, yyleng(0)
	, yylaleng(0)
	, yyerr_flag__(false)
	, yyltok(PARSE_UNDEFSYMB_ID)
	, yylexer(plex)
	, yyoutput(stdout)
	, yylogger(stderr)
	, yyerror(yyemit_error__) {

	}
	~coder_parser_t(void) {

		if(yytext) {
			delete[] yytext;
		}

	}

	inline bool yylexinit__(const char *pchFile, bool bi) {

		YYPBUFFER pbuf = yy_new_filebuf(pchFile, bi);
		if( !pbuf ) {
			return false;
		}
		
		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(const char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_cstrbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_strbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	int yylex__(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
		
		if( !yy_has_buffer()) {yyecode__ = YYE_EOS; return 0;}

		int yylstate__ = LEX_ERROR_STATE;
		int yylrule__ = LEX_ERROR_RULE;
		int yyaccleng__ = 0;
		int yycchar__ = END_OF_FILE;
		bool yylast_at_bol__ = yyat_bol__;
		bool bwrap__ = false;
		
#line 97 "meta/coderyac.upg"

	int c;

#line 1102 "gcode/coderyac.cpp"

		yymore_flag__ = false;
		yyecode__ = YYE_ALIVE;
		
		yyleng = 0;
		yylaleng = 0;
		yytext[0] = '\0';

		

		if(yyat_bol__) {
			yylstate__ = yydsc[yystart__];
		}
		else {
			yylstate__ = yydsc[yystart__ + 1];
		}

		while(yylex_is_running__()) {

			yycchar__ = yybufmgr__.get();
			yylstate__ = yynext_lexstate__(yylstate__, yycchar__);

			if(LEX_ERROR_STATE != yylstate__) {

				if(yylaleng >= yysize__ - 1) {
					renew_text__();
				}
				yytext[yylaleng] = (char)yycchar__;

				++yylaleng;

				if(yyget_lexrule__(yylstate__) != LEX_ERROR_RULE) {

					yylrule__ = yyget_lexrule__(yylstate__);
					yyaccleng__ = yylaleng;
				}
			}

			if(LEX_ERROR_STATE == yylstate__ || (yybufmgr__.isimod() 
					&& ('\n' == yycchar__ || END_OF_FILE == yycchar__))) {
				if(LEX_ERROR_RULE == yylrule__) {
					if(yylaleng == yyleng) {
						if(yycchar__ == END_OF_FILE) {
							yylrule__ = LEX_EOFRULE_BASE + yystart__ / 2;
						}
						else if(yycchar__ == END_OF_ALLFILE) {
							yylrule__ = LEX_EOAF_RULE;
						}
					}
				}
				else {
					if( LEX_ERROR_STATE == yylstate__) {
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);
					}
					yylaleng = yyaccleng__;
					yytext[yylaleng] = '\0';
				 yyleng = yylaleng;
				}

				if(LEX_ERROR_RULE != yylrule__) {
					if(yyleng > 0) yyat_bol__ = (yytext[yyleng - 1] == '\n');{
				int nline = yyget_lineno();
				int ncol = yyget_colno() - 1;
				int nt = yyget_tabsize();
				int ts, yyt1__;
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {
					if(yytext[yyt1__] == '\t') {

						ts = nt - ncol % nt;
						yybufmgr__.pushtsz(ts);
						ncol += ts;
					}
					else if(yytext[yyt1__] == '\n') {
						yybufmgr__.pushlsz(ncol + 1);
						ncol = 0;
						++nline;
					}
					else {
						++ncol;
					}
				}
				coder_lloc.firstLine = yyget_lineno();
				coder_lloc.firstColumn = yyget_colno();
				coder_lloc.lastLine  = nline;
				coder_lloc.lastColumn = (ncol < 0)?0: ncol;
				yyset_lineno(nline);
				yyset_colno(ncol + 1);
			}
				}

		bwrap__ = (yylrule__ >= LEX_EOFRULE_BASE
			&& yylrule__ < LEX_EOAF_RULE
			&& yywrap__(coder, dmap, cmmgr));

		if(!bwrap__) {
				switch(yylrule__) {
				
case 0:
{
	
#line 146 "meta/coderyac.upg"
		{
		
		if(coder.isThrowAway()) {
		
			coder_lval.m_textVal = nullptr;
			
			while((c = yyinput()) != END_OF_FILE) {
			
				switch(c) {

				case ']':
				
					if((c = yyinput()) == ']') {
						if((c = yyinput()) == '>') {
							c = END_OF_FILE;
						}
						else {
							yyunput(c);
						}
					}
					else {
						yyunput(c);
					}
					
					break;
					
				default:
	
					break;
				}
				
				if(END_OF_FILE == c) {
					break;
				}
			}
		}
		else {
			
			coder_lval.m_textVal = new int2pstr_t;
			coder_lval.m_textVal->second = new string;
			coder_lval.m_textVal->first = 0;
			c = yyinput();
			
			while(END_OF_FILE != c) {
			
				if(']' == c) {
				
					c = yyinput();
					if(']' == c) {
						c = yyinput();
						if(c != '>') {
							(*coder_lval.m_textVal->second) += ']';
							(*coder_lval.m_textVal->second) += ']';
						}
						else {
							break;
						}
					}
					else {
						(*coder_lval.m_textVal->second) += ']';
					}
				}
				else if('&' == c) {
					c = yyinput();
					switch(c) {
					case '&':
						c = yyinput();
						switch(c) {
						case 'g':
							c = yyinput();
							if('t' == c) {
								c = yyinput();
								if(';' == c) {
									(*coder_lval.m_textVal->second) += "&gt;";
								}
								else {
									(*coder_lval.m_textVal->second) += "&&gt";
								}
							}
							else {
								(*coder_lval.m_textVal->second) += "&&g";
							}
							break;
						case 'l':
							c = yyinput();
							if('t' == c) {
								c = yyinput();
								if(';' == c) {
									(*coder_lval.m_textVal->second) += "&lt;";
								}
								else {
									(*coder_lval.m_textVal->second) += "&&lt";
								}
							}
							else {
								(*coder_lval.m_textVal->second) += "&&l";
							}
							break;
						default:
							(*coder_lval.m_textVal->second) += "&&";
							break;
						}
						break;
					case 'g':
						c = yyinput();
						if('t' == c) {
							c = yyinput();
							if(';' == c) {
								(*coder_lval.m_textVal->second) += '>';
								c = yyinput();
							}
							else {
								(*coder_lval.m_textVal->second) += "&gt";
							}
						}
						else {
							(*coder_lval.m_textVal->second) += "&g";
						}
						break;
					case 'l':
						c = yyinput();
						if('t' == c) {
							c = yyinput();
							if(';' == c) {
								(*coder_lval.m_textVal->second) += '<';
								c = yyinput();
							}
							else {
								(*coder_lval.m_textVal->second) += "&lt";
							}
						}
						else {
							(*coder_lval.m_textVal->second) += "&l";
						}
						break;
					default:
						(*coder_lval.m_textVal->second) += '&';
						break;
					}
				}
				
				if(END_OF_FILE != c) {
					if(']' != c && '&' != c) {
						if('\n' == c) {
							++coder_lval.m_textVal->first;
						}
						(*coder_lval.m_textVal->second) += c;
						c = yyinput();
					}
				}
			}
		}

		return PLAIN_TEXT;
	}
	

#line 1361 "gcode/coderyac.cpp"

	}
	break;
	
case 1:
{
	
#line 302 "meta/coderyac.upg"
		return yytext[0];


#line 1373 "gcode/coderyac.cpp"

	}
	break;
	
case 2:
{
	
#line 304 "meta/coderyac.upg"
			return LBL_HAS;


#line 1385 "gcode/coderyac.cpp"

	}
	break;
	
case 3:
{
	
#line 306 "meta/coderyac.upg"
			return LBL_EMPTY;


#line 1397 "gcode/coderyac.cpp"

	}
	break;
	
case 4:
{
	
#line 308 "meta/coderyac.upg"
			return LBL_EQUAL;


#line 1409 "gcode/coderyac.cpp"

	}
	break;
	
case 5:
{
	
#line 310 "meta/coderyac.upg"
		return LBL_UNEQUAL;


#line 1421 "gcode/coderyac.cpp"

	}
	break;
	
case 6:
{
	
#line 312 "meta/coderyac.upg"
			return LBL_END;


#line 1433 "gcode/coderyac.cpp"

	}
	break;
	
case 7:
{
	
#line 314 "meta/coderyac.upg"
			return 	LBL_LAST;


#line 1445 "gcode/coderyac.cpp"

	}
	break;
	
case 8:
{
	
#line 316 "meta/coderyac.upg"
			return LBL_MORE;


#line 1457 "gcode/coderyac.cpp"

	}
	break;
	
case 9:
{
	
#line 318 "meta/coderyac.upg"
	return LBL_GROUPFIRST;


#line 1469 "gcode/coderyac.cpp"

	}
	break;
	
case 10:
{
	
#line 320 "meta/coderyac.upg"
		return LBL_GROUP;


#line 1481 "gcode/coderyac.cpp"

	}
	break;
	
case 11:
{
	
#line 322 "meta/coderyac.upg"
			return LBL_MOD;


#line 1493 "gcode/coderyac.cpp"

	}
	break;
	
case 12:
{
	
#line 324 "meta/coderyac.upg"
			return LBL_TRUE;


#line 1505 "gcode/coderyac.cpp"

	}
	break;
	
case 13:
{
	
#line 326 "meta/coderyac.upg"
			return LBL_FALSE;


#line 1517 "gcode/coderyac.cpp"

	}
	break;
	
case 14:
{
	
#line 328 "meta/coderyac.upg"
		return LBL_SCALAR;
	

#line 1529 "gcode/coderyac.cpp"

	}
	break;
	
case 15:
{
	
#line 330 "meta/coderyac.upg"
		return LBL_SETUPHEAD;
	

#line 1541 "gcode/coderyac.cpp"

	}
	break;
	
case 16:
{
	
#line 332 "meta/coderyac.upg"
		return LBL_MSHEAD;
	

#line 1553 "gcode/coderyac.cpp"

	}
	break;
	
case 17:
{
	
#line 334 "meta/coderyac.upg"
		return LBL_MSTAIL;
	

#line 1565 "gcode/coderyac.cpp"

	}
	break;
	
case 18:
{
	
#line 336 "meta/coderyac.upg"
			return LBL_MACRO;
	

#line 1577 "gcode/coderyac.cpp"

	}
	break;
	
case 19:
{
	
#line 338 "meta/coderyac.upg"
		return LBL_DEFAULTHEAD;
	

#line 1589 "gcode/coderyac.cpp"

	}
	break;
	
case 20:
{
	
#line 340 "meta/coderyac.upg"
	return LBL_DEFAULTTAIL;


#line 1601 "gcode/coderyac.cpp"

	}
	break;
	
case 21:
{
	
#line 342 "meta/coderyac.upg"
			return LBL_CASEHEAD;


#line 1613 "gcode/coderyac.cpp"

	}
	break;
	
case 22:
{
	
#line 344 "meta/coderyac.upg"
		return LBL_CASETAIL;


#line 1625 "gcode/coderyac.cpp"

	}
	break;
	
case 23:
{
	
#line 346 "meta/coderyac.upg"
			return LBL_IFHEAD;


#line 1637 "gcode/coderyac.cpp"

	}
	break;
	
case 24:
{
	
#line 348 "meta/coderyac.upg"
			return LBL_IFTAIL;
	

#line 1649 "gcode/coderyac.cpp"

	}
	break;
	
case 25:
{
	
#line 350 "meta/coderyac.upg"
		return LBL_ELSEHEAD;


#line 1661 "gcode/coderyac.cpp"

	}
	break;
	
case 26:
{
	
#line 352 "meta/coderyac.upg"
		return LBL_ELSETAIL;


#line 1673 "gcode/coderyac.cpp"

	}
	break;
	
case 27:
{
	
#line 354 "meta/coderyac.upg"
	return LBL_DECLARE;


#line 1685 "gcode/coderyac.cpp"

	}
	break;
	
case 28:
{
	
#line 356 "meta/coderyac.upg"
		return LBL_DEFINE;


#line 1697 "gcode/coderyac.cpp"

	}
	break;
	
case 29:
{
	
#line 358 "meta/coderyac.upg"
		return LBL_PHEAD;


#line 1709 "gcode/coderyac.cpp"

	}
	break;
	
case 30:
{
	
#line 360 "meta/coderyac.upg"
	return LBL_PTAIL;


#line 1721 "gcode/coderyac.cpp"

	}
	break;
	
case 31:
{
	
#line 362 "meta/coderyac.upg"
		{
		if( ! coder.isThrowAway()) {
			yytext[yyleng - 1] = '\0';
			coder_lval.m_pstrVal = new string(&yytext[1]);
		}
		else {
			coder_lval.m_pstrVal = nullptr;
		}
		return QUOTEDSTR;
	}

#line 1741 "gcode/coderyac.cpp"

	}
	break;
	
case 32:
{
	
#line 372 "meta/coderyac.upg"
		{
		if( ! coder.isThrowAway()) {		
			coder_lval.m_pstrVal = new string(yytext);
		}
		else {
			coder_lval.m_pstrVal = nullptr;
		}
		return CID;
	}

#line 1760 "gcode/coderyac.cpp"

	}
	break;
	
case 33:
{
	
#line 381 "meta/coderyac.upg"
		{
		
		strhelper_t::toSnum(yytext, coder_lval.m_nVal);

		return INTEGER;
	}

#line 1776 "gcode/coderyac.cpp"

	}
	break;
	
case 34:
{
	
#line 387 "meta/coderyac.upg"



#line 1788 "gcode/coderyac.cpp"

	}
	break;
	
case 35:
{
	
#line 388 "meta/coderyac.upg"



#line 1800 "gcode/coderyac.cpp"

	}
	break;
	
case 36:
{
	
#line 389 "meta/coderyac.upg"


	

#line 1813 "gcode/coderyac.cpp"

	}
	break;
	
case 37:
{
	
#line 0 "meta/coderyac.upg"

#line 1823 "gcode/coderyac.cpp"

	}
	break;
	

				case LEX_EOAF_RULE: 
					yy_delete_buffer();
					yyecode__ = YYE_EOS;
					break;
				default:
					if(yyleng > 0)
						yyat_bol__ = (yytext[yyleng - 1] == '\n');
			
					YYMSG_UNMATCHED[28] = yycchar__;
					yyecode__ = YYE_UNMATCHED;
					if(yyerror)
						yyerror(YYMSG_UNMATCHED, coder, dmap, cmmgr);
				
				break;
				}
			}
				if(yylex_is_running__()) {

					yylast_at_bol__ = yyat_bol__;

					if(yyat_bol__) {
						yylstate__ = yydsc[yystart__];
					}
					else {
						yylstate__ = yydsc[yystart__ + 1];
					}

					yylrule__ = LEX_ERROR_RULE;

					if( ! yymore_flag__) {
						yyaccleng__ = 0;
						yylaleng = 0;
						yyleng = 0;
						yytext[yylaleng] = '\0';
					}
					else {
						yymore_flag__ = false;
					}
				}
			}
		}

		return (yyecode__ == YYE_EOS)? 0 : yyecode__;
	}

	int yyparse__(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {

		if( ! yylexer) {
			return YYE_ABORT;
		}

		yyecode__ = YYE_ALIVE;
		sstack_t<xstype_t> yys_sv__;
		xstype_t yyval;

		sstack_t<xltype_t> yys_loc__;

		xltype_t yyloc;
		sstack_t<int> yys_stt__;
		sstack_t<int> yys_symb__;

		int yyrplen__;
		bool yyreducing__;

		int yypstate__ = PARSE_START_STATE;
		int yyprule__ = PERROR_RULE;
		int yysidx__ = PARSE_UNDEFSYMB_INDEX;
		int yytok__ = PARSE_UNDEFSYMB_ID;
		

		yyltok = PARSE_UNDEFSYMB_ID;
		yyerr_flag__ = false;


		yys_stt__.push(yypstate__);

		while( ! yys_stt__.empty() && yyparse_is_running__(yypstate__)) {
			yyprule__ = yyget_defrule(yypstate__);
			if(is_valid_prule__(yyprule__)) {
				yyreducing__ = true;
			}
			else {
				if(PARSE_UNDEFSYMB_ID == yytok__) {
					if(PARSE_UNDEFSYMB_ID == yyltok) {
						yytok__ = (yylexer)(coder, dmap, cmmgr);
					}
					else  {
						yytok__ = yyltok;
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yysidx__ = (yytok__ < 0 || yytok__ >= PARSE_TOKENMAP_SIZE) ? PARSE_UNDEFSYMB_INDEX
						: yyptmap[yytok__];
				}


				yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);

				if(is_valid_pstate__(yypstate__)) {


					yys_symb__.push(yysidx__);
					yys_stt__.push(yypstate__);
					yys_sv__.push(coder_lval);

					yys_loc__.push(coder_lloc);
 
					yytok__ = PARSE_UNDEFSYMB_ID;
					yyreducing__ = false;
				}
				else {
					yyprule__ = yyget_prule__(yypstate__);
					yyreducing__ = true;
				}
			}

			if(yyreducing__) {
				switch(yyprule__) {
				
	case 0:
	{
#line 394 "meta/coderyac.upg"

#line 1951 "gcode/coderyac.cpp"

	}
	break;
	
	case 1:
	{
#line 394 "meta/coderyac.upg"


			YYACCEPT();
		
#line 1963 "gcode/coderyac.cpp"

	}
	break;
	
	case 2:
	{
#line 400 "meta/coderyac.upg"

			
			if( ! coder.openStream(dmap)) {
				YYABORT();
			}
		
#line 1977 "gcode/coderyac.cpp"

	}
	break;
	
	case 3:
	{
#line 408 "meta/coderyac.upg"

			
			if( ! coder.addSetupItem(*(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal))) {
				
				string strMsg = " description: setting item `";
				strMsg += *(yys_sv__[2].m_pstrVal);
				strMsg += "\' already exists, this setting is discarded.";
				_WARNING(strMsg);
			}
			
			delete (yys_sv__[2].m_pstrVal);
			delete (yys_sv__[0].m_pstrVal);
		
#line 1998 "gcode/coderyac.cpp"

	}
	break;
	
	case 4:
	{
#line 421 "meta/coderyac.upg"


			if( ! coder.addSetupItem(*(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal))) {
				
				string strMsg = " description: setting item `";
				strMsg += *(yys_sv__[2].m_pstrVal);
				strMsg += "\' already exists, this setting is discarded.";
				_WARNING(strMsg);
			}
			
			delete (yys_sv__[2].m_pstrVal);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2019 "gcode/coderyac.cpp"

	}
	break;
	
	case 5:
	{
#line 436 "meta/coderyac.upg"

#line 2028 "gcode/coderyac.cpp"

	}
	break;
	
	case 6:
	{
#line 437 "meta/coderyac.upg"

#line 2037 "gcode/coderyac.cpp"

	}
	break;
	
	case 7:
	{
#line 437 "meta/coderyac.upg"

#line 2046 "gcode/coderyac.cpp"

	}
	break;
	
	case 8:
	{
#line 439 "meta/coderyac.upg"


			(yyval.m_pMac) = cmmgr.newMacro(*(yys_sv__[2].m_pstrVal));
			for(int i = 0; i < (int)(yys_sv__[1].m_pvmac2Cond)->size(); ++i) {
			
				(yyval.m_pMac)->addTerms((*(yys_sv__[1].m_pvmac2Cond))[i]->first, (*(yys_sv__[1].m_pvmac2Cond))[i]->second);
				delete (*(yys_sv__[1].m_pvmac2Cond))[i];
			}
			
			delete (yys_sv__[1].m_pvmac2Cond);
			delete (yys_sv__[2].m_pstrVal);
	
#line 2066 "gcode/coderyac.cpp"

	}
	break;
	
	case 9:
	{
#line 451 "meta/coderyac.upg"

	
		(yyval.m_pMac) = cmmgr.newMacro(*(yys_sv__[2].m_pstrVal));
		
		(yyval.m_pMac)->addTerms((yys_sv__[1].m_pvmTerms));
		
		delete (yys_sv__[2].m_pstrVal);
	
#line 2082 "gcode/coderyac.cpp"

	}
	break;
	
	case 10:
	{
#line 461 "meta/coderyac.upg"

			
			(yyval.m_pstrVal) = (yys_sv__[1].m_pstrVal);
		
#line 2094 "gcode/coderyac.cpp"

	}
	break;
	
	case 11:
	{
#line 466 "meta/coderyac.upg"

#line 2103 "gcode/coderyac.cpp"

	}
	break;
	
	case 12:
	{
#line 468 "meta/coderyac.upg"

			
			(yyval.m_pvmac2Cond) = new vmac2cond_t;
			(yyval.m_pvmac2Cond)->push_back((yys_sv__[0].m_pmac2Cond));
		
#line 2116 "gcode/coderyac.cpp"

	}
	break;
	
	case 13:
	{
#line 473 "meta/coderyac.upg"

		
			(yyval.m_pvmac2Cond) = (yys_sv__[1].m_pvmac2Cond);
			(yyval.m_pvmac2Cond)->push_back((yys_sv__[0].m_pmac2Cond));
		
#line 2129 "gcode/coderyac.cpp"

	}
	break;
	
	case 14:
	{
#line 479 "meta/coderyac.upg"

		
			(yyval.m_pmac2Cond) = new mac2cond_pair_t;
			(yyval.m_pmac2Cond)->first = (yys_sv__[1].m_pvmTerms);
			(yyval.m_pmac2Cond)->second = nullptr;
		
#line 2143 "gcode/coderyac.cpp"

	}
	break;
	
	case 15:
	{
#line 485 "meta/coderyac.upg"

		
			(yyval.m_pmac2Cond) = new mac2cond_pair_t;
			(yyval.m_pmac2Cond)->first = (yys_sv__[1].m_pvmTerms);
			(yyval.m_pmac2Cond)->second = (yys_sv__[2].m_pCpdcond);
		
#line 2157 "gcode/coderyac.cpp"

	}
	break;
	
	case 16:
	{
#line 493 "meta/coderyac.upg"


			(yyval.m_pCpdcond) = (yys_sv__[1].m_pCpdcond);
		
#line 2169 "gcode/coderyac.cpp"

	}
	break;
	
	case 17:
	{
#line 499 "meta/coderyac.upg"

			
			assert((yys_sv__[0].m_pmTerm));
			(yyval.m_pvmTerms) = new vterm_t;
			(yyval.m_pvmTerms)->push_back((yys_sv__[0].m_pmTerm));
		
#line 2183 "gcode/coderyac.cpp"

	}
	break;
	
	case 18:
	{
#line 505 "meta/coderyac.upg"

		
			assert((yys_sv__[1].m_pvmTerms));
			(yyval.m_pvmTerms) = (yys_sv__[1].m_pvmTerms);
			(yyval.m_pvmTerms)->push_back((yys_sv__[0].m_pmTerm));			
			
		
#line 2198 "gcode/coderyac.cpp"

	}
	break;
	
	case 19:
	{
#line 513 "meta/coderyac.upg"

			if((yys_sv__[0].m_textVal) && (yys_sv__[0].m_textVal)->second) {
				(yyval.m_pmTerm) = cmmgr.newTextTerm(*((yys_sv__[0].m_textVal)->second), (yys_sv__[0].m_textVal)->first);
				delete (yys_sv__[0].m_textVal)->second;
				delete (yys_sv__[0].m_textVal);
			}
		
#line 2213 "gcode/coderyac.cpp"

	}
	break;
	
	case 20:
	{
#line 520 "meta/coderyac.upg"

		
			if((yys_sv__[0].m_pmacRef)->second) {
				
				(yyval.m_pmTerm) = cmmgr.newMacroTerm(*(yys_sv__[0].m_pmacRef)->first, *(yys_sv__[0].m_pmacRef)->second);
				delete (yys_sv__[0].m_pmacRef)->second;
			}
			else {
			
				(yyval.m_pmTerm) = cmmgr.newMacroTerm(*(yys_sv__[0].m_pmacRef)->first);
			}
			delete (yys_sv__[0].m_pmacRef)->first;
			delete (yys_sv__[0].m_pmacRef);
		
#line 2235 "gcode/coderyac.cpp"

	}
	break;
	
	case 21:
	{
#line 534 "meta/coderyac.upg"

			
			string strVal;
			if(dmap.getString(*(yys_sv__[2].m_pstrVal), strVal)) {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm(strVal, 0);
			}
			else {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm("", 0);
			}
			delete (yys_sv__[2].m_pstrVal);
		
#line 2256 "gcode/coderyac.cpp"

	}
	break;
	
	case 22:
	{
#line 547 "meta/coderyac.upg"

			
			string strVal;
			if(dmap.getString(*(yys_sv__[2].m_pstrVal), strVal)) {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm(strVal, 0);
			}
			else {
			
				(yyval.m_pmTerm) = cmmgr.newTextTerm("", 0);
			}
			delete (yys_sv__[2].m_pstrVal);
		
#line 2277 "gcode/coderyac.cpp"

	}
	break;
	
	case 23:
	{
#line 561 "meta/coderyac.upg"


			(yyval.m_pCpdcond) = cmmgr.newCompoundCond();
			(yyval.m_pCpdcond)->addCondItem((yys_sv__[0].m_pcondItem));
		
#line 2290 "gcode/coderyac.cpp"

	}
	break;
	
	case 24:
	{
#line 566 "meta/coderyac.upg"

		
			(yyval.m_pCpdcond) = (yys_sv__[1].m_pCpdcond);
			(yyval.m_pCpdcond)->addCondItem((yys_sv__[0].m_pcondItem));
		
#line 2303 "gcode/coderyac.cpp"

	}
	break;
	
	case 25:
	{
#line 572 "meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_nVal));
			delete (yys_sv__[2].m_pstrVal);
		
#line 2316 "gcode/coderyac.cpp"

	}
	break;
	
	case 26:
	{
#line 577 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[0].m_pstrVal), true);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2329 "gcode/coderyac.cpp"

	}
	break;
	
	case 27:
	{
#line 582 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_bVal));
			delete (yys_sv__[2].m_pstrVal);
		
#line 2342 "gcode/coderyac.cpp"

	}
	break;
	
	case 28:
	{
#line 587 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newOptCond(*(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal));
			delete (yys_sv__[2].m_pstrVal);
			delete (yys_sv__[0].m_pstrVal);
		
#line 2356 "gcode/coderyac.cpp"

	}
	break;
	
	case 29:
	{
#line 593 "meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_EQ, (yys_sv__[0].m_nVal));
		
#line 2368 "gcode/coderyac.cpp"

	}
	break;
	
	case 30:
	{
#line 597 "meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_NE, (yys_sv__[0].m_nVal));	
		
#line 2380 "gcode/coderyac.cpp"

	}
	break;
	
	case 31:
	{
#line 601 "meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_EQ, (yys_sv__[0].m_bVal));
		
#line 2392 "gcode/coderyac.cpp"

	}
	break;
	
	case 32:
	{
#line 605 "meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_NE, (yys_sv__[0].m_bVal));	
		
#line 2404 "gcode/coderyac.cpp"

	}
	break;
	
	case 33:
	{
#line 609 "meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_EQ, *(yys_sv__[0].m_pstrVal));
			delete (yys_sv__[0].m_pstrVal);
		
#line 2417 "gcode/coderyac.cpp"

	}
	break;
	
	case 34:
	{
#line 614 "meta/coderyac.upg"


			(yyval.m_pcondItem) = cmmgr.newERelCond(cond_elemrel_t::EOP_NE, *(yys_sv__[0].m_pstrVal));
			delete (yys_sv__[0].m_pstrVal);		
		
#line 2430 "gcode/coderyac.cpp"

	}
	break;
	
	case 35:
	{
#line 619 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getHasCond();
		
#line 2442 "gcode/coderyac.cpp"

	}
	break;
	
	case 36:
	{
#line 623 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getEmptyCond();
		
#line 2454 "gcode/coderyac.cpp"

	}
	break;
	
	case 37:
	{
#line 627 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getEndCond();
		
#line 2466 "gcode/coderyac.cpp"

	}
	break;
	
	case 38:
	{
#line 631 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getLastCond();
		
#line 2478 "gcode/coderyac.cpp"

	}
	break;
	
	case 39:
	{
#line 635 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.getMoreCond();
		
#line 2490 "gcode/coderyac.cpp"

	}
	break;
	
	case 40:
	{
#line 639 "meta/coderyac.upg"

			
			(yyval.m_pcondItem) = cmmgr.getGroupCond();
		
#line 2502 "gcode/coderyac.cpp"

	}
	break;
	
	case 41:
	{
#line 643 "meta/coderyac.upg"

			(yyval.m_pcondItem) = cmmgr.getGroupFirstCond();
		
#line 2513 "gcode/coderyac.cpp"

	}
	break;
	
	case 42:
	{
#line 646 "meta/coderyac.upg"

		
			(yyval.m_pcondItem) = cmmgr.newModCond((yys_sv__[0].m_nVal));
		
#line 2525 "gcode/coderyac.cpp"

	}
	break;
	
	case 43:
	{
#line 651 "meta/coderyac.upg"

		
			(yyval.m_bVal) = true;
		
#line 2537 "gcode/coderyac.cpp"

	}
	break;
	
	case 44:
	{
#line 655 "meta/coderyac.upg"

		
			(yyval.m_bVal) = false;
		
#line 2549 "gcode/coderyac.cpp"

	}
	break;
	
	case 45:
	{
#line 660 "meta/coderyac.upg"

			
			(yyval.m_pmacRef) = new pstr2pvn_t;
			(yyval.m_pmacRef)->first = (yys_sv__[2].m_pstrVal);
			(yyval.m_pmacRef)->second = nullptr;
		
#line 2563 "gcode/coderyac.cpp"

	}
	break;
	
	case 46:
	{
#line 666 "meta/coderyac.upg"

		
			(yyval.m_pmacRef) = new pstr2pvn_t;
			(yyval.m_pmacRef)->first = (yys_sv__[3].m_pstrVal);;
			(yyval.m_pmacRef)->second = (yys_sv__[2].m_pvnVal);
		
#line 2577 "gcode/coderyac.cpp"

	}
	break;
	
	case 47:
	{
#line 674 "meta/coderyac.upg"


			(yyval.m_pvnVal) = new vint_t;
			(yyval.m_pvnVal)->push_back((yys_sv__[0].m_nVal));
		
#line 2590 "gcode/coderyac.cpp"

	}
	break;
	
	case 48:
	{
#line 679 "meta/coderyac.upg"

		
			(yyval.m_pvnVal) = (yys_sv__[2].m_pvnVal);
			(yyval.m_pvnVal)->push_back((yys_sv__[0].m_nVal));
		
#line 2603 "gcode/coderyac.cpp"

	}
	break;
	
	case 49:
	{
#line 685 "meta/coderyac.upg"


			if( ! coder.isThrowAway()) {
				(yyval.m_pvstrVal) = new vstr_t;
				(yyval.m_pvstrVal)->push_back(*(yys_sv__[0].m_pstrVal));
			}
			else {
				(yyval.m_pvstrVal) = nullptr;
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2625 "gcode/coderyac.cpp"

	}
	break;
	
	case 50:
	{
#line 699 "meta/coderyac.upg"

		
			(yyval.m_pvstrVal) = (yys_sv__[1].m_pvstrVal);
			if( ! coder.isThrowAway()) {
				(yyval.m_pvstrVal)->push_back(*(yys_sv__[0].m_pstrVal));
			}
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2643 "gcode/coderyac.cpp"

	}
	break;
	
	case 52:
	{
#line 711 "meta/coderyac.upg"


			coder.switchToDef();
		
#line 2655 "gcode/coderyac.cpp"

	}
	break;
	
	case 51:
	{
#line 714 "meta/coderyac.upg"


			coder.flush();
		
#line 2667 "gcode/coderyac.cpp"

	}
	break;
	
	case 53:
	{
#line 720 "meta/coderyac.upg"

#line 2676 "gcode/coderyac.cpp"

	}
	break;
	
	case 54:
	{
#line 720 "meta/coderyac.upg"

#line 2685 "gcode/coderyac.cpp"

	}
	break;
	
	case 55:
	{
#line 723 "meta/coderyac.upg"

			
			if((yys_sv__[0].m_textVal) && (yys_sv__[0].m_textVal)->second) {
				coder.getStream() << *((yys_sv__[0].m_textVal)->second);
				dmap.addSrcLineNo((yys_sv__[0].m_textVal)->first);
				
				delete (yys_sv__[0].m_textVal)->second;
				delete (yys_sv__[0].m_textVal);
			}
		
#line 2703 "gcode/coderyac.cpp"

	}
	break;
	
	case 56:
	{
#line 733 "meta/coderyac.upg"

#line 2712 "gcode/coderyac.cpp"

	}
	break;
	
	case 57:
	{
#line 734 "meta/coderyac.upg"

#line 2721 "gcode/coderyac.cpp"

	}
	break;
	
	case 58:
	{
#line 735 "meta/coderyac.upg"

#line 2730 "gcode/coderyac.cpp"

	}
	break;
	
	case 59:
	{
#line 738 "meta/coderyac.upg"


			if( ! coder.isThrowAway()) {
				cmmgr.expandWithStack(*(yys_sv__[3].m_pstrVal), dmap, *(yys_sv__[2].m_pvstrVal), coder.getStream());
			}
			if((yys_sv__[3].m_pstrVal)) {
				delete (yys_sv__[3].m_pstrVal);
			}
			if((yys_sv__[2].m_pvstrVal)) {
				delete (yys_sv__[2].m_pvstrVal);
			}
		
#line 2750 "gcode/coderyac.cpp"

	}
	break;
	
	case 60:
	{
#line 750 "meta/coderyac.upg"

			
			if( ! coder.isThrowAway()) {
				cmmgr.expandWithStack(*(yys_sv__[2].m_pstrVal), dmap, cmmgr.getEmptyParam(), coder.getStream());
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
		
#line 2767 "gcode/coderyac.cpp"

	}
	break;
	
	case 61:
	{
#line 761 "meta/coderyac.upg"


		if( ! coder.isThrowAway()) {
				coder.switchToDecl();
			}
		
#line 2781 "gcode/coderyac.cpp"

	}
	break;
	
	case 62:
	{
#line 767 "meta/coderyac.upg"


			if( coder.isCondTrue()) {
				coder.switchToDef();
			}
		
#line 2795 "gcode/coderyac.cpp"

	}
	break;
	
	case 63:
	{
#line 775 "meta/coderyac.upg"

#line 2804 "gcode/coderyac.cpp"

	}
	break;
	
	case 65:
	{
#line 776 "meta/coderyac.upg"

			coder.addIPCond( ! (yys_sv__[1].m_bVal));
		
#line 2815 "gcode/coderyac.cpp"

	}
	break;
	
	case 64:
	{
#line 779 "meta/coderyac.upg"

			coder.subIPCond( ! (yys_sv__[4].m_bVal));
		
#line 2826 "gcode/coderyac.cpp"

	}
	break;
	
	case 67:
	{
#line 784 "meta/coderyac.upg"


			coder.addIPCond((yys_sv__[1].m_bVal));
		
#line 2838 "gcode/coderyac.cpp"

	}
	break;
	
	case 66:
	{
#line 788 "meta/coderyac.upg"

			coder.subIPCond((yys_sv__[4].m_bVal));
			(yyval.m_bVal) = (yys_sv__[4].m_bVal);
		
#line 2850 "gcode/coderyac.cpp"

	}
	break;
	
	case 68:
	{
#line 794 "meta/coderyac.upg"


			(yyval.m_bVal) = (yys_sv__[0].m_bVal);
		
#line 2862 "gcode/coderyac.cpp"

	}
	break;
	
	case 69:
	{
#line 798 "meta/coderyac.upg"

			(yyval.m_bVal) = (yys_sv__[1].m_bVal) && (yys_sv__[0].m_bVal);
		
#line 2873 "gcode/coderyac.cpp"

	}
	break;
	
	case 70:
	{
#line 803 "meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[0].m_pstrVal), true);
			}
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}			
		
#line 2893 "gcode/coderyac.cpp"

	}
	break;
	
	case 71:
	{
#line 815 "meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = ! cmmgr.testCond(dmap, *(yys_sv__[0].m_pstrVal), true);
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2914 "gcode/coderyac.cpp"

	}
	break;
	
	case 72:
	{
#line 828 "meta/coderyac.upg"


			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_nVal));
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
		
#line 2934 "gcode/coderyac.cpp"

	}
	break;
	
	case 73:
	{
#line 840 "meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[2].m_pstrVal), (yys_sv__[0].m_bVal));			
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
		
#line 2954 "gcode/coderyac.cpp"

	}
	break;
	
	case 74:
	{
#line 852 "meta/coderyac.upg"

		
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testCond(dmap, *(yys_sv__[2].m_pstrVal), *(yys_sv__[0].m_pstrVal));
			}
			if((yys_sv__[2].m_pstrVal)) {
				delete (yys_sv__[2].m_pstrVal);
			}
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2977 "gcode/coderyac.cpp"

	}
	break;
	
	case 75:
	{
#line 867 "meta/coderyac.upg"

			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testHas(dmap, *(yys_sv__[0].m_pstrVal));
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 2997 "gcode/coderyac.cpp"

	}
	break;
	
	case 76:
	{
#line 879 "meta/coderyac.upg"

			
			if( coder.isThrowAway()) {
				(yyval.m_bVal) = false;
			}
			else {
				(yyval.m_bVal) = cmmgr.testEmpty(dmap, *(yys_sv__[0].m_pstrVal));
			}
			
			if((yys_sv__[0].m_pstrVal)) {
				delete (yys_sv__[0].m_pstrVal);
			}
		
#line 3018 "gcode/coderyac.cpp"

	}
	break;
	
				default:

					if( ! yyerr_flag__ || PARSE_ENDSYMB_ID == yytok__) {
						if(! yyerr_flag__) {
							if(yyerror) {

char yycc[MAX_MSG_LENG];
sprintf(yycc, "Error: syntax error at %d:%d.", coder_lloc.firstLine, coder_lloc.firstColumn);
yyerror(yycc, coder, dmap, cmmgr);
				}

							yyecode__ = YYE_PERROR;
						}
						else {
							yyecode__ = YYE_NOINPUT;
						}
						
						yyerr_flag__ = true;
						yyltok = yytok__;
					}
					else {
					
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yytok__ = PARSE_ERRORSYMB_ID;
					yysidx__ = PARSE_ERRORSYMB_INDEX;

					while(! yys_sv__.empty())  {
						yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);
						if(is_valid_pstate__(yypstate__)) {
							break;
						}
			

						yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top(), coder, dmap, cmmgr);
						yys_loc__.pop(1);


						yys_symb__.pop(1);
						yys_sv__.pop(1);
						yys_stt__.pop(1);
					}

					if( yys_sv__.empty()) {
						yys_stt__.pop(1);
					}

					break;
				}

				if(is_valid_prule__(yyprule__) || YYE_ACCEPT == yyecode__) {
					yyrplen__ = yyprnum[yyprule__];
					yypstate__ = yynext_goto__(yys_stt__[yyrplen__], yyplid[yyprule__]);


					if(YYE_ACCEPT != yyecode__) {
						yys_stt__.pop(yyrplen__);
						yys_symb__.pop(yyrplen__);
						yys_sv__.pop(yyrplen__);

						if(!yys_loc__.empty()) {
							if(yyrplen__ == 0) {
								yyloc.firstLine = yyloc.lastLine = yys_loc__[0].lastLine;
								yyloc.firstColumn = yyloc.lastColumn = yys_loc__[0].lastColumn;
							}
							else {
								yyloc.firstLine = yys_loc__[yyrplen__ - 1].firstLine;
								yyloc.lastLine = yys_loc__[0].lastLine;
								yyloc.firstColumn = yys_loc__[yyrplen__ - 1].firstColumn;
								yyloc.lastColumn = yys_loc__[0].lastColumn;
							}
						}
						yys_loc__.pop(yyrplen__);
						yys_loc__.push(yyloc);

						yys_stt__.push(yypstate__);
						yys_symb__.push(yyplid[yyprule__] + PARSE_TYPE_BASE);
						yys_sv__.push(yyval);
					}
				}
			}
		}

		while( ! yys_sv__.empty()) {

			yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top(), coder, dmap, cmmgr);

			yys_sv__.pop(1);
			yys_symb__.pop(1);
		}

		if(YYE_ACCEPT == yyecode__) {


			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE, coder, dmap, cmmgr);

		}

		return (yyecode__ == YYE_EOS || yyecode__ == YYE_ACCEPT )? 0: yyecode__;
	}

public:
	inline void yyclearall__(void) {
		yyecode__ = YYE_ALIVE;
		yystart__ = INITIAL;		
		yymore_flag__ = false;
		yyat_bol__ = true;
		
		yyleng = 0;
		yylaleng = 0;
		if(yytext) {
			yytext[0] = '\0';
		}
		yybufmgr__.destroyall();

		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;

	}

private:

	// user interfaces
	// easy way to print matched string
	inline void YYECHO(void) const {
		ECHO();
	}
	inline void ECHO(void) const {
		if(yyoutput)
			fprintf(yyoutput, "%s", yytext);
	}

	// start-condition operations
	// switch start-condition
	inline void YYBEGIN(int sc) {
		BEGIN(sc);
	}
	inline void BEGIN(int sc) {
		yystart__ = sc;
	}
	// return current start-condition
	inline int YYSTART(void) const {
		return yystart__;
	}
	// save current start-condition and switch to new start-condition
	inline void yy_push_state(int nsc) {
		yyscstk__.push(yystart__);
		yystart__ = nsc;
	}
	// switch to last saved start-condition
	inline bool yy_pop_state(void) {

		if(yyscstk__.empty()) {
			return false;
		}
		yystart__ = yyscstk__.top();
		yyscstk__.pop(1);
		return true;
	}
	// return last saved start-condition
	inline int yy_top_state(void) {

		if(yyscstk__.empty()) {
			return INITIAL;
		}
		return yyscstk__.top();
	}

	// get/set flag of beginning-of-line
	inline bool yy_get_bol(void) const {
		return yyat_bol__;
	}
	inline void yy_set_bol(bool b) {
		yyat_bol__ = b;
	}

	// buffer operations
	inline YYPBUFFER yy_current_buffer(void) const {
		return yybufmgr__.current();
	}
	// 
	inline bool yy_has_buffer(void) const {
		return ! yybufmgr__.empty();
	}
	inline void yy_push_buffer(YYPBUFFER pbuffer) {
		yybufmgr__.switchto(pbuffer);
	}
	inline YYPBUFFER yy_pop_buffer(void) {
		return yybufmgr__.pop();
	}
	inline YYPBUFFER yy_new_filebuf(const char *strfile, bool bi = false) {
		if( !strfile ) {
			return yybufmgr__.newbuf(stdin, bi);
		}

	 	FILE *pfile = fopen(strfile, "r");
	 	if( !pfile) return NULL;
		return yybufmgr__.newbuf(pfile);
	}

	inline YYPBUFFER yy_new_cstrbuf(const char *cstrbuffer, int size) {
		if( ! cstrbuffer || size < 1) {
			return NULL;
		}
		return yybufmgr__.newbuf(cstrbuffer, size);
	}
	inline YYPBUFFER yy_new_strbuf(char *strbuffer, int size) {
		if( ! strbuffer || size < 1) {
			return NULL;
		}
		return yybufmgr__.newbuf(strbuffer, size);
	}
	inline void yy_delete_buffer(void) {
		yybufmgr__.destroytop();
	}
	inline void yy_switch_buffer(YYPBUFFER buf) {
		yybufmgr__.switchto(buf);
	}
	inline void yyrestart(void) {

		yystart__ = INITIAL;
		yyecode__ = YYE_ALIVE;
		yymore_flag__ = false;
		
		yyleng = 0;
		yylaleng = 0;
		if( yytext ) {
			yytext[0] = '\0';
		}

		yyscstk__.clear();
		yybufmgr__.reset();
	}

	inline void yymore(void) {

		yymore_flag__ = true;
		yylaleng = yyleng;
	}
	inline int yyless(int n) {

		if(n > 0 && n < yyleng) {

			yytext[n] = '\0';
			n = yyleng - n;
			yyleng -= n;
			yylaleng = yyleng;
			return yybufmgr__.unget(n);
		}
		yylaleng = yyleng;
		yytext[yylaleng] = '\0';

		return 0;
	}

	inline int yyinput(void) {

		int c = yybufmgr__.get();
		if(c < END_OF_FILE) {
			if(c == '\t') {
				int nt = yyget_tabsize();
				nt -= (yyget_colno() + nt - 1) % nt;
				yybufmgr__.pushtsz(nt);
				yyadd_colno(nt);
			}
			else if(c == '\n') {
				yybufmgr__.pushlsz(yyget_colno());
				yyset_colno(1);
				yyadd_lineno(1);
			}
			else {
				yyadd_colno(1);
			}
		}	
		return c;
	}
	inline bool yyunput(char c) {
		int oldc = yybufmgr__.put(c);
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;
	}
	inline bool yyunget(void) {
		int oldc = yybufmgr__.unget();
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;		
	}
	inline void yyterminate(void) {
		yyecode__ = YYE_TERM;
	}
	inline void yyadd_lineno(int nline) {
		yybufmgr__.setlineno(yybufmgr__.getlineno() + nline);
	}
	inline void yyadd_colno(int ncol) {
		yybufmgr__.setcolno(yybufmgr__.getcolno() + ncol);
	}
	inline int yyget_lineno(void) const {
		return yybufmgr__.getlineno();
	}
	inline void yyset_lineno(int nline) {
		yybufmgr__.setlineno(nline);
	}
	inline int yyget_colno(void) const {
		return yybufmgr__.getcolno();
	}
	inline void yyset_colno(int ncol) {
		yybufmgr__.setcolno(ncol);
	}
	inline int yyget_tabsize(void) const {
		return yybufmgr__.gettabsize();
	}
	inline void yyset_tabsize(int ntab) {
		yybufmgr__.settabsize(ntab);
	}
	bool yywrap__(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
		
			return false;
	}


private:

	int yyecode__;


	// buffer manager
	bufmgr_t yybufmgr__;
	// start-condition stack
    sstack_t<int, 32> yyscstk__;
	int yysize__;
	int yystart__;

	bool yymore_flag__;
	bool yyat_bol__;

	char *yytext;
	int yyleng;
	int yylaleng;

	
	bool yyerr_flag__;
	int yyltok;
	coder_lex_t yylexer;

	FILE* yyoutput;
	FILE* yylogger;
	coder_error_t yyerror;
	
private:
	

///////////////////////////////////////////////////////////////////////////
	// lexical tables
	// start states of DFAs
	static const int yydsc[2];

	// @yydcmap is a char map: char -> transition-label,
	// that is, chars are grouped, transition label is
	// representation of equivalent class of chars
	static const int yydcmap[258];

	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,
	// that is, transition-label in @yydcmap are further grouped in order to save space
	static const int yydmeta[47];

	// use next-check-base-default scheme to store DFAs
	// 
	static const int yydbase[198];
	static const int yyddef[198];
	// next table is an indeed transition table
	static const int yydnxt[271];
	static const int yydchk[271];
	static const int yydaccpt[174];
	
	static char YYMSG_UNMATCHED[];

///////////////////////////////////////////////////////////////////////////////
	// LALR parse tables
	// token map: token ID --> token index in token ID table
	// in fact, it acts like inverse table of token ID table
	static const int yyptmap[291];
	// token ID table, which contains token IDs
	//static const int yyptid[43];
	// number of symbols in a grammar rule
	static const int yyprnum[77];
	// index of left symbol in a grammar rule
	static const int yyplid[77];
	// parse action table
	static const int yypact[110];

	// base array for parse action table
	// which is used to determine the base location of the entries
	// for each state stored in the yypack table
	static const int yypabase[145];
	static const int yypgoto[23];
	static const int yypgbase[145];

	// check table for parse action table
	static const by_te_t yyvbmap[870];
	static const int yyparv[145];
	static const int yyparn[145];

	static const int yypcv[75];
	static const int yypcn[75];
	static const int yypgrv[145];
	static const int yypgrn[145];
	static const std::unordered_map<std::string, int> yyslexemID;

///////////////////////////////////////////////////////////////////////////////////
	// optional tables, they are available only under certain conditions

	// lookahead distant table, only available when there are some lookahead patterns
	// each pattern has its entry of the table
	

};


char coder_parser_t::YYMSG_UNMATCHED[] = "Error: unmatched character ` \'.";

const int coder_parser_t::yydsc[2] = {
173,	173
};

const int coder_parser_t::yydcmap[258] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	1,	2,	0,	0,	3,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	1,	4,	5,	6,	7,	0,	0,	0,
	0,	0,	0,	8,	0,	8,	0,	9,
	10,	10,	10,	10,	10,	10,	10,	10,
	10,	10,	0,	0,	11,	6,	12,	13,
	0,	7,	7,	14,	15,	16,	17,	18,
	19,	20,	7,	7,	21,	22,	7,	7,
	23,	7,	7,	24,	25,	26,	7,	7,
	7,	7,	7,	27,	0,	0,	0,	7,
	0,	28,	7,	29,	30,	31,	32,	33,
	7,	34,	7,	7,	35,	36,	37,	38,
	39,	40,	41,	42,	43,	44,	7,	7,
	7,	45,	7,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	46,	46
};

const int coder_parser_t::yydmeta[47] = {
0,	0,	1,	1,	0,	0,	0,	2,
	0,	0,	2,	0,	0,	0,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	0,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	3
};

const int coder_parser_t::yydbase[198] = {
224,	224,	224,	224,	224,	224,	224,	224,
	224,	224,	224,	224,	224,	224,	224,	224,
	224,	224,	224,	224,	224,	224,	224,	224,
	224,	224,	224,	224,	224,	224,	224,	224,
	224,	224,	224,	224,	224,	224,	172,	174,
	169,	187,	164,	166,	161,	157,	150,	189,
	179,	145,	159,	151,	143,	172,	155,	141,
	150,	145,	138,	166,	165,	132,	148,	143,
	144,	144,	140,	142,	137,	133,	126,	128,
	123,	163,	121,	124,	159,	118,	120,	117,
	145,	128,	118,	110,	120,	121,	120,	122,
	106,	107,	118,	114,	103,	132,	101,	104,
	100,	105,	108,	107,	104,	98,	91,	99,
	100,	2,	122,	89,	120,	98,	92,	115,
	83,	89,	112,	111,	113,	109,	108,	107,
	106,	5,	4,	89,	88,	74,	73,	82,
	3,	84,	80,	67,	77,	68,	75,	76,
	61,	63,	72,	56,	51,	3,	2,	1,
	24,	64,	58,	58,	61,	53,	53,	60,
	48,	53,	42,	38,	40,	40,	32,	36,
	26,	32,	21,	30,	21,	28,	10,	21,
	17,	10,	0,	29,	19,	0,	224,	221,
	220,	219,	218,	217,	216,	215,	214,	213,
	212,	211,	210,	209,	208,	207,	206,	205,
	204,	203,	202,	200,	201,	198
};

const int coder_parser_t::yyddef[198] = {
174,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	105,	168,
	168,	168,	168,	168,	168,	168,	168,	168,
	168,	168,	168,	168,	168,	168,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	195,
	194,	196,	0,	193,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	192,	191,	190,	189,	188,
	186,	187,	181,	184,	181,	185,	181,	183,
	184,	185,	183,	187,	187,	187,	187,	187,
	184,	178,	178,	180,	177,	179,	176,	0,
	180,	0,	179,	179,	178,	182,	180,	176,
	179,	176,	180,	176,	179,	176,	182,	177,
	175,	175,	175,	0,	0,	197,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0
};

const int coder_parser_t::yydnxt[271] = {
20,	73,	18,	76,	16,	22,	16,	21,
	122,	16,	121,	172,	16,	16,	108,	106,
	170,	140,	125,	141,	167,	129,	166,	38,
	135,	126,	169,	20,	171,	145,	148,	147,
	39,	43,	42,	45,	133,	163,	138,	44,
	164,	40,	46,	67,	66,	69,	168,	132,
	165,	68,	168,	65,	70,	168,	168,	150,
	139,	168,	27,	168,	30,	168,	168,	127,
	168,	143,	168,	146,	168,	134,	137,	168,
	168,	23,	136,	124,	160,	157,	37,	103,
	168,	83,	168,	168,	104,	168,	130,	82,
	149,	97,	168,	168,	153,	168,	107,	168,
	28,	142,	168,	33,	31,	159,	128,	32,
	24,	123,	26,	144,	152,	168,	36,	29,
	158,	35,	154,	155,	161,	156,	15,	2,
	3,	4,	120,	5,	6,	119,	118,	7,
	117,	116,	106,	131,	48,	34,	162,	78,
	77,	79,	80,	13,	81,	71,	84,	85,
	14,	86,	87,	96,	101,	102,	61,	60,
	59,	58,	57,	56,	55,	12,	54,	11,
	53,	18,	100,	99,	47,	98,	52,	95,
	94,	93,	92,	91,	90,	89,	88,	1,
	51,	10,	9,	50,	49,	41,	109,	110,
	8,	111,	112,	113,	114,	17,	47,	75,
	74,	19,	72,	151,	115,	64,	63,	62,
	25,	105,	168,	105,	168,	168,	168,	168,
	168,	168,	168,	168,	168,	168,	168,	168,
	168,	168,	168,	168,	168,	168,	168,	168,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0
};

const int coder_parser_t::yydchk[271] = {
173,	173,	173,	173,	173,	173,	173,	105,
	173,	173,	173,	173,	173,	173,	122,	121,
	173,	173,	173,	173,	128,	173,	173,	172,
	173,	173,	173,	173,	172,	143,	142,	141,
	172,	172,	172,	172,	170,	170,	166,	172,
	170,	172,	172,	171,	171,	171,	169,	169,
	166,	171,	169,	171,	171,	168,	168,	167,
	167,	168,	165,	164,	163,	162,	161,	162,
	160,	164,	159,	144,	157,	165,	160,	163,
	158,	161,	158,	156,	155,	159,	157,	140,
	154,	153,	155,	150,	139,	156,	154,	153,
	152,	151,	152,	149,	151,	146,	150,	148,
	148,	149,	147,	145,	147,	138,	137,	146,
	136,	135,	134,	133,	132,	145,	131,	130,
	129,	127,	126,	125,	124,	123,	120,	119,
	118,	117,	116,	115,	114,	113,	112,	111,
	110,	109,	108,	107,	106,	104,	103,	102,
	101,	100,	99,	98,	97,	96,	95,	94,
	93,	92,	91,	90,	89,	88,	87,	86,
	85,	84,	83,	82,	81,	80,	79,	78,
	77,	76,	75,	74,	73,	72,	71,	70,
	69,	68,	67,	66,	65,	64,	63,	62,
	61,	60,	59,	58,	57,	56,	55,	54,
	53,	52,	51,	50,	49,	48,	47,	46,
	45,	44,	43,	42,	41,	40,	39,	38,
	197,	196,	195,	196,	194,	193,	192,	191,
	190,	189,	188,	187,	186,	185,	184,	183,
	182,	181,	180,	179,	178,	177,	176,	175,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174,	174,
	174,	174,	174,	174,	174,	174,	174
};

const int coder_parser_t::yydaccpt[174] = {
-1,	0,	30,	20,	29,	28,	19,	17,
	16,	26,	22,	15,	25,	21,	24,	27,
	1,	33,	34,	23,	36,	31,	36,	14,
	7,	32,	8,	11,	5,	12,	6,	2,
	3,	4,	10,	13,	9,	18,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	35,
	33,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	35,	-1,	-1,	36,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	32,
	32,	-1,	33,	32,	33,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	33,	36,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	-1,
	32,	-1,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	-1,	1,	-1
};

// token map: token ID --> token index in token ID table
// in fact, it acts like inverse table of token ID table
const int coder_parser_t::yyptmap[291] = {
0,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	42,	2,	41,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	36,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	39,	38,	37,	40,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	1,	2,	3,	4,	5,	6,	7,	8,
	9,	10,	11,	12,	13,	14,	15,	16,
	17,	18,	19,	20,	21,	22,	23,	24,
	25,	26,	27,	28,	29,	30,	31,	32,
	33,	34,	35
};
/*
// token ID table, containing token IDs
const int coder_parser_t::yyptid[43] = {
0,	256,	257,	258,	259,	260,	261,	262,
	263,	264,	265,	266,	267,	268,	269,	270,
	271,	272,	273,	274,	275,	276,	277,	278,
	279,	280,	281,	282,	283,	284,	285,	286,
	287,	288,	289,	290,	47,	62,	61,	60,
	63,	35,	33
};
*/
// prnum table, its element is number of symbols in right part of corresponding grammar rule
const int coder_parser_t::yyprnum[77] = {
2,	3,	4,	4,	3,	3,	1,	2,
	3,	3,	4,	4,	1,	2,	3,	3,
	3,	1,	2,	1,	1,	5,	5,	1,
	2,	3,	1,	3,	3,	3,	3,	3,
	3,	3,	3,	1,	1,	1,	1,	1,
	1,	1,	3,	1,	1,	4,	5,	2,
	3,	1,	2,	4,	0,	1,	2,	1,
	1,	1,	1,	5,	4,	1,	1,	1,
	5,	0,	6,	0,	1,	2,	1,	2,
	3,	3,	3,	3,	3
};

// plid table, its element is the index of left part of corresponding grammar rule in token ID table
const int coder_parser_t::yyplid[77] = {
17,	2,	18,	21,	21,	19,	22,	22,
	11,	11,	13,	23,	12,	12,	14,	14,
	1,	10,	10,	9,	9,	9,	9,	7,
	7,	8,	8,	8,	8,	8,	8,	8,
	8,	8,	8,	8,	8,	8,	8,	8,
	8,	8,	8,	0,	0,	15,	15,	6,
	6,	16,	16,	20,	25,	24,	24,	26,
	26,	26,	26,	27,	27,	28,	28,	29,
	29,	30,	3,	31,	4,	4,	5,	5,
	5,	5,	5,	5,	5
};

// parse action table
const int coder_parser_t::yypact[110] = {
17,	29,	38,	16,	29,	29,	31,	42,
	223,	31,	31,	58,	57,	59,	60,	61,
	64,	62,	63,	29,	38,	81,	80,	29,
	66,	42,	55,	56,	31,	29,	54,	223,
	69,	93,	31,	82,	92,	91,	95,	223,
	78,	58,	57,	59,	60,	61,	64,	62,
	63,	79,	98,	223,	112,	223,	99,	108,
	55,	56,	115,	118,	54,	113,	116,	223,
	85,	172,	172,	172,	172,	172,	172,	172,
	172,	81,	80,	216,	216,	123,	223,	126,
	172,	172,	124,	127,	172,	38,	38,	223,
	172,	87,	42,	42,	78,	223,	216,	223,
	101,	133,	216,	103,	131,	79,	38,	216,
	38,	223,	223,	42,	223,	42
};

// base array for parse action table
// which is used to determine the base location of the entries
// for each state stored in the yypack table
const int coder_parser_t::yypabase[145] = {
0,	0,	0,	0,	0,	0,	0,	0,
	-33,	0,	0,	0,	0,	0,	-33,	0,
	0,	0,	0,	-32,	0,	0,	0,	0,
	-30,	-29,	-3,	-15,	0,	0,	0,	0,
	0,	0,	0,	0,	-14,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	7,	0,
	0,	0,	-11,	-5,	27,	0,	51,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	-1,	0,	4,	-3,	0,	0,
	0,	0,	18,	0,	59,	0,	61,	0,
	0,	0,	0,	0,	0,	0,	0,	20,
	26,	27,	0,	0,	0,	0,	41,	0,
	0,	47,	0,	0,	51,	0,	0,	65,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	52,	68,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	70,
	0
};

const int coder_parser_t::yypgoto[23] = {
28,	27,	49,	28,	50,	23,	28,	51,
	67,	223,	223,	47,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	65
};

const int coder_parser_t::yypgbase[145] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	-9,	0,
	0,	0,	0,	0,	0,	0,	-12,	0,
	-6,	-3,	0,	-1,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0
};

const by_te_t coder_parser_t::yyvbmap[870] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	4,	0,	0,	1,	0,	0,	0,
	0,	0,	8,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	2,	0,	1,	0,
	0,	0,	0,	0,	0,	0,	0,	1,
	0,	0,	0,	0,	0,	0,	128,	0,
	0,	0,	0,	0,	18,	0,	0,	0,
	0,	0,	64,	0,	1,	0,	0,	0,
	0,	0,	0,	4,	0,	24,	132,	0,
	16,	0,	0,	0,	128,	0,	16,	0,
	0,	0,	128,	0,	64,	1,	0,	0,
	132,	0,	32,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	0,	64,	0,	0,	0,	0,	0,
	1,	0,	0,	4,	0,	24,	132,	0,
	0,	0,	0,	1,	0,	0,	16,	0,
	0,	0,	128,	0,	64,	1,	0,	0,
	128,	0,	64,	1,	0,	0,	128,	0,
	0,	0,	0,	0,	132,	0,	0,	0,
	0,	0,	132,	0,	0,	192,	63,	96,
	2,	0,	0,	0,	0,	0,	132,	0,
	128,	2,	0,	0,	132,	0,	128,	2,
	0,	0,	132,	0,	128,	2,	0,	0,
	132,	0,	0,	0,	0,	128,	2,	0,
	0,	0,	0,	0,	1,	0,	8,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	18,	0,
	0,	4,	0,	26,	132,	0,	0,	44,
	0,	26,	132,	0,	0,	44,	0,	26,
	132,	0,	0,	44,	0,	26,	132,	0,
	0,	44,	0,	26,	132,	0,	0,	44,
	0,	26,	132,	0,	0,	0,	0,	0,
	2,	0,	0,	44,	0,	26,	132,	0,
	0,	44,	0,	26,	132,	0,	0,	60,
	0,	26,	132,	0,	0,	192,	0,	0,
	2,	4,	16,	0,	0,	0,	128,	0,
	0,	0,	0,	0,	16,	0,	64,	1,
	0,	0,	128,	0,	0,	2,	0,	0,
	132,	0,	128,	0,	0,	0,	132,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	98,	0,	0,	0,	0,	0,	0,	1,
	0,	0,	0,	0,	0,	1,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	0,	0,	0,	0,	1,	16,	0,
	0,	0,	128,	0,	0,	0,	0,	128,
	18,	0,	128,	2,	0,	0,	132,	0,
	0,	0,	0,	0,	3,	0,	0,	0,
	0,	0,	16,	2,	0,	0,	0,	0,
	32,	0,	0,	0,	0,	0,	18,	0,
	1,	0,	0,	0,	0,	0,	0,	44,
	0,	26,	132,	0,	0,	0,	0,	0,
	17,	0,	0,	4,	0,	24,	132,	0,
	0,	192,	0,	0,	34,	4,	0,	192,
	0,	0,	34,	4,	0,	192,	0,	0,
	98,	4,	0,	0,	0,	0,	2,	0,
	0,	0,	0,	0,	0,	1,	0,	0,
	0,	0,	0,	1,	32,	0,	0,	0,
	0,	0,	64,	1,	0,	0,	128,	0,
	64,	1,	0,	0,	128,	0,	0,	0,
	0,	0,	132,	0,	0,	192,	63,	96,
	34,	0,	0,	0,	192,	0,	9,	0,
	0,	0,	192,	0,	9,	0,	0,	0,
	192,	0,	9,	0,	0,	0,	0,	0,
	8,	0,	0,	0,	0,	0,	16,	0,
	0,	0,	0,	0,	16,	0,	0,	0,
	0,	0,	32,	0,	0,	0,	0,	0,
	16,	2,	0,	0,	0,	0,	8,	0,
	64,	1,	0,	0,	132,	0,	0,	0,
	0,	0,	17,	0,	0,	0,	0,	0,
	17,	0,	0,	0,	0,	0,	32,	0,
	0,	4,	0,	24,	132,	0,	0,	4,
	0,	24,	132,	0,	0,	192,	0,	0,
	34,	4,	0,	0,	192,	0,	9,	0,
	0,	192,	0,	0,	34,	4,	0,	0,
	0,	0,	1,	0,	0,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	32,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	4,	0,	192,	63,	96,	34,	4,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	192,	63,	96,	34,	0,	0,	192,
	63,	96,	34,	0,	0,	192,	63,	96,
	34,	0,	0,	192,	63,	96,	34,	0,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	0,	32,	0,	128,	2,	0,	0,
	132,	0,	0,	0,	0,	0,	32,	0,
	0,	0,	0,	0,	8,	0,	0,	0,
	0,	0,	16,	2,	0,	0,	0,	0,
	17,	0,	0,	0,	0,	0,	32,	0,
	0,	44,	0,	26,	132,	0,	0,	36,
	0,	24,	132,	0,	0,	4,	0,	24,
	132,	0,	0,	192,	0,	0,	34,	4,
	0,	192,	0,	0,	34,	4,	0,	192,
	0,	0,	34,	4,	0,	192,	0,	0,
	34,	4,	0,	192,	0,	0,	34,	4,
	16,	0,	0,	0,	128,	0,	128,	2,
	0,	0,	132,	0,	128,	2,	0,	0,
	132,	0,	128,	2,	0,	0,	132,	0,
	0,	0,	0,	0,	16,	2,	0,	44,
	0,	26,	132,	0,	0,	44,	0,	26,
	132,	0,	0,	12,	0,	24,	132,	0,
	0,	60,	0,	26,	132,	0
};

const int coder_parser_t::yyparv[145] = {
223,	4,	5,	7,	9,	146,	11,	15,
	223,	18,	147,	198,	15,	152,	223,	32,
	33,	34,	35,	223,	151,	153,	48,	158,
	223,	223,	223,	223,	163,	165,	166,	69,
	70,	148,	71,	150,	223,	199,	201,	202,
	203,	204,	74,	207,	208,	209,	223,	154,
	82,	159,	223,	223,	223,	169,	223,	88,
	89,	181,	182,	183,	184,	185,	186,	187,
	90,	155,	223,	164,	223,	223,	96,	149,
	197,	200,	223,	211,	223,	214,	223,	104,
	105,	106,	107,	160,	161,	162,	170,	223,
	223,	223,	119,	120,	121,	122,	223,	125,
	156,	223,	195,	128,	223,	213,	215,	223,
	217,	134,	135,	136,	171,	173,	189,	190,
	174,	175,	177,	179,	176,	178,	180,	188,
	137,	138,	191,	139,	140,	193,	196,	141,
	206,	223,	223,	218,	219,	220,	221,	222,
	157,	167,	168,	192,	194,	205,	210,	223,
	212
};


const int coder_parser_t::yyparn[145] = {
32,	0,	0,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	2,	0,	32,	0,
	0,	0,	0,	32,	0,	0,	2,	0,
	32,	32,	32,	32,	0,	0,	0,	2,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	0,	0,	0,	0,	2,	32,	0,
	0,	0,	32,	32,	32,	0,	32,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	32,	0,	32,	32,	0,	0,
	0,	0,	32,	0,	32,	0,	32,	0,
	0,	0,	0,	0,	0,	0,	0,	32,
	32,	32,	0,	0,	0,	0,	32,	0,
	0,	32,	0,	0,	32,	0,	0,	32,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	32,	32,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	32,
	0
};

const int coder_parser_t::yypcv[75] = {
223,	223,	223,	223,	20,	223,	26,	84,
	24,	83,	46,	144,	75,	142,	223,	223,
	223,	223,	223,	223,	223,	223,	110,	111,
	223,	72,	223,	43,	44,	223,	223,	68,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	25,	2,	45,	76,
	77,	223,	52,	53,	223,	223,	223,	22,
	14,	223,	30,	223,	223,	3,	223,	223,
	223,	12,	223,	223,	223,	37,	39,	40,
	41,	223,	223
};

const int coder_parser_t::yypcn[75] = {
32,	32,	32,	32,	1,	32,	1,	1,
	1,	1,	3,	3,	1,	3,	32,	32,
	32,	32,	32,	32,	32,	32,	1,	1,
	32,	3,	32,	3,	3,	32,	32,	1,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	1,	1,	1,	1,
	1,	32,	1,	1,	32,	32,	32,	1,
	1,	32,	1,	32,	32,	1,	32,	32,
	32,	1,	32,	32,	32,	3,	1,	1,
	1,	32,	32
};


const int coder_parser_t::yypgrv[145] = {
223,	223,	223,	6,	8,	223,	10,	13,
	223,	223,	223,	19,	21,	223,	223,	223,
	223,	223,	223,	36,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	73,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	67,	67,	86,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	94,	223,	223,
	223,	223,	97,	100,	102,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	109,
	114,	117,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	129,	130,	223,	132,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	223,
	223,	73,	143,	223,	223,	223,	223,	223,
	223,	223,	223,	223,	223,	223,	223,	73,
	223
};

const int coder_parser_t::yypgrn[145] = {
32,	32,	32,	0,	0,	32,	0,	2,
	32,	32,	32,	0,	2,	32,	32,	32,
	32,	32,	32,	4,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	2,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	2,	2,	0,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	0,	32,	32,
	32,	32,	0,	0,	0,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	0,
	0,	0,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	4,	0,	32,	0,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	2,	4,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	2,
	32
};

const std::unordered_map<std::string, int> coder_parser_t::yyslexemID{

};


// get global parser object,
// it's invisiable to user
static coder_parser_t& getTheParser(void) {

	static coder_parser_t yyp(coder_lex);
	return yyp;
}

// assign new log stream
void coder_setstream(FILE *poutput, FILE *plogger) {

	coder_parser_t& yyp = getTheParser();
	yyp.yyoutput = poutput;
	yyp.yylogger = plogger;
}

void yyemit_error__(const char *s, coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
	coder_parser_t& yyp = getTheParser();
	if(yyp.yylogger) 
		fprintf(yyp.yylogger, "%s\n", s);
}

// assign new error-reporter and return the old one
coder_error_t coder_seterror(coder_error_t perror) {

	coder_parser_t& yyp = getTheParser();
	coder_error_t pold = yyp.yyerror;
	yyp.yyerror = perror;

	return pold;
}

// reset all (both scanner and parser, if they are available)
void coder_clearall(void) {
	getTheParser().yyclearall__();
}


// initializing file buffer before parsing or patter-matching
int coder_lexfile(const char* pchFile, bool iMod) {
	
	return getTheParser().yylexinit__(pchFile, iMod)? 0: -1;
}
// initializing string buffer before parsing or patter-matching
int coder_lexstr(char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}
// initializing const string buffer before parsing or patter-matching
int coder_lexcstr(const char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}

// generated scanner, can be replaced
int coder_lex(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {

	return getTheParser().yylex__(coder, dmap, cmmgr);
} 

// assign new scanner and return the old one 
coder_lex_t coder_setlex(coder_lex_t plex) {
	
	coder_parser_t& yyp = getTheParser();
	coder_lex_t pold = yyp.yylexer;
	yyp.yylexer = plex;

	return pold;
}

// generated parser, it should not be replaced
int coder_parse(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr) {
	return getTheParser().yyparse__(coder, dmap, cmmgr);
}
} // namspace

#line 894 "meta/coderyac.upg"



#line 4136 "gcode/coderyac.cpp"


