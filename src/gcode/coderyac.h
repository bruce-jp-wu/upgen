/*******************************************************************************
A parser program in C++, generated by Upgen 0.5.3.
******************************************************************************/

#ifndef CLASS_coder_PARSE_T_FILE_CODERYAC_1528767357_H__
#define CLASS_coder_PARSE_T_FILE_CODERYAC_1528767357_H__

#line 1 "meta/coderyac.upg"

/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2009-2018 Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "../coder/ctoken.h"
using coder_ns::ctoken_t;
#include "../coder/dmmap.h"
#include "../coder/coder.h"
#include "../coder/cmmgr.h"
using coder_ns::coder_t;
using coder_ns::cmacro_mgr_t;
using coder_ns::dmmap_t;


#line 41 "coderyac.h"
namespace coder_nsx {

// token ID definition
enum {
LBL_MSHEAD = 258,
LBL_MSTAIL = 259,
LBL_MACRO = 260,
LBL_CASEHEAD = 261,
LBL_CASETAIL = 262,
LBL_DEFAULTHEAD = 263,
LBL_DEFAULTTAIL = 264,
LBL_IFHEAD = 265,
LBL_IFTAIL = 266,
LBL_ELSEHEAD = 267,
LBL_ELSETAIL = 268,
LBL_EMPTY = 269,
LBL_HAS = 270,
LBL_END = 271,
LBL_LAST = 272,
LBL_MORE = 273,
LBL_MOD = 274,
LBL_GROUP = 275,
LBL_GROUPFIRST = 276,
LBL_TRUE = 277,
LBL_FALSE = 278,
LBL_PHEAD = 279,
LBL_PTAIL = 280,
LBL_SETUPHEAD = 281,
LBL_DECLARE = 282,
LBL_DEFINE = 283,
LBL_EQUAL = 284,
LBL_UNEQUAL = 285,
LBL_SCALAR = 286,
QUOTEDSTR = 287,
CID = 288,
PLAIN_TEXT = 289,
INTEGER = 290,

__UPGEN_GENERATED_PARSE_TOKEN_VALUE = 0
};

// function type for error-reporting
typedef void(*coder_error_t)(const char* msg, coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr);

// assign new log stream
void coder_setstream(FILE *poutput, FILE *plogger);
// assign new error-reporter and return the old one
coder_error_t coder_seterror(coder_error_t);
// reset all (both scanner and parser, if they are available)
void coder_clearall(void);

// location defines here
struct coder_ltype_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	
};

// semantic value type defined by user as ctoken_t
typedef ctoken_t xstype_t;
typedef coder_ltype_t xltype_t;
// function type for scanning
typedef int (*coder_lex_t)(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr);

// assign new scanner and return the old one
coder_lex_t coder_setlex(coder_lex_t);

// initializing file buffer before parsing or patter-matching
int coder_lexfile(const char* pchFile, bool iMod = false);
// initializing string buffer before parsing or patter-matching
int coder_lexstr(char *strbuffer, int size);
// initializing const string buffer before parsing or patter-matching
int coder_lexcstr(const char *strbuffer, int size);

// generated scanner, can be replaced
int coder_lex(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr);


// generated parser, it should not be replaced
int coder_parse(coder_t &coder, dmmap_t &dmap, cmacro_mgr_t &cmmgr);

extern xstype_t coder_lval;
extern xltype_t coder_lloc;

} // namespace
#endif
