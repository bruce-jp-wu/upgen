/*******************************************************************************
A parser program in C++, generated by Upgen 0.5.3.
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
// update 14/12/17
#include <vector>
#include <unordered_map>
#include <string>

namespace yynsx {
typedef unsigned char by_te_t;
}
namespace yynsx {

class bufbase_t;
typedef bufbase_t *YYPBUFFER;
}

#include "./ulyac.h"

#line 43 "meta/ulyac.upg"

/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2009-2018 Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#ifdef UPGEN_TEST_VERSION
#include <iostream>
using std::cerr;
using std::endl;
#endif

#include "../common/common.h"
#include "../common/reporter.h"
#include "../common/action.h"
using common_ns::action_t;


#include "../coder/metakeys.h"
#include "../common/strhelper.h"
using common_ns::strhelper_t;

#include "../lexer/retree.h"
using lexer_ns::renode_t;
using lexer_ns::retree_t;
using lexer_ns::rnpool_t;
using lexer_ns::rtpool_t;

#include "../parser/prod.h"
using parser_ns::prod_t;
#include "../parser/symbol.h"
using parser_ns::symbol_t;

#define CRET		{return yytext[0];}

#define NULL_ACTION(x)

#define PROCESS_ACTION_1(C, CH1, CH2, ACT) {\
	C = yyinput();\
	while(C && C != END_OF_FILE){\
		if(CH1 == C) {\
			C = yyinput();\
			if(CH2 == C) {\
				break;\
			}\
			else {\
				ACT(CH1);\
			}\
		}\
		if(C != CH1) {\
			ACT((char)C);\
			C = yyinput();\
		}\
	}\
}

#define PROCESS_UNTIL(C, CH1, CH2, CE, ACT) {\
	C = yyinput();\
	while(C && C != END_OF_FILE){\
		if(CE == C) {\
			C = yyinput();\
			if('$' == C) {\
				C = yyinput();\
				if('$' == C || '<' == C || (C >= '0' && C <= '9')) {\
					ACT('$');\
					ACT(C);\
					C = yyinput();\
				}\
				else {\
					ACT(CE);\
					ACT('$');\
				}\
			}\
			else if('@' == C) {\
				C = yyinput();\
				if('$' == C || (C >= '0' && C <= '9')) {\
					ACT('@');\
					ACT(C);\
					C = yyinput();\
				}\
				else {\
					ACT(CE);\
					ACT('@');\
				}\
			}\
			else if(CH1 == C) {\
				C = yyinput();\
				if(CH2 == C) {\
					ACT(CH1);\
					ACT(CH2);\
					C = yyinput();\
				}\
				else {\
					ACT(CE);\
					ACT(CH1);\
				}\
			}\
			else {\
				ACT(CE);\
			}\
		}\
		else {\
			if(CH1 == C) {\
				C = yyinput();\
				if(CH2 == C) {\
					break;\
				}\
				else {\
					ACT(CH1);\
				}\
			}\
			if(C != CH1 && C != CE) {\
				ACT((char)C);\
				C = yyinput();\
			}\
		}\
	}\
}

#define LEX_PUSH_STATE(x)	yy_push_state(x)
#define LEX_POP_STATE()		yy_pop_state()
#define LEX_BEGIN(x)		YYBEGIN(x)

#define FAKE_TYPE		"$FAKE_TYPE"

static action_t *sn_pactDefHeader = nullptr;
static action_t *sn_pactDeclHeader = nullptr;
static int sn_nVarDeclInit = -1;



#line 174 "gcode/ulyac.cpp"
namespace yynsx {
enum {
INC_YYTEXT_SIZE = 4096,
END_OF_FILE = 256,
END_OF_ALLFILE = 257,

// start-condition names
INITIAL = 0,
OPT_SC = 2,
MAC_SC = 4,
LEX_SC = 6,
SCR_SC = 8,
CSH_SC = 10,
XISC_SC = 12,
TOK_SC = 14,
TYP_SC = 16,
PRS_SC = 18,
PACT_SC = 20,
DSCRD_SC = 22,
PLVAR_SC = 24,

// number of DFA states of scanner
LEX_STATE_COUNT = 570,

// DFA trap-state of scanner
LEX_ERROR_STATE = 0,

// ID of invalid rule for scanner,
// indicating current string can not be matched by any pattern
LEX_ERROR_RULE = -1,

// this constant used by computing index of a rule that matches EOF
// for example, in start-condition INITIAL, index of the rule that
// matches EOF is 
//	LEX_EOFRULE_BASE + INITIAL
LEX_EOFRULE_BASE = 121,

// index of the rule that matches EOAF (end of all files, or end of input)
LEX_EOAF_RULE = 134,


// index of symbol `$end' in symbol table
PARSE_ENDSYMB_INDEX = 0,
// index of symbol `error' in symbol table
PARSE_ERRORSYMB_INDEX = 1,
// index of symbol `$undef' in symbol table
PARSE_UNDEFSYMB_INDEX = 2,

// ID of symbol `$end'
PARSE_ENDSYMB_ID = 0,
// ID of symbol `error'
PARSE_ERRORSYMB_ID = 256,
// ID of symbol '$undef'
PARSE_UNDEFSYMB_ID = 257,

// row size(in byte) of non-error bitmap of parse table
PARSE_BMAP_ROWSIZE = 8,
// base address of indexes of types (aka non-terminals or variables)
PARSE_TYPE_BASE = 59,
// number of symbols in parser
PARSE_SYMBOL_COUNT = 113,

// number of symbols in parser
PARSE_TOKENMAP_SIZE = 295,

// start state of parser
PARSE_START_STATE = 1,

// accept state of parser
PARSE_ACCEPT_STATE = 4,

// illegal state for parser
PARSE_ERROR_STATE  = 209,

// special ID of invalid rule for parser, indicating current lookahead
// symbol can not be shifted
PERROR_RULE = 147,


MAX_MSG_LENG = 128,
};

// macros for wrapped new operator
#define MYNEW(var, type) {\
	var = new type;\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYNEWS(var, type, size) {\
	var = new type[size];\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYRENEW(var, type, size, osize) {\
	type *p = new type[size];\
	if(!p) {\
		exit_on_oom();\
	}\
	memcpy(p, var, sizeof(type) * osize);\
	delete[] var;\
	var = p;\
}

// error IDs
enum {
	// grammar is accepted by automation
	YYE_ACCEPT =	1,
	// indicate automation is alive
	YYE_ALIVE =	2,
	// run out of all buffers,
	// and token `$end' will be sent to parser
	YYE_EOS =	3,
	// lexical analysis terminated manually,
	// and token `$end' will be sent to parser
	YYE_TERM =	3,
	// syntactic error occurs, and try to error-recover
	YYE_PERROR =	4,

	// can not match any pattern, token `$undef' will
	// be sent to parser
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID,

	// out of memory
	YYE_OOM = 	-1,
	// out of range
	YYE_OOR =	-2,
	// I/O error
	YYE_IO =	-3,
	// parsing aborted
	YYE_ABORT = 	-4,
	YYE_NOINPUT =	-5,
};

class bufbase_t;
typedef bufbase_t *YYPBUFFER;

class bufbase_t {

public:
	virtual ~bufbase_t(void){}
	virtual int get(void) = 0;
	virtual int peek(void) = 0;
	virtual int unget(void) = 0;
	virtual int unget(int num) = 0;
	virtual int put(char) = 0;

	inline void reset(void) {
		xreset();
		stlsz.clear();
		sttsz.clear();
	}
	inline bool iseof(void) const { return gptr == gend;}
	inline bool iseos(void) const { return eos;	}
	inline bool isimod(void) const { return imod;}
	inline void setimod(bool bi) { imod = bi;}
	inline int getlineno(void) const { return line;}
	inline void setlineno(int nline) { line = nline;}
	inline int getcolno(void) const { return col;}
	inline void setcolno(int ncol) { col = ncol;}
	inline int gettabsize(void) const { return tab;}
	inline void settabsize(int ntab) { tab = (ntab > 0)? ntab : 1;}

	inline void* getdata(void) const { return pvoid; }
	inline void setdata(void* pv) { pvoid = pv; }
protected:
	virtual void xreset(void) = 0;

	by_te_t *pbase;
	by_te_t *gptr;
	by_te_t *gend;
	bool eos;
	// interactive mode
	bool imod;
	int line;
	int col;
	int tab;
	
	void *pvoid;

public:
    // update 14/12/17
    inline void pushlsz(int nlsize) {
        stlsz.push_back(nlsize);
    }
    inline int poplsz(void) {
        if(stlsz.empty()) {
            return 0;
        }
        auto n = stlsz.back();
        stlsz.pop_back();
        return n;
    }

    inline void pushtsz(int ntsize) {
        // update 14/12/17
        sttsz.push_back(ntsize);
    }
    inline int poptsz(void) {
        if(sttsz.empty()) {
            return 0;
        }
        auto n = sttsz.back();
        sttsz.pop_back();
        return n;
    }
protected:
    // update 14/12/17
    std::vector<int> stlsz;
    std::vector<int> sttsz;

};

xstype_t yylval;
xltype_t yylloc;


// program abort due to out of memory
inline static void exit_on_oom(void) {
	exit(-1);
}
static char stext__[24] = "unprintable-char{";
inline static const char* sym_text__(const char* ps) {
	
	by_te_t b = (by_te_t)*ps, i = 17, t;
	if( !ps[1] && (b < 32 || b >= 127)) {
		if((t = b / 100) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 100;
		}
		if((t = b / 10) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 10;
		}
		stext__[i++] = (char)(b + 48);
		stext__[i++] = '}';
		stext__[i] = '\0';
		return stext__;
	}
	return ps;
}

static void yyemit_error__(const char *s, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup);

class yyparser_t {

	friend void yysetstream(FILE *poutput, FILE *plogger);
	friend yyerror_t yyseterror(yyerror_t);
	friend yylex_t yysetlex(yylex_t);

private:

	// class bufmgr_t class define HERE
	class bufmgr_t {

	public:

		enum {
			// half size of buffer
			BUF_HALF_SIZE = 4096,
			// fullsize of buffer
			BUF_FULL_SIZE = BUF_HALF_SIZE * 2
		};

	private:
		class filebuf_t: public bufbase_t {

			friend class bufmgr_t;
		private:

			inline void init(void) {

				gptr = pbase = &buf[BUF_FULL_SIZE - 1];
				gend = &buf[0];
				eos = false;
				bpeeked = false;
			}

		public:

			filebuf_t(FILE* pf = stdin)
			: pfile(pf) {
				imod = (pf == stdin);
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
				init();
			}

			virtual ~filebuf_t(void) {

				if(pfile != stdin) {

					fclose(pfile);
				}
			}

			virtual void xreset(void) {

				if(pfile != stdin) {
					fseek(pfile, 0, SEEK_SET);
				}
				init();
			}

			virtual int get(void) {

				if(gptr == gend) {

					eos = true;
					return END_OF_ALLFILE;
				}

				gptr = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(gptr == gend && !bpeeked) {

					fill(gptr);
				}

				bpeeked = false;

				return iseof()? END_OF_FILE: (int)(*gptr);
			}

			virtual int peek(void) {

				if(gptr == gend) {

					return END_OF_ALLFILE;
				}

				by_te_t *p = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(p == gend) {

					fill(p);
				}

				bpeeked = true;

				return (p == gend)? END_OF_FILE: (int)(*p);
			}

			virtual int unget(void) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

			virtual int unget(int num) {

				if(eos || gptr == pbase) {
					return 0;
				}
				int n = ((gptr - pbase) + BUF_FULL_SIZE) % BUF_FULL_SIZE;

				if(n > num) {
					n = num;
				}
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - n) % BUF_FULL_SIZE;

				return n;
			}
		
			virtual int put(char c) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				*gptr = (by_te_t)c;
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

		private:

			int fill(by_te_t *p) {

				int ncnt = 0;
				int vacents = ((pbase + BUF_FULL_SIZE) - gend) % BUF_FULL_SIZE;
				if(stdin != pfile) {
					while((ncnt = fread(p, 1, BUF_HALF_SIZE, pfile)) == 0 && ferror(pfile)) {
						if(errno != EINTR) {
							// IO error
							return 0;
						}
						clearerr(pfile);
						errno = 0;
					}
					gend = buf + (p - buf + ncnt) % BUF_FULL_SIZE;
				}
				else {
					for(int c = 0; '\n' !=  c && ncnt < BUF_HALF_SIZE;
						gend = buf + ((gend - buf) + 1) % BUF_FULL_SIZE, ++ncnt) {

						c = fgetc(stdin);
						*gend = (by_te_t)c;
						if(EOF == c && feof(pfile)) {
							break;
						}
					}
				}
				if(ncnt > vacents) {
					pbase = buf + ((gend - buf) + 1) % BUF_FULL_SIZE;
				}
				return ncnt;
			}

		private:

			bool bpeeked;
			FILE *pfile;
			by_te_t buf[BUF_FULL_SIZE];
		};

	private:

		class strbuf_t: public bufbase_t {

			friend class bufmgr_t;
		public:

			// nSize is length of string including terminating NULL
			strbuf_t(const char *pchBuf, int nSize)
			: bowner(true) {

				MYNEWS(pbase, by_te_t, nSize);
				memcpy(pbase, pchBuf, sizeof(char)*(nSize - 1));
				pbase[nSize - 1] = '\0';

				gend = pbase + nSize - 1;
				xreset();
				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
			}

			strbuf_t(char *pchBuf, int nSize)
			: bowner(false) {

				pbase = (by_te_t*)pchBuf;
				gend = pbase + nSize - 1;
				xreset();

				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
			}

			virtual ~strbuf_t(void) {
				if(bowner) {
					delete [] pbase;
				}
			}

		public:

			virtual void xreset(void) {

				gptr = pbase - 1;
				eos = false;
			}
			virtual int get(void) {

				if(gptr == gend) {
					eos = true;
					return END_OF_ALLFILE;
				}
				++gptr;

				return (gptr == gend)? END_OF_FILE : (int)(*gptr);
			}

			virtual int peek(void) {

				return (gptr == gend) ? (eos ? END_OF_ALLFILE: END_OF_FILE) : 
					(int)(*(gptr + 1));
			}
			virtual int unget(void) {
				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}
				return (int)(*gptr--);
			}
			virtual int unget(int num) {

				if(eos || (pbase - 1 == gptr)) {
					return 0;
				}
				int n = gptr - pbase + 1;
				if(n > num) {
					n = num;
				}
				gptr -= n;

				return n;
			}

			virtual int put(char c) {

				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);

				*gptr-- = (by_te_t)c;

				return oldc;
			}

		private:
			bool bowner;
		};

	private:

		struct link_t {

			link_t(bufbase_t *pxb, link_t *plnk = NULL)
			: pxbuf(pxb)
			, plink(plnk){}

			bufbase_t *pxbuf;
			link_t *plink;
		};

	public:

		bufmgr_t(void)
		: phead(NULL) {

			MYNEW(pstdin, filebuf_t);
			MYNEW(pavail, link_t(pstdin, NULL));
		}
		~bufmgr_t(void) {

			while(pavail) {

				link_t *p = pavail->plink;

				delete pavail->pxbuf;
				delete pavail;

				pavail = p;
			}			
		}

	public:

		inline int get(void) {
			return phead? phead->pxbuf->get(): END_OF_ALLFILE;
		}
		inline int peek(void) {
			return phead? phead->pxbuf->peek(): END_OF_ALLFILE;
		}
		inline int unget(void) {
			return phead? phead->pxbuf->unget(): END_OF_FILE;
		}
		inline int unget(int num) {
			return phead? phead->pxbuf->unget(num): 0;
		}
		inline int put(char c) {
			return phead? phead->pxbuf->put(c): END_OF_FILE;
		}
		inline bool iseof(void) const {
			return phead? phead->pxbuf->iseof(): true;
		}
		inline bool iseos(void) const {
			return phead? phead->pxbuf->iseos(): true;
		}
		inline bool isimod(void) const {
			return phead? phead->pxbuf->isimod(): false;
		}
		inline int getlineno(void) const {
			 return phead? phead->pxbuf->getlineno(): 0;
		}
		inline void setlineno(int nline) {
			if(phead) {
				phead->pxbuf->setlineno(nline);
			}
		}
		inline int getcolno(void) const {
			return phead? phead->pxbuf->getcolno(): 0;
		}
		inline void setcolno(int ncol) {
			if(phead) {
				phead->pxbuf->setcolno(ncol);
			}
		}
		inline int gettabsize(void) const {
			return phead? phead->pxbuf->gettabsize(): 0;
		}
		inline void settabsize(int ntab) {
			if(phead) {
				phead->pxbuf->settabsize(ntab);
			}
		}
		inline void reset(void) {
			if(phead) {
				phead->pxbuf->reset();
			}
		}
		inline void pushlsz(int nlsize) {
			if(phead) {
				phead->pxbuf->pushlsz(nlsize);
			}
		}
		inline int poplsz(void) {
			if(phead) {
				return phead->pxbuf->poplsz();
			}
			return 0;
		}
		inline void pushtsz(int ntsize) {
			if(phead) {
				phead->pxbuf->pushtsz(ntsize);
			}
		}
		inline int poptsz(void) {
			if(phead) {
				return phead->pxbuf->poptsz();
			}
			return 0;
		}


		inline bufbase_t* current(void) const {
			return phead ? phead->pxbuf : NULL;
		}

		inline bool empty(void) const {
			return ! phead;
		}

		inline bufbase_t* newbuf(FILE *pfile, bool iMod = false) {

			bufbase_t *p;
			if(pfile == stdin) {
				p = pstdin;
				p->reset();
			}
			else {
				MYNEW(p, filebuf_t(pfile));
				MYNEW(pavail->plink, link_t(p, pavail->plink));
			}
			
			p->setimod(iMod);
			
			return p;
		}
		inline bufbase_t* newbuf(char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		inline bufbase_t* newbuf(const char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		
		inline bufbase_t* switchto(bufbase_t* pbuf) {

			bufbase_t *pold = phead ? phead->pxbuf : NULL;
			link_t* p = rmwork(pbuf);
			if( ! p) {
				MYNEW(phead, link_t(pbuf, phead));
			}
			else {
				p->plink = phead;
				phead = p;
			}
			
			return pold;
		}
		
		inline bufbase_t* pop(void) {
			
			if(! phead) {
				return NULL;
			}
			
			link_t *p = phead;
			bufbase_t* pbuf = p->pxbuf;
			phead = phead->plink;
			
			delete p;
			
			return pbuf;
		}

		void destroytop(void) {
			
			bufbase_t *pxb = pop();
			if( pxb && pxb != pstdin) {

				link_t *p = pavail;
				
				while(p->plink && p->plink->pxbuf != pxb) {
					p = p->plink;
				}
				if(p->plink) {
					link_t *q = p->plink;
					p->plink = q->plink;

					delete pxb;
					delete q;
				}
			}
		}
		
		void destroyall(void) {

			while(pavail->plink) {
				link_t *p = pavail->plink;
				pavail->plink = p->plink;
				if(p->pxbuf) {
					delete p->pxbuf;
				}
				delete p;
			}
			
			phead = NULL;
		}

	private:

		link_t* rmwork(bufbase_t* pxb) {

			link_t *p = phead;
			// then check if @pxb is in the list, if so, then remove it
			if(p) {

				if(pxb == phead->pxbuf) {
					phead = phead->plink;
					return p;
				}
				else {
					while(p->plink && p->plink->pxbuf != pxb) {
						p = p->plink;
					}
					if(p->plink) {
						link_t *q = p->plink;
						p->plink = q->plink;
						return q;
					}
				}
			}

			return NULL;
		}

	private:

		// working buffer stack
		link_t *phead;
		// available buffer stack
		link_t *pavail;
		// stdin buffer
		bufbase_t *pstdin;
	};


    template<class ElemType, int INIT_SIZE = 4096>
    class sstack_t {
    public:
        inline sstack_t(void) {

        }

        inline void push(void) {
            mStk.push_back(ElemType());
        }
        inline void push(const ElemType &e) {
            mStk.push_back(e);
        }
        inline ElemType& top(void) {
            return mStk.back();
        }
        inline const ElemType& top(void) const {
            return mStk.back();
        }
        inline void pop(int n) {
            while(n > 0 && !mStk.empty()) {
                mStk.pop_back();
                n--;
            }
        }
        inline ElemType& operator[](int down) {
            const auto sz = (int) mStk.size();
            return mStk[sz - 1 - down];
        }
        inline const ElemType& operator[](int down) const {
            const auto sz = (int) mStk.size();
            return mStk[sz - 1 - down];
        }

        inline bool empty(void) const {
            return mStk.empty();
        }

        inline int count(void) const {
            return (int)mStk.size();
        }

        inline void clear(void) {
            mStk.clear();
        }
    private:
        std::vector<ElemType> mStk;
    };


private:

	inline void renew_text__(void) {

		MYRENEW(yytext, char, INC_YYTEXT_SIZE + yysize__, yysize__);
		yysize__ += INC_YYTEXT_SIZE;
		yytext[yysize__ - 1] = '\0';
	}

	inline bool yylex_is_running__(void) const {
		return yyecode__ == YYE_ALIVE;
	}
	inline int yyget_lexrule__(int s) const{
		return yydaccpt[s];
	}

	int yynext_lexstate__(int s, int c) const {

		int d = yydcmap[c];
		while(s < LEX_STATE_COUNT && yydchk[ yydbase[s] + d] != s) {
			s = yyddef[s];
		}

		if(s > LEX_STATE_COUNT) {
			return yydchk[yydbase[s] + yydmeta[d]] == s?
				yydnxt[ yydbase[s] + yydmeta[d]] : LEX_ERROR_STATE;
		}
		else {
			return yydnxt[ yydbase[s] + d];
		}
	}

	friend void yyemit_error__(const char *s, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup);

private:
	// update 16/12/17
    int YYSTOKEN(const std::string& lexeme) const {
		if(lexeme.size() == 1) {
			return (int)lexeme[0];
		}
        auto cit = yyslexemID.find(lexeme);
        if(cit == yyslexemID.cend()) {
			return PARSE_UNDEFSYMB_ID;
		}
        return cit->second;
	}

	inline void YYACCEPT(void) {
		yyecode__ = YYE_ACCEPT;
	}
	inline void YYABORT(void) {
		yyecode__ = YYE_ABORT;
	}
	inline void yyerrok(void) {
		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;
	}

	inline bool yyparse_is_running__(int s) const {
		return yyecode__ > YYE_ACCEPT && s != PARSE_ACCEPT_STATE;
	}
	inline int yyget_defrule(int s) const {
		if(0 == yyparn[s] && is_valid_prule__(yyget_prule__(yyparv[s])) ) {
			return yyget_prule__(yyparv[s]);
		}
		return PERROR_RULE;
	}
	inline bool is_valid_pstate__(int s) const {
		return s < PARSE_ERROR_STATE;
	}
	inline bool is_valid_prule__(int r) const {
		return r >= 0 && r < PERROR_RULE;
	}
	inline int yyget_prule__(int s) const {
		return s - (PARSE_ERROR_STATE + 1);
	}
	inline void yydiscard__(xstype_t &yydval, xltype_t  &yydloc, int yydsymb, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
	
	}
	inline int yynext_pstate__(int s, int t) const {
		if(yyvbmap[s * PARSE_BMAP_ROWSIZE + t / 8] & (1 << (t % 8))) {
			if(yyparn[s] < yypcn[t]) {
				return yyparv[s];
			}
			else if(yyparn[s] > yypcn[t]) {
				return yypcv[t];
			}
			return yypact[yypabase[s] + t];
		}
		return PARSE_ERROR_STATE;
	}
	inline int yynext_goto__(int s, int t) const {
		if(yypgrn[s] < yypcn[PARSE_TYPE_BASE + t]) {
			return yypgrv[s];
		}
		else if(yypgrn[s] > yypcn[PARSE_TYPE_BASE + t]) {
			return yypcv[PARSE_TYPE_BASE + t];
		}
		return yypgoto[yypgbase[s] + t];
	}

public:

	inline yyparser_t(yylex_t plex = NULL)
	: yyecode__(YYE_ALIVE)
	, yysize__(0)
	, yystart__(INITIAL)
	, yymore_flag__(false)
	, yyat_bol__(true)
	, yytext(NULL)
	, yyleng(0)
	, yylaleng(0)
	, yyerr_flag__(false)
	, yyltok(PARSE_UNDEFSYMB_ID)
	, yylexer(plex)
	, yyoutput(stdout)
	, yylogger(stderr)
	, yyerror(yyemit_error__) {

	}
	~yyparser_t(void) {

		if(yytext) {
			delete[] yytext;
		}

	}

	inline bool yylexinit__(const char *pchFile, bool bi) {

		YYPBUFFER pbuf = yy_new_filebuf(pchFile, bi);
		if( !pbuf ) {
			return false;
		}
		
		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(const char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_cstrbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_strbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	int yylex__(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
		
		if( !yy_has_buffer()) {yyecode__ = YYE_EOS; return 0;}

		int yylstate__ = LEX_ERROR_STATE;
		int yylrule__ = LEX_ERROR_RULE;
		int yyaccleng__ = 0;
		int yycchar__ = END_OF_FILE;
		bool yylast_at_bol__ = yyat_bol__;
		bool bwrap__ = false;
		
#line 196 "meta/ulyac.upg"

	int c, i, j;
	string strMsg;

#line 1210 "gcode/ulyac.cpp"

		yymore_flag__ = false;
		yyecode__ = YYE_ALIVE;
		
		yyleng = 0;
		yylaleng = 0;
		yytext[0] = '\0';

		

		if(yyat_bol__) {
			yylstate__ = yydsc[yystart__];
		}
		else {
			yylstate__ = yydsc[yystart__ + 1];
		}

		while(yylex_is_running__()) {

			yycchar__ = yybufmgr__.get();
			yylstate__ = yynext_lexstate__(yylstate__, yycchar__);

			if(LEX_ERROR_STATE != yylstate__) {

				if(yylaleng >= yysize__ - 1) {
					renew_text__();
				}
				yytext[yylaleng] = (char)yycchar__;

				++yylaleng;

				if(yyget_lexrule__(yylstate__) != LEX_ERROR_RULE) {

					yylrule__ = yyget_lexrule__(yylstate__);
					yyaccleng__ = yylaleng;
				}
			}

			if(LEX_ERROR_STATE == yylstate__ || (yybufmgr__.isimod() 
					&& ('\n' == yycchar__ || END_OF_FILE == yycchar__))) {
				if(LEX_ERROR_RULE == yylrule__) {
					if(yylaleng == yyleng) {
						if(yycchar__ == END_OF_FILE) {
							yylrule__ = LEX_EOFRULE_BASE + yystart__ / 2;
						}
						else if(yycchar__ == END_OF_ALLFILE) {
							yylrule__ = LEX_EOAF_RULE;
						}
					}
				}
				else {
					if( LEX_ERROR_STATE == yylstate__) {
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);
					}
					yylaleng = yyaccleng__;
					yytext[yylaleng] = '\0';
				 yyleng = yylaleng;
				}

				if(LEX_ERROR_RULE != yylrule__) {
					if(yyleng > 0) yyat_bol__ = (yytext[yyleng - 1] == '\n');{
				int nline = yyget_lineno();
				int ncol = yyget_colno() - 1;
				int nt = yyget_tabsize();
				int ts, yyt1__;
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {
					if(yytext[yyt1__] == '\t') {

						ts = nt - ncol % nt;
						yybufmgr__.pushtsz(ts);
						ncol += ts;
					}
					else if(yytext[yyt1__] == '\n') {
						yybufmgr__.pushlsz(ncol + 1);
						ncol = 0;
						++nline;
					}
					else {
						++ncol;
					}
				}
				yylloc.firstLine = yyget_lineno();
				yylloc.firstColumn = yyget_colno();
				yylloc.lastLine  = nline;
				yylloc.lastColumn = (ncol < 0)?0: ncol;
				yyset_lineno(nline);
				yyset_colno(ncol + 1);
			}
				}

		bwrap__ = (yylrule__ >= LEX_EOFRULE_BASE
			&& yylrule__ < LEX_EOAF_RULE
			&& yywrap__(lexer, dtbl, grammar, ptbl, dmap, gsetup));

		if(!bwrap__) {
				switch(yylrule__) {
				
case 0:
{
	
#line 333 "meta/ulyac.upg"
	{

		yy_set_bol(true);
	}
	

#line 1318 "gcode/ulyac.cpp"

	}
	break;
	
case 1:
{
	
#line 338 "meta/ulyac.upg"
	{
		
		PROCESS_ACTION_1(c, '*', '/', NULL_ACTION)
	}
	

#line 1333 "gcode/ulyac.cpp"

	}
	break;
	
case 2:
{
	
#line 343 "meta/ulyac.upg"
		{

		c = yyinput();
		while(END_OF_FILE != c) {
			if('\n' == c) {

				c = yyinput();
				
				if((' ' != c && '\t' != c) && ('\r' != c && '\n' != c)) {
					
					yyunput((char)c);
					yy_set_bol(true);
					break;
				}
			}
			else {
				c = yyinput();
			}
		}
		
		if( sn_pactDefHeader) {
			// definition header code, which is copied literally to generated source file
			dmap.insert(CKEY_DEF_HEADER, sn_pactDefHeader);
			sn_pactDefHeader = nullptr;
		}
		
		if( sn_pactDeclHeader) {
			// declaration header code, which is copied literally to generated header file
			dmap.insert(CKEY_DECL_HEADER, sn_pactDeclHeader);
			sn_pactDeclHeader = nullptr;
		}
		
		LEX_BEGIN(LEX_SC);
		return SECT_DELIM;
	}


#line 1379 "gcode/ulyac.cpp"

	}
	break;
	
case 3:
{
	
#line 379 "meta/ulyac.upg"
		{

		LEX_BEGIN(PRS_SC);		
		return SECT_DELIM;
	}

#line 1394 "gcode/ulyac.cpp"

	}
	break;
	
case 4:
{
	
#line 384 "meta/ulyac.upg"
		{
		
		// scanning code section comes here		
		action_t *pact = new action_t(yylloc.firstLine);
		
		while(END_OF_FILE != (c = yyinput())) {
			
			pact->addText((char)c);
		}
		
		// user code, all contents in fourth section of script
		dmap.insert(CKEY_USER_CODE, pact);
		
		return SECT_DELIM;
	}


#line 1420 "gcode/ulyac.cpp"

	}
	break;
	
case 5:
{
	
#line 400 "meta/ulyac.upg"
	{

		int idx = 8;
		while(' ' == yytext[idx] || '\t' == yytext[idx]) {
		
			++idx;
		}
		
		yylval.m_pchVal = new char[yyleng + 1 - idx];
		strncpy(yylval.m_pchVal, &yytext[idx], yyleng - idx);
		yylval.m_pchVal[yyleng - idx] = '\0';

		if(yylval.m_pchVal[0] >= 'a' && yylval.m_pchVal[0] <= 'z') {
		
			yylval.m_pchVal[0] -= 32;
		}
		
		LEX_BEGIN(OPT_SC);
		
		return OPT_KEY;
	}
	

#line 1452 "gcode/ulyac.cpp"

	}
	break;
	
case 6:
{
	
#line 422 "meta/ulyac.upg"
				{

		CRET
	}
	

#line 1467 "gcode/ulyac.cpp"

	}
	break;
	
case 7:
{
	
#line 427 "meta/ulyac.upg"
		{
		if(!strhelper_t::toSnum(yytext, yylval.m_nVal)) {
			
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: integer value `";
			strMsg += yytext;
			strMsg += "\' is out of range. ";
			_ERROR(strMsg, ELEX(1));
			
			yylval.m_nVal = 1;
		}
		
		return INT;
	}
	

#line 1494 "gcode/ulyac.cpp"

	}
	break;
	
case 8:
{
	
#line 444 "meta/ulyac.upg"
	{

		return KW_ON;
	}
	

#line 1509 "gcode/ulyac.cpp"

	}
	break;
	
case 9:
{
	
#line 449 "meta/ulyac.upg"
	{

		return KW_OFF;
	}


#line 1524 "gcode/ulyac.cpp"

	}
	break;
	
case 10:

case 11:
{
	
#line 455 "meta/ulyac.upg"
	{

		char *tx = yytext;
		int num = yyleng;
		if(yytext[0] == '\"') {
		
			yylval.m_pchVal = new char[yyleng - 1];
			++tx;
			num -= 2;
		}
		else {
			
			yylval.m_pchVal = new char[yyleng + 1];
		}
		i = 0, j = 0;
		for(; i < num; ++i, ++j) {
		
			if(i < num - 1 && tx[i] == '\\' && (tx[i + 1] == '\"' || tx[i + 1] == '\\')) {
				
				yylval.m_pchVal[j] = tx[i + 1];
				++i;
			}
			else {
			
				yylval.m_pchVal[j] = tx[i];
			}
		}
		yylval.m_pchVal[j] = '\0';
		
		return CSTR;
	}

#line 1567 "gcode/ulyac.cpp"

	}
	break;
	
case 12:
{
	
#line 486 "meta/ulyac.upg"
		{
		
		LEX_BEGIN(INITIAL);
	}


#line 1582 "gcode/ulyac.cpp"

	}
	break;
	
case 13:

case 14:
{
	
#line 492 "meta/ulyac.upg"
		{
		
		LEX_BEGIN(XISC_SC);
		if(yytext[1] == 'x' || yytext[1] == 'X') {
		
			return XSCLABEL;
		}
		else {
		
			return ISCLABEL;
		}
	}


#line 1607 "gcode/ulyac.cpp"

	}
	break;
	
case 15:
{
	
#line 505 "meta/ulyac.upg"
		{
		
		yylval.m_pchVal = new char[yyleng + 1];
		strncpy(yylval.m_pchVal, yytext, yyleng);
		yylval.m_pchVal[yyleng] = '\0';

		LEX_BEGIN(INITIAL);
		
		return XISC;
	}

#line 1627 "gcode/ulyac.cpp"

	}
	break;
	
case 16:
{
	
#line 515 "meta/ulyac.upg"


	

#line 1640 "gcode/ulyac.cpp"

	}
	break;
	
case 17:
{
	
#line 517 "meta/ulyac.upg"
		{
	
		LEX_BEGIN(INITIAL);
	}


#line 1655 "gcode/ulyac.cpp"

	}
	break;
	
case 18:
{
	
#line 522 "meta/ulyac.upg"
	{

		i = 7;
		for(; ' ' == yytext[i] || '\t' == yytext[i]; ++i) {}
		
		yylval.m_pchVal = new char[yyleng - i + 1];
		strncpy(yylval.m_pchVal, &yytext[i], yyleng - i);
		yylval.m_pchVal[yyleng - i] = '\0';
		
		// TODO: set start-symbol
		return START_LABEL;
	}


#line 1678 "gcode/ulyac.cpp"

	}
	break;
	
case 19:
{
	
#line 535 "meta/ulyac.upg"
		{

		if(dmap.isAction(CKEY_LTYPE_DECLARE)) {
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: location type has already declared, ";
			strMsg += "this statement is discarded.";
			_WARNING(strMsg);
		}
		else {
		
			if(dmap.isAction(CKEY_LTYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: location type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);			
			}
			else {
					i = 10;
					for(; ' ' == yytext[i] || '\t' == yytext[i]; ++i); {;}
					action_t *pact = new action_t(yylloc.firstLine);
					
					pact->addText(&yytext[i]);
					
					bool b = dmap.insert(CKEY_LTYPE_NAME, pact);
					assert(b);
			}
		}
		
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);
		
	}


#line 1725 "gcode/ulyac.cpp"

	}
	break;
	
case 20:
{
	
#line 572 "meta/ulyac.upg"
			{
		
		if(dmap.isAction(CKEY_STYPE_DECLARE)) {
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: semantic value type has already declared, ";
			strMsg += "this statement is discarded.";
			_WARNING(strMsg);
		}
		else {
		
			if( dmap.isAction(CKEY_STYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: semantic value type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);		
			}
			else {
			
				i = 7;
				for(; ' ' == yytext[i] || '\t' == yytext[i]; ++i); {;}
				
				action_t *pact = new action_t(yylloc.firstLine);
				
				pact->addText(&yytext[i]);
				
				bool b = dmap.insert(CKEY_STYPE_NAME, pact);
				assert(b);
				
			}
		}
		
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);
			
	}


#line 1775 "gcode/ulyac.cpp"

	}
	break;
	
case 21:

case 22:

case 23:

case 24:
{
	
#line 615 "meta/ulyac.upg"
	{

		string strKey;
		int nlen = 0;
		switch(yytext[1]) {
		case 'a':
			strKey = CKEY_ACTUAL_PARAMETERS;
			nlen = 13;
			break;
		case 'f':
			strKey = CKEY_FORMAL_PARAMETERS;
			nlen = 13;
			break;
		case 'l':
			if(dmap.isAction(CKEY_LTYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: location type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);
			}
			else {
				strKey = CKEY_LTYPE_DECLARE;
				nlen = 9;
			}
			break;
			
		default:	// case 'u':
			if(dmap.isAction(CKEY_STYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: semantic value type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);
			}
			else {			
				strKey = CKEY_STYPE_DECLARE;
				nlen = 6;
			}
			break;
		}
		
		if(nlen == 0 || dmap.isAction(strKey)) {
		
			if(nlen > 0) {
				yytext[nlen] = '\0';
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: `";
				strMsg += yytext;
				strMsg += "\' duplicated and discarded";
				_WARNING(strMsg);
			}

			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, NULL_ACTION)
		}
		else {
			
			action_t *pact = new action_t(yylloc.firstLine);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, pact->addText)
			
			if(c == END_OF_FILE) {
				
				_ERROR("description: lack of `%}\'.", ELEX(3));
			}

			bool b = dmap.insert(strKey, pact);
			assert(b);
		}
	}

	

#line 1867 "gcode/ulyac.cpp"

	}
	break;
	
case 25:

case 26:

case 27:
{
	
#line 693 "meta/ulyac.upg"
		{

		bool bret;
		
		switch(yytext[1]) {
		case 'l':
			bret = dtbl.beginLexInit(yylloc.firstLine);
			yytext[9] = '\0';
			break;
		case 'p':
			bret = dtbl.beginPrematch(yylloc.firstLine);
			yytext[10] = '\0';
			break;
		default: // yytext[1] == 'y'
			bret = dtbl.beginWrap(yylloc.firstLine);
			yytext[7] = '\0';
			break;
		}

		if( ! bret)  {
		
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: `";
			strMsg += yytext;
			strMsg += "\' duplicated and discarded";
			_WARNING(strMsg);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, NULL_ACTION)
		}
		else {
		
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, dtbl.addActionText)
			
		}
		
		if(c == END_OF_FILE) {
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: lack of `%}\'.";
			_ERROR(strMsg, ELEX(4));
		}
	}



#line 1928 "gcode/ulyac.cpp"

	}
	break;
	
case 28:
{
	
#line 740 "meta/ulyac.upg"
		{

		if( ! sn_pactDeclHeader) {
		
			sn_pactDeclHeader = new action_t(yylloc.firstLine);
		}

		PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, sn_pactDeclHeader->addText)
		
		sn_pactDeclHeader->addText('\n');
	}


#line 1950 "gcode/ulyac.cpp"

	}
	break;
	
case 29:
{
	
#line 752 "meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TOK_SC);
		return TOKEN_LABEL;
	}

#line 1964 "gcode/ulyac.cpp"

	}
	break;
	
case 30:
{
	
#line 756 "meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TOK_SC);
		return LEFT_LABEL;
	}

#line 1978 "gcode/ulyac.cpp"

	}
	break;
	
case 31:
{
	
#line 760 "meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TOK_SC);
		return RIGHT_LABEL;
	}

#line 1992 "gcode/ulyac.cpp"

	}
	break;
	
case 32:
{
	
#line 764 "meta/ulyac.upg"
		{
		LEX_PUSH_STATE(TOK_SC);
		return NONASSOC_LABEL;
	}

#line 2006 "gcode/ulyac.cpp"

	}
	break;
	
case 33:
{
	
#line 768 "meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TYP_SC);
		return TYPE_LABEL;
	}


#line 2021 "gcode/ulyac.cpp"

	}
	break;
	
case 34:

case 35:
{
	
#line 774 "meta/ulyac.upg"
 {		
		yylval.m_pDstrct = new action_t(yylloc.firstLine);
		
		c = yyinput();
		while(c && c != END_OF_FILE) {
			if(LEX_ESCAPE_CHAR == c) {
				c = yyinput();
				if(c && c != END_OF_FILE) {
					yylval.m_pDstrct->addText(c);
				}
				else {
					yylval.m_pDstrct->addText(LEX_ESCAPE_CHAR);
					break;
				}
				c = yyinput();
			}
			else {
				if('%' == c) {
					c = yyinput();
					if('}' == c) { break; }
					else {	yylval.m_pDstrct->addText('%');	}
				}
				else if('$' == c) {
					c = yyinput();
					if('$' == c) {
						yylval.m_pDstrct->addMacroPH(SKEY_SVNAME_DSTRCT);
						c = yyinput();
					}
					else {
						yylval.m_pDstrct->addText('$');
					}
				}
				else if('@' == c) {
					c = yyinput();
					if('$' == c) {
						yylval.m_pDstrct->addMacro(SKEY_SVLOC_DSTRCT);
						c = yyinput();
					}
					else {
						yylval.m_pDstrct->addText('@');
					}
				}
				if(c && END_OF_FILE != c) {
					if('%' != c && '@' != c && '$' != c && LEX_ESCAPE_CHAR != c) {
						yylval.m_pDstrct->addText(c);
						c = yyinput();
					}
				}
			}
		}

		LEX_PUSH_STATE(DSCRD_SC);
		
		yylloc.lastLine = yyget_lineno();
		yylloc.lastColumn = yyget_colno() - 1;

		return DESTRUCTOR_LABEL;
	}

#line 2091 "gcode/ulyac.cpp"

	}
	break;
	
case 36:
{
	
#line 832 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 0;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2105 "gcode/ulyac.cpp"

	}
	break;
	
case 37:
{
	
#line 836 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 1;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2119 "gcode/ulyac.cpp"

	}
	break;
	
case 38:
{
	
#line 840 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 2;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2133 "gcode/ulyac.cpp"

	}
	break;
	
case 39:
{
	
#line 844 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 3;
		LEX_PUSH_STATE(PLVAR_SC);
	}
	

#line 2148 "gcode/ulyac.cpp"

	}
	break;
	
case 40:
{
	
#line 849 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 0;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2162 "gcode/ulyac.cpp"

	}
	break;
	
case 41:
{
	
#line 853 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 1;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2176 "gcode/ulyac.cpp"

	}
	break;
	
case 42:
{
	
#line 857 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 2;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2190 "gcode/ulyac.cpp"

	}
	break;
	
case 43:
{
	
#line 861 "meta/ulyac.upg"
		{
		sn_nVarDeclInit = 3;
		LEX_PUSH_STATE(PLVAR_SC);
	}
	

#line 2205 "gcode/ulyac.cpp"

	}
	break;
	
case 44:
{
	
#line 866 "meta/ulyac.upg"
			{
		sn_nVarDeclInit = 4;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2219 "gcode/ulyac.cpp"

	}
	break;
	
case 45:
{
	
#line 870 "meta/ulyac.upg"
			{
		sn_nVarDeclInit = 5;
		LEX_PUSH_STATE(PLVAR_SC);
	}


#line 2234 "gcode/ulyac.cpp"

	}
	break;
	
case 46:
{
	
#line 875 "meta/ulyac.upg"
		{

		string strKey;
		string strText;
		switch(sn_nVarDeclInit) {
		case 0:	// %lexvar-decl
			strKey = CKEY_LEXVAR_DECL;
			strText = "declaration block for yylex\'s local variables";
			break;
		case 1:	// %lexvar-init
			strKey = CKEY_LEXVAR_INIT;
			strText = "initialization block for yylex\'s local variables";
			break;
		case 2:	// %parsevar-decl
			strKey = CKEY_PARSEVAR_DECL;
			strText = "declaration block for yyparse\'s local variables";
			break;

		case 3:	// %parsevar-init
			strKey = CKEY_PARSEVAR_INIT;
			strText = "initialization block for yyparse\'s local variables";
			break;
		case 4: // %parse-init
			strKey = CKEY_PARSEINIT_ACTION;
			strText = "yyparse's entry action";
			break;
		case 5: 
			strKey = CKEY_PARSEEXIT_ACTION;
			strText = "yyparse's exit action";
			break;
		default:
			assert(false);
		}

		if(dmap.isAction(strKey)) {
		
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: ";
			strMsg += strText;
			strMsg += " duplicated and discarded";
			_WARNING(strMsg);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, NULL_ACTION)

		}
		else {
		
			action_t *pact = new action_t(yylloc.firstLine);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, pact->addText)
			
			if(c == END_OF_FILE) {
				_ERROR("description: lack of `%}\'.", ELEX(3));
			}
			
			bool b = dmap.insert(strKey, pact);
			assert(b);
		}
		LEX_POP_STATE();
		
	}


#line 2308 "gcode/ulyac.cpp"

	}
	break;
	
case 47:
{
	
#line 939 "meta/ulyac.upg"
		{
		
		if(! sn_pactDefHeader) {
		
			sn_pactDefHeader = new action_t(yylloc.firstLine);
		}
		
		PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, sn_pactDefHeader->addText)
		
		sn_pactDefHeader->addText('\n');
	}


#line 2330 "gcode/ulyac.cpp"

	}
	break;
	
case 48:
{
	
#line 951 "meta/ulyac.upg"
	{

		c = yyleng - 1;
		while(yytext[--c] == ' ' || yytext[c] == '\t');
		++c;
		yytext[c] = '\0';
		yylval.m_pchVal = new char[c + 1];
		strncpy(yylval.m_pchVal, yytext, c);
		yylval.m_pchVal[c] = '\0';
		
		return LFTID;
	}


#line 2353 "gcode/ulyac.cpp"

	}
	break;
	
case 49:
{
	
#line 964 "meta/ulyac.upg"
	{

		yylval.m_pchVal = new char[yyleng + 1];
		strncpy(yylval.m_pchVal, yytext, yyleng);
		yylval.m_pchVal[yyleng] = '\0';
		
		return CID;
	}

#line 2371 "gcode/ulyac.cpp"

	}
	break;
	
case 50:
{
	
#line 972 "meta/ulyac.upg"
	{
		CRET
	}

#line 2384 "gcode/ulyac.cpp"

	}
	break;
	
case 51:
{
	
#line 975 "meta/ulyac.upg"
		{
        yylval.m_cVal = strhelper_t::toEsc(&yytext[1]);
		return QCHAR;
	}

#line 2398 "gcode/ulyac.cpp"

	}
	break;
	
case 52:
{
	
#line 979 "meta/ulyac.upg"
		{	
		yylval.m_cVal = (char)strhelper_t::ostr2Num(&yytext[1]);
		return QCHAR;
	}

#line 2412 "gcode/ulyac.cpp"

	}
	break;
	
case 53:
{
	
#line 983 "meta/ulyac.upg"
		{
		yylval.m_cVal = (char)strhelper_t::hstr2Num(&yytext[1]);
		return QCHAR;
	}

#line 2426 "gcode/ulyac.cpp"

	}
	break;
	
case 54:
{
	
#line 987 "meta/ulyac.upg"
	{
		yylval.m_cVal = yytext[1];
		return QCHAR;
	}

#line 2440 "gcode/ulyac.cpp"

	}
	break;
	
case 55:
{
	
#line 991 "meta/ulyac.upg"
		{
		yylval.m_cVal = yytext[2];
		return QCHAR;
	}

#line 2454 "gcode/ulyac.cpp"

	}
	break;
	
case 56:
{
	
#line 995 "meta/ulyac.upg"
           {
        std::string tstr;
        for(auto i = 0; i < yyleng; ) {
            if(yytext[i] == '\\') {

                int ncnt = 0;
                switch(yytext[i + 1]) {
                case 'x':
                case 'X':
                    tstr += (char)strhelper_t::hstr2Num(&yytext[i], &ncnt);
                    i += ncnt;
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                    tstr += (char)strhelper_t::ostr2Num(&yytext[i], &ncnt);
                    i += ncnt;
                    break;
                default:
                    tstr += strhelper_t::toEsc(&yytext[i]);
                    i += 2;
                }
            } else {
                tstr += yytext[i];
                i++;
            }
        }

        if(tstr.size() == 3) {
            yylval.m_cVal = tstr[1];
            return QCHAR;
        }

        yylval.m_pchVal = new char[tstr.size() + 1];
        yylval.m_pchVal[tstr.size()] = '\0';
        strncpy(yylval.m_pchVal, tstr.data(), tstr.size());

        return QSTR_TOKEN;

    }

#line 2505 "gcode/ulyac.cpp"

	}
	break;
	
case 57:
{
	
#line 1036 "meta/ulyac.upg"
		{

		if(!strhelper_t::toSnum(yytext, yylval.m_nVal)) {		
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: integer value `";
			strMsg += yytext;
			strMsg += "\' is out of range.";
			_ERROR(strMsg, ELEX(2));
			
			yylval.m_nVal = 1;
		}
		return INT;
	}

#line 2530 "gcode/ulyac.cpp"

	}
	break;
	
case 58:
{
	
#line 1051 "meta/ulyac.upg"
		{
		return yytext[0];
	}

#line 2543 "gcode/ulyac.cpp"

	}
	break;
	
case 59:
{
	
#line 1054 "meta/ulyac.upg"
	{
		LEX_POP_STATE();
		return '\n';
	}
	

#line 2558 "gcode/ulyac.cpp"

	}
	break;
	
case 60:
{
	
#line 1059 "meta/ulyac.upg"
		{

		strMsg = strhelper_t::fromInt(yylloc.firstLine);
		strMsg += ':';
		strMsg += strhelper_t::fromInt(yylloc.firstColumn);
		strMsg += "; description: option `";
		strMsg += yytext;
		strMsg += "\' unsupported and discarded";
		_WARNING(strMsg);
		
		while(0 != (c = yyinput())) {
		
			if('\n' == c || END_OF_FILE == c) {

				break;
			}
		}
		
		yy_set_bol(true);
	}


#line 2589 "gcode/ulyac.cpp"

	}
	break;
	
case 61:
{
	
#line 1080 "meta/ulyac.upg"
		{

		LEX_PUSH_STATE(SCR_SC);
		
		CRET
	}

#line 2605 "gcode/ulyac.cpp"

	}
	break;
	
case 62:
{
	
#line 1086 "meta/ulyac.upg"
	{

		return KW_INITIAL;
	}
	

#line 2620 "gcode/ulyac.cpp"

	}
	break;
	
case 63:
{
	
#line 1091 "meta/ulyac.upg"
		{

		yylval.m_pchVal = new char[yyleng + 1];
		strncpy(yylval.m_pchVal, yytext, yyleng);
		yylval.m_pchVal[yyleng] = '\0';
		return CID;
	}
	

#line 2638 "gcode/ulyac.cpp"

	}
	break;
	
case 64:
{
	
#line 1099 "meta/ulyac.upg"
			{

		CRET
	}
	

#line 2653 "gcode/ulyac.cpp"

	}
	break;
	
case 65:
{
	
#line 1104 "meta/ulyac.upg"
			{

		LEX_POP_STATE();
		
		CRET
	}
	

#line 2670 "gcode/ulyac.cpp"

	}
	break;
	
case 66:
{
	
#line 1111 "meta/ulyac.upg"
			{
		return KW_ALLSC;
	}


#line 2684 "gcode/ulyac.cpp"

	}
	break;
	
case 67:
{
	
#line 1115 "meta/ulyac.upg"
		{
		return KW_EOF;
	}


#line 2698 "gcode/ulyac.cpp"

	}
	break;
	
case 68:
{
	
#line 1119 "meta/ulyac.upg"
		{

		i = yyleng - 1;
		for(; i > 0 && (' ' == yytext[i] || '\t' == yytext[i]); --i) {
		}
		assert(i >= 0);
		++i;
		
		yylval.m_pchVal = new char[i + 1];
		strncpy(yylval.m_pchVal, yytext, i);
		yylval.m_pchVal[i] = '\0';

		
		LEX_PUSH_STATE(MAC_SC);
		
		return CID;
	}


#line 2726 "gcode/ulyac.cpp"

	}
	break;
	
case 69:
{
	
#line 1137 "meta/ulyac.upg"
	{

		LEX_POP_STATE();
		return '\n';
	}


#line 2742 "gcode/ulyac.cpp"

	}
	break;
	
case 70:
{
	
#line 1143 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::ALNUM;
		
		return POSIX_SET;
	}


#line 2759 "gcode/ulyac.cpp"

	}
	break;
	
case 71:
{
	
#line 1150 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::ALPHA;
		
		return POSIX_SET;
	}
	

#line 2776 "gcode/ulyac.cpp"

	}
	break;
	
case 72:
{
	
#line 1157 "meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::BLANK;
		
		return POSIX_SET;
	}
	

#line 2793 "gcode/ulyac.cpp"

	}
	break;
	
case 73:
{
	
#line 1164 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::CNTRL;
		
		return POSIX_SET;
	}
	

#line 2810 "gcode/ulyac.cpp"

	}
	break;
	
case 74:
{
	
#line 1171 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::DIGIT;
		
		return POSIX_SET;
	}
	

#line 2827 "gcode/ulyac.cpp"

	}
	break;
	
case 75:
{
	
#line 1178 "meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::GRAPH;
		
		return POSIX_SET;
	}
	

#line 2844 "gcode/ulyac.cpp"

	}
	break;
	
case 76:
{
	
#line 1185 "meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::LOWER;
		
		return POSIX_SET;
	}
	

#line 2861 "gcode/ulyac.cpp"

	}
	break;
	
case 77:
{
	
#line 1192 "meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::PRINT;
		
		return POSIX_SET;
	}
	

#line 2878 "gcode/ulyac.cpp"

	}
	break;
	
case 78:
{
	
#line 1199 "meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::PUNCT;
		
		return POSIX_SET;
	}
	

#line 2895 "gcode/ulyac.cpp"

	}
	break;
	
case 79:
{
	
#line 1206 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::SPACE;
		
		return POSIX_SET;
	}
	

#line 2912 "gcode/ulyac.cpp"

	}
	break;
	
case 80:
{
	
#line 1213 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::UPPER;
		
		return POSIX_SET;
	}
	

#line 2929 "gcode/ulyac.cpp"

	}
	break;
	
case 81:
{
	
#line 1220 "meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::XDIGIT;
		
		return POSIX_SET;
	}

#line 2945 "gcode/ulyac.cpp"

	}
	break;
	
case 82:
{
	
#line 1226 "meta/ulyac.upg"
			{
		
		yylval.m_nPosix = charset_t::CIDF;
		
		return POSIX_SET;
	}
	

#line 2962 "gcode/ulyac.cpp"

	}
	break;
	
case 83:
{
	
#line 1233 "meta/ulyac.upg"
			{

		yylval.m_nPosix = charset_t::CIDS;
		
		return POSIX_SET;
	}
	

#line 2979 "gcode/ulyac.cpp"

	}
	break;
	
case 84:
{
	
#line 1240 "meta/ulyac.upg"
		{

		LEX_PUSH_STATE(CSH_SC);	
		CRET
	}
	

#line 2995 "gcode/ulyac.cpp"

	}
	break;
	
case 85:
{
	
#line 1246 "meta/ulyac.upg"
		{

		LEX_PUSH_STATE(CSH_SC);
		return NCS;
	}

#line 3010 "gcode/ulyac.cpp"

	}
	break;
	
case 86:
{
	
#line 1251 "meta/ulyac.upg"
	{
		
		yylval.m_cVal = yytext[1];
		return CCHAR;
	}

#line 3025 "gcode/ulyac.cpp"

	}
	break;
	
case 87:
{
	
#line 1256 "meta/ulyac.upg"
		{

        yylval.m_cVal = strhelper_t::toEsc(yytext);
		return CCHAR;
	}
	

#line 3041 "gcode/ulyac.cpp"

	}
	break;
	
case 88:
{
	
#line 1262 "meta/ulyac.upg"
		{
	
		yylval.m_cVal = (char)strhelper_t::ostr2Num(yytext);
		
		return CCHAR;
	}

#line 3057 "gcode/ulyac.cpp"

	}
	break;
	
case 89:
{
	
#line 1268 "meta/ulyac.upg"
		{

		yylval.m_cVal = (char)strhelper_t::hstr2Num(yytext);
		
		return CCHAR;
	}

#line 3073 "gcode/ulyac.cpp"

	}
	break;
	
case 90:
{
	
#line 1274 "meta/ulyac.upg"
	{

		if(yytext[0] == '\\') {
		
			assert(yyleng >= 2);
			yylval.m_cVal = yytext[1];
		}
		else {
		
			yylval.m_cVal = yytext[0];
		}
		return CCHAR;
	}
	

#line 3097 "gcode/ulyac.cpp"

	}
	break;
	
case 91:
{
	
#line 1288 "meta/ulyac.upg"
			{
		CRET
	}


#line 3111 "gcode/ulyac.cpp"

	}
	break;
	
case 92:
{
	
#line 1292 "meta/ulyac.upg"
			{

		LEX_POP_STATE();
		
		CRET
	}

#line 3127 "gcode/ulyac.cpp"

	}
	break;
	
case 93:
{
	
#line 1298 "meta/ulyac.upg"
			{

		yylval.m_cVal = yytext[0];
		
		return CCHAR;
	}


#line 3144 "gcode/ulyac.cpp"

	}
	break;
	
case 94:
{
	
#line 1305 "meta/ulyac.upg"
		{

		CRET
	}
	

#line 3159 "gcode/ulyac.cpp"

	}
	break;
	
case 95:
{
	
#line 1310 "meta/ulyac.upg"
		{

		yylval.m_pchVal = new char[yyleng - 1];
		strncpy(yylval.m_pchVal, &yytext[1], yyleng - 2);
		yylval.m_pchVal[yyleng - 2] = '\0';
		
		return MCALL;
	}
	

#line 3178 "gcode/ulyac.cpp"

	}
	break;
	
case 96:
{
	
#line 1319 "meta/ulyac.upg"
		{

		char cc = yytext[yyleng - 1];
		yytext[yyleng - 1] = '\0';
		
		int n;
		
		strhelper_t::toSnum(&yytext[1], n);
		
		yytext[yyleng - 1] = cc;	
		
		yylval.m_nRange.m_nLower = yylval.m_nRange.m_nUpper = (short)n;
		
		return RANGE_EQUAL;
	}


#line 3204 "gcode/ulyac.cpp"

	}
	break;
	
case 97:
{
	
#line 1335 "meta/ulyac.upg"
		{

		char cc = yytext[yyleng - 1];
		yytext[yyleng - 1] = '\0';
		
		int n;
		strhelper_t::toSnum(&yytext[2], n);		
		
		yytext[yyleng - 1] = cc;
		yylval.m_nRange.m_nLower = 0;
		yylval.m_nRange.m_nUpper = (short)n;
		
		return RANGE_LESS;
	}
	

#line 3229 "gcode/ulyac.cpp"

	}
	break;
	
case 98:
{
	
#line 1350 "meta/ulyac.upg"
		{
		
		char cc = yytext[yyleng - 2];
		yytext[yyleng - 2] = '\0';
		
		int n;
		strhelper_t::toSnum(&yytext[1], n);		
		
		yylval.m_nRange.m_nLower = (short)n;
		yylval.m_nRange.m_nUpper = INF;

		yytext[yyleng - 2] = cc;
		
		return RANGE_MORE;
	}
	

#line 3255 "gcode/ulyac.cpp"

	}
	break;
	
case 99:
{
	
#line 1366 "meta/ulyac.upg"
		{

		int n;
		char cc;
		for(i = 2; isdigit(yytext[i]); ++i);
		
		cc = yytext[i];
		yytext[i] = '\0';
		
		strhelper_t::toSnum(&yytext[1], n);		
		yylval.m_nRange.m_nLower = (short)n;
		yytext[i] = cc;
		
		for(; !isdigit(yytext[i]); ++i);
		j = i;
		for(; isdigit(yytext[i]); ++i);
		
		cc = yytext[i];
		yytext[i] = '\0';
		
		strhelper_t::toSnum(&yytext[j], n);
		yylval.m_nRange.m_nUpper = (short)n;
		yytext[i] = cc;
		
		return RANGE_BET;
	}

#line 3291 "gcode/ulyac.cpp"

	}
	break;
	
case 100:
{
	
#line 1392 "meta/ulyac.upg"
	{

		yylval.m_cVal = yytext[0];
		return CCHAR;
	}
	

#line 3307 "gcode/ulyac.cpp"

	}
	break;
	
case 101:

case 102:
{
	
#line 1399 "meta/ulyac.upg"
	{

		yylval.m_pchVal = new char[yyleng - 1];
		strncpy(yylval.m_pchVal, &yytext[1], yyleng - 2);
		yylval.m_pchVal[yyleng - 2] = '\0';
		
		return CSTR;
	}
	

#line 3328 "gcode/ulyac.cpp"

	}
	break;
	
case 103:
{
	
#line 1408 "meta/ulyac.upg"
	{

		if('\n' != yytext[yyleng - 1]) {
		
			string strIgnored;
		
			c = yyinput();
			while('\n' != c && END_OF_FILE != c) {
			
				if('\r' != c) {
				
					strIgnored += (char) c;
				}
				c = yyinput();
			}
			
			if(strIgnored.size() > 0) {
				
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: action `";
				strMsg += strIgnored;
				strMsg += "\' unsupported and discarded.";
				_WARNING(strMsg);
			}
		}

		return ENDP;
	}


#line 3369 "gcode/ulyac.cpp"

	}
	break;
	
case 104:

case 105:
{
	
#line 1440 "meta/ulyac.upg"
		{

		c = yytext[yyleng - 1];
		
		if(c != '\n') {

			c = yyinput();
		}
		
		yylval.m_nVal = dtbl.addEmptyAction(yylloc.firstLine);
		
		dtbl.addActionText(yytext);
		
		while(END_OF_FILE != c) {
			
			if('\n' == c) {
				
				dtbl.addActionText(c);
				c = yyinput();
				
				if((' ' != c && '\t' != c) && ('\r' != c && '\n' != c)) {
					
					break;
				}
			}
			else {
			
				dtbl.addActionText(c);
				c = yyinput();
			}
		}
		
		yyunput((char)c);
		yy_set_bol(true);
		
		yylloc.lastLine = yyget_lineno();
		yylloc.lastColumn = yyget_colno() - 1;
		
		return LEX_ACTION;
	}
	

#line 3422 "gcode/ulyac.cpp"

	}
	break;
	
case 106:
{
	
#line 1481 "meta/ulyac.upg"
		{
		CRET
	}


#line 3436 "gcode/ulyac.cpp"

	}
	break;
	
case 107:
{
	
#line 1485 "meta/ulyac.upg"
	{

		return DPRE_LABEL;
	}

#line 3450 "gcode/ulyac.cpp"

	}
	break;
	
case 108:
{
	
#line 1489 "meta/ulyac.upg"
		{

		return PREC_LABEL;
	}

#line 3464 "gcode/ulyac.cpp"

	}
	break;
	
case 109:
{
	
#line 1493 "meta/ulyac.upg"
				{

		LEX_PUSH_STATE(PACT_SC);
		yylval.m_nVal = ptbl.addEmptyAction(yylloc.firstLine);
		
		return PACT_BEGIN;
	}

#line 3481 "gcode/ulyac.cpp"

	}
	break;
	
case 110:
{
	
#line 1500 "meta/ulyac.upg"
		{

		LEX_POP_STATE();
		return PACT_END;
	}
	
	/* ` is considered as escape char during action processing */

#line 3498 "gcode/ulyac.cpp"

	}
	break;
	
case 111:

case 112:
{
	
#line 1508 "meta/ulyac.upg"
		{

		ptbl.addActionText(&yytext[1]);
	}

#line 3514 "gcode/ulyac.cpp"

	}
	break;
	
case 113:
{
	
#line 1512 "meta/ulyac.upg"
		{

		int nRuleID = grammar.getLastProdIndex();
		const prod_t *p = grammar.getProd(nRuleID);
		assert(p);
		
		switch(yytext[0]) {
		case '$': {
				string strSVT;
				bool bret = grammar.getSymbolSVT(nRuleID, -1, strSVT);
				assert(bret);
				if( ! strSVT.empty()) {
					ptbl.addActionMacro(SKEY_SVNAME_LEFT, strSVT);
				}
				else {
					strMsg = strhelper_t::fromInt(yylloc.firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt(yylloc.firstColumn);
					strMsg += "; description: semantic value type is needed.";
					_ERROR(strMsg, ELEX(5));
					
					// TODO: add default semantic value
				}
			}
			break;
		case '@': {
		
				if( ! gsetup.m_bLocCompute) {
					_ERROR("description: location computation disabled.", ELEX(5));
				}
				ptbl.addActionMacro(SKEY_SVLOC_LEFT);
			}
			break;
		default:
			break;
		}
	}

#line 3561 "gcode/ulyac.cpp"

	}
	break;
	
case 114:
{
	
#line 1549 "meta/ulyac.upg"
		{
		yytext[yyleng - 2] = '\0';
		ptbl.addActionMacro(SKEY_SVNAME_LEFT, &yytext[2]);
		
		if(!grammar.setMidSVT(&yytext[2])) {
			yytext[yyleng - 2] = '>';
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: semantic value type set more than once, `";
			strMsg += yytext;
			strMsg += "\' will overwrite the former one.";
			_WARNING(strMsg);
		}
	}

#line 3586 "gcode/ulyac.cpp"

	}
	break;
	
case 115:
{
	
#line 1564 "meta/ulyac.upg"
		{

		int nVal;
		if(!strhelper_t::toSnum(&yytext[1], nVal)) {
			
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: integer value `";
			strMsg += &yytext[1];
			strMsg += "\' is out of range.";
			_ERROR(strMsg, ELEX(6));
		}
		else {
		
			int nRuleID = grammar.getLastProdIndex();
			prod_t *pr = grammar.getProd(nRuleID);
			if(nVal < 0 || nVal > pr->getRightSize()) {
			
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: rule item index `";
				strMsg += &yytext[1];
				strMsg += "\' is out of range.";
				_ERROR(strMsg, ELEX(7));
			}
			else {
			
				switch(yytext[0]) {
				
				case '$': {
						string strSVT;
						bool bret = grammar.getSymbolSVT(nRuleID, nVal - 1, strSVT);
						assert(bret);
						if( ! strSVT.empty()) {
							ptbl.addActionMacro(SKEY_SVNAME_RIGHT,
								strhelper_t::fromInt(pr->getRightSize() - nVal), strSVT);
						}
						else {
							strMsg = strhelper_t::fromInt(yylloc.firstLine);
							strMsg += ':';
							strMsg += strhelper_t::fromInt(yylloc.firstColumn);
							strMsg += "; description: semantic value type is needed.";
							_ERROR(strMsg, ELEX(8));
						}
					}
					break;
				case '@': {
				
						if( ! gsetup.m_bLocCompute) {
							strMsg = strhelper_t::fromInt(yylloc.firstLine);
							strMsg += ':';
							strMsg += strhelper_t::fromInt(yylloc.firstColumn);
							strMsg += "; description: location computation disabled."; 
							_ERROR(strMsg, ELEX(5));
						}
						ptbl.addActionMacro(SKEY_SVLOC_RIGHT, strhelper_t::fromInt(pr->getRightSize() - nVal));
					}
					break;
				default:
					break;
				}
			}
		}
	}

#line 3662 "gcode/ulyac.cpp"

	}
	break;
	
case 116:
{
	
#line 1630 "meta/ulyac.upg"
	{

		i = yyleng - 1;
		while(yytext[i] != '>') {--i;}
		assert(i > 2);
		
		int nVal;
		if(!strhelper_t::toSnum(&yytext[i + 1], nVal)) {
			
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: rule item index `";
			strMsg += &yytext[i + 1];
			strMsg += "\' is out of range.";
			_ERROR(strMsg, ELEX(9));
		}
		else {
		
			yytext[i] = '\0';
			int nRuleID = grammar.getLastProdIndex();
			prod_t *pr = grammar.getProd(nRuleID);
			
			if(nVal < 0 || nVal > pr->getRightSize()) {
			
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: rule item index `";
				strMsg += &yytext[i + 1];
				strMsg += "\' is out of range.";
				_ERROR(strMsg, ELEX(10));
			}
			else {
			string strSVT;
			bool bret = grammar.getSymbolSVT(nRuleID, nVal - 1, strSVT);
			assert(bret);
				
				if(strSVT != string(&yytext[2])) {
				
					strMsg = strhelper_t::fromInt(yylloc.firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt(yylloc.firstColumn);
					strMsg += "; description: semantic value `";
					strMsg += &yytext[2];
					strMsg += "\' is different from it declaration.";
					_WARNING(strMsg);
				}
						
				ptbl.addActionMacro(SKEY_SVNAME_RIGHT,
					strhelper_t::fromInt(pr->getRightSize() - nVal), &yytext[2]);
			}
		}
	}

#line 3726 "gcode/ulyac.cpp"

	}
	break;
	
case 117:
{
	
#line 1684 "meta/ulyac.upg"
			{
		ptbl.addActionText(yytext[0]);
	}
	
	/********* default pattern ******/
	

#line 3742 "gcode/ulyac.cpp"

	}
	break;
	
case 118:
{
	
#line 1690 "meta/ulyac.upg"



#line 3754 "gcode/ulyac.cpp"

	}
	break;
	
case 119:
{
	
#line 1691 "meta/ulyac.upg"


	

#line 3767 "gcode/ulyac.cpp"

	}
	break;
	
case 120:
{
	
#line 1693 "meta/ulyac.upg"
		{
		
		strMsg = strhelper_t::fromInt(yylloc.firstLine);
		strMsg += ':';
		strMsg += strhelper_t::fromInt(yylloc.firstColumn);
		strMsg += "; description: unknown symbol `";
		strMsg += yytext[0];
		strMsg += "\'";
		
		switch(YYSTART()) {
		case INITIAL:
			
			while(0 != (c = yyinput()) && END_OF_FILE != c) {
			
				if('\n' == c) {
				
					break;
				}
			}
			
			yy_set_bol(true);
			
			strMsg += ".";
			_ERROR(strMsg, ECMD(20));
			
			break;
				
		case OPT_SC:
		
			while(0 != (c = yyinput()) && END_OF_FILE != c) {
			
				if('\n' == c) {

					break;
				}
			}
			
			yy_set_bol(true);
			
			strMsg += " in option.";
			
			_ERROR(strMsg, ECMD(20));
			
			return KW_ON;
				
		case MAC_SC:
		
			while(0 != (c = yyinput()) && END_OF_FILE != c) {
			
				if('\n' == c) {

					break;
				}
			}
			
			yy_set_bol(true);
			
			strMsg += " in regular expression macro.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			
			return CCHAR;
				
		case LEX_SC:
			
			strMsg += " in sub regular expression.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			
			return CCHAR;

		case SCR_SC:
			
			strMsg += " in start-condition referrence.";
			_ERROR(strMsg, ECMD(20));
			return KW_INITIAL;
				
		case CSH_SC:
			strMsg += " in charset.";
			_ERROR(strMsg, ESYN(20));
			
			yylval.m_cVal = yytext[0];
			return CCHAR;
				
		case XISC_SC:
			strMsg += " in start-condition declaration.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_pchVal = new char[2];
			yylval.m_pchVal[0] = yytext[0];
			yylval.m_pchVal[1] = '\0';
			
			return XISC;
				
		case TOK_SC:
		
			strMsg += " in token declaration.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			return QCHAR;
				
		case TYP_SC:
		
			strMsg += " in type declaration.";
			_ERROR(strMsg, ECMD(20));
			
			strMsg = grammar.getFakeSymbol();
			yylval.m_pchVal = new char[strMsg.size() + 1];
			strncpy(yylval.m_pchVal, strMsg.c_str(), strMsg.size());
			yylval.m_pchVal[strMsg.size()] = '\0';
			
			return CID;
				
		case DSCRD_SC:
			strMsg += " in destructor declaration.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			return QCHAR;
		
		//case PACT_SC:
		//case PRS_SC:
		default:
		
			strMsg += ".";
			_ERROR(strMsg, ECMD(20));
			return yytext[0];
		}
	}


#line 3910 "gcode/ulyac.cpp"

	}
	break;
	
case 121:
{
	
#line 0 "meta/ulyac.upg"

#line 3920 "gcode/ulyac.cpp"

	}
	break;
	
case 122:
{
	
#line 0 "meta/ulyac.upg"

#line 3930 "gcode/ulyac.cpp"

	}
	break;
	
case 123:
{
	
#line 0 "meta/ulyac.upg"

#line 3940 "gcode/ulyac.cpp"

	}
	break;
	
case 124:
{
	
#line 0 "meta/ulyac.upg"

#line 3950 "gcode/ulyac.cpp"

	}
	break;
	
case 125:
{
	
#line 0 "meta/ulyac.upg"

#line 3960 "gcode/ulyac.cpp"

	}
	break;
	
case 126:
{
	
#line 0 "meta/ulyac.upg"

#line 3970 "gcode/ulyac.cpp"

	}
	break;
	
case 127:
{
	
#line 0 "meta/ulyac.upg"

#line 3980 "gcode/ulyac.cpp"

	}
	break;
	
case 128:
{
	
#line 0 "meta/ulyac.upg"

#line 3990 "gcode/ulyac.cpp"

	}
	break;
	
case 129:
{
	
#line 0 "meta/ulyac.upg"

#line 4000 "gcode/ulyac.cpp"

	}
	break;
	
case 130:
{
	
#line 0 "meta/ulyac.upg"

#line 4010 "gcode/ulyac.cpp"

	}
	break;
	
case 131:
{
	
#line 0 "meta/ulyac.upg"

#line 4020 "gcode/ulyac.cpp"

	}
	break;
	
case 132:
{
	
#line 0 "meta/ulyac.upg"

#line 4030 "gcode/ulyac.cpp"

	}
	break;
	
case 133:
{
	
#line 0 "meta/ulyac.upg"

#line 4040 "gcode/ulyac.cpp"

	}
	break;
	

				case LEX_EOAF_RULE: 
					yy_delete_buffer();
					yyecode__ = YYE_EOS;
					break;
				default:
					if(yyleng > 0)
						yyat_bol__ = (yytext[yyleng - 1] == '\n');
			
					YYMSG_UNMATCHED[28] = yycchar__;
					yyecode__ = YYE_UNMATCHED;
					if(yyerror)
						yyerror(YYMSG_UNMATCHED, lexer, dtbl, grammar, ptbl, dmap, gsetup);
				
				break;
				}
			}
				if(yylex_is_running__()) {

					yylast_at_bol__ = yyat_bol__;

					if(yyat_bol__) {
						yylstate__ = yydsc[yystart__];
					}
					else {
						yylstate__ = yydsc[yystart__ + 1];
					}

					yylrule__ = LEX_ERROR_RULE;

					if( ! yymore_flag__) {
						yyaccleng__ = 0;
						yylaleng = 0;
						yyleng = 0;
						yytext[yylaleng] = '\0';
					}
					else {
						yymore_flag__ = false;
					}
				}
			}
		}

		return (yyecode__ == YYE_EOS)? 0 : yyecode__;
	}

	int yyparse__(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {

		if( ! yylexer) {
			return YYE_ABORT;
		}

		yyecode__ = YYE_ALIVE;
		sstack_t<xstype_t> yys_sv__;
		xstype_t yyval;

		sstack_t<xltype_t> yys_loc__;

		xltype_t yyloc;
		sstack_t<int> yys_stt__;
		sstack_t<int> yys_symb__;

		int yyrplen__;
		bool yyreducing__;

		int yypstate__ = PARSE_START_STATE;
		int yyprule__ = PERROR_RULE;
		int yysidx__ = PARSE_UNDEFSYMB_INDEX;
		int yytok__ = PARSE_UNDEFSYMB_ID;
		
#line 201 "meta/ulyac.upg"

	string strMsg;
	
	int s_nCurAssoc = ASSOC_UNKNOWN;
	int s_nCurPrec = DEFAULT_PREC;
	int s_nCounter = DEFAULT_PREC + 1;
	int s_nCurSVTID = DEFAULT_SVT_ID;

	s2i_map_t s_sname2Idx;
	vstr_t s_vstrSName;
	vint_t s_vnToken;
	string s_strStartSymbol;
	
	int s_nCurLeftSymbol = INVALID_INDEX;

#line 4133 "gcode/ulyac.cpp"


		yyltok = PARSE_UNDEFSYMB_ID;
		yyerr_flag__ = false;


		yys_stt__.push(yypstate__);

		while( ! yys_stt__.empty() && yyparse_is_running__(yypstate__)) {
			yyprule__ = yyget_defrule(yypstate__);
			if(is_valid_prule__(yyprule__)) {
				yyreducing__ = true;
			}
			else {
				if(PARSE_UNDEFSYMB_ID == yytok__) {
					if(PARSE_UNDEFSYMB_ID == yyltok) {
						yytok__ = (yylexer)(lexer, dtbl, grammar, ptbl, dmap, gsetup);
					}
					else  {
						yytok__ = yyltok;
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yysidx__ = (yytok__ < 0 || yytok__ >= PARSE_TOKENMAP_SIZE) ? PARSE_UNDEFSYMB_INDEX
						: yyptmap[yytok__];
				}


				yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);

				if(is_valid_pstate__(yypstate__)) {


					yys_symb__.push(yysidx__);
					yys_stt__.push(yypstate__);
					yys_sv__.push(yylval);

					yys_loc__.push(yylloc);
 
					yytok__ = PARSE_UNDEFSYMB_ID;
					yyreducing__ = false;
				}
				else {
					yyprule__ = yyget_prule__(yypstate__);
					yyreducing__ = true;
				}
			}

			if(yyreducing__) {
				switch(yyprule__) {
				
	case 0:
	{
#line 1828 "meta/ulyac.upg"

#line 4188 "gcode/ulyac.cpp"

	}
	break;
	
	case 2:
	{
#line 1829 "meta/ulyac.upg"

			if(_GETERR() >= ERRID_BASE) {
				YYABORT();
			}
			else {
			
				grammar.setTypeBase();
				for(s2i_cit_t cit = s_sname2Idx.begin();
					cit != s_sname2Idx.end(); ++cit) {
				
					grammar.addType(cit->first, cit->second);
				}
				grammar.setStartSymbol(s_strStartSymbol);
				s_sname2Idx.clear();
				s_nCounter = 0;
			}
		
#line 4213 "gcode/ulyac.cpp"

	}
	break;
	
	case 3:
	{
#line 1847 "meta/ulyac.upg"

			if(_GETERR() >= ERRID_BASE) {
				YYABORT();
			}
		
#line 4226 "gcode/ulyac.cpp"

	}
	break;
	
	case 4:
	{
#line 1853 "meta/ulyac.upg"


			if(_GETERR() >= ERRID_BASE) {
				YYABORT();
			}
		
#line 4240 "gcode/ulyac.cpp"

	}
	break;
	
	case 1:
	{
#line 1859 "meta/ulyac.upg"

			if(s_vstrSName.size() > 0) {
				grammar.addTokens(s_vstrSName, s_vnToken);
			}
			
#ifdef UPGEN_TEST_VERSION
			cerr << "Before grammar adjusting" << endl;
			cerr << grammar << endl;
#endif
			grammar.adjust(ptbl, gsetup);
			if(grammar.isValid()) {

				grammar.updateTID();
				if( ! grammar.initDstrct(gsetup)) {
					
					YYABORT();
				}
				else {
					YYACCEPT();
				}
			}
			else {
				YYACCEPT();
			}
		
#line 4273 "gcode/ulyac.cpp"

	}
	break;
	
	case 5:
	{
#line 1885 "meta/ulyac.upg"

#line 4282 "gcode/ulyac.cpp"

	}
	break;
	
	case 6:
	{
#line 1885 "meta/ulyac.upg"

#line 4291 "gcode/ulyac.cpp"

	}
	break;
	
	case 7:
	{
#line 1888 "meta/ulyac.upg"

			grammar.reset();
		
#line 4302 "gcode/ulyac.cpp"

	}
	break;
	
	case 8:
	{
#line 1892 "meta/ulyac.upg"

#line 4311 "gcode/ulyac.cpp"

	}
	break;
	
	case 9:
	{
#line 1893 "meta/ulyac.upg"

#line 4320 "gcode/ulyac.cpp"

	}
	break;
	
	case 10:
	{
#line 1896 "meta/ulyac.upg"

#line 4329 "gcode/ulyac.cpp"

	}
	break;
	
	case 11:
	{
#line 1897 "meta/ulyac.upg"

#line 4338 "gcode/ulyac.cpp"

	}
	break;
	
	case 12:
	{
#line 1898 "meta/ulyac.upg"

#line 4347 "gcode/ulyac.cpp"

	}
	break;
	
	case 13:
	{
#line 1899 "meta/ulyac.upg"

#line 4356 "gcode/ulyac.cpp"

	}
	break;
	
	case 14:
	{
#line 1900 "meta/ulyac.upg"

#line 4365 "gcode/ulyac.cpp"

	}
	break;
	
	case 15:
	{
#line 1901 "meta/ulyac.upg"

				
				if(!lexer.addXSC((yys_sv__[0].m_pchVal))) {
				
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: start-condition `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' duplicated and discarded.";
					_WARNING(strMsg);
				}
				delete[] (yys_sv__[0].m_pchVal);
			
#line 4387 "gcode/ulyac.cpp"

	}
	break;
	
	case 16:
	{
#line 1915 "meta/ulyac.upg"

				
				if(!lexer.addISC((yys_sv__[0].m_pchVal)))  {
				
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: start-condition `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' duplicated and discarded.";
					_WARNING(strMsg);
				}
				delete[] (yys_sv__[0].m_pchVal);
			
#line 4409 "gcode/ulyac.cpp"

	}
	break;
	
	case 17:
	{
#line 1929 "meta/ulyac.upg"

				if(s_strStartSymbol.empty()) {
					s_strStartSymbol = (yys_sv__[0].m_pchVal);
					s_sname2Idx.insert(s2i_pair_t(s_strStartSymbol, INVALID_INDEX));	
				}
				else {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: start symbol is already set as `";
					strMsg += s_strStartSymbol;
					strMsg += "\', this setting discarded.";
					_WARNING(strMsg);
				}
				delete[] (yys_sv__[0].m_pchVal);
			
#line 4433 "gcode/ulyac.cpp"

	}
	break;
	
	case 18:
	{
#line 1946 "meta/ulyac.upg"

#line 4442 "gcode/ulyac.cpp"

	}
	break;
	
	case 19:
	{
#line 1947 "meta/ulyac.upg"


			strMsg = "token name expected.";
			_ERROR(strMsg, ESYN(1));
			
			yyerrok();
		
#line 4457 "gcode/ulyac.cpp"

	}
	break;
	
	case 20:
	{
#line 1954 "meta/ulyac.upg"


			strMsg = "semantic value type or token name expected.";
			_ERROR(strMsg, ESYN(1));
			
			yyerrok();
		
#line 4472 "gcode/ulyac.cpp"

	}
	break;
	
	case 21:
	{
#line 1962 "meta/ulyac.upg"

			s_nCurAssoc = ASSOC_UNKNOWN;
			s_nCurPrec = DEFAULT_PREC;
			s_nCurSVTID = DEFAULT_SVT_ID;
		
#line 4485 "gcode/ulyac.cpp"

	}
	break;
	
	case 22:
	{
#line 1967 "meta/ulyac.upg"

			s_nCurAssoc = ASSOC_LEFT;
			s_nCurPrec = s_nCounter;
			s_nCurSVTID = DEFAULT_SVT_ID;
			++s_nCounter;
		
#line 4499 "gcode/ulyac.cpp"

	}
	break;
	
	case 23:
	{
#line 1973 "meta/ulyac.upg"

			s_nCurAssoc = ASSOC_RIGHT;
			s_nCurPrec = s_nCounter;
			s_nCurSVTID = DEFAULT_SVT_ID;
			++s_nCounter;
		
#line 4513 "gcode/ulyac.cpp"

	}
	break;
	
	case 24:
	{
#line 1979 "meta/ulyac.upg"

			s_nCurAssoc = ASSOC_NO;
			s_nCurPrec = DEFAULT_PREC;
			s_nCurSVTID = DEFAULT_SVT_ID;
		
#line 4526 "gcode/ulyac.cpp"

	}
	break;
	
	case 26:
	{
#line 1985 "meta/ulyac.upg"

			s_nCurSVTID = grammar.addSVT((yys_sv__[0].m_pchVal)).first;
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4539 "gcode/ulyac.cpp"

	}
	break;
	
	case 25:
	{
#line 1985 "meta/ulyac.upg"

#line 4548 "gcode/ulyac.cpp"

	}
	break;
	
	case 27:
	{
#line 1991 "meta/ulyac.upg"

#line 4557 "gcode/ulyac.cpp"

	}
	break;
	
	case 28:
	{
#line 1993 "meta/ulyac.upg"

#line 4566 "gcode/ulyac.cpp"

	}
	break;
	
	case 29:
	{
#line 1994 "meta/ulyac.upg"

#line 4575 "gcode/ulyac.cpp"

	}
	break;
	
	case 30:
	{
#line 1996 "meta/ulyac.upg"

			if(s_sname2Idx.find((yys_sv__[0].m_pchVal)) != s_sname2Idx.end()) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: identifier `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' already be name of a symbol, this definition discarded.";
				_WARNING(strMsg);			
			}
			else {
				i2b_pair_t pairRet = grammar.addToken((yys_sv__[0].m_pchVal), s_nCurSVTID, s_nCurPrec, s_nCurAssoc);
				if(!pairRet.second) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: identifier `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' already be name of a token, this definition discarded.";
					_WARNING(strMsg);
				}
			}
			delete[] (yys_sv__[0].m_pchVal);		
		
#line 4607 "gcode/ulyac.cpp"

	}
	break;
	
	case 31:
	{
#line 2020 "meta/ulyac.upg"

			i2b_pair_t pairRet = grammar.addToken(strhelper_t::quotedChar((yys_sv__[0].m_cVal)), (int)(yys_sv__[0].m_cVal),
				s_nCurSVTID, s_nCurPrec, s_nCurAssoc, false);
			if(!pairRet.second) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: character `";
				strMsg += (yys_sv__[0].m_cVal);
				strMsg += "\' already be name of a token, this definition discarded.";
				_WARNING(strMsg);
			}
		
#line 4628 "gcode/ulyac.cpp"

	}
	break;
	
	case 32:
	{
#line 2033 "meta/ulyac.upg"

            std::string tokenText((yys_sv__[0].m_pchVal));
            delete[] (yys_sv__[0].m_pchVal);

            auto pairRet = grammar.addToken(tokenText, s_nCurSVTID, s_nCurPrec, s_nCurAssoc);
            if(!pairRet.second) {
                strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
                strMsg += ':';
                strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
                strMsg += "; description: character `";
                strMsg += tokenText;
                strMsg += "\' already be name of a token, this definition discarded.";
                _WARNING(strMsg);
            }
        
#line 4651 "gcode/ulyac.cpp"

	}
	break;
	
	case 34:
	{
#line 2050 "meta/ulyac.upg"

			s_nCurSVTID = grammar.addSVT((yys_sv__[0].m_pchVal)).first;
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4663 "gcode/ulyac.cpp"

	}
	break;
	
	case 33:
	{
#line 2050 "meta/ulyac.upg"

#line 4672 "gcode/ulyac.cpp"

	}
	break;
	
	case 35:
	{
#line 2054 "meta/ulyac.upg"

		
			strMsg = "semantic value type expected.";
			
			_ERROR(strMsg, ESYN(1));
			yyerrok();		
		
#line 4687 "gcode/ulyac.cpp"

	}
	break;
	
	case 36:
	{
#line 2061 "meta/ulyac.upg"

		
			strMsg = "semantic value type or type name expected.";
			
			_ERROR(strMsg, ESYN(1));
			yyerrok();		
		
#line 4702 "gcode/ulyac.cpp"

	}
	break;
	
	case 37:
	{
#line 2070 "meta/ulyac.upg"

			if(grammar.isToken((yys_sv__[0].m_pchVal))) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: identifier `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' is already name of a token, this definition discarded.";
				_WARNING(strMsg);
			}
			else {
				if(s_strStartSymbol == string((yys_sv__[0].m_pchVal))) {
					s2i_it_t it = s_sname2Idx.find(s_strStartSymbol);
					assert(it != s_sname2Idx.end());
					if(it->second == INVALID_INDEX) {
						it->second = s_nCurSVTID;
					}
					else {
						strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
						strMsg += ':';
						strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
						strMsg += "; description: identifier `";
						strMsg += (yys_sv__[0].m_pchVal);
						strMsg += "\' is already name of a type, this definition discarded.";
						_WARNING(strMsg);					
					}
				}
				else if( ! s_sname2Idx.insert(s2i_pair_t(string((yys_sv__[0].m_pchVal)), s_nCurSVTID)).second) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: identifier `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' is already name of a type, this definition discarded.";
					_WARNING(strMsg);
				}
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4749 "gcode/ulyac.cpp"

	}
	break;
	
	case 38:
	{
#line 2109 "meta/ulyac.upg"

			if(grammar.isToken((yys_sv__[0].m_pchVal))) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: identifier `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' is already name of a token, this definition discarded.";
				_WARNING(strMsg);
			}
			else {
				if(s_strStartSymbol == string((yys_sv__[0].m_pchVal))) {
					s2i_it_t it = s_sname2Idx.find(s_strStartSymbol);
					assert(it != s_sname2Idx.end());
					if(it->second == INVALID_INDEX) {
						it->second = s_nCurSVTID;
					}
					else {
						strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
						strMsg += ':';
						strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
						strMsg += "; description: identifier `";
						strMsg += (yys_sv__[0].m_pchVal);
						strMsg += "\' is already name of a type, this definition discarded.";
						_WARNING(strMsg);					
					}
				}
				else if( !s_sname2Idx.insert(s2i_pair_t(string((yys_sv__[0].m_pchVal)), s_nCurSVTID)).second) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: identifier `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' is already name of a type, this definition discarded.";
					_WARNING(strMsg);			
				}
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4796 "gcode/ulyac.cpp"

	}
	break;
	
	case 39:
	{
#line 2150 "meta/ulyac.upg"

		if( ! grammar.setUntagDstrct((yys_sv__[3].m_pDstrct))) {
			delete (yys_sv__[3].m_pDstrct);
		}
	
#line 4809 "gcode/ulyac.cpp"

	}
	break;
	
	case 40:
	{
#line 2155 "meta/ulyac.upg"

		if( ! grammar.setOtherDstrct((yys_sv__[4].m_pDstrct))) {
			delete (yys_sv__[4].m_pDstrct);
		}
	
#line 4822 "gcode/ulyac.cpp"

	}
	break;
	
	case 41:
	{
#line 2160 "meta/ulyac.upg"

	
		if( ! grammar.addDstrctBySVT((yys_sv__[4].m_pDstrct), (yys_sv__[2].m_pchVal))) {
			delete (yys_sv__[4].m_pDstrct);
		}
		else {
		
			for(int i = 0; i < (yys_sv__[4].m_pDstrct)->getPHCount(); ++i) {
				(yys_sv__[4].m_pDstrct)->updateMacroPH(i, (yys_sv__[2].m_pchVal));
			}
		}
		delete[] (yys_sv__[2].m_pchVal);
	
#line 4843 "gcode/ulyac.cpp"

	}
	break;
	
	case 42:
	{
#line 2173 "meta/ulyac.upg"

		assert((yys_sv__[1].m_pvstrSymbs));
		if( ! grammar.addDstrctBySymbs((yys_sv__[2].m_pDstrct), *(yys_sv__[1].m_pvstrSymbs))) {
			delete (yys_sv__[2].m_pDstrct);
		}

		delete (yys_sv__[1].m_pvstrSymbs);
	
#line 4859 "gcode/ulyac.cpp"

	}
	break;
	
	case 43:
	{
#line 2181 "meta/ulyac.upg"

		
		strMsg = "semantic value type or symbol name expected.";
		_ERROR(strMsg, ESYN(1));
		
		delete (yys_sv__[2].m_pDstrct);
		
		yyerrok();
	
#line 4876 "gcode/ulyac.cpp"

	}
	break;
	
	case 44:
	{
#line 2190 "meta/ulyac.upg"

	
		strMsg = "semantic value type or symbol name expected.";
		_ERROR(strMsg, ESYN(1));
		
		delete (yys_sv__[3].m_pDstrct);
		delete (yys_sv__[2].m_pvstrSymbs);
		yyerrok();	
	
#line 4893 "gcode/ulyac.cpp"

	}
	break;
	
	case 45:
	{
#line 2201 "meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = (yys_sv__[1].m_pvstrSymbs);
		(yyval.m_pvstrSymbs)->push_back((yys_sv__[0].m_pchVal));
		delete[] (yys_sv__[0].m_pchVal);
	
#line 4906 "gcode/ulyac.cpp"

	}
	break;
	
	case 46:
	{
#line 2206 "meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = (yys_sv__[1].m_pvstrSymbs);
		(yyval.m_pvstrSymbs)->push_back(strhelper_t::quotedChar((yys_sv__[0].m_cVal)));
	
#line 4918 "gcode/ulyac.cpp"

	}
	break;
	
	case 47:
	{
#line 2210 "meta/ulyac.upg"

        (yyval.m_pvstrSymbs) = (yys_sv__[1].m_pvstrSymbs);
        (yyval.m_pvstrSymbs)->push_back((yys_sv__[0].m_pchVal));
        delete[] (yys_sv__[0].m_pchVal);
    
#line 4931 "gcode/ulyac.cpp"

	}
	break;
	
	case 48:
	{
#line 2215 "meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = new vstr_t;
		(yyval.m_pvstrSymbs)->push_back((yys_sv__[0].m_pchVal));
		
		delete[] (yys_sv__[0].m_pchVal);
	
#line 4945 "gcode/ulyac.cpp"

	}
	break;
	
	case 49:
	{
#line 2221 "meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = new vstr_t;
		(yyval.m_pvstrSymbs)->push_back(strhelper_t::quotedChar((yys_sv__[0].m_cVal)));
	
#line 4957 "gcode/ulyac.cpp"

	}
	break;
	
	case 50:
	{
#line 2225 "meta/ulyac.upg"

        (yyval.m_pvstrSymbs) = new vstr_t;
        (yyval.m_pvstrSymbs)->push_back((yys_sv__[0].m_pchVal));

        delete[] (yys_sv__[0].m_pchVal);
    
#line 4971 "gcode/ulyac.cpp"

	}
	break;
	
	case 51:
	{
#line 2233 "meta/ulyac.upg"

			
			if(! dmap.insert((yys_sv__[2].m_pchVal), (yys_sv__[0].m_pchVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}
			
			delete[] (yys_sv__[2].m_pchVal);
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4995 "gcode/ulyac.cpp"

	}
	break;
	
	case 52:
	{
#line 2249 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[2].m_pchVal), (yys_sv__[0].m_nVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[2].m_pchVal);
		
#line 5018 "gcode/ulyac.cpp"

	}
	break;
	
	case 53:
	{
#line 2264 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[2].m_pchVal), false)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[2].m_pchVal);
		
#line 5041 "gcode/ulyac.cpp"

	}
	break;
	
	case 54:
	{
#line 2279 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[2].m_pchVal), true)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[2].m_pchVal);
		
#line 5064 "gcode/ulyac.cpp"

	}
	break;
	
	case 55:
	{
#line 2294 "meta/ulyac.upg"

			
			if( ! dmap.insert((yys_sv__[1].m_pchVal), (yys_sv__[0].m_pchVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
			delete[] (yys_sv__[0].m_pchVal);
		
#line 5088 "gcode/ulyac.cpp"

	}
	break;
	
	case 56:
	{
#line 2310 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[1].m_pchVal), (yys_sv__[0].m_nVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
		
#line 5111 "gcode/ulyac.cpp"

	}
	break;
	
	case 57:
	{
#line 2325 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[1].m_pchVal), false)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
		
#line 5134 "gcode/ulyac.cpp"

	}
	break;
	
	case 58:
	{
#line 2340 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[1].m_pchVal), true)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
		
#line 5157 "gcode/ulyac.cpp"

	}
	break;
	
	case 59:
	{
#line 2355 "meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[0].m_pchVal), true)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete (yys_sv__[0].m_pchVal);
		
#line 5180 "gcode/ulyac.cpp"

	}
	break;
	
	case 60:
	{
#line 2372 "meta/ulyac.upg"


			if(!lexer.addMacro((yys_sv__[2].m_pchVal), (yys_sv__[1].m_pRENode))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: macro is duplicated and ignored `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\'";
				
				_ERROR(strMsg, ESYN(1));
			}
				
			delete[] (yys_sv__[2].m_pchVal);
		
#line 5204 "gcode/ulyac.cpp"

	}
	break;
	
	case 61:
	{
#line 2388 "meta/ulyac.upg"


			lexer.addMacro((yys_sv__[3].m_pchVal), (yys_sv__[2].m_pRENode));
			
			strMsg = "invalid symbol.";
			
			_ERROR(strMsg, ESYN(1));

			delete[] (yys_sv__[3].m_pchVal);
			
			yyerrok();
		
#line 5224 "gcode/ulyac.cpp"

	}
	break;
	
	case 62:
	{
#line 2400 "meta/ulyac.upg"

			
			strMsg = "invalid symbol.";
			
			_ERROR(strMsg, ESYN(1));

			delete[] (yys_sv__[2].m_pchVal);
			yyerrok();
		
#line 5241 "gcode/ulyac.cpp"

	}
	break;
	
	case 63:
	{
#line 2411 "meta/ulyac.upg"

#line 5250 "gcode/ulyac.cpp"

	}
	break;
	
	case 64:
	{
#line 2412 "meta/ulyac.upg"

#line 5259 "gcode/ulyac.cpp"

	}
	break;
	
	case 65:
	{
#line 2415 "meta/ulyac.upg"

		
			assert((yys_sv__[1].m_prTrees));
			assert((yys_sv__[0].m_nVal) >= 0);
			
			for(unsigned int i = 0; i < (yys_sv__[1].m_prTrees)->size(); ++i) {
				
				lexer.attachAction((*(yys_sv__[1].m_prTrees))[i], (yys_sv__[0].m_nVal));
				dtbl.mapRule2Action(lexer.tree2Rule((*(yys_sv__[1].m_prTrees))[i]->getID()), (yys_sv__[0].m_nVal));
			}
			
			delete (yys_sv__[1].m_prTrees);
		
#line 5280 "gcode/ulyac.cpp"

	}
	break;
	
	case 66:
	{
#line 2428 "meta/ulyac.upg"

		
			assert((yys_sv__[2].m_prTrees));
			
			strMsg = "invalid symbol.";
			
			_ERROR(strMsg, ESYN(2));
			
			delete (yys_sv__[2].m_prTrees);
			
			yyerrok();
		
#line 5300 "gcode/ulyac.cpp"

	}
	break;
	
	case 67:
	{
#line 2442 "meta/ulyac.upg"


			assert((yys_sv__[0].m_pRETree));
			(yyval.m_prTrees) = new rtpool_t;
			(yyval.m_prTrees)->push_back((yys_sv__[0].m_pRETree));
		
#line 5314 "gcode/ulyac.cpp"

	}
	break;
	
	case 68:
	{
#line 2448 "meta/ulyac.upg"

			
			assert((yys_sv__[2].m_prTrees) && (yys_sv__[0].m_pRETree));
			(yyval.m_prTrees) = (yys_sv__[2].m_prTrees);
			(yyval.m_prTrees)->push_back((yys_sv__[0].m_pRETree));
		
#line 5328 "gcode/ulyac.cpp"

	}
	break;
	
	case 69:
	{
#line 2456 "meta/ulyac.upg"


			assert((yys_sv__[0].m_pRETree));
			
			if( ! (yys_sv__[1].m_pIndices)) {
			
				lexer.addSCTree((yys_sv__[0].m_pRETree)->getID());
			}
			else {
				
				for(unsigned int i = 0; i < (yys_sv__[1].m_pIndices)->size(); ++i) {

					lexer.addSCTree((*(yys_sv__[1].m_pIndices))[i], (yys_sv__[0].m_pRETree)->getID());
				}
				
				delete (yys_sv__[1].m_pIndices);
			}

			(yyval.m_pRETree) = (yys_sv__[0].m_pRETree);
			
			dtbl.mapRule2Line(lexer.tree2Rule((yys_sv__[0].m_pRETree)->getID()), (yys_loc__[0]).firstLine); 
		
#line 5358 "gcode/ulyac.cpp"

	}
	break;
	
	case 70:
	{
#line 2480 "meta/ulyac.upg"


			(yyval.m_nVal) = (yys_sv__[0].m_nVal);
		
#line 5370 "gcode/ulyac.cpp"

	}
	break;
	
	case 71:
	{
#line 2484 "meta/ulyac.upg"

		
			assert((yys_sv__[1].m_nVal) == (yys_sv__[0].m_nVal));
			(yyval.m_nVal) = (yys_sv__[1].m_nVal);
		
#line 5383 "gcode/ulyac.cpp"

	}
	break;
	
	case 72:
	{
#line 2491 "meta/ulyac.upg"

			
			(yyval.m_pIndices) = (yys_sv__[1].m_pIndices);
		
#line 5395 "gcode/ulyac.cpp"

	}
	break;
	
	case 73:
	{
#line 2495 "meta/ulyac.upg"

		
			(yyval.m_pIndices) = nullptr;
		
#line 5407 "gcode/ulyac.cpp"

	}
	break;
	
	case 74:
	{
#line 2499 "meta/ulyac.upg"

		
			(yyval.m_pIndices) = new vint_t;
			(yyval.m_pIndices)->push_back(0);
		
#line 5420 "gcode/ulyac.cpp"

	}
	break;
	
	case 75:
	{
#line 2506 "meta/ulyac.upg"


			(yyval.m_pIndices) = new vint_t;
			(yyval.m_pIndices)->push_back((yys_sv__[0].m_nVal));
		
#line 5433 "gcode/ulyac.cpp"

	}
	break;
	
	case 76:
	{
#line 2511 "meta/ulyac.upg"

		
			assert((yys_sv__[2].m_pIndices));
			(yys_sv__[2].m_pIndices)->push_back((yys_sv__[0].m_nVal));
			(yyval.m_pIndices) = (yys_sv__[2].m_pIndices);
		
#line 5447 "gcode/ulyac.cpp"

	}
	break;
	
	case 77:
	{
#line 2519 "meta/ulyac.upg"


			(yyval.m_nVal) = lexer.getSCIdx((yys_sv__[0].m_pchVal));
			if(_EQ(INVALID_INDEX, (yyval.m_nVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: invalid start condition `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\'";
				
				(yyval.m_nVal) = 0;
				_ERROR(strMsg, ESYN(2));
			}
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 5473 "gcode/ulyac.cpp"

	}
	break;
	
	case 78:
	{
#line 2537 "meta/ulyac.upg"

		
			(yyval.m_nVal) = 0;
		
#line 5485 "gcode/ulyac.cpp"

	}
	break;
	
	case 79:
	{
#line 2543 "meta/ulyac.upg"


			(yys_sv__[0].m_pRENode) = lexer.addConcatNode((yys_sv__[0].m_pRENode), lexer.addEorNode(false));
			(yyval.m_pRETree) = lexer.addTree(dtbl.addRule(), (yys_sv__[0].m_pRENode), false);
			lexer.setLookaheadFlag(false);
		
#line 5499 "gcode/ulyac.cpp"

	}
	break;
	
	case 80:
	{
#line 2549 "meta/ulyac.upg"

		
			(yys_sv__[0].m_pRENode) = lexer.addConcatNode((yys_sv__[0].m_pRENode), lexer.addEorNode(false));
			(yyval.m_pRETree) = lexer.addTree(dtbl.addRule(), (yys_sv__[0].m_pRENode), true);
			lexer.setLookaheadFlag(false);
		
#line 5513 "gcode/ulyac.cpp"

	}
	break;
	
	case 81:
	{
#line 2555 "meta/ulyac.upg"

		
			(yyval.m_pRETree) = lexer.addTree(dtbl.addRule(), lexer.addEofNode(), false, true);
		
#line 5525 "gcode/ulyac.cpp"

	}
	break;
	
	case 82:
	{
#line 2561 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5537 "gcode/ulyac.cpp"

	}
	break;
	
	case 83:
	{
#line 2565 "meta/ulyac.upg"

			lexer.setLookaheadFlag(true);
			(yyval.m_pRENode) = lexer.addLeafNode(new charset_t('\n'), false);
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yyval.m_pRENode));
		
#line 5550 "gcode/ulyac.cpp"

	}
	break;
	
	case 84:
	{
#line 2570 "meta/ulyac.upg"
		
			
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5562 "gcode/ulyac.cpp"

	}
	break;
	
	case 85:
	{
#line 2576 "meta/ulyac.upg"

		
			lexer.setLookaheadFlag(true);
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
		
#line 5575 "gcode/ulyac.cpp"

	}
	break;
	
	case 86:
	{
#line 2583 "meta/ulyac.upg"


			(yyval.m_pRENode) = lexer.addUnionNode((yys_sv__[2].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5587 "gcode/ulyac.cpp"

	}
	break;
	
	case 87:
	{
#line 2587 "meta/ulyac.upg"

		
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
        
#line 5599 "gcode/ulyac.cpp"

	}
	break;
	
	case 88:
	{
#line 2593 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5611 "gcode/ulyac.cpp"

	}
	break;
	
	case 89:
	{
#line 2597 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5623 "gcode/ulyac.cpp"

	}
	break;
	
	case 90:
	{
#line 2603 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nLower > 1; --((yys_sv__[0].m_nRange).m_nLower)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}			
		
#line 5640 "gcode/ulyac.cpp"

	}
	break;
	
	case 91:
	{
#line 2612 "meta/ulyac.upg"

		
			(yys_sv__[1].m_pRENode)->setNullable(true);
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nUpper > 1; --((yys_sv__[0].m_nRange).m_nUpper)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}
		
#line 5658 "gcode/ulyac.cpp"

	}
	break;
	
	case 92:
	{
#line 2622 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nLower > 1; --((yys_sv__[0].m_nRange).m_nLower)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}
			
			(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.addStarNode(lexer.copySubtree((yys_sv__[1].m_pRENode))));
		
#line 5677 "gcode/ulyac.cpp"

	}
	break;
	
	case 93:
	{
#line 2633 "meta/ulyac.upg"

		
			if((yys_sv__[0].m_nRange).m_nLower > (yys_sv__[0].m_nRange).m_nUpper || _EQ(0, (yys_sv__[0].m_nRange).m_nUpper)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: invalid range `{";
				strMsg += strhelper_t::fromInt((yys_sv__[0].m_nRange).m_nLower);
				strMsg += ",";
				strMsg += strhelper_t::fromInt((yys_sv__[0].m_nRange).m_nUpper);
				strMsg += "}\'";
				
				(yys_sv__[0].m_nRange).m_nLower = (yys_sv__[0].m_nRange).m_nUpper = 1;
				_ERROR(strMsg, ESYN(3));
			}
			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			int i = 1;
			
			if((yys_sv__[0].m_nRange).m_nLower <= 0) {
				(yys_sv__[1].m_pRENode)->setNullable(true);
			}
			else {
				for(; i < (yys_sv__[0].m_nRange).m_nLower; ++i) {
				
					(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
				}
			}
			
			for(; i < (yys_sv__[0].m_nRange).m_nUpper; ++i) {
			
				renode_t *pNode = lexer.copySubtree((yys_sv__[1].m_pRENode));
				pNode->setNullable(true);
				
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), pNode);
			}
		
#line 5723 "gcode/ulyac.cpp"

	}
	break;
	
	case 94:
	{
#line 2671 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = lexer.addStarNode((yys_sv__[1].m_pRENode));
		
#line 5735 "gcode/ulyac.cpp"

	}
	break;
	
	case 95:
	{
#line 2675 "meta/ulyac.upg"

			
			renode_t *pNode = lexer.copySubtree((yys_sv__[1].m_pRENode));
			
			assert(pNode);
			
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), lexer.addStarNode(pNode));			
		
#line 5751 "gcode/ulyac.cpp"

	}
	break;
	
	case 96:
	{
#line 2683 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			(yys_sv__[1].m_pRENode)->setNullable(true);
		
#line 5764 "gcode/ulyac.cpp"

	}
	break;
	
	case 97:
	{
#line 2688 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5776 "gcode/ulyac.cpp"

	}
	break;
	
	case 98:
	{
#line 2694 "meta/ulyac.upg"


			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
		
#line 5788 "gcode/ulyac.cpp"

	}
	break;
	
	case 99:
	{
#line 2698 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5800 "gcode/ulyac.cpp"

	}
	break;
	
	case 100:
	{
#line 2704 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5812 "gcode/ulyac.cpp"

	}
	break;
	
	case 101:
	{
#line 2708 "meta/ulyac.upg"
		
			
			(yyval.m_pRENode) = lexer.copyMacrotree((yys_sv__[0].m_pchVal));
			if(_EQ(nullptr, (yyval.m_pRENode))) {
				
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: undefined regular expression macro `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\'";	
				
				(yyval.m_pRENode) = lexer.addLeafNode('a');			
				_ERROR(strMsg, ESYN(4));
			}
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 5838 "gcode/ulyac.cpp"

	}
	break;
	
	case 102:
	{
#line 2727 "meta/ulyac.upg"


			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5850 "gcode/ulyac.cpp"

	}
	break;
	
	case 103:
	{
#line 2731 "meta/ulyac.upg"

		
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5862 "gcode/ulyac.cpp"

	}
	break;
	
	case 104:
	{
#line 2736 "meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nLower > 1; --((yys_sv__[0].m_nRange).m_nLower)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}			
		
#line 5879 "gcode/ulyac.cpp"

	}
	break;
	
	case 105:
	{
#line 2745 "meta/ulyac.upg"


			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
		
#line 5891 "gcode/ulyac.cpp"

	}
	break;
	
	case 106:
	{
#line 2749 "meta/ulyac.upg"

		
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5903 "gcode/ulyac.cpp"

	}
	break;
	
	case 107:
	{
#line 2755 "meta/ulyac.upg"

			(yyval.m_pRENode) = lexer.addLeafNode((yys_sv__[0].m_pCS));
		
#line 5914 "gcode/ulyac.cpp"

	}
	break;
	
	case 108:
	{
#line 2758 "meta/ulyac.upg"

			charset_t *pcs = new charset_t((yys_sv__[0].m_cVal));	
			if( ! gsetup.m_bCaseSensitive) {
				if((yys_sv__[0].m_cVal) >= 65 && (yys_sv__[0].m_cVal) <= 90) {
					pcs->set((yys_sv__[0].m_cVal) + 32);
				}
				else if((yys_sv__[0].m_cVal) >= 97 && (yys_sv__[0].m_cVal) <= 122) {
					pcs->set((yys_sv__[0].m_cVal) - 32);
				}
			}
			(yyval.m_pRENode) = lexer.addLeafNode(pcs);
		
#line 5934 "gcode/ulyac.cpp"

	}
	break;
	
	case 109:
	{
#line 2770 "meta/ulyac.upg"

			if( ! gsetup.m_bCaseSensitive && (charset_t::LOWER == (yys_sv__[0].m_nPosix) || charset_t::UPPER == (yys_sv__[0].m_nPosix))) {
			
				(yys_sv__[0].m_nPosix) = charset_t::ALPHA;
			}
			(yyval.m_pRENode) = lexer.addLeafNode((yys_sv__[0].m_nPosix));
		
#line 5949 "gcode/ulyac.cpp"

	}
	break;
	
	case 110:
	{
#line 2777 "meta/ulyac.upg"

		
			string str;
			
			bool bret =
				strhelper_t::ustr2Str((yys_sv__[0].m_pchVal), str);
			assert(bret);
			
			charset_t *pcs = nullptr;
			if(str.size() > 0) {
				
				pcs = new charset_t(str[0]);
				if( ! gsetup.m_bCaseSensitive) {
					if(str[0] >= 65 && str[0] <= 90) {
						pcs->set(str[0] + 32);
					}
					else if(str[0] >= 97 && str[0] <= 122) {
						pcs->set(str[0] - 32);
					}
				}
				(yyval.m_pRENode) = lexer.addLeafNode(pcs);
			}
			
			for(unsigned int i = 1; i < str.size(); ++i) {
			
				pcs = new charset_t(str[i]);
				if( ! gsetup.m_bCaseSensitive) {
					if(str[i] >= 65 && str[i] <= 90) {
						pcs->set(str[i] + 32);
					}
					else if(str[i] >= 97 && str[i] <= 122) {
						pcs->set(str[i] - 32);
					}
				}
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.addLeafNode(pcs));
			}
			delete (yys_sv__[0].m_pchVal);
		
#line 5995 "gcode/ulyac.cpp"

	}
	break;
	
	case 111:
	{
#line 2815 "meta/ulyac.upg"

			
			const char cc[2] = {'\n', '\0'};
			(yyval.m_pRENode) = lexer.addLeafNode(cc, true);
		
#line 6008 "gcode/ulyac.cpp"

	}
	break;
	
	case 112:
	{
#line 2822 "meta/ulyac.upg"


			(yyval.m_pCS) = (yys_sv__[1].m_pCS);
		
#line 6020 "gcode/ulyac.cpp"

	}
	break;
	
	case 113:
	{
#line 2826 "meta/ulyac.upg"


			(yyval.m_pCS) = (yys_sv__[1].m_pCS);
			(yys_sv__[1].m_pCS)->flip();			
		
#line 6033 "gcode/ulyac.cpp"

	}
	break;
	
	case 114:
	{
#line 2833 "meta/ulyac.upg"

		
			(yyval.m_pCS) = (yys_sv__[0].m_pCS);
		
#line 6045 "gcode/ulyac.cpp"

	}
	break;
	
	case 115:
	{
#line 2837 "meta/ulyac.upg"

			
			*((yys_sv__[1].m_pCS)) |= *((yys_sv__[0].m_pCS));
			(yyval.m_pCS) = (yys_sv__[1].m_pCS);

			delete (yys_sv__[0].m_pCS);
		
#line 6060 "gcode/ulyac.cpp"

	}
	break;
	
	case 116:
	{
#line 2846 "meta/ulyac.upg"

			
			(yyval.m_pCS) = new charset_t('\n', true);			
		
#line 6072 "gcode/ulyac.cpp"

	}
	break;
	
	case 117:
	{
#line 2850 "meta/ulyac.upg"

		
			(yyval.m_pCS) = new charset_t((yys_sv__[0].m_cVal));
			
			if( ! gsetup.m_bCaseSensitive) {
				if((yys_sv__[0].m_cVal) >= 65 && (yys_sv__[0].m_cVal) <= 90) {
					(yyval.m_pCS)->set((yys_sv__[0].m_cVal) + 32);
				}
				else if((yys_sv__[0].m_cVal) >= 97 && (yys_sv__[0].m_cVal) <= 122) {
					(yyval.m_pCS)->set((yys_sv__[0].m_cVal) - 32);
				}
			}
		
#line 6093 "gcode/ulyac.cpp"

	}
	break;
	
	case 118:
	{
#line 2863 "meta/ulyac.upg"

		
			if((unsigned char)(yys_sv__[2].m_cVal) > (unsigned char)(yys_sv__[0].m_cVal)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: char range `";
				strMsg += (yys_sv__[2].m_cVal);
				strMsg += "-";
				strMsg += (yys_sv__[0].m_cVal);
				strMsg += "\' empty and ignored.";
				_ERROR(strMsg, ESYN(5));

				(yys_sv__[2].m_cVal) = (yys_sv__[0].m_cVal);
			}
			
			(yyval.m_pCS) = new charset_t((yys_sv__[2].m_cVal), (yys_sv__[0].m_cVal));
			if( ! gsetup.m_bCaseSensitive) {
				for(unsigned char c = (unsigned char)(yys_sv__[2].m_cVal); c <= 122 && c <= (unsigned char)(yys_sv__[0].m_cVal); ++c ) {
					
					if(c >= 65 && c <= 90) {
					
						(yyval.m_pCS)->set(c + 32);
					}
					else if(c >= 97 && c <= 122) {
					
						(yyval.m_pCS)->set(c - 32);
					}
				}
			} 
		
#line 6133 "gcode/ulyac.cpp"

	}
	break;
	
	case 119:
	{
#line 2895 "meta/ulyac.upg"

		
			if( ! gsetup.m_bCaseSensitive && (charset_t::LOWER == (yys_sv__[0].m_nPosix) || charset_t::UPPER == (yys_sv__[0].m_nPosix))) {
			
				(yys_sv__[0].m_nPosix) = charset_t::ALPHA;
			}
			(yyval.m_pCS) = new charset_t((yys_sv__[0].m_nPosix));
		
#line 6149 "gcode/ulyac.cpp"

	}
	break;
	
	case 120:
	{
#line 2905 "meta/ulyac.upg"

#line 6158 "gcode/ulyac.cpp"

	}
	break;
	
	case 121:
	{
#line 2906 "meta/ulyac.upg"

#line 6167 "gcode/ulyac.cpp"

	}
	break;
	
	case 122:
	{
#line 2908 "meta/ulyac.upg"

#line 6176 "gcode/ulyac.cpp"

	}
	break;
	
	case 123:
	{
#line 2909 "meta/ulyac.upg"

				strMsg = strhelper_t::fromInt((yys_loc__[0]).lastLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).lastColumn);
				strMsg += "; description: lack of `;\'.";
				_WARNING(strMsg);
		
#line 6191 "gcode/ulyac.cpp"

	}
	break;
	
	case 124:
	{
#line 2916 "meta/ulyac.upg"

				strMsg = "invalid syntactic rule.";
				_ERROR(strMsg, ESYN(5));
				yyerrok();
		
#line 6204 "gcode/ulyac.cpp"

	}
	break;
	
	case 125:
	{
#line 2922 "meta/ulyac.upg"

			
			if( grammar.isToken((yys_sv__[0].m_pchVal))) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: declaration of type `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' expected.";
				_ERROR(strMsg, ESYN(5));

				
				strMsg = grammar.getFakeSymbol();
				(yyval.m_nVal) = grammar.addType(strMsg, DEFAULT_SVT_ID).first;
			}
			else {
			
				(yyval.m_nVal) = grammar.getSymbolIndex((yys_sv__[0].m_pchVal));
				if(INVALID_INDEX == (yyval.m_nVal)) {
					(yyval.m_nVal) = grammar.addType((yys_sv__[0].m_pchVal), DEFAULT_SVT_ID).first;
					++s_nCounter;
				}
				else {
					(yyval.m_nVal) = grammar.getSymbolIndex((yys_sv__[0].m_pchVal));
				}
			}
				
			s_nCurLeftSymbol = (yyval.m_nVal);
			assert(s_nCurLeftSymbol != INVALID_INDEX);
			
			if(grammar.getRuleCount() == 0) {
				if(grammar.getStartSymbol() == INVALID_INDEX) {
					grammar.setStartSymbol(s_nCurLeftSymbol);
				}
				
				i2b_pair_t pairRet = grammar.addType(INTERNAL_ACCEPT_TYPE, DEFAULT_SVT_ID, false);
				++s_nCounter;
				assert(pairRet.second);
				grammar.setAcceptSymbol(pairRet.first);
				parser_ns::prod_t *pr = grammar.addEmptyRule(grammar.getAcceptSymbol());
				assert(pr);
				pr->addRight(grammar.getStartSymbol());
				pr->addRight(END_SYMBOL_INDEX);
				grammar.setAcceptRule(pr->getID());
				
				int nActID = ptbl.addEmptyAction((yys_loc__[0]).firstLine);
				ptbl.mapRule2Action(pr->getID(), nActID);			
				ptbl.mapRule2Line(pr->getID(), (yys_loc__[0]).firstLine);
			}
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 6264 "gcode/ulyac.cpp"

	}
	break;
	
	case 127:
	{
#line 2976 "meta/ulyac.upg"


			grammar.addEmptyRule(s_nCurLeftSymbol);
		
#line 6276 "gcode/ulyac.cpp"

	}
	break;
	
	case 126:
	{
#line 2976 "meta/ulyac.upg"

#line 6285 "gcode/ulyac.cpp"

	}
	break;
	
	case 129:
	{
#line 2981 "meta/ulyac.upg"

			grammar.addEmptyRule(s_nCurLeftSymbol);
		
#line 6296 "gcode/ulyac.cpp"

	}
	break;
	
	case 128:
	{
#line 2981 "meta/ulyac.upg"

#line 6305 "gcode/ulyac.cpp"

	}
	break;
	
	case 130:
	{
#line 2986 "meta/ulyac.upg"

			
			(yyval.m_pProd) = (yys_sv__[4].m_pProd);
			(yyval.m_pProd)->setPrec((yys_sv__[2].m_nVal));
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));			
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[4]).firstLine);
			
			grammar.clearMidSVT();
		
#line 6323 "gcode/ulyac.cpp"

	}
	break;
	
	case 131:
	{
#line 2996 "meta/ulyac.upg"

			
			(yyval.m_pProd) = (yys_sv__[2].m_pProd);
			(yyval.m_pProd)->setPrec((yys_sv__[0].m_nVal));
			int nActID = ptbl.addEmptyAction((yys_loc__[2]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[2]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);
		
#line 6340 "gcode/ulyac.cpp"

	}
	break;
	
	case 132:
	{
#line 3005 "meta/ulyac.upg"

		
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->setPrec((yys_sv__[2].m_nVal));
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[3]).firstLine);
			
			grammar.clearMidSVT();
		
#line 6358 "gcode/ulyac.cpp"

	}
	break;
	
	case 133:
	{
#line 3015 "meta/ulyac.upg"

		
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->setPrec((yys_sv__[0].m_nVal));
			int nActID = ptbl.addEmptyAction((yys_loc__[1]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[1]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);
		
#line 6375 "gcode/ulyac.cpp"

	}
	break;
	
	case 134:
	{
#line 3024 "meta/ulyac.upg"

			
			(yyval.m_pProd) = (yys_sv__[2].m_pProd);
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[2]).firstLine);
			
			grammar.clearMidSVT();
		
#line 6392 "gcode/ulyac.cpp"

	}
	break;
	
	case 135:
	{
#line 3033 "meta/ulyac.upg"

			(yyval.m_pProd) = (yys_sv__[0].m_pProd);
			int nActID = ptbl.addEmptyAction((yys_loc__[0]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[0]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);
		
#line 6407 "gcode/ulyac.cpp"

	}
	break;
	
	case 136:
	{
#line 3040 "meta/ulyac.upg"

			
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[1]).firstLine);
			
			grammar.clearMidSVT();
		
#line 6424 "gcode/ulyac.cpp"

	}
	break;
	
	case 137:
	{
#line 3049 "meta/ulyac.upg"

			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			int nActID = ptbl.addEmptyAction((yys_loc__[0]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line(nActID, (yys_loc__[0]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);			
		
#line 6439 "gcode/ulyac.cpp"

	}
	break;
	
	case 138:
	{
#line 3057 "meta/ulyac.upg"

			(yyval.m_pProd) = (yys_sv__[3].m_pProd);
			prod_t* pr = grammar.addMidRule((yys_sv__[2].m_nVal));
			assert(pr);
			(yyval.m_pProd)->addRight(pr->getLeft());
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			ptbl.mapRule2Action(pr->getID(), (yys_sv__[2].m_nVal));
			ptbl.mapRule2Line(pr->getID(), (yys_loc__[2]).firstLine);
			pr->setActionIndex((yys_sv__[2].m_nVal));
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6460 "gcode/ulyac.cpp"

	}
	break;
	
	case 139:
	{
#line 3070 "meta/ulyac.upg"

			(yyval.m_pProd) = (yys_sv__[1].m_pProd);
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6474 "gcode/ulyac.cpp"

	}
	break;
	
	case 140:
	{
#line 3076 "meta/ulyac.upg"

			prod_t* pr = grammar.addMidRule((yys_sv__[2].m_nVal));
			assert(pr);
			
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->addRight(pr->getLeft());
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			ptbl.mapRule2Action(pr->getID(), (yys_sv__[2].m_nVal));
			ptbl.mapRule2Line(pr->getID(), (yys_loc__[2]).firstLine);
			pr->setActionIndex((yys_sv__[2].m_nVal));
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6496 "gcode/ulyac.cpp"

	}
	break;
	
	case 141:
	{
#line 3090 "meta/ulyac.upg"

			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6510 "gcode/ulyac.cpp"

	}
	break;
	
	case 142:
	{
#line 3097 "meta/ulyac.upg"

			if((yys_sv__[2].m_nVal) >= grammar.getTypeBase()) {
				strMsg = "at line ";
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += "; description: %prec can not apply to types, ignored.";
				_WARNING(strMsg);
				
				(yyval.m_pPItem) = new prod_item_t((yys_sv__[2].m_nVal));
			}
			else {
				const symbol_t* psym = grammar.getSymbolObj((yys_sv__[0].m_pchVal));
		// update 18/06/09
                if( ! psym || !psym->isToken()) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: declaration of token `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' expected.";
					_ERROR(strMsg, ESYN(6));
					
                    psym = grammar.getSymbolObj(ERROR_SYMBOL_INDEX);
                }
                (const_cast<symbol_t*>(psym))->setUsed(true);
                (yyval.m_pPItem) = new prod_item_t((yys_sv__[2].m_nVal), psym->getPrec(), psym->getAssoc());

			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 6547 "gcode/ulyac.cpp"

	}
	break;
	
	case 143:
	{
#line 3126 "meta/ulyac.upg"

		
			if((yys_sv__[0].m_nVal) >= grammar.getTypeBase()) {				
				(yyval.m_pPItem) = new prod_item_t((yys_sv__[0].m_nVal));
			}
			else {
				if((yys_sv__[0].m_nVal) < 0) {
					(yyval.m_pPItem) = new prod_item_t((yys_sv__[0].m_nVal));
				}
				else {
					const symbol_t* psym = grammar.getSymbolObj((yys_sv__[0].m_nVal));
					assert(psym && psym->isToken());
					(yyval.m_pPItem) = new prod_item_t((yys_sv__[0].m_nVal), psym->getPrec(), psym->getAssoc());					
				}
			}
		
#line 6571 "gcode/ulyac.cpp"

	}
	break;
	
	case 144:
	{
#line 3143 "meta/ulyac.upg"

			(yyval.m_nVal) = grammar.getSymbolIndex((yys_sv__[0].m_pchVal));
			if(INVALID_INDEX == (yyval.m_nVal)) {
				(yyval.m_nVal) = grammar.addType((yys_sv__[0].m_pchVal), DEFAULT_SVT_ID).first;
				++s_nCounter;
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 6587 "gcode/ulyac.cpp"

	}
	break;
	
	case 145:
	{
#line 3151 "meta/ulyac.upg"

				string strSName = strhelper_t::quotedChar((yys_sv__[0].m_cVal));
				(yyval.m_nVal) = grammar.getSymbolIndex(strSName);
				if(INVALID_INDEX == (yyval.m_nVal)) {
				
						s2i_cit_t cit = s_sname2Idx.find(strSName);
						if(cit == s_sname2Idx.end()) {
							
							s_vstrSName.push_back(strSName);
							s_vnToken.push_back((int)(yys_sv__[0].m_cVal));
							
							(yyval.m_nVal) = (int)s_vstrSName.size();
							(yyval.m_nVal) = - (yyval.m_nVal);
							s_sname2Idx.insert(s2i_pair_t(strSName, (yyval.m_nVal)));
						}
						else {
							(yyval.m_nVal) = cit->second;
						}
				}
		
#line 6615 "gcode/ulyac.cpp"

	}
	break;
	
	case 146:
	{
#line 3171 "meta/ulyac.upg"

            std::string strSName{(yys_sv__[0].m_pchVal)};
            delete[] (yys_sv__[0].m_pchVal);

            (yyval.m_nVal) = grammar.getSymbolIndex(strSName);
            if(INVALID_INDEX == (yyval.m_nVal)) {

                s2i_cit_t cit = s_sname2Idx.find(strSName);
                if(cit == s_sname2Idx.end()) {

                    s_vstrSName.push_back(strSName);
                    s_vnToken.push_back(INVALID_INDEX);

                    (yyval.m_nVal) = (int)s_vstrSName.size();
                    (yyval.m_nVal) = - (yyval.m_nVal);
                    s_sname2Idx.insert(s2i_pair_t(strSName, (yyval.m_nVal)));
                }
                else {
                    (yyval.m_nVal) = cit->second;
                }
            }
        
#line 6645 "gcode/ulyac.cpp"

	}
	break;
	
				default:

					if( ! yyerr_flag__ || PARSE_ENDSYMB_ID == yytok__) {
						if(! yyerr_flag__) {
							if(yyerror) {

char yycc[MAX_MSG_LENG];
sprintf(yycc, "Error: syntax error at %d:%d.", yylloc.firstLine, yylloc.firstColumn);
yyerror(yycc, lexer, dtbl, grammar, ptbl, dmap, gsetup);
				}

							yyecode__ = YYE_PERROR;
						}
						else {
							yyecode__ = YYE_NOINPUT;
						}
						
						yyerr_flag__ = true;
						yyltok = yytok__;
					}
					else {
					
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yytok__ = PARSE_ERRORSYMB_ID;
					yysidx__ = PARSE_ERRORSYMB_INDEX;

					while(! yys_sv__.empty())  {
						yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);
						if(is_valid_pstate__(yypstate__)) {
							break;
						}
			

						yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top(), lexer, dtbl, grammar, ptbl, dmap, gsetup);
						yys_loc__.pop(1);


						yys_symb__.pop(1);
						yys_sv__.pop(1);
						yys_stt__.pop(1);
					}

					if( yys_sv__.empty()) {
						yys_stt__.pop(1);
					}

					break;
				}

				if(is_valid_prule__(yyprule__) || YYE_ACCEPT == yyecode__) {
					yyrplen__ = yyprnum[yyprule__];
					yypstate__ = yynext_goto__(yys_stt__[yyrplen__], yyplid[yyprule__]);


					if(YYE_ACCEPT != yyecode__) {
						yys_stt__.pop(yyrplen__);
						yys_symb__.pop(yyrplen__);
						yys_sv__.pop(yyrplen__);

						if(!yys_loc__.empty()) {
							if(yyrplen__ == 0) {
								yyloc.firstLine = yyloc.lastLine = yys_loc__[0].lastLine;
								yyloc.firstColumn = yyloc.lastColumn = yys_loc__[0].lastColumn;
							}
							else {
								yyloc.firstLine = yys_loc__[yyrplen__ - 1].firstLine;
								yyloc.lastLine = yys_loc__[0].lastLine;
								yyloc.firstColumn = yys_loc__[yyrplen__ - 1].firstColumn;
								yyloc.lastColumn = yys_loc__[0].lastColumn;
							}
						}
						yys_loc__.pop(yyrplen__);
						yys_loc__.push(yyloc);

						yys_stt__.push(yypstate__);
						yys_symb__.push(yyplid[yyprule__] + PARSE_TYPE_BASE);
						yys_sv__.push(yyval);
					}
				}
			}
		}

		while( ! yys_sv__.empty()) {

			yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top(), lexer, dtbl, grammar, ptbl, dmap, gsetup);

			yys_sv__.pop(1);
			yys_symb__.pop(1);
		}

		if(YYE_ACCEPT == yyecode__) {


			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE, lexer, dtbl, grammar, ptbl, dmap, gsetup);

		}

		return (yyecode__ == YYE_EOS || yyecode__ == YYE_ACCEPT )? 0: yyecode__;
	}

public:
	inline void yyclearall__(void) {
		yyecode__ = YYE_ALIVE;
		yystart__ = INITIAL;		
		yymore_flag__ = false;
		yyat_bol__ = true;
		
		yyleng = 0;
		yylaleng = 0;
		if(yytext) {
			yytext[0] = '\0';
		}
		yybufmgr__.destroyall();

		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;

	}

private:

	// user interfaces
	// easy way to print matched string
	inline void YYECHO(void) const {
		ECHO();
	}
	inline void ECHO(void) const {
		if(yyoutput)
			fprintf(yyoutput, "%s", yytext);
	}

	// start-condition operations
	// switch start-condition
	inline void YYBEGIN(int sc) {
		BEGIN(sc);
	}
	inline void BEGIN(int sc) {
		yystart__ = sc;
	}
	// return current start-condition
	inline int YYSTART(void) const {
		return yystart__;
	}
	// save current start-condition and switch to new start-condition
	inline void yy_push_state(int nsc) {
		yyscstk__.push(yystart__);
		yystart__ = nsc;
	}
	// switch to last saved start-condition
	inline bool yy_pop_state(void) {

		if(yyscstk__.empty()) {
			return false;
		}
		yystart__ = yyscstk__.top();
		yyscstk__.pop(1);
		return true;
	}
	// return last saved start-condition
	inline int yy_top_state(void) {

		if(yyscstk__.empty()) {
			return INITIAL;
		}
		return yyscstk__.top();
	}

	// get/set flag of beginning-of-line
	inline bool yy_get_bol(void) const {
		return yyat_bol__;
	}
	inline void yy_set_bol(bool b) {
		yyat_bol__ = b;
	}

	// buffer operations
	inline YYPBUFFER yy_current_buffer(void) const {
		return yybufmgr__.current();
	}
	// 
	inline bool yy_has_buffer(void) const {
		return ! yybufmgr__.empty();
	}
	inline void yy_push_buffer(YYPBUFFER pbuffer) {
		yybufmgr__.switchto(pbuffer);
	}
	inline YYPBUFFER yy_pop_buffer(void) {
		return yybufmgr__.pop();
	}
	inline YYPBUFFER yy_new_filebuf(const char *strfile, bool bi = false) {
		if( !strfile ) {
			return yybufmgr__.newbuf(stdin, bi);
		}

	 	FILE *pfile = fopen(strfile, "r");
	 	if( !pfile) return NULL;
		return yybufmgr__.newbuf(pfile);
	}

	inline YYPBUFFER yy_new_cstrbuf(const char *cstrbuffer, int size) {
		if( ! cstrbuffer || size < 1) {
			return NULL;
		}
		return yybufmgr__.newbuf(cstrbuffer, size);
	}
	inline YYPBUFFER yy_new_strbuf(char *strbuffer, int size) {
		if( ! strbuffer || size < 1) {
			return NULL;
		}
		return yybufmgr__.newbuf(strbuffer, size);
	}
	inline void yy_delete_buffer(void) {
		yybufmgr__.destroytop();
	}
	inline void yy_switch_buffer(YYPBUFFER buf) {
		yybufmgr__.switchto(buf);
	}
	inline void yyrestart(void) {

		yystart__ = INITIAL;
		yyecode__ = YYE_ALIVE;
		yymore_flag__ = false;
		
		yyleng = 0;
		yylaleng = 0;
		if( yytext ) {
			yytext[0] = '\0';
		}

		yyscstk__.clear();
		yybufmgr__.reset();
	}

	inline void yymore(void) {

		yymore_flag__ = true;
		yylaleng = yyleng;
	}
	inline int yyless(int n) {

		if(n > 0 && n < yyleng) {

			yytext[n] = '\0';
			n = yyleng - n;
			yyleng -= n;
			yylaleng = yyleng;
			return yybufmgr__.unget(n);
		}
		yylaleng = yyleng;
		yytext[yylaleng] = '\0';

		return 0;
	}

	inline int yyinput(void) {

		int c = yybufmgr__.get();
		if(c < END_OF_FILE) {
			if(c == '\t') {
				int nt = yyget_tabsize();
				nt -= (yyget_colno() + nt - 1) % nt;
				yybufmgr__.pushtsz(nt);
				yyadd_colno(nt);
			}
			else if(c == '\n') {
				yybufmgr__.pushlsz(yyget_colno());
				yyset_colno(1);
				yyadd_lineno(1);
			}
			else {
				yyadd_colno(1);
			}
		}	
		return c;
	}
	inline bool yyunput(char c) {
		int oldc = yybufmgr__.put(c);
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;
	}
	inline bool yyunget(void) {
		int oldc = yybufmgr__.unget();
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;		
	}
	inline void yyterminate(void) {
		yyecode__ = YYE_TERM;
	}
	inline void yyadd_lineno(int nline) {
		yybufmgr__.setlineno(yybufmgr__.getlineno() + nline);
	}
	inline void yyadd_colno(int ncol) {
		yybufmgr__.setcolno(yybufmgr__.getcolno() + ncol);
	}
	inline int yyget_lineno(void) const {
		return yybufmgr__.getlineno();
	}
	inline void yyset_lineno(int nline) {
		yybufmgr__.setlineno(nline);
	}
	inline int yyget_colno(void) const {
		return yybufmgr__.getcolno();
	}
	inline void yyset_colno(int ncol) {
		yybufmgr__.setcolno(ncol);
	}
	inline int yyget_tabsize(void) const {
		return yybufmgr__.gettabsize();
	}
	inline void yyset_tabsize(int ntab) {
		yybufmgr__.settabsize(ntab);
	}
	bool yywrap__(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
		
			return false;
	}


private:

	int yyecode__;


	// buffer manager
	bufmgr_t yybufmgr__;
	// start-condition stack
    sstack_t<int, 32> yyscstk__;
	int yysize__;
	int yystart__;

	bool yymore_flag__;
	bool yyat_bol__;

	char *yytext;
	int yyleng;
	int yylaleng;

	
	bool yyerr_flag__;
	int yyltok;
	yylex_t yylexer;

	FILE* yyoutput;
	FILE* yylogger;
	yyerror_t yyerror;
	
private:
	

///////////////////////////////////////////////////////////////////////////
	// lexical tables
	// start states of DFAs
	static const int yydsc[26];

	// @yydcmap is a char map: char -> transition-label,
	// that is, chars are grouped, transition label is
	// representation of equivalent class of chars
	static const int yydcmap[258];

	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,
	// that is, transition-label in @yydcmap are further grouped in order to save space
	static const int yydmeta[76];

	// use next-check-base-default scheme to store DFAs
	// 
	static const int yydbase[667];
	static const int yyddef[667];
	// next table is an indeed transition table
	static const int yydnxt[3003];
	static const int yydchk[3003];
	static const int yydaccpt[570];
	
	static char YYMSG_UNMATCHED[];

///////////////////////////////////////////////////////////////////////////////
	// LALR parse tables
	// token map: token ID --> token index in token ID table
	// in fact, it acts like inverse table of token ID table
	static const int yyptmap[295];
	// token ID table, which contains token IDs
	//static const int yyptid[59];
	// number of symbols in a grammar rule
	static const int yyprnum[147];
	// index of left symbol in a grammar rule
	static const int yyplid[147];
	// parse action table
	static const int yypact[599];

	// base array for parse action table
	// which is used to determine the base location of the entries
	// for each state stored in the yypack table
	static const int yypabase[209];
	static const int yypgoto[35];
	static const int yypgbase[209];

	// check table for parse action table
	static const by_te_t yyvbmap[1672];
	static const int yyparv[209];
	static const int yyparn[209];

	static const int yypcv[113];
	static const int yypcn[113];
	static const int yypgrv[209];
	static const int yypgrn[209];
	static const std::unordered_map<std::string, int> yyslexemID;

///////////////////////////////////////////////////////////////////////////////////
	// optional tables, they are available only under certain conditions

	// lookahead distant table, only available when there are some lookahead patterns
	// each pattern has its entry of the table
	

};


char yyparser_t::YYMSG_UNMATCHED[] = "Error: unmatched character ` \'.";

const int yyparser_t::yydsc[26] = {
506,	490,	566,	566,	568,	568,	386,	385,
	536,	536,	567,	567,	487,	487,	553,	553,
	435,	435,	332,	331,	546,	546,	436,	436,
	491,	491
};

const int yyparser_t::yydcmap[258] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	1,	2,	0,	0,	3,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	1,	4,	5,	4,	6,	7,	8,	9,
	10,	10,	11,	12,	13,	14,	15,	16,
	17,	18,	18,	18,	19,	19,	19,	19,
	20,	20,	21,	22,	23,	24,	25,	26,
	27,	28,	29,	29,	29,	30,	31,	4,
	4,	32,	4,	4,	33,	4,	34,	35,
	4,	4,	36,	37,	38,	39,	4,	4,
	40,	41,	4,	42,	43,	44,	45,	4,
	46,	47,	48,	49,	50,	51,	52,	53,
	54,	55,	4,	56,	57,	58,	59,	60,
	61,	4,	62,	63,	64,	65,	66,	67,
	68,	69,	4,	70,	71,	72,	4,	73,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	75,	75
};

const int yyparser_t::yydmeta[76] = {
0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	7,	10,	10,	7,	10,	11,
	12,	13,	13,	13,	13,	14,	15,	16,
	17,	16,	18,	4,	4,	4,	4,	4,
	4,	4,	4,	4,	4,	4,	4,	4,
	4,	4,	19,	20,	7,	10,	8,	4,
	4,	4,	4,	4,	4,	4,	4,	4,
	4,	4,	4,	4,	4,	4,	4,	4,
	4,	21,	4,	4,	4,	4,	22,	23,
	7,	24,	25,	26
};

const int yyparser_t::yydbase[667] = {
2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	2927,	2927,
	2927,	2927,	2927,	2927,	2927,	2927,	1389,	1325,
	1327,	1336,	1384,	1323,	1382,	1362,	1320,	1326,
	1359,	1358,	1357,	1375,	1355,	1331,	1330,	1348,
	1351,	1346,	1349,	1299,	1347,	1346,	1296,	1334,
	1329,	1361,	1341,	1340,	1339,	1357,	1294,	1287,
	1312,	1325,	1329,	1283,	1350,	1307,	1306,	1305,
	1304,	1340,	1302,	1275,	1300,	1281,	1270,	1271,
	1296,	1318,	1294,	1293,	1292,	1291,	1283,	1263,
	1285,	1261,	1266,	1254,	1259,	1318,	1249,	1254,
	1308,	1252,	1300,	1231,	1285,	1265,	1280,	1231,
	1251,	1172,	1160,	1205,	1162,	1198,	1122,	1121,
	1153,	1148,	1101,	1149,	1131,	1087,	1083,	1082,
	1081,	1063,	1100,	1092,	1049,	1049,	1030,	1024,
	1021,	1003,	985,	989,	978,	974,	952,	1005,
	961,	955,	950,	952,	937,	937,	938,	923,
	927,	911,	912,	961,	892,	892,	875,	883,
	873,	858,	890,	885,	883,	807,	797,	760,
	759,	732,	721,	718,	721,	689,	674,	646,
	687,	656,	639,	602,	571,	564,	548,	558,
	540,	515,	513,	488,	501,	498,	481,	411,
	391,	383,	408,	345,	3,	290,	268,	187,
	184,	114,	46,	20,	13,	953,	933,	86,
	858,	1012,	1008,	547,	839,	799,	307,	744,
	278,	825,	731,	703,	3,	416,	243,	559,
	727,	652,	502,	370,	726,	28,	125,	675,
	108,	448,	632,	602,	202,	538,	351,	593,
	383,	327,	427,	422,	314,	367,	278,	247,
	172,	186,	224,	196,	191,	101,	148,	167,
	83,	74,	12,	1310,	1275,	1272,	1259,	1271,
	1270,	1267,	1249,	1266,	1257,	1256,	1255,	1253,
	1252,	1250,	1241,	1228,	1221,	1218,	1130,	792,
	708,	935,	1243,	915,	895,	855,	1256,	1251,
	835,	806,	0,	795,	1190,	1162,	1038,	620,
	215,	555,	341,	1232,	1228,	624,	385,	327,
	148,	122,	32,	197,	52,	1210,	508,	1175,
	1174,	1169,	1163,	1157,	1140,	1156,	1150,	1134,
	1161,	1128,	636,	1125,	1121,	1114,	1111,	1105,
	1098,	1121,	1088,	1109,	1076,	1070,	1064,	1058,
	1085,	1049,	1052,	1045,	505,	1035,	1028,	1027,
	397,	651,	317,	615,	1020,	1016,	1012,	1008,
	1038,	699,	777,	719,	599,	572,	312,	106,
	53,	496,	451,	225,	985,	11,	731,	76,
	281,	121,	531,	568,	425,	256,	207,	154,
	276,	3,	103,	990,	984,	970,	964,	950,
	944,	930,	924,	910,	904,	890,	884,	870,
	864,	850,	844,	830,	824,	810,	804,	790,
	784,	769,	763,	424,	390,	354,	318,	246,
	175,	764,	739,	738,	713,	710,	696,	682,
	661,	178,	31,	676,	667,	640,	617,	613,
	561,	582,	530,	524,	488,	482,	430,	414,
	378,	342,	306,	270,	83,	209,	193,	148,
	73,	0,	2927,	1419,	1417,	1406,	1405,	1449,
	1445,	2292,	2276,	2260,	2244,	1500,	2905,	2894,
	2883,	2872,	2861,	2850,	2839,	1416,	2828,	2817,
	2806,	2795,	2784,	2773,	2757,	2741,	2730,	2714,
	2698,	2682,	2666,	2650,	2634,	2618,	2602,	2586,
	2570,	2554,	2538,	2522,	2506,	2490,	2474,	2458,
	2442,	2426,	2410,	2394,	2378,	2362,	2346,	2330,
	2314,	2298,	2282,	2266,	2250,	2234,	2223,	2203,
	2183,	2163,	2143,	2123,	2103,	2083,	1440,	2061,
	2035,	2010,	1987,	1962,	1936,	1910,	1885,	1863,
	1838,	1813,	1788,	1763,	1738,	1713,	1687,	1661,
	1635,	1609,	1583,	1557,	1531,	1505,	1486,	1464,
	1439,	1417,	1391
};

const int yyparser_t::yyddef[667] = {
570,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	348,	492,	492,	492,	492,	492,	492,
	492,	492,	492,	492,	492,	492,	492,	428,
	492,	492,	492,	492,	492,	492,	364,	304,
	127,	587,	437,	437,	125,	585,	584,	583,
	582,	578,	577,	427,	427,	488,	438,	427,
	428,	550,	547,	414,	425,	428,	410,	418,
	410,	415,	410,	410,	569,	547,	547,	547,
	427,	428,	387,	571,	572,	573,	574,	596,
	641,	640,	631,	575,	597,	576,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	642,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	629,	628,	627,	0,	0,	0,
	0,	0,	0,	0,	626,	625,	624,	623,
	622,	0,	0,	579,	621,	620,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	618,	617,	0,	616,	0,	615,	614,	590,
	591,	592,	593,	0,	0,	0,	0,	0,
	611,	612,	588,	588,	619,	572,	571,	601,
	610,	612,	619,	611,	596,	610,	601,	601,
	601,	576,	575,	663,	663,	0,	0,	0,
	599,	603,	603,	0,	604,	604,	0,	604,
	654,	606,	606,	0,	653,	0,	608,	0,
	0,	0,	603,	0,	609,	0,	0,	0,
	0,	603,	604,	604,	594,	604,	603,	606,
	606,	603,	604,	604,	603,	606,	603,	603,
	603,	606,	604,	604,	599,	609,	608,	645,
	645,	666,	666,	0,	0,	0,	0,	607,
	607,	607,	613,	607,	607,	607,	607,	607,
	607,	607,	607,	607,	607,	607,	607,	607,
	607,	0,	632,	0,	0,	0,	0,	0,
	580,	0,	0,	0,	613,	613,	613,	581,
	0,	0,	0,	648,	647,	648,	632,	647,
	647,	632,	648,	656,	656,	586,	0,	598,
	602,	598,	602,	598,	598,	602,	602,	602,
	586,	598,	0,	602,	602,	605,	602,	598,
	602,	586,	598,	586,	598,	598,	598,	602,
	586,	602,	598,	602,	0,	602,	598,	602,
	0,	598,	602,	598,	605,	605,	605,	605,
	635,	605,	633,	635,	634,	633,	634,	657,
	0,	0,	655,	655,	595,	589,	595,	595,
	595,	595,	643,	644,	644,	644,	644,	644,
	643,	643,	658,	600,	600,	600,	600,	600,
	600,	600,	600,	600,	600,	600,	600,	600,
	600,	600,	600,	600,	600,	600,	600,	600,
	600,	600,	600,	600,	600,	600,	600,	600,
	660,	595,	595,	595,	595,	595,	595,	595,
	595,	595,	659,	639,	639,	639,	639,	639,
	0,	661,	0,	0,	0,	0,	646,	636,
	652,	651,	650,	637,	649,	630,	665,	662,
	664,	638,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0
};

const int yyparser_t::yydnxt[3003] = {
0,	418,	44,	197,	324,	73,	75,	75,
	82,	73,	75,	75,	75,	75,	75,	75,
	75,	387,	154,	209,	489,	75,	75,	75,
	390,	75,	74,	424,	271,	360,	360,	360,
	16,	15,	292,	352,	150,	330,	286,	150,
	556,	138,	75,	73,	75,	75,	335,	73,
	73,	427,	427,	427,	73,	16,	488,	43,
	193,	162,	163,	73,	150,	239,	73,	3,
	73,	150,	73,	138,	556,	129,	75,	75,
	75,	9,	415,	80,	251,	351,	160,	77,
	77,	77,	161,	77,	77,	77,	77,	77,
	77,	77,	311,	348,	66,	309,	77,	78,
	77,	353,	77,	77,	153,	153,	153,	153,
	6,	8,	291,	166,	32,	229,	565,	153,
	153,	153,	153,	339,	148,	77,	77,	355,
	499,	472,	283,	112,	418,	6,	480,	479,
	6,	348,	153,	153,	153,	153,	153,	153,
	369,	130,	112,	147,	147,	147,	397,	493,
	77,	77,	499,	1,	33,	34,	8,	170,
	365,	33,	33,	33,	362,	33,	33,	33,
	33,	33,	37,	33,	33,	111,	111,	111,
	112,	33,	34,	33,	112,	33,	33,	168,
	6,	8,	291,	416,	68,	112,	150,	112,
	383,	270,	171,	112,	40,	150,	173,	569,
	35,	33,	414,	83,	179,	6,	97,	319,
	39,	150,	9,	347,	151,	383,	9,	464,
	9,	469,	137,	137,	137,	137,	150,	547,
	13,	84,	33,	33,	33,	112,	33,	17,
	502,	112,	425,	501,	551,	112,	151,	498,
	225,	439,	503,	504,	333,	150,	112,	312,
	112,	9,	150,	112,	112,	502,	114,	326,
	94,	116,	444,	527,	501,	551,	504,	407,
	375,	498,	150,	382,	376,	285,	503,	462,
	112,	168,	495,	150,	513,	354,	494,	392,
	532,	380,	296,	28,	171,	116,	526,	29,
	36,	172,	324,	474,	150,	18,	150,	410,
	410,	410,	410,	505,	112,	466,	112,	2,
	514,	112,	410,	410,	410,	410,	112,	150,
	537,	112,	112,	150,	112,	384,	112,	67,
	150,	486,	150,	112,	505,	410,	410,	410,
	410,	410,	410,	135,	135,	135,	135,	110,
	112,	433,	433,	507,	112,	384,	135,	135,
	135,	135,	150,	112,	150,	112,	426,	112,
	136,	136,	136,	112,	215,	485,	510,	66,
	563,	135,	135,	135,	135,	135,	135,	428,
	428,	428,	428,	373,	328,	112,	293,	112,
	289,	112,	428,	428,	428,	428,	112,	112,
	467,	112,	112,	112,	563,	12,	113,	67,
	112,	480,	344,	112,	112,	428,	428,	428,
	428,	428,	428,	152,	152,	152,	152,	544,
	266,	441,	144,	144,	144,	112,	152,	152,
	152,	152,	112,	88,	112,	112,	112,	214,
	214,	214,	112,	28,	112,	485,	476,	112,
	99,	152,	152,	152,	152,	152,	152,	146,
	146,	146,	146,	249,	112,	112,	525,	248,
	103,	112,	146,	146,	146,	146,	112,	468,
	450,	112,	112,	454,	6,	150,	391,	151,
	249,	486,	358,	112,	150,	146,	146,	146,
	146,	146,	146,	355,	240,	65,	557,	461,
	150,	249,	301,	112,	151,	245,	245,	237,
	112,	401,	245,	112,	112,	150,	393,	5,
	112,	245,	112,	24,	245,	112,	245,	112,
	245,	367,	557,	554,	554,	554,	554,	19,
	4,	555,	555,	555,	555,	112,	554,	554,
	554,	554,	26,	276,	555,	555,	555,	555,
	457,	9,	388,	388,	388,	438,	438,	438,
	438,	554,	554,	554,	554,	554,	554,	555,
	555,	555,	555,	555,	555,	62,	62,	62,
	62,	459,	168,	259,	259,	259,	259,	112,
	62,	62,	62,	62,	140,	171,	259,	259,
	259,	259,	223,	515,	150,	329,	18,	549,
	552,	150,	516,	62,	62,	62,	62,	62,
	62,	259,	259,	259,	259,	259,	259,	6,
	30,	238,	165,	162,	150,	434,	434,	239,
	70,	549,	520,	150,	150,	112,	138,	134,
	134,	134,	134,	150,	6,	31,	399,	31,
	274,	273,	359,	272,	562,	263,	265,	150,
	430,	430,	264,	138,	64,	423,	357,	261,
	262,	76,	257,	187,	150,	254,	150,	150,
	150,	150,	550,	550,	550,	550,	269,	559,
	562,	132,	132,	132,	548,	24,	112,	151,
	150,	255,	108,	150,	150,	388,	388,	388,
	150,	150,	150,	150,	150,	545,	417,	202,
	317,	548,	112,	559,	211,	150,	112,	150,
	151,	112,	150,	201,	150,	456,	150,	500,
	112,	318,	150,	409,	150,	150,	150,	150,
	232,	227,	91,	321,	150,	150,	150,	150,
	150,	419,	138,	150,	112,	150,	112,	190,
	347,	500,	150,	150,	112,	112,	150,	423,
	112,	394,	426,	150,	112,	187,	69,	138,
	215,	112,	112,	112,	17,	361,	150,	112,
	150,	112,	275,	89,	150,	112,	226,	150,
	432,	432,	202,	412,	413,	150,	112,	112,
	112,	203,	199,	112,	112,	302,	201,	112,
	92,	463,	370,	345,	112,	112,	112,	564,
	112,	112,	112,	112,	112,	411,	90,	112,
	281,	337,	112,	230,	112,	112,	282,	112,
	112,	470,	465,	112,	91,	112,	112,	88,
	112,	112,	112,	564,	404,	112,	112,	112,
	341,	529,	429,	429,	419,	533,	112,	112,
	112,	112,	190,	313,	112,	112,	112,	417,
	86,	85,	346,	112,	112,	211,	112,	112,
	112,	560,	400,	112,	422,	250,	112,	112,
	112,	112,	112,	112,	112,	112,	112,	445,
	112,	112,	93,	112,	416,	112,	112,	112,
	112,	112,	270,	112,	112,	560,	443,	519,
	112,	112,	112,	112,	247,	112,	112,	112,
	413,	112,	496,	112,	112,	112,	199,	112,
	112,	90,	112,	112,	112,	112,	112,	112,
	246,	471,	101,	366,	89,	112,	112,	112,
	112,	112,	316,	112,	112,	8,	112,	8,
	112,	112,	112,	112,	71,	112,	497,	372,
	412,	112,	492,	112,	112,	112,	203,	112,
	112,	94,	112,	112,	112,	112,	112,	112,
	244,	112,	453,	112,	411,	112,	363,	112,
	112,	112,	230,	112,	112,	85,	112,	112,
	117,	112,	112,	447,	242,	112,	106,	112,
	409,	112,	150,	112,	112,	112,	227,	112,
	112,	241,	112,	11,	112,	112,	112,	112,
	446,	112,	100,	112,	268,	112,	150,	112,
	112,	112,	283,	112,	112,	86,	112,	235,
	542,	112,	112,	112,	233,	112,	405,	112,
	150,	112,	267,	112,	112,	112,	398,	112,
	112,	93,	112,	508,	164,	112,	378,	112,
	343,	112,	112,	112,	150,	112,	395,	112,
	112,	112,	349,	112,	112,	92,	112,	342,
	102,	112,	112,	112,	224,	112,	107,	112,
	298,	112,	472,	112,	112,	112,	94,	541,
	112,	231,	112,	323,	112,	112,	112,	112,
	112,	112,	104,	112,	112,	112,	368,	112,
	112,	112,	105,	112,	112,	112,	112,	112,
	320,	112,	374,	112,	449,	112,	112,	431,
	431,	112,	112,	112,	509,	115,	280,	112,
	112,	300,	522,	279,	112,	396,	524,	371,
	112,	112,	112,	379,	420,	112,	561,	112,
	112,	308,	112,	228,	112,	112,	112,	109,
	112,	112,	543,	307,	521,	112,	475,	112,
	112,	299,	167,	112,	253,	22,	112,	112,
	112,	112,	561,	112,	112,	23,	539,	327,
	112,	123,	112,	528,	112,	112,	123,	314,
	460,	112,	112,	123,	295,	112,	112,	112,
	538,	112,	96,	169,	112,	294,	112,	112,
	95,	123,	112,	112,	24,	278,	123,	123,
	478,	350,	112,	315,	112,	448,	402,	80,
	174,	112,	123,	123,	112,	25,	112,	123,
	112,	112,	25,	408,	112,	112,	112,	112,
	112,	325,	112,	112,	473,	540,	175,	112,
	381,	112,	112,	112,	176,	112,	112,	523,
	112,	112,	403,	112,	112,	123,	112,	421,
	112,	112,	437,	123,	322,	112,	112,	123,
	112,	112,	112,	112,	277,	112,	356,	26,
	340,	177,	112,	112,	455,	112,	27,	112,
	178,	112,	112,	112,	112,	112,	112,	112,
	112,	531,	98,	112,	518,	180,	112,	406,
	112,	112,	112,	338,	535,	112,	123,	112,
	112,	112,	112,	123,	123,	141,	141,	141,
	123,	131,	131,	131,	145,	71,	290,	481,
	451,	139,	81,	236,	142,	142,	142,	477,
	112,	112,	112,	112,	112,	112,	112,	112,
	181,	297,	558,	284,	112,	310,	310,	310,
	112,	112,	30,	112,	112,	112,	182,	81,
	112,	63,	63,	63,	258,	258,	258,	184,
	112,	112,	112,	112,	112,	234,	112,	458,
	442,	534,	186,	336,	517,	232,	512,	112,
	112,	440,	112,	112,	188,	112,	452,	93,
	32,	112,	511,	189,	92,	377,	112,	389,
	389,	389,	287,	76,	288,	76,	256,	49,
	48,	50,	51,	212,	52,	87,	61,	260,
	47,	89,	53,	45,	54,	55,	56,	57,
	46,	86,	42,	192,	58,	85,	217,	44,
	220,	221,	219,	43,	191,	185,	90,	218,
	216,	91,	210,	183,	208,	41,	59,	60,
	207,	83,	206,	205,	200,	198,	196,	552,
	36,	222,	8,	195,	213,	194,	234,	9,
	133,	46,	204,	79,	160,	77,	77,	79,
	161,	77,	77,	77,	79,	77,	78,	77,
	79,	77,	339,	148,	79,	493,	143,	79,
	1,	149,	158,	157,	303,	149,	303,	149,
	149,	149,	149,	149,	149,	149,	156,	149,
	155,	149,	303,	149,	149,	303,	149,	149,
	149,	149,	149,	79,	72,	0,	0,	79,
	72,	0,	0,	7,	79,	72,	0,	10,
	79,	72,	158,	0,	79,	72,	157,	79,
	9,	6,	8,	291,	364,	162,	364,	9,
	9,	239,	9,	9,	355,	134,	20,	21,
	9,	9,	364,	9,	9,	364,	9,	20,
	9,	9,	38,	0,	0,	0,	38,	0,
	0,	0,	0,	38,	0,	0,	0,	38,
	121,	9,	121,	38,	0,	120,	38,	120,
	9,	9,	0,	9,	9,	9,	121,	9,
	0,	121,	9,	120,	9,	9,	120,	9,
	9,	9,	9,	9,	0,	0,	0,	122,
	9,	122,	9,	9,	9,	9,	9,	9,
	9,	9,	0,	9,	9,	122,	9,	9,
	122,	9,	9,	9,	9,	14,	0,	0,
	0,	14,	14,	0,	14,	14,	14,	14,
	14,	14,	14,	14,	0,	14,	14,	14,
	14,	14,	14,	14,	14,	14,	14,	9,
	0,	0,	0,	119,	9,	119,	9,	9,
	9,	9,	9,	0,	9,	9,	0,	9,
	9,	119,	9,	9,	119,	9,	9,	9,
	9,	9,	0,	0,	0,	124,	9,	124,
	9,	9,	9,	9,	9,	9,	9,	9,
	0,	9,	9,	124,	9,	9,	124,	9,
	9,	9,	9,	9,	6,	30,	238,	120,
	0,	120,	9,	9,	0,	9,	9,	9,
	9,	9,	6,	31,	9,	120,	9,	9,
	120,	9,	9,	9,	9,	9,	0,	8,
	291,	9,	9,	9,	9,	9,	9,	9,
	9,	0,	9,	9,	6,	9,	9,	9,
	9,	9,	9,	0,	9,	9,	9,	344,
	344,	0,	0,	344,	344,	344,	344,	344,
	344,	344,	344,	344,	344,	344,	344,	344,
	344,	344,	344,	344,	344,	344,	344,	344,
	344,	348,	348,	0,	0,	348,	0,	348,
	348,	348,	348,	348,	348,	348,	348,	348,
	348,	348,	348,	348,	348,	0,	348,	348,
	348,	348,	348,	131,	0,	0,	131,	0,
	131,	131,	131,	0,	131,	131,	131,	0,
	131,	131,	131,	131,	131,	131,	0,	131,
	131,	131,	131,	131,	141,	0,	0,	141,
	0,	141,	141,	141,	0,	141,	141,	141,
	0,	141,	141,	141,	141,	141,	141,	0,
	141,	141,	141,	141,	141,	131,	0,	0,
	131,	0,	131,	131,	131,	0,	131,	131,
	131,	0,	131,	131,	131,	131,	131,	131,
	0,	131,	131,	131,	131,	131,	141,	0,
	0,	141,	0,	141,	141,	141,	0,	141,
	141,	141,	0,	141,	141,	141,	141,	141,
	141,	0,	141,	141,	141,	141,	141,	131,
	0,	0,	131,	67,	131,	131,	131,	0,
	131,	131,	131,	131,	131,	131,	131,	131,
	131,	131,	485,	131,	131,	131,	131,	131,
	141,	0,	0,	141,	0,	141,	141,	141,
	66,	141,	141,	141,	141,	141,	141,	141,
	141,	141,	141,	480,	141,	141,	141,	141,
	141,	252,	0,	252,	252,	252,	0,	252,
	252,	252,	252,	252,	252,	252,	252,	0,
	252,	0,	252,	252,	252,	252,	150,	0,
	0,	0,	150,	0,	150,	150,	150,	150,
	150,	150,	150,	150,	150,	150,	150,	0,
	150,	150,	334,	150,	150,	150,	150,	150,
	150,	0,	0,	0,	150,	0,	150,	150,
	150,	150,	150,	150,	150,	150,	150,	150,
	150,	0,	150,	150,	334,	150,	150,	150,
	150,	150,	150,	0,	0,	0,	150,	0,
	150,	150,	150,	150,	150,	150,	150,	150,
	150,	150,	150,	0,	150,	150,	334,	150,
	150,	150,	150,	150,	243,	0,	0,	243,
	243,	243,	243,	243,	243,	243,	243,	243,
	243,	243,	243,	243,	243,	243,	243,	0,
	243,	243,	243,	131,	0,	0,	131,	0,
	131,	131,	131,	0,	131,	131,	131,	131,
	131,	131,	131,	131,	131,	131,	482,	131,
	131,	131,	131,	131,	141,	0,	0,	141,
	0,	141,	141,	141,	0,	141,	141,	141,
	141,	141,	141,	141,	141,	141,	141,	483,
	141,	141,	141,	141,	141,	150,	0,	0,
	0,	150,	0,	150,	150,	150,	150,	150,
	150,	150,	0,	150,	150,	150,	0,	150,
	150,	334,	0,	150,	150,	150,	150,	142,
	0,	142,	142,	142,	142,	142,	142,	142,
	0,	142,	142,	142,	142,	142,	142,	0,
	142,	142,	142,	142,	0,	142,	142,	142,
	142,	142,	142,	142,	0,	142,	142,	142,
	142,	142,	142,	0,	142,	142,	142,	141,
	141,	141,	141,	141,	141,	141,	141,	141,
	141,	141,	141,	141,	141,	141,	141,	141,
	141,	141,	141,	142,	142,	142,	142,	142,
	142,	142,	142,	142,	142,	142,	142,	142,
	142,	142,	142,	142,	142,	142,	142,	131,
	131,	131,	131,	131,	131,	131,	131,	131,
	131,	131,	131,	131,	131,	131,	131,	131,
	131,	131,	131,	142,	28,	142,	142,	142,
	142,	142,	142,	142,	142,	142,	142,	142,
	142,	142,	142,	486,	142,	142,	142,	142,
	0,	142,	142,	142,	142,	142,	142,	142,
	142,	142,	142,	142,	142,	142,	142,	484,
	142,	142,	142,	112,	0,	112,	0,	112,
	0,	112,	112,	0,	112,	0,	112,	0,
	112,	112,	112,	0,	112,	112,	0,	112,
	126,	0,	126,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	126,	112,
	128,	126,	128,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	128,	112,
	305,	128,	305,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	305,	112,
	306,	305,	306,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	306,	112,
	0,	306,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	0,	0,	0,	112,	0,	112,	112,
	112,	0,	112,	0,	112,	112,	0,	112,
	0,	112,	0,	112,	112,	112,	0,	112,
	112,	0,	112,	0,	0,	0,	0,	112,
	0,	159,	530,	159,	0,	159,	0,	159,
	159,	0,	159,	0,	0,	0,	0,	159,
	0,	112,	159,	112,	0,	112,	0,	112,
	112,	0,	112,	0,	118,	0,	118,	112,
	0,	0,	112,	118,	0,	118,	0,	306,
	0,	306,	118,	0,	0,	118,	306,	0,
	306,	0,	305,	0,	305,	306,	0,	0,
	306,	305,	0,	305,	0,	304,	0,	304,
	305,	0,	0,	305,	304,	0,	304,	0,
	303,	0,	303,	304,	0,	0,	304,	303,
	0,	303,	0,	123,	0,	123,	303,	0,
	0,	303,	123,	0,	123,	0,	121,	0,
	121,	123,	0,	0,	123,	121,	0,	121,
	0,	123,	0,	123,	121,	0,	0,	121,
	123,	0,	123,	0,	125,	0,	125,	123,
	0,	0,	123,	125,	0,	125,	0,	126,
	0,	126,	125,	0,	0,	125,	126,	0,
	126,	0,	127,	0,	127,	126,	0,	0,
	126,	127,	0,	127,	0,	128,	0,	128,
	127,	0,	0,	127,	128,	0,	128,	0,
	0,	0,	0,	128,	0,	0,	128,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0
};

const int yyparser_t::yydchk[3003] = {
570,	418,	418,	418,	324,	569,	569,	569,
	348,	569,	569,	569,	569,	569,	569,	569,
	569,	569,	569,	386,	332,	569,	569,	569,
	493,	569,	569,	331,	493,	493,	493,	493,
	546,	546,	546,	386,	505,	546,	546,	505,
	569,	505,	569,	569,	569,	569,	348,	569,
	569,	434,	434,	434,	569,	546,	488,	488,
	488,	436,	546,	569,	505,	436,	569,	436,
	569,	505,	569,	505,	569,	330,	569,	569,
	569,	568,	568,	568,	568,	546,	568,	568,
	568,	385,	568,	568,	568,	568,	568,	568,
	568,	568,	357,	335,	564,	357,	568,	568,
	568,	385,	568,	568,	564,	564,	564,	564,
	506,	506,	506,	487,	487,	487,	506,	564,
	564,	564,	564,	568,	568,	568,	568,	506,
	384,	360,	497,	495,	488,	506,	564,	495,
	487,	335,	564,	564,	564,	564,	564,	564,
	495,	329,	495,	433,	433,	433,	495,	568,
	568,	568,	384,	568,	567,	567,	567,	567,
	381,	567,	567,	567,	381,	567,	567,	567,
	567,	567,	567,	567,	567,	432,	432,	432,
	497,	567,	567,	567,	497,	567,	567,	358,
	536,	536,	536,	545,	360,	497,	503,	497,
	503,	545,	358,	497,	536,	503,	567,	567,
	567,	567,	566,	566,	566,	536,	566,	382,
	536,	503,	435,	364,	383,	503,	435,	536,
	435,	382,	566,	566,	566,	566,	503,	566,
	565,	566,	567,	567,	567,	376,	567,	364,
	566,	545,	491,	566,	566,	545,	383,	566,
	491,	376,	566,	502,	566,	502,	545,	377,
	545,	491,	502,	377,	545,	566,	565,	328,
	545,	565,	327,	380,	566,	566,	502,	379,
	565,	566,	502,	565,	380,	565,	566,	565,
	379,	424,	565,	502,	565,	565,	565,	565,
	565,	565,	565,	563,	424,	565,	565,	565,
	344,	344,	496,	378,	501,	424,	501,	563,
	563,	563,	563,	501,	378,	535,	350,	491,
	375,	535,	563,	563,	563,	563,	535,	501,
	350,	535,	535,	501,	375,	504,	535,	562,
	504,	563,	504,	535,	501,	563,	563,	563,
	563,	563,	563,	562,	562,	562,	562,	374,
	496,	486,	486,	326,	496,	504,	562,	562,
	562,	562,	504,	374,	504,	496,	426,	496,
	431,	431,	431,	496,	426,	562,	325,	561,
	486,	562,	562,	562,	562,	562,	562,	561,
	561,	561,	561,	372,	474,	534,	342,	474,
	342,	534,	561,	561,	561,	561,	534,	372,
	369,	534,	534,	474,	486,	355,	534,	560,
	474,	561,	355,	534,	369,	561,	561,	561,
	561,	561,	561,	560,	560,	560,	560,	323,
	366,	533,	430,	430,	430,	533,	560,	560,
	560,	560,	533,	426,	366,	533,	533,	472,
	472,	472,	533,	559,	373,	560,	322,	533,
	373,	560,	560,	560,	560,	560,	560,	559,
	559,	559,	559,	558,	368,	532,	321,	558,
	368,	532,	559,	559,	559,	559,	532,	558,
	558,	532,	532,	320,	490,	500,	532,	500,
	558,	559,	490,	532,	500,	559,	559,	559,
	559,	559,	559,	490,	349,	472,	558,	531,
	500,	558,	319,	531,	500,	558,	558,	349,
	531,	371,	558,	531,	531,	500,	370,	318,
	531,	558,	371,	557,	558,	531,	558,	370,
	558,	361,	558,	557,	557,	557,	557,	489,
	317,	556,	556,	556,	556,	361,	557,	557,
	557,	557,	468,	316,	556,	556,	556,	556,
	315,	490,	468,	468,	468,	438,	438,	438,
	438,	557,	557,	557,	557,	557,	557,	556,
	556,	556,	556,	556,	556,	555,	555,	555,
	555,	314,	489,	554,	554,	554,	554,	354,
	555,	555,	555,	555,	425,	489,	554,	554,
	554,	554,	425,	354,	498,	351,	489,	498,
	339,	498,	313,	555,	555,	555,	555,	555,
	555,	554,	554,	554,	554,	554,	554,	553,
	553,	553,	351,	553,	498,	485,	485,	553,
	339,	498,	312,	498,	499,	365,	499,	553,
	553,	553,	553,	499,	553,	553,	365,	553,
	552,	552,	552,	552,	485,	311,	552,	499,
	484,	484,	552,	499,	310,	423,	552,	309,
	552,	425,	552,	423,	499,	552,	551,	551,
	551,	551,	550,	550,	550,	550,	308,	484,
	485,	429,	429,	429,	551,	450,	367,	551,
	550,	307,	367,	550,	551,	450,	450,	450,
	550,	549,	549,	549,	549,	363,	544,	353,
	306,	551,	475,	484,	544,	550,	363,	549,
	551,	475,	549,	353,	550,	475,	551,	549,
	475,	305,	550,	543,	548,	548,	548,	548,
	304,	543,	423,	362,	549,	547,	547,	547,
	547,	542,	548,	549,	362,	548,	473,	542,
	347,	549,	548,	547,	544,	473,	547,	541,
	544,	473,	540,	547,	473,	541,	303,	548,
	540,	544,	408,	544,	347,	302,	548,	544,
	547,	543,	359,	544,	548,	543,	359,	547,
	483,	483,	352,	539,	538,	547,	543,	542,
	543,	539,	538,	542,	543,	481,	352,	481,
	543,	301,	481,	408,	542,	541,	542,	483,
	540,	541,	542,	408,	540,	537,	542,	481,
	300,	299,	541,	537,	541,	540,	298,	540,
	541,	356,	494,	540,	541,	356,	494,	540,
	346,	539,	538,	483,	346,	539,	538,	494,
	297,	494,	482,	482,	419,	494,	539,	538,
	539,	538,	419,	343,	539,	538,	407,	417,
	539,	538,	530,	537,	343,	417,	530,	537,
	529,	482,	296,	530,	529,	295,	530,	530,
	537,	529,	537,	530,	529,	529,	537,	528,
	530,	529,	537,	528,	416,	527,	529,	407,
	528,	527,	416,	528,	528,	482,	527,	407,
	528,	527,	527,	526,	294,	528,	527,	526,
	413,	525,	341,	527,	526,	525,	413,	526,
	526,	419,	525,	341,	526,	525,	525,	524,
	293,	526,	525,	524,	417,	523,	345,	525,
	524,	523,	345,	524,	524,	292,	523,	291,
	524,	523,	523,	522,	290,	524,	523,	522,
	412,	521,	340,	523,	522,	521,	412,	522,
	522,	416,	521,	340,	522,	521,	521,	520,
	289,	522,	521,	520,	411,	519,	336,	521,
	520,	519,	411,	520,	520,	413,	519,	336,
	520,	519,	519,	518,	288,	520,	519,	518,
	409,	517,	334,	519,	518,	517,	409,	518,
	518,	287,	517,	286,	518,	517,	517,	516,
	285,	518,	517,	516,	284,	515,	333,	517,
	516,	515,	283,	516,	516,	412,	515,	282,
	516,	515,	515,	514,	281,	516,	515,	514,
	334,	513,	280,	515,	514,	513,	279,	514,
	514,	411,	513,	278,	514,	513,	513,	512,
	277,	514,	513,	512,	333,	511,	276,	513,
	512,	511,	275,	512,	512,	409,	511,	274,
	512,	511,	511,	510,	273,	512,	511,	510,
	272,	509,	271,	511,	510,	509,	270,	510,
	510,	269,	509,	268,	510,	509,	509,	508,
	492,	510,	509,	508,	492,	507,	267,	509,
	508,	507,	266,	508,	508,	492,	507,	492,
	508,	507,	507,	492,	422,	508,	507,	480,
	480,	338,	479,	507,	479,	337,	478,	479,
	478,	265,	477,	478,	477,	338,	476,	477,
	476,	337,	471,	476,	479,	471,	480,	470,
	478,	264,	469,	263,	477,	469,	470,	422,
	476,	471,	470,	262,	467,	470,	471,	467,
	465,	469,	261,	465,	260,	259,	469,	466,
	422,	463,	480,	467,	463,	258,	466,	465,
	467,	464,	466,	462,	465,	466,	464,	464,
	463,	461,	462,	464,	257,	463,	462,	460,
	461,	462,	256,	255,	461,	254,	460,	461,
	253,	459,	460,	458,	252,	460,	459,	459,
	406,	456,	458,	459,	456,	457,	458,	251,
	250,	458,	457,	457,	455,	249,	454,	457,
	456,	454,	248,	455,	453,	456,	453,	455,
	452,	453,	455,	452,	451,	454,	247,	451,
	421,	406,	454,	449,	246,	447,	453,	452,
	447,	406,	449,	451,	452,	448,	449,	444,
	451,	449,	448,	448,	447,	446,	444,	448,
	446,	447,	444,	445,	420,	444,	445,	245,
	443,	244,	442,	421,	446,	442,	243,	443,
	242,	446,	445,	443,	441,	440,	443,	445,
	440,	442,	439,	441,	421,	241,	442,	441,
	405,	439,	441,	404,	440,	439,	437,	420,
	439,	440,	403,	437,	437,	428,	428,	428,
	437,	427,	427,	427,	415,	415,	415,	402,
	420,	414,	414,	414,	410,	410,	410,	394,
	401,	405,	400,	399,	404,	398,	397,	396,
	240,	405,	239,	403,	404,	390,	390,	390,
	395,	393,	238,	403,	392,	391,	237,	236,
	402,	389,	389,	389,	388,	388,	388,	235,
	402,	401,	394,	400,	399,	234,	398,	397,
	396,	401,	233,	400,	399,	232,	398,	397,
	396,	395,	393,	394,	231,	392,	391,	230,
	229,	395,	393,	228,	227,	392,	391,	387,
	387,	387,	226,	225,	224,	223,	222,	221,
	220,	219,	218,	217,	216,	215,	214,	213,
	212,	211,	210,	209,	208,	207,	206,	205,
	204,	203,	202,	201,	200,	199,	198,	197,
	196,	195,	194,	193,	192,	191,	190,	189,
	188,	187,	186,	185,	184,	183,	182,	181,
	180,	179,	178,	177,	176,	175,	174,	173,
	172,	171,	170,	169,	168,	167,	166,	666,
	666,	666,	666,	666,	666,	666,	666,	666,
	666,	666,	666,	666,	666,	666,	666,	666,
	666,	666,	666,	666,	666,	666,	666,	666,
	666,	665,	574,	573,	589,	665,	589,	665,
	665,	665,	665,	665,	665,	665,	572,	665,
	571,	665,	589,	665,	665,	589,	665,	665,
	665,	665,	665,	664,	638,	664,	664,	664,
	638,	664,	664,	576,	664,	638,	664,	575,
	664,	638,	576,	664,	664,	638,	575,	664,
	663,	663,	663,	663,	663,	663,	663,	663,
	663,	663,	663,	663,	663,	663,	663,	663,
	663,	663,	663,	663,	663,	663,	663,	663,
	663,	663,	662,	662,	662,	662,	662,	662,
	662,	662,	662,	662,	662,	662,	662,	662,
	581,	661,	581,	662,	662,	661,	662,	661,
	661,	661,	661,	661,	661,	661,	581,	661,
	661,	581,	661,	661,	661,	661,	661,	661,
	661,	661,	661,	660,	660,	660,	660,	660,
	660,	660,	660,	660,	660,	660,	660,	660,
	660,	660,	660,	660,	660,	660,	660,	660,
	660,	660,	660,	660,	660,	659,	659,	659,
	659,	659,	659,	659,	659,	659,	659,	659,
	659,	659,	659,	659,	659,	659,	659,	659,
	659,	659,	659,	659,	659,	659,	659,	658,
	658,	658,	658,	658,	658,	658,	658,	658,
	658,	658,	658,	658,	658,	658,	658,	658,
	658,	658,	658,	658,	658,	658,	658,	658,
	658,	657,	657,	657,	657,	657,	657,	657,
	657,	657,	657,	657,	657,	657,	657,	657,
	657,	657,	657,	657,	657,	657,	657,	657,
	657,	657,	657,	656,	656,	656,	656,	656,
	656,	656,	656,	656,	656,	656,	656,	656,
	656,	656,	656,	656,	656,	656,	656,	656,
	656,	656,	656,	656,	656,	655,	655,	655,
	655,	655,	655,	655,	655,	655,	655,	655,
	655,	655,	655,	655,	655,	655,	655,	655,
	655,	655,	655,	655,	655,	655,	655,	654,
	654,	654,	654,	654,	654,	654,	654,	654,
	654,	654,	654,	654,	654,	654,	654,	654,
	654,	654,	654,	654,	654,	654,	654,	654,
	654,	653,	653,	653,	653,	653,	653,	653,
	653,	653,	653,	653,	653,	653,	653,	653,
	653,	653,	653,	653,	653,	653,	653,	653,
	653,	653,	653,	652,	652,	652,	652,	652,
	652,	652,	652,	652,	652,	652,	652,	652,
	652,	652,	652,	652,	652,	652,	652,	652,
	652,	652,	652,	652,	651,	651,	651,	651,
	651,	651,	651,	651,	651,	651,	651,	651,
	651,	651,	651,	651,	651,	651,	651,	651,
	651,	651,	651,	651,	651,	650,	650,	650,
	650,	650,	650,	650,	650,	650,	650,	650,
	650,	650,	650,	650,	650,	650,	650,	650,
	650,	650,	650,	650,	650,	650,	649,	649,
	649,	649,	649,	649,	649,	649,	649,	649,
	649,	649,	649,	649,	649,	649,	649,	649,
	649,	649,	649,	649,	649,	649,	649,	648,
	648,	648,	648,	648,	648,	648,	648,	648,
	648,	648,	648,	648,	648,	648,	648,	648,
	648,	648,	648,	648,	648,	648,	648,	648,
	647,	647,	647,	647,	647,	647,	647,	647,
	647,	647,	647,	647,	647,	647,	647,	647,
	647,	647,	647,	647,	647,	647,	647,	647,
	647,	646,	646,	646,	646,	646,	646,	646,
	646,	646,	646,	646,	646,	646,	646,	646,
	646,	646,	646,	646,	646,	646,	645,	645,
	645,	645,	645,	645,	645,	645,	645,	645,
	645,	645,	645,	645,	645,	645,	645,	645,
	645,	645,	645,	645,	645,	645,	645,	645,
	644,	644,	644,	644,	644,	644,	644,	644,
	644,	644,	644,	644,	644,	644,	644,	644,
	644,	644,	644,	644,	644,	644,	644,	644,
	644,	644,	643,	643,	643,	643,	643,	643,
	643,	643,	643,	643,	643,	643,	643,	643,
	643,	643,	643,	643,	643,	643,	643,	643,
	643,	643,	643,	643,	642,	642,	642,	642,
	642,	642,	642,	642,	642,	642,	642,	642,
	642,	642,	642,	642,	642,	642,	642,	642,
	642,	642,	642,	641,	641,	641,	641,	641,
	641,	641,	641,	641,	641,	641,	641,	641,
	641,	641,	641,	641,	641,	641,	641,	641,
	641,	641,	641,	641,	640,	640,	640,	640,
	640,	640,	640,	640,	640,	640,	640,	640,
	640,	640,	640,	640,	640,	640,	640,	640,
	640,	640,	640,	640,	640,	639,	639,	639,
	639,	639,	639,	639,	639,	639,	639,	639,
	639,	639,	639,	639,	639,	639,	639,	639,
	639,	639,	639,	639,	639,	639,	639,	637,
	637,	637,	637,	637,	637,	637,	637,	637,
	637,	637,	637,	637,	637,	637,	637,	637,
	637,	637,	637,	636,	636,	636,	636,	636,
	636,	636,	636,	636,	636,	636,	636,	636,
	636,	636,	636,	636,	636,	636,	636,	635,
	635,	635,	635,	635,	635,	635,	635,	635,
	635,	635,	635,	635,	635,	635,	635,	635,
	635,	635,	635,	634,	634,	634,	634,	634,
	634,	634,	634,	634,	634,	634,	634,	634,
	634,	634,	634,	634,	634,	634,	634,	633,
	633,	633,	633,	633,	633,	633,	633,	633,
	633,	633,	633,	633,	633,	633,	633,	633,
	633,	633,	633,	632,	632,	632,	632,	632,
	632,	632,	632,	632,	632,	632,	632,	632,
	632,	632,	632,	632,	632,	632,	632,	631,
	631,	631,	631,	631,	631,	631,	631,	631,
	631,	631,	631,	631,	631,	631,	631,	631,
	631,	631,	631,	630,	630,	630,	630,	630,
	630,	630,	630,	630,	630,	630,	629,	630,
	629,	630,	629,	629,	629,	629,	629,	629,
	580,	629,	580,	629,	629,	629,	628,	629,
	628,	628,	628,	628,	628,	628,	580,	628,
	579,	580,	579,	628,	628,	628,	627,	628,
	627,	627,	627,	627,	627,	627,	579,	627,
	578,	579,	578,	627,	627,	627,	626,	627,
	626,	626,	626,	626,	626,	626,	578,	626,
	577,	578,	577,	626,	626,	626,	625,	626,
	625,	625,	625,	625,	625,	625,	577,	625,
	625,	577,	625,	625,	625,	625,	624,	625,
	624,	624,	624,	624,	624,	624,	624,	624,
	624,	624,	624,	624,	624,	624,	623,	624,
	623,	623,	623,	623,	623,	623,	623,	623,
	623,	623,	623,	623,	623,	623,	622,	623,
	622,	622,	622,	622,	622,	622,	622,	622,
	622,	622,	622,	622,	622,	622,	621,	622,
	621,	621,	621,	621,	621,	621,	621,	621,
	621,	621,	621,	621,	621,	621,	620,	621,
	620,	620,	620,	620,	620,	620,	620,	620,
	620,	620,	620,	620,	620,	620,	619,	620,
	619,	619,	619,	619,	619,	619,	619,	619,
	619,	619,	619,	619,	619,	619,	618,	619,
	618,	618,	618,	618,	618,	618,	618,	618,
	618,	618,	618,	618,	618,	618,	617,	618,
	617,	617,	617,	617,	617,	617,	617,	617,
	617,	617,	617,	617,	617,	617,	616,	617,
	616,	616,	616,	616,	616,	616,	616,	616,
	616,	616,	616,	616,	616,	616,	615,	616,
	615,	615,	615,	615,	615,	615,	615,	615,
	615,	615,	615,	615,	615,	615,	614,	615,
	614,	614,	614,	614,	614,	614,	614,	614,
	614,	614,	614,	614,	614,	614,	613,	614,
	613,	613,	613,	613,	613,	613,	613,	613,
	613,	613,	613,	613,	613,	613,	612,	613,
	612,	612,	612,	612,	612,	612,	612,	612,
	612,	612,	612,	612,	612,	612,	611,	612,
	611,	611,	611,	611,	611,	611,	611,	611,
	611,	611,	611,	611,	611,	611,	610,	611,
	610,	610,	610,	610,	610,	610,	610,	610,
	610,	610,	610,	610,	610,	610,	609,	610,
	609,	609,	609,	609,	609,	609,	609,	609,
	609,	609,	609,	609,	609,	609,	608,	609,
	608,	608,	608,	608,	608,	608,	608,	608,
	608,	608,	608,	608,	608,	608,	607,	608,
	607,	607,	607,	607,	607,	607,	607,	607,
	607,	607,	607,	607,	607,	607,	606,	607,
	606,	606,	606,	606,	606,	606,	606,	606,
	606,	606,	606,	606,	606,	606,	605,	606,
	605,	605,	605,	605,	605,	605,	605,	605,
	605,	605,	605,	605,	605,	605,	604,	605,
	604,	604,	604,	604,	604,	604,	604,	604,
	604,	604,	604,	604,	604,	604,	603,	604,
	603,	603,	603,	603,	603,	603,	603,	603,
	603,	603,	603,	603,	603,	603,	602,	603,
	602,	602,	602,	602,	602,	602,	602,	602,
	602,	602,	602,	602,	602,	602,	601,	602,
	601,	601,	601,	601,	601,	601,	601,	601,
	601,	601,	601,	601,	601,	601,	600,	601,
	600,	600,	600,	600,	600,	600,	600,	600,
	600,	600,	600,	600,	600,	600,	599,	600,
	599,	599,	599,	599,	599,	599,	599,	599,
	599,	599,	599,	599,	599,	599,	598,	599,
	598,	598,	598,	598,	598,	598,	598,	598,
	598,	597,	598,	597,	598,	597,	597,	597,
	597,	597,	597,	597,	597,	597,	597,	597,
	597,	596,	597,	596,	596,	596,	596,	596,
	596,	596,	596,	596,	596,	596,	596,	596,
	596,	595,	596,	595,	595,	595,	595,	595,
	595,	595,	595,	595,	594,	595,	594,	595,
	595,	595,	595,	594,	594,	594,	594,	593,
	594,	593,	594,	594,	594,	594,	593,	593,
	593,	593,	592,	593,	592,	593,	593,	593,
	593,	592,	592,	592,	592,	591,	592,	591,
	592,	592,	592,	592,	591,	591,	591,	591,
	590,	591,	590,	591,	591,	591,	591,	590,
	590,	590,	590,	588,	590,	588,	590,	590,
	590,	590,	588,	588,	588,	588,	587,	588,
	587,	588,	588,	588,	588,	587,	587,	587,
	587,	586,	587,	586,	587,	587,	587,	587,
	586,	586,	586,	586,	585,	586,	585,	586,
	586,	586,	586,	585,	585,	585,	585,	584,
	585,	584,	585,	585,	585,	585,	584,	584,
	584,	584,	583,	584,	583,	584,	584,	584,
	584,	583,	583,	583,	583,	582,	583,	582,
	583,	583,	583,	583,	582,	582,	582,	582,
	582,	582,	582,	582,	582,	582,	582,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570,	570,	570,	570,	570,	570,
	570,	570,	570
};

const int yyparser_t::yydaccpt[570] = {
-1,	100,	46,	58,	112,	114,	118,	111,
	119,	120,	113,	110,	1,	2,	117,	117,
	117,	48,	109,	4,	106,	106,	53,	52,
	55,	51,	51,	54,	56,	47,	59,	50,
	17,	93,	93,	92,	0,	91,	90,	65,
	64,	67,	66,	105,	103,	3,	105,	81,
	80,	79,	78,	77,	76,	75,	74,	73,
	72,	71,	70,	83,	82,	99,	89,	88,
	97,	98,	102,	101,	96,	95,	85,	69,
	90,	87,	86,	86,	46,	94,	94,	90,
	69,	12,	10,	12,	6,	24,	23,	35,
	34,	26,	25,	21,	28,	27,	22,	107,
	108,	120,	33,	40,	45,	44,	39,	38,
	30,	42,	43,	37,	36,	60,	32,	-1,
	60,	41,	14,	60,	13,	31,	49,	120,
	49,	19,	63,	63,	15,	15,	20,	49,
	18,	-1,	-1,	-1,	-1,	104,	57,	-1,
	-1,	7,	9,	-1,	-1,	-1,	-1,	94,
	-1,	-1,	-1,	-1,	120,	11,	11,	8,
	-1,	-1,	90,	116,	112,	115,	111,	5,
	120,	120,	120,	117,	60,	-1,	16,	-1,
	-1,	-1,	93,	-1,	-1,	93,	-1,	-1,
	-1,	-1,	-1,	120,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	120,	-1,	-1,	-1,
	-1,	94,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	120,	-1,	-1,	-1,	120,	-1,	-1,
	68,	-1,	16,	-1,	-1,	-1,	120,	120,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	54,	-1,	-1,	120,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	60,	60,	60,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	60,	60,	60,	60,
	60,	-1,	-1,	-1,	60,	60,	117,	-1,
	-1,	-1,	-1,	120,	117,	-1,	-1,	-1,
	60,	60,	-1,	60,	-1,	60,	60,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	60,	60,	63,	63,	60,	-1,	-1,	60,
	60,	60,	60,	60,	-1,	60,	60,	60,
	60,	-1,	117,	-1,	-1,	120,	-1,	-1,
	60,	60,	60,	84,	60,	60,	-1,	60,
	-1,	60,	60,	-1,	-1,	-1,	60,	117,
	61,	94,	60,	120,	60,	-1,	120,	-1,
	-1,	60,	60,	60,	49,	60,	60,	60,
	60,	60,	60,	60,	60,	60,	60,	60,
	60,	60,	60,	60,	60,	60,	60,	11,
	11,	-1,	-1,	87,	-1,	-1,	-1,	60,
	60,	60,	60,	60,	60,	60,	60,	60,
	60,	60,	60,	60,	60,	60,	60,	60,
	60,	-1,	-1,	-1,	-1,	-1,	118,	118,
	-1,	-1,	103,	-1,	60,	60,	60,	-1,
	120,	118,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	62,	57,	60,
	60,	60,	60,	60,	60,	60,	60,	60,
	63,	60,	-1,	60,	60,	60,	60,	60,
	60,	63,	60,	63,	60,	60,	60,	60,
	63,	60,	60,	60,	-1,	60,	60,	60,
	-1,	60,	60,	60,	60,	60,	60,	60,
	-1,	60,	-1,	-1,	-1,	-1,	-1,	-1,
	104,	120,	-1,	-1,	29,	94,	60,	60,
	60,	60,	11,	11,	11,	11,	11,	11,
	11,	11,	-1,	60,	60,	60,	60,	60,
	60,	60,	60,	60,	60,	60,	60,	60,
	60,	60,	60,	60,	60,	60,	60,	60,
	60,	60,	60,	60,	14,	60,	60,	60,
	-1,	60,	60,	60,	60,	60,	60,	60,
	60,	60,	-1,	11,	11,	11,	7,	11,
	-1,	-1,	-1,	-1,	90,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	120,	-1,	-1,
	-1,	93
};

// token map: token ID --> token index in token ID table
// in fact, it acts like inverse table of token ID table
const int yyparser_t::yyptmap[295] = {
0,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	44,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	50,	2,	2,	2,
	52,	53,	41,	42,	48,	57,	54,	51,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	58,	45,	47,	46,	43,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	55,	2,	56,	49,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	40,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	1,	2,	3,	4,	5,	6,	7,	8,
	9,	10,	11,	12,	13,	14,	15,	16,
	17,	18,	19,	20,	21,	22,	23,	24,
	25,	26,	27,	28,	29,	30,	31,	32,
	33,	34,	35,	36,	37,	38,	39
};
/*
// token ID table, containing token IDs
const int yyparser_t::yyptid[59] = {
0,	256,	257,	258,	259,	260,	261,	262,
	263,	264,	265,	266,	267,	268,	269,	270,
	271,	272,	273,	274,	275,	276,	277,	278,
	279,	280,	281,	282,	283,	284,	285,	286,
	287,	288,	289,	290,	291,	292,	293,	294,
	124,	42,	43,	63,	10,	60,	62,	61,
	44,	94,	36,	47,	40,	41,	46,	91,
	93,	45,	59
};
*/
// prnum table, its element is number of symbols in right part of corresponding grammar rule
const int yyparser_t::yyprnum[147] = {
2,	10,	0,	0,	0,	0,	1,	0,
	2,	0,	1,	1,	1,	1,	1,	2,
	2,	1,	3,	4,	3,	1,	1,	1,
	1,	5,	0,	1,	2,	1,	1,	1,
	1,	7,	0,	4,	3,	2,	1,	4,
	5,	5,	3,	3,	4,	2,	2,	2,
	1,	1,	1,	3,	3,	3,	3,	2,
	2,	2,	2,	1,	3,	4,	3,	0,
	2,	2,	3,	1,	3,	2,	1,	2,
	3,	1,	0,	1,	3,	1,	1,	1,
	2,	1,	1,	2,	2,	2,	3,	1,
	2,	1,	2,	2,	2,	2,	2,	2,
	2,	1,	3,	1,	1,	1,	2,	1,
	2,	3,	1,	1,	1,	1,	1,	1,
	3,	3,	1,	2,	1,	1,	3,	1,
	2,	0,	3,	2,	2,	1,	4,	0,
	2,	0,	5,	3,	4,	2,	3,	1,
	2,	0,	4,	2,	3,	1,	3,	1,
	1,	1,	1
};

// plid table, its element is the index of left part of corresponding grammar rule in token ID table
const int yyparser_t::yyplid[147] = {
28,	26,	31,	33,	36,	35,	35,	29,
	30,	30,	37,	37,	37,	37,	37,	37,
	37,	37,	39,	39,	39,	42,	42,	42,
	42,	43,	44,	43,	45,	45,	46,	46,
	46,	40,	47,	40,	40,	48,	48,	41,
	41,	41,	41,	41,	41,	27,	27,	27,
	27,	27,	27,	38,	38,	38,	38,	38,
	38,	38,	38,	38,	5,	5,	5,	32,
	32,	49,	49,	6,	6,	11,	0,	0,
	25,	25,	25,	23,	23,	24,	24,	22,
	22,	22,	20,	20,	20,	21,	19,	19,
	18,	18,	13,	13,	13,	13,	13,	13,
	13,	13,	14,	14,	12,	12,	17,	17,
	16,	16,	16,	15,	15,	15,	15,	15,
	3,	3,	2,	2,	1,	1,	1,	1,
	34,	34,	50,	50,	50,	4,	51,	52,
	51,	53,	7,	7,	7,	7,	7,	7,
	7,	7,	9,	9,	9,	9,	8,	8,
	10,	10,	10
};

// parse action table
const int yyparser_t::yypact[599] = {
212,	37,	77,	67,	29,	90,	14,	13,
	40,	33,	23,	74,	118,	24,	118,	215,
	357,	171,	125,	176,	33,	34,	35,	357,
	41,	105,	76,	17,	19,	18,	20,	21,
	34,	35,	15,	22,	42,	43,	73,	117,
	104,	174,	50,	357,	237,	36,	66,	180,
	30,	269,	47,	48,	38,	64,	60,	269,
	269,	61,	89,	269,	33,	45,	269,	357,
	46,	357,	103,	105,	57,	59,	79,	357,
	34,	35,	86,	87,	269,	269,	269,	269,
	269,	357,	104,	269,	269,	84,	80,	237,
	85,	357,	357,	357,	297,	54,	297,	62,
	63,	90,	81,	82,	357,	88,	357,	64,
	60,	214,	168,	61,	103,	214,	299,	297,
	299,	78,	132,	105,	133,	357,	57,	59,
	357,	299,	299,	169,	357,	299,	357,	357,
	357,	299,	104,	297,	93,	134,	357,	297,
	299,	299,	357,	357,	357,	297,	297,	54,
	297,	62,	63,	357,	357,	299,	97,	64,
	60,	299,	357,	61,	103,	105,	126,	299,
	299,	299,	299,	299,	299,	213,	57,	59,
	357,	284,	113,	357,	104,	284,	284,	357,
	357,	284,	357,	357,	64,	60,	357,	235,
	61,	292,	357,	292,	284,	284,	357,	54,
	357,	62,	63,	57,	59,	357,	103,	33,
	129,	357,	357,	357,	292,	357,	112,	357,
	357,	357,	284,	34,	35,	284,	357,	284,
	284,	298,	357,	298,	54,	357,	62,	63,
	90,	357,	235,	357,	298,	298,	357,	357,
	298,	138,	155,	156,	298,	64,	60,	93,
	357,	61,	357,	298,	298,	357,	357,	64,
	60,	357,	357,	61,	57,	59,	357,	357,
	298,	97,	357,	357,	298,	357,	57,	59,
	357,	357,	298,	298,	298,	298,	298,	298,
	357,	296,	137,	296,	357,	54,	357,	62,
	63,	357,	357,	357,	64,	60,	357,	54,
	61,	62,	63,	357,	296,	357,	357,	357,
	357,	275,	357,	57,	59,	275,	275,	357,
	357,	275,	275,	357,	357,	275,	357,	357,
	296,	151,	64,	60,	296,	357,	61,	357,
	275,	275,	296,	296,	54,	296,	62,	63,
	357,	357,	59,	284,	113,	357,	357,	284,
	284,	357,	275,	284,	357,	357,	275,	357,
	357,	275,	357,	275,	275,	357,	284,	284,
	357,	357,	159,	357,	62,	63,	276,	357,
	357,	357,	276,	276,	357,	357,	276,	276,
	112,	357,	276,	357,	284,	357,	151,	284,
	357,	284,	284,	357,	357,	276,	276,	294,
	357,	294,	357,	357,	64,	60,	357,	357,
	61,	357,	64,	60,	357,	357,	61,	276,
	357,	357,	294,	276,	59,	313,	276,	313,
	276,	276,	59,	333,	333,	357,	357,	333,
	313,	313,	357,	357,	313,	357,	343,	343,
	313,	357,	343,	171,	159,	333,	62,	63,
	313,	312,	159,	312,	62,	63,	357,	357,
	343,	357,	357,	202,	312,	312,	357,	357,
	312,	347,	347,	182,	312,	347,	357,	171,
	313,	357,	313,	313,	312,	357,	343,	357,
	357,	357,	189,	347,	357,	181,	186,	357,
	357,	345,	345,	357,	357,	345,	190,	191,
	343,	357,	357,	357,	312,	185,	312,	312,
	357,	347,	189,	345,	357,	357,	194,	357,
	357,	347,	347,	357,	357,	347,	190,	191,
	357,	357,	357,	347,	357,	193,	357,	357,
	357,	345,	189,	347,	357,	357,	186,	357,
	357,	346,	346,	357,	357,	346,	190,	191,
	341,	341,	357,	345,	341,	185,	357,	357,
	357,	347,	189,	346,	344,	344,	357,	357,
	344,	357,	341,	357,	357,	205,	190,	191,
	357,	357,	357,	347,	357,	189,	344,	357,
	357,	346,	357,	357,	357,	357,	357,	357,
	341,	190,	191,	357,	357,	357,	357,	357,
	357,	357,	357,	346,	344,	357,	357,	357,
	357,	357,	341,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	344
};

// base array for parse action table
// which is used to determine the base location of the entries
// for each state stored in the yypack table
const int yyparser_t::yypabase[209] = {
0,	0,	0,	0,	0,	-4,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	3,	0,	0,	0,	0,	0,	7,	45,
	41,	0,	0,	0,	2,	0,	0,	43,
	0,	0,	0,	0,	0,	-6,	-15,	69,
	0,	0,	0,	0,	69,	0,	0,	0,
	0,	57,	0,	91,	109,	0,	139,	0,
	0,	0,	0,	0,	0,	0,	0,	12,
	54,	161,	0,	0,	0,	0,	0,	0,
	-5,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	168,	0,	216,	0,	0,	0,
	0,	0,	0,	0,	-35,	102,	0,	0,
	0,	0,	144,	0,	0,	113,	0,	225,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	272,	0,	0,	0,
	0,	0,	0,	293,	0,	323,	0,	0,
	0,	235,	0,	184,	302,	0,	0,	0,
	0,	-8,	0,	0,	0,	0,	105,	0,
	354,	0,	0,	0,	0,	382,	404,	376,
	0,	0,	0,	182,	-3,	15,	0,	0,
	0,	0,	432,	0,	-6,	0,	0,	0,
	0,	411,	449,	0,	0,	0,	0,	0,
	473,	0,	0,	0,	0,	0,	0,	0,
	497,	0,	0,	0,	422,	521,	0,	0,
	528,	540,	0,	0,	0,	0,	0,	0,
	0
};

const int yyparser_t::yypgoto[35] = {
52,	92,	56,	56,	357,	51,	49,	52,
	92,	56,	56,	357,	51,	100,	52,	52,
	56,	56,	357,	124,	51,	139,	136,	52,
	357,	56,	160,	158,	51,	139,	154,	160,
	170,	160,	172
};

const int yyparser_t::yypgbase[209] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	-13,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	-12,	0,	0,	-6,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	1,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	2,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	-5,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	10,	0,	0,	11,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	18,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0
};

const by_te_t yyparser_t::yyvbmap[1672] = {
0,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	128,	0,	0,	0,	0,	0,	0,
	0,	128,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	2,	0,	2,	96,	0,	32,	0,	0,
	2,	0,	2,	96,	0,	32,	0,	0,
	2,	0,	2,	96,	0,	32,	0,	0,
	2,	0,	2,	96,	0,	32,	0,	0,
	2,	0,	2,	96,	0,	32,	0,	0,
	2,	0,	0,	0,	0,	32,	0,	0,
	2,	0,	2,	96,	0,	32,	0,	0,
	112,	76,	11,	128,	207,	128,	0,	0,
	2,	48,	1,	24,	0,	0,	208,	0,
	16,	51,	1,	24,	0,	32,	210,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	2,	0,	0,	0,	0,	16,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	0,	0,	2,	0,	0,	0,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	0,	0,	2,	0,	0,	0,	0,	0,
	0,	0,	2,	0,	0,	16,	0,	0,
	0,	0,	2,	0,	0,	66,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	96,	0,	9,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	2,	0,	0,	0,	0,	17,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	10,	48,	17,	24,	0,	17,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	0,	48,	1,	24,	0,	0,	208,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	0,	32,	0,	16,	0,	0,	64,	0,
	0,	32,	0,	16,	0,	0,	64,	0,
	16,	51,	1,	24,	0,	32,	210,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	0,	0,	0,	64,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	0,	0,	0,	0,	0,	64,	0,	0,
	0,	0,	2,	0,	0,	16,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	2,	0,	0,	16,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	0,	0,	0,	0,	0,	64,	0,	0,
	0,	0,	0,	0,	0,	64,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	0,	48,	1,	24,	0,	0,	208,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	0,	0,	0,	0,	0,	1,	32,	0,
	0,	32,	0,	16,	0,	0,	64,	1,
	0,	32,	0,	16,	0,	0,	64,	1,
	0,	32,	0,	16,	0,	0,	64,	1,
	0,	32,	0,	16,	0,	0,	64,	3,
	0,	32,	0,	16,	0,	0,	64,	1,
	0,	32,	0,	16,	0,	0,	64,	1,
	16,	0,	0,	0,	0,	0,	0,	0,
	16,	51,	1,	24,	0,	32,	210,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	49,	1,	24,	0,	0,	210,	0,
	128,	0,	2,	0,	0,	0,	0,	0,
	0,	49,	1,	24,	0,	0,	210,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	0,	0,	0,	64,	0,	0,
	0,	0,	0,	0,	0,	64,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	2,	0,	0,	16,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	0,	0,	0,	0,	0,	16,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	10,	48,	17,	24,	0,	17,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	0,	32,	0,	16,	0,	0,	64,	1,
	0,	0,	0,	16,	0,	0,	0,	0,
	10,	48,	145,	31,	0,	31,	252,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	16,	51,	17,	24,	0,	32,	210,	0,
	0,	0,	16,	0,	0,	0,	0,	0,
	0,	51,	1,	24,	0,	32,	210,	0,
	16,	51,	17,	24,	0,	32,	210,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	48,	1,	24,	0,	0,	208,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	1,	12,	0,
	0,	48,	1,	16,	0,	0,	208,	0,
	0,	0,	0,	0,	0,	64,	1,	0,
	0,	0,	0,	0,	0,	64,	1,	0,
	0,	0,	0,	0,	0,	64,	1,	0,
	0,	0,	0,	0,	0,	64,	1,	0,
	0,	0,	2,	96,	0,	0,	0,	0,
	0,	0,	2,	0,	0,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	0,	32,	0,	16,	0,	0,	64,	1,
	19,	0,	4,	0,	0,	0,	0,	0,
	16,	51,	17,	24,	0,	32,	210,	0,
	16,	51,	17,	24,	0,	32,	210,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	48,	1,	16,	0,	0,	208,	0,
	10,	48,	17,	16,	0,	0,	208,	0,
	10,	48,	145,	16,	0,	0,	208,	0,
	0,	48,	1,	16,	0,	0,	208,	0,
	10,	48,	145,	16,	0,	0,	240,	0,
	0,	49,	1,	24,	0,	0,	210,	0,
	128,	0,	2,	0,	0,	0,	0,	0,
	2,	0,	2,	96,	0,	16,	0,	0,
	0,	0,	2,	0,	0,	16,	0,	0,
	17,	0,	0,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	19,	0,	38,	96,	16,	1,	0,	4,
	0,	0,	0,	0,	0,	0,	0,	4,
	19,	0,	38,	96,	16,	1,	0,	4,
	10,	48,	145,	16,	0,	0,	208,	0,
	10,	48,	145,	16,	0,	0,	240,	0,
	0,	0,	128,	0,	0,	0,	32,	0,
	0,	0,	0,	0,	0,	64,	1,	0,
	16,	76,	2,	128,	207,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	0,	1,	0,	4,
	19,	0,	38,	96,	16,	1,	0,	4,
	19,	0,	4,	0,	0,	0,	0,	0,
	10,	48,	145,	16,	0,	0,	240,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	19,	0,	38,	96,	16,	1,	0,	4,
	19,	0,	4,	0,	0,	1,	0,	4,
	19,	0,	38,	96,	16,	1,	0,	4,
	0,	0,	8,	0,	0,	0,	0,	0,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	96,	16,	1,	0,	4,
	19,	0,	38,	96,	48,	1,	0,	4,
	19,	0,	38,	96,	48,	1,	0,	4,
	19,	0,	38,	96,	48,	1,	0,	4,
	19,	0,	38,	96,	48,	1,	0,	4,
	19,	0,	38,	96,	16,	1,	0,	4,
	0,	0,	8,	0,	0,	0,	0,	0,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	96,	16,	1,	0,	4,
	19,	0,	36,	0,	0,	1,	0,	4,
	19,	0,	6,	96,	0,	1,	0,	4,
	0,	0,	2,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	0,	1,	0,	4,
	19,	0,	36,	0,	0,	1,	0,	4,
	19,	0,	6,	96,	0,	1,	0,	4,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	96,	16,	1,	0,	4,
	19,	0,	38,	96,	16,	1,	0,	4,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	96,	16,	1,	0,	4,
	19,	0,	4,	0,	0,	1,	0,	4,
	19,	0,	4,	0,	0,	1,	0,	4
};

const int yyparser_t::yyparv[209] = {
357,	217,	4,	219,	210,	357,	25,	218,
	220,	221,	222,	223,	224,	26,	27,	227,
	357,	231,	232,	233,	234,	357,	357,	357,
	357,	273,	225,	226,	357,	68,	69,	357,
	239,	240,	241,	242,	71,	357,	357,	357,
	83,	258,	259,	260,	357,	265,	266,	267,
	268,	357,	91,	357,	357,	307,	357,	309,
	310,	311,	317,	318,	319,	320,	321,	357,
	357,	357,	228,	114,	230,	236,	238,	244,
	357,	246,	248,	119,	120,	121,	252,	122,
	255,	256,	257,	253,	261,	262,	263,	264,
	270,	123,	357,	272,	357,	300,	301,	302,
	303,	304,	305,	306,	357,	357,	324,	326,
	327,	329,	357,	130,	274,	357,	277,	357,
	143,	283,	229,	145,	146,	245,	247,	249,
	147,	148,	254,	271,	357,	308,	322,	325,
	149,	323,	331,	357,	134,	357,	280,	279,
	289,	357,	291,	357,	357,	161,	285,	287,
	288,	357,	74,	250,	251,	328,	357,	281,
	357,	278,	290,	293,	295,	357,	357,	357,
	316,	282,	143,	357,	357,	357,	330,	339,
	179,	335,	357,	314,	357,	286,	243,	211,
	216,	357,	357,	334,	315,	332,	337,	338,
	357,	196,	197,	351,	353,	354,	355,	356,
	357,	200,	201,	349,	357,	357,	204,	336,
	357,	357,	207,	350,	352,	208,	348,	342,
	340
};


const int yyparser_t::yyparn[209] = {
32,	0,	0,	0,	0,	32,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	0,	32,	32,	32,
	32,	0,	0,	0,	32,	0,	0,	32,
	0,	0,	0,	0,	0,	32,	32,	32,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	32,	0,	32,	32,	0,	32,	0,
	0,	0,	0,	0,	0,	0,	0,	32,
	32,	32,	0,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	32,	0,	32,	0,	0,	0,
	0,	0,	0,	0,	32,	32,	0,	0,
	2,	0,	32,	0,	0,	32,	0,	32,
	2,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	32,	0,	0,	0,
	0,	0,	0,	32,	0,	32,	0,	0,
	0,	32,	0,	32,	32,	2,	0,	0,
	0,	32,	0,	0,	0,	0,	32,	0,
	32,	0,	0,	0,	0,	32,	32,	32,
	0,	0,	2,	32,	32,	32,	0,	0,
	0,	0,	32,	0,	32,	0,	0,	0,
	0,	32,	32,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	2,	0,	0,	0,
	32,	0,	0,	0,	32,	32,	0,	0,
	32,	32,	0,	0,	0,	0,	0,	0,
	0
};

const int yyparser_t::yypcv[113] = {
357,	357,	357,	357,	357,	357,	357,	144,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	94,	95,	96,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	198,	357,	357,
	357,	357,	98,	99,	357,	357,	75,	44,
	162,	357,	357,	357,	357,	357,	357,	357,
	357,	128,	357,	357,	102,	357,	58,	167,
	9,	109,	357,	187,	184,	188,	357,	55,
	357,	53,	357,	357,	157,	357,	357,	357,
	140,	135,	141,	142,	111,	2,	357,	357,
	3,	357,	6,	357,	107,	357,	357,	165,
	7,	8,	10,	11,	12,	16,	28,	357,
	357,	32,	357,	357,	108,	166,	177,	357,
	178
};

const int yyparser_t::yypcn[113] = {
32,	32,	32,	32,	32,	32,	32,	1,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	1,	1,	1,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	1,	32,	32,
	32,	32,	1,	1,	32,	32,	3,	1,
	1,	32,	32,	32,	32,	32,	32,	32,
	32,	1,	32,	32,	1,	32,	1,	1,
	1,	1,	32,	3,	1,	1,	32,	1,
	32,	1,	32,	32,	1,	32,	32,	32,
	1,	1,	1,	1,	1,	1,	32,	32,
	1,	32,	1,	32,	1,	32,	32,	1,
	1,	1,	1,	1,	1,	1,	1,	32,
	32,	1,	32,	32,	1,	1,	1,	32,
	1
};


const int yyparser_t::yypgrv[209] = {
357,	357,	357,	5,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	31,	357,	357,	357,	357,	357,	39,	357,
	357,	65,	357,	357,	357,	357,	357,	70,
	357,	357,	357,	357,	357,	72,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	101,
	106,	110,	357,	357,	357,	115,	357,	116,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	127,	357,	357,
	357,	357,	127,	357,	357,	131,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	150,	357,	152,	153,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	163,	164,	357,	357,	357,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	173,	70,	357,	175,	357,	357,
	357,	357,	357,	357,	357,	357,	357,	357,
	357,	357,	183,	357,	357,	357,	192,	357,
	195,	357,	357,	357,	357,	357,	357,	357,
	199,	357,	357,	357,	357,	203,	357,	357,
	357,	206,	357,	357,	357,	357,	357,	357,
	357
};

const int yyparser_t::yypgrn[209] = {
32,	32,	32,	0,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	2,	32,	32,	32,	32,	32,	0,	32,
	32,	0,	32,	32,	32,	32,	32,	0,
	32,	32,	32,	32,	32,	0,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	2,
	2,	2,	32,	32,	32,	0,	32,	0,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	0,	32,	32,
	32,	32,	0,	32,	32,	0,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	0,	32,	0,	2,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	2,	0,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	0,	0,	32,	0,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	4,	32,	32,	32,	0,	32,
	2,	32,	32,	32,	32,	32,	32,	32,
	4,	32,	32,	32,	32,	2,	32,	32,
	32,	2,	32,	32,	32,	32,	32,	32,
	32
};

const std::unordered_map<std::string, int> yyparser_t::yyslexemID{

};


// get global parser object,
// it's invisiable to user
static yyparser_t& getTheParser(void) {

	static yyparser_t yyp(yylex);
	return yyp;
}

// assign new log stream
void yysetstream(FILE *poutput, FILE *plogger) {

	yyparser_t& yyp = getTheParser();
	yyp.yyoutput = poutput;
	yyp.yylogger = plogger;
}

void yyemit_error__(const char *s, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
	yyparser_t& yyp = getTheParser();
	if(yyp.yylogger) 
		fprintf(yyp.yylogger, "%s\n", s);
}

// assign new error-reporter and return the old one
yyerror_t yyseterror(yyerror_t perror) {

	yyparser_t& yyp = getTheParser();
	yyerror_t pold = yyp.yyerror;
	yyp.yyerror = perror;

	return pold;
}

// reset all (both scanner and parser, if they are available)
void yyclearall(void) {
	getTheParser().yyclearall__();
}


// initializing file buffer before parsing or patter-matching
int yylexfile(const char* pchFile, bool iMod) {
	
	return getTheParser().yylexinit__(pchFile, iMod)? 0: -1;
}
// initializing string buffer before parsing or patter-matching
int yylexstr(char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}
// initializing const string buffer before parsing or patter-matching
int yylexcstr(const char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}

// generated scanner, can be replaced
int yylex(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {

	return getTheParser().yylex__(lexer, dtbl, grammar, ptbl, dmap, gsetup);
} 

// assign new scanner and return the old one 
yylex_t yysetlex(yylex_t plex) {
	
	yyparser_t& yyp = getTheParser();
	yylex_t pold = yyp.yylexer;
	yyp.yylexer = plex;

	return pold;
}

// generated parser, it should not be replaced
int yyparse(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
	return getTheParser().yyparse__(lexer, dtbl, grammar, ptbl, dmap, gsetup);
}
} // namspace

#line 3196 "meta/ulyac.upg"


int debug_yyparse(lexer_ns::lexer_t &lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {

    int nRet = yynsx::yyparse(lexer, dtbl, grammar, ptbl, dmap, gsetup);
	
	return nRet;
}

#line 8879 "gcode/ulyac.cpp"


