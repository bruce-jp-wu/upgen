/*******************************************************************************
A parser program in C++, generated by Upgen 0.5.1.
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
typedef unsigned char by_te_t;

class bufbase_t;
typedef bufbase_t *YYPBUFFER;

#include "./ulyac.h"

#line 43 "../meta/ulyac.upg"

/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2016  Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#ifdef UPGEN_TEST_VERSION
#include <iostream>
using std::cerr;
using std::endl;
#endif

#include "../common/common.h"
#include "../common/reporter.h"
#include "../common/action.h"
using common_ns::action_t;


#include "../coder/metakeys.h"
#include "../common/strhelper.h"
using common_ns::strhelper_t;

#include "../lexer/retree.h"
using lexer_ns::renode_t;
using lexer_ns::retree_t;
using lexer_ns::rnpool_t;
using lexer_ns::rtpool_t;

#include "../parser/prod.h"
using parser_ns::prod_t;
#include "../parser/symbol.h"
using parser_ns::symbol_t;

#define CRET		{return yytext[0];}

#define ESC2CHAR(text, y)		switch(text[1])	{	\
		case '0': y = '\0';	break;		\
		case 'a': y = '\a'; break;		\
		case 'b': y = '\b'; break;		\
		case 'f': y = '\f'; break;		\
		case 'n': y = '\n'; break;		\
		case 'r': y = '\r'; break;		\
		case 't': y = '\t'; break;		\
		case 'v': y = '\v'; break;		\
		case '?': y = '\?'; break;		\
		default: y = text[1]; break;	\
		}

#define NULL_ACTION(x)

#define PROCESS_ACTION_1(C, CH1, CH2, ACT) {\
	C = yyinput();\
	while(C && C != END_OF_FILE){\
		if(CH1 == C) {\
			C = yyinput();\
			if(CH2 == C) {\
				break;\
			}\
			else {\
				ACT(CH1);\
			}\
		}\
		if(C != CH1) {\
			ACT((char)C);\
			C = yyinput();\
		}\
	}\
}

#define PROCESS_UNTIL(C, CH1, CH2, CE, ACT) {\
	C = yyinput();\
	while(C && C != END_OF_FILE){\
		if(CE == C) {\
			C = yyinput();\
			if('$' == C) {\
				C = yyinput();\
				if('$' == C || '<' == C || (C >= '0' && C <= '9')) {\
					ACT('$');\
					ACT(C);\
					C = yyinput();\
				}\
				else {\
					ACT(CE);\
					ACT('$');\
				}\
			}\
			else if('@' == C) {\
				C = yyinput();\
				if('$' == C || (C >= '0' && C <= '9')) {\
					ACT('@');\
					ACT(C);\
					C = yyinput();\
				}\
				else {\
					ACT(CE);\
					ACT('@');\
				}\
			}\
			else if(CH1 == C) {\
				C = yyinput();\
				if(CH2 == C) {\
					ACT(CH1);\
					ACT(CH2);\
					C = yyinput();\
				}\
				else {\
					ACT(CE);\
					ACT(CH1);\
				}\
			}\
			else {\
				ACT(CE);\
			}\
		}\
		else {\
			if(CH1 == C) {\
				C = yyinput();\
				if(CH2 == C) {\
					break;\
				}\
				else {\
					ACT(CH1);\
				}\
			}\
			if(C != CH1 && C != CE) {\
				ACT((char)C);\
				C = yyinput();\
			}\
		}\
	}\
}

#define LEX_PUSH_STATE(x)	yy_push_state(x)
#define LEX_POP_STATE()		yy_pop_state()
#define LEX_BEGIN(x)		YYBEGIN(x)

#define FAKE_TYPE		"$FAKE_TYPE"

static action_t *sn_pactDefHeader = nullptr;
static action_t *sn_pactDeclHeader = nullptr;
static int sn_nVarDeclInit = -1;



#line 178 "ulyac.cpp"

#define	INC_YYTEXT_SIZE		4096
#define LINESIZE_STACK_LENG	32
#define TABSIZE_STACK_LENG	64
#define END_OF_FILE			256
#define END_OF_ALLFILE		257

// start-condition names
#define INITIAL 0
#define OPT_SC 2
#define MAC_SC 4
#define LEX_SC 6
#define SCR_SC 8
#define CSH_SC 10
#define XISC_SC 12
#define TOK_SC 14
#define TYP_SC 16
#define PRS_SC 18
#define PACT_SC 20
#define DSCRD_SC 22
#define PLVAR_SC 24

// number of DFA states of scanner
#define LEX_STATE_COUNT   557

// DFA trap-state of scanner
#define LEX_ERROR_STATE    0

// ID of invalid rule for scanner,
// indicating current string can not be matched by any pattern
#define LEX_ERROR_RULE    -1

// this constant used by computing index of a rule that matches EOF
// for example, in start-condition INITIAL, index of the rule that
// matches EOF is 
//	LEX_EOFRULE_BASE + INITIAL
#define LEX_EOFRULE_BASE   120

// index of the rule that matches EOAF (end of all files, or end of input)
#define LEX_EOAF_RULE   133


// index of symbol `$end' in symbol table
#define PARSE_ENDSYMB_INDEX   0
// index of symbol `error' in symbol table
#define PARSE_ERRORSYMB_INDEX   1
// index of symbol `$undef' in symbol table
#define PARSE_UNDEFSYMB_INDEX   2

// ID of symbol `$end'
#define PARSE_ENDSYMB_ID   0
// ID of symbol `error'
#define PARSE_ERRORSYMB_ID   256
// ID of symbol '$undef'
#define PARSE_UNDEFSYMB_ID   257

// row size(in byte) of non-error bitmap of parse table
#define PARSE_BMAP_ROWSIZE	8
// base address of indexes of types (aka non-terminals or variables)
#define PARSE_TYPE_BASE   58
// number of symbols in parser
#define PARSE_SYMBOL_COUNT   112

// number of symbols in parser
#define PARSE_TOKENMAP_SIZE   294

// start state of parser
#define PARSE_START_STATE   1

// accept state of parser
#define PARSE_ACCEPT_STATE   4

// illegal state for parser
#define PARSE_ERROR_STATE   205

// special ID of invalid rule for parser, indicating current lookahead
// symbol can not be shifted
#define PERROR_RULE   143

#define	MAX_MSG_LENG 		128

// macros for wrapped new operator
#define MYNEW(var, type) {\
	var = new type;\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYNEWS(var, type, size) {\
	var = new type[size];\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYRENEW(var, type, size, osize) {\
	type *p = new type[size];\
	if(!p) {\
		exit_on_oom();\
	}\
	memcpy(p, var, sizeof(type) * osize);\
	delete[] var;\
	var = p;\
}

// error IDs
enum {
	// grammar is accepted by automation
	YYE_ACCEPT =	1,
	// indicate automation is alive
	YYE_ALIVE =	2,
	// run out of all buffers,
	// and token `$end' will be sent to parser
	YYE_EOS =	3,
	// lexical analysis terminated manually,
	// and token `$end' will be sent to parser
	YYE_TERM =	3,
	// syntactic error occurs, and try to error-recover
	YYE_PERROR =	4,

	// can not match any pattern, token `$undef' will
	// be sent to parser
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID,

	// out of memory
	YYE_OOM = 	-1,
	// out of range
	YYE_OOR =	-2,
	// I/O error
	YYE_IO =	-3,
	// parsing aborted
	YYE_ABORT = 	-4,
	YYE_NOINPUT =	-5,
};


template<class INT_TYPE, int STACK_SIZE>
class cycstack_t {

public:
	inline cycstack_t(void)
	: m_nBase(0)
	, m_nTop(0) {
	}
	inline void push(INT_TYPE a_nSize) {
		m_nTop = (m_nTop + 1) % STACK_SIZE;
		m_nElem[m_nTop] = a_nSize;
		if(m_nTop == m_nBase) {
			m_nBase = (m_nTop + 1) % STACK_SIZE;
		}
	}
	inline INT_TYPE pop(void) {
		if(m_nTop != m_nBase) {
			INT_TYPE sz = m_nElem[m_nTop];
			m_nTop = (m_nTop + STACK_SIZE - 1) % STACK_SIZE;
			return sz;
		}
		return 0;
	}
	inline void clear(void) {
		m_nTop = m_nBase;
	}	
private:
	INT_TYPE m_nElem[STACK_SIZE];
	short m_nBase, m_nTop;
};

class bufbase_t {

public:
	virtual ~bufbase_t(void){}
	virtual int get(void) = 0;
	virtual int peek(void) = 0;
	virtual int unget(void) = 0;
	virtual int unget(int num) = 0;
	virtual int put(char) = 0;

	inline void reset(void) {
		xreset();
		stlsz.clear();
		sttsz.clear();
	}
	inline bool iseof(void) const { return gptr == gend;}
	inline bool iseos(void) const { return eos;	}
	inline bool isimod(void) const { return imod;}
	inline void setimod(bool bi) { imod = bi;}
	inline int getlineno(void) const { return line;}
	inline void setlineno(int nline) { line = nline;}
	inline int getcolno(void) const { return col;}
	inline void setcolno(int ncol) { col = ncol;}
	inline int gettabsize(void) const { return tab;}
	inline void settabsize(int ntab) { tab = (ntab > 0)? ntab : 1;}

	inline void* getdata(void) const { return pvoid; }
	inline void setdata(void* pv) { pvoid = pv; }
protected:
	virtual void xreset(void) = 0;

	by_te_t *pbase;
	by_te_t *gptr;
	by_te_t *gend;
	bool eos;
	// interactive mode
	bool imod;
	int line;
	int col;
	int tab;
	
	void *pvoid;

public:
	inline void pushlsz(int nlsize) {
		stlsz.push((short)nlsize);
	}
	inline int poplsz(void) {
		return stlsz.pop();
	}
	inline void pushtsz(int ntsize) {
		sttsz.push((by_te_t)ntsize);
	}
	inline int poptsz(void) {
		return sttsz.pop();
	}
protected:
	cycstack_t<short, LINESIZE_STACK_LENG> stlsz;
	cycstack_t<by_te_t, TABSIZE_STACK_LENG> sttsz;

};

xstype_t yylval;
xltype_t yylloc;


// program abort due to out of memory
inline static void exit_on_oom(void) {
	exit(-1);
}
static char stext__[24] = "unprintable-char{";
inline static const char* sym_text__(const char* ps) {
	
	by_te_t b = (by_te_t)*ps, i = 17, t;
	if( !ps[1] && (b < 32 || b >= 127)) {
		if((t = b / 100) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 100;
		}
		if((t = b / 10) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 10;
		}
		stext__[i++] = (char)(b + 48);
		stext__[i++] = '}';
		stext__[i] = '\0';
		return stext__;
	}
	return ps;
}

class yyparser_t {

	friend yyerror_t yyseterror(yyerror_t);
	friend yylex_t yysetlex(yylex_t);

private:

	// class bufmgr_t class define HERE
	class bufmgr_t {

	public:

		enum {
			// half size of buffer
			BUF_HALF_SIZE = 4096,
			// fullsize of buffer
			BUF_FULL_SIZE = BUF_HALF_SIZE * 2
		};

	private:
		class filebuf_t: public bufbase_t {

			friend class bufmgr_t;
		private:

			inline void init(void) {

				gptr = pbase = &buf[BUF_FULL_SIZE - 1];
				gend = &buf[0];
				eos = false;
				bpeeked = false;
			}

		public:

			filebuf_t(FILE* pf = stdin)
			: pfile(pf) {
				imod = (pf == stdin);
				line = 1;
				col = 1;
				tab = 4;
				pvoid = nullptr;
				init();
			}

			virtual ~filebuf_t(void) {

				if(pfile != stdin) {

					fclose(pfile);
				}
			}

			virtual void xreset(void) {

				if(pfile != stdin) {
					fseek(pfile, 0, SEEK_SET);
				}
				init();
			}

			virtual int get(void) {

				if(gptr == gend) {

					eos = true;
					return END_OF_ALLFILE;
				}

				gptr = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(gptr == gend && !bpeeked) {

					fill(gptr);
				}

				bpeeked = false;

				return iseof()? END_OF_FILE: (int)(*gptr);
			}

			virtual int peek(void) {

				if(gptr == gend) {

					return END_OF_ALLFILE;
				}

				by_te_t *p = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(p == gend) {

					fill(p);
				}

				bpeeked = true;

				return (p == gend)? END_OF_FILE: (int)(*p);
			}

			virtual int unget(void) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

			virtual int unget(int num) {

				if(eos || gptr == pbase) {
					return 0;
				}
				int n = ((gptr - pbase) + BUF_FULL_SIZE) % BUF_FULL_SIZE;

				if(n > num) {
					n = num;
				}
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - n) % BUF_FULL_SIZE;

				return n;
			}
		
			virtual int put(char c) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				*gptr = (by_te_t)c;
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

		private:

			int fill(by_te_t *p) {

				int ncnt = 0;
				int vacents = ((pbase + BUF_FULL_SIZE) - gend) % BUF_FULL_SIZE;
				if(stdin != pfile) {
					while((ncnt = fread(p, 1, BUF_HALF_SIZE, pfile)) == 0 && ferror(pfile)) {
						if(errno != EINTR) {
							// IO error
							return 0;
						}
						clearerr(pfile);
						errno = 0;
					}
					gend = buf + (p - buf + ncnt) % BUF_FULL_SIZE;
				}
				else {
					for(int c = 0; '\n' !=  c && ncnt < BUF_HALF_SIZE;
						gend = buf + ((gend - buf) + 1) % BUF_FULL_SIZE, ++ncnt) {

						c = fgetc(stdin);
						*gend = (by_te_t)c;
						if(EOF == c && feof(pfile)) {
							break;
						}
					}
				}
				if(ncnt > vacents) {
					pbase = buf + ((gend - buf) + 1) % BUF_FULL_SIZE;
				}
				return ncnt;
			}

		private:

			bool bpeeked;
			FILE *pfile;
			by_te_t buf[BUF_FULL_SIZE];
		};

	private:

		class strbuf_t: public bufbase_t {

			friend class bufmgr_t;
		public:

			// nSize is length of string including terminating nullptr
			strbuf_t(const char *pchBuf, int nSize)
			: bowner(true) {

				MYNEWS(pbase, by_te_t, nSize);
				memcpy(pbase, pchBuf, sizeof(char)*(nSize - 1));
				pbase[nSize - 1] = '\0';

				gend = pbase + nSize - 1;
				xreset();
				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = nullptr;
			}

			strbuf_t(char *pchBuf, int nSize)
			: bowner(false) {

				pbase = (by_te_t*)pchBuf;
				gend = pbase + nSize - 1;
				xreset();

				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = nullptr;
			}

			virtual ~strbuf_t(void) {
				if(bowner) {
					delete [] pbase;
				}
			}

		public:

			virtual void xreset(void) {

				gptr = pbase - 1;
				eos = false;
			}
			virtual int get(void) {

				if(gptr == gend) {
					eos = true;
					return END_OF_ALLFILE;
				}
				++gptr;

				return (gptr == gend)? END_OF_FILE : (int)(*gptr);
			}

			virtual int peek(void) {

				return (gptr == gend) ? (eos ? END_OF_ALLFILE: END_OF_FILE) : 
					(int)(*(gptr + 1));
			}
			virtual int unget(void) {
				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}
				return (int)(*gptr--);
			}
			virtual int unget(int num) {

				if(eos || (pbase - 1 == gptr)) {
					return 0;
				}
				int n = gptr - pbase + 1;
				if(n > num) {
					n = num;
				}
				gptr -= n;

				return n;
			}

			virtual int put(char c) {

				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);

				*gptr-- = (by_te_t)c;

				return oldc;
			}

		private:
			bool bowner;
		};

	private:

		struct link_t {

			link_t(bufbase_t *pxb, link_t *plnk = nullptr)
			: pxbuf(pxb)
			, plink(plnk){}

			bufbase_t *pxbuf;
			link_t *plink;
		};

	public:

		bufmgr_t(void)
		: phead(nullptr) {

			MYNEW(pstdin, filebuf_t);
			MYNEW(pavail, link_t(pstdin, nullptr));
		}
		~bufmgr_t(void) {

			while(pavail) {

				link_t *p = pavail->plink;

				delete pavail->pxbuf;
				delete pavail;

				pavail = p;
			}			
		}

	public:

		inline int get(void) {
			return phead? phead->pxbuf->get(): END_OF_ALLFILE;
		}
		inline int peek(void) {
			return phead? phead->pxbuf->peek(): END_OF_ALLFILE;
		}
		inline int unget(void) {
			return phead? phead->pxbuf->unget(): END_OF_FILE;
		}
		inline int unget(int num) {
			return phead? phead->pxbuf->unget(num): 0;
		}
		inline int put(char c) {
			return phead? phead->pxbuf->put(c): END_OF_FILE;
		}
		inline bool iseof(void) const {
			return phead? phead->pxbuf->iseof(): true;
		}
		inline bool iseos(void) const {
			return phead? phead->pxbuf->iseos(): true;
		}
		inline bool isimod(void) const {
			return phead? phead->pxbuf->isimod(): false;
		}
		inline int getlineno(void) const {
			 return phead? phead->pxbuf->getlineno(): 0;
		}
		inline void setlineno(int nline) {
			if(phead) {
				phead->pxbuf->setlineno(nline);
			}
		}
		inline int getcolno(void) const {
			return phead? phead->pxbuf->getcolno(): 0;
		}
		inline void setcolno(int ncol) {
			if(phead) {
				phead->pxbuf->setcolno(ncol);
			}
		}
		inline int gettabsize(void) const {
			return phead? phead->pxbuf->gettabsize(): 0;
		}
		inline void settabsize(int ntab) {
			if(phead) {
				phead->pxbuf->settabsize(ntab);
			}
		}
		inline void reset(void) {
			if(phead) {
				phead->pxbuf->reset();
			}
		}
		inline void pushlsz(int nlsize) {
			if(phead) {
				phead->pxbuf->pushlsz(nlsize);
			}
		}
		inline int poplsz(void) {
			if(phead) {
				return phead->pxbuf->poplsz();
			}
			return 0;
		}
		inline void pushtsz(int ntsize) {
			if(phead) {
				phead->pxbuf->pushtsz(ntsize);
			}
		}
		inline int poptsz(void) {
			if(phead) {
				return phead->pxbuf->poptsz();
			}
			return 0;
		}


		inline bufbase_t* current(void) const {
			return phead ? phead->pxbuf : nullptr;
		}

		inline bool empty(void) const {
			return ! phead;
		}

		inline bufbase_t* newbuf(FILE *pfile, bool iMod = false) {

			bufbase_t *p;
			if(pfile == stdin) {
				p = pstdin;
				p->reset();
			}
			else {
				MYNEW(p, filebuf_t(pfile));
				MYNEW(pavail->plink, link_t(p, pavail->plink));
			}
			
			p->setimod(iMod);
			
			return p;
		}
		inline bufbase_t* newbuf(char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		inline bufbase_t* newbuf(const char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		
		inline bufbase_t* switchto(bufbase_t* pbuf) {

			bufbase_t *pold = phead ? phead->pxbuf : nullptr;
			link_t* p = rmwork(pbuf);
			if( ! p) {
				MYNEW(phead, link_t(pbuf, phead));
			}
			else {
				p->plink = phead;
				phead = p;
			}
			
			return pold;
		}
		
		inline bufbase_t* pop(void) {
			
			if(! phead) {
				return nullptr;
			}
			
			link_t *p = phead;
			bufbase_t* pbuf = p->pxbuf;
			phead = phead->plink;
			
			delete p;
			
			return pbuf;
		}

		void destroytop(void) {
			
			bufbase_t *pxb = pop();
			if( pxb && pxb != pstdin) {

				link_t *p = pavail;
				
				while(p->plink && p->plink->pxbuf != pxb) {
					p = p->plink;
				}
				if(p->plink) {
					link_t *q = p->plink;
					p->plink = q->plink;

					delete pxb;
					delete q;
				}
			}
		}
		
		void destroyall(void) {

			while(pavail->plink) {
				link_t *p = pavail->plink;
				pavail->plink = p->plink;
				if(p->pxbuf) {
					delete p->pxbuf;
				}
				delete p;
			}
			
			phead = nullptr;
		}

	private:

		link_t* rmwork(bufbase_t* pxb) {

			link_t *p = phead;
			// then check if @pxb is in the list, if so, then remove it
			if(p) {

				if(pxb == phead->pxbuf) {
					phead = phead->plink;
					return p;
				}
				else {
					while(p->plink && p->plink->pxbuf != pxb) {
						p = p->plink;
					}
					if(p->plink) {
						link_t *q = p->plink;
						p->plink = q->plink;
						return q;
					}
				}
			}

			return nullptr;
		}

	private:

		// working buffer stack
		link_t *phead;
		// available buffer stack
		link_t *pavail;
		// stdin buffer
		bufbase_t *pstdin;
	};


	template<class ElemType, int INIT_SIZE = 4096, int INC_SIZE = 1024>
	class sstack_t {
	private:
		ElemType *pbase;
		int size;
		int ntop;

	public:
		inline sstack_t(void)
		: pbase(nullptr)
		, size(INIT_SIZE)
		, ntop(-1) {
			MYNEWS(pbase, ElemType, INIT_SIZE);
		}
		inline ~sstack_t(void) {
			if(pbase) {
				delete[] pbase;
			}
		}

		inline void push(void) {
			if(ntop == size - 1) {
				MYRENEW(pbase, ElemType, INC_SIZE + size, size);
				size += INC_SIZE;
			}
			++ntop;
		}
		inline void push(const ElemType &e) {
			if(ntop == size - 1) {
				MYRENEW(pbase, ElemType, INC_SIZE + size, size);
				size += INC_SIZE;
			}
			pbase[++ntop] = e;
		}
		inline ElemType& top(void) {
			return pbase[ntop];
		}
		inline const ElemType& top(void) const {
			return pbase[ntop];
		}
		inline void pop(int n) {
			ntop -= n;
		}
		inline ElemType& operator[](int down) {
			return pbase[ntop - down];
		}
		inline const ElemType& operator[](int down) const {
			return pbase[ntop - down];
		}

		inline bool empty(void) const {
			return ntop < 0;
		}

		inline int count(void) const {
			return ntop + 1;
		}

		inline void clear(void) {
			ntop = -1;
		}
	};


private:

	inline void renew_text__(void) {

		MYRENEW(yytext, char, INC_YYTEXT_SIZE + yysize__, yysize__);
		yysize__ += INC_YYTEXT_SIZE;
		yytext[yysize__ - 1] = '\0';
	}

	inline bool yylex_is_running__(void) const {
		return yyecode__ == YYE_ALIVE;
	}
	inline int yyget_lexrule__(int s) const{
		return yydaccpt[s];
	}

	int yynext_lexstate__(int s, int c) const {

		int d = yydcmap[c];
		while(s < LEX_STATE_COUNT && yydchk[ yydbase[s] + d] != s) {
			s = yyddef[s];
		}

		if(s > LEX_STATE_COUNT) {
			return yydchk[yydbase[s] + yydmeta[d]] == s?
				yydnxt[ yydbase[s] + yydmeta[d]] : LEX_ERROR_STATE;
		}
		else {
			return yydnxt[ yydbase[s] + d];
		}
	}

	inline static void yyemit_error__(const char *s, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
		fprintf(stderr, "%s\n", s);
	}

private:

	inline void YYACCEPT(void) {
		yyecode__ = YYE_ACCEPT;
	}
	inline void YYABORT(void) {
		yyecode__ = YYE_ABORT;
	}
	inline void yyerrok(void) {
		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;
	}

	inline bool yyparse_is_running__(int s) const {
		return yyecode__ > YYE_ACCEPT && s != PARSE_ACCEPT_STATE;
	}
	inline int yyget_defrule(int s) const {
		if(0 == yyparn[s] && is_valid_prule__(yyget_prule__(yyparv[s])) ) {
			return yyget_prule__(yyparv[s]);
		}
		return PERROR_RULE;
	}
	inline bool is_valid_pstate__(int s) const {
		return s < PARSE_ERROR_STATE;
	}
	inline bool is_valid_prule__(int r) const {
		return r >= 0 && r < PERROR_RULE;
	}
	inline int yyget_prule__(int s) const {
		return s - (PARSE_ERROR_STATE + 1);
	}
	inline void yydiscard__(xstype_t &yydval, xltype_t  &yydloc, int yydsymb, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
	
	}
	inline int yynext_pstate__(int s, int t) const {
		if(yyvbmap[s * PARSE_BMAP_ROWSIZE + t / 8] & (1 << (t % 8))) {
			if(yyparn[s] < yypcn[t]) {
				return yyparv[s];
			}
			else if(yyparn[s] > yypcn[t]) {
				return yypcv[t];
			}
			return yypact[yypabase[s] + t];
		}
		return PARSE_ERROR_STATE;
	}
	inline int yynext_goto__(int s, int t) const {
		if(yypgrn[s] < yypcn[PARSE_TYPE_BASE + t]) {
			return yypgrv[s];
		}
		else if(yypgrn[s] > yypcn[PARSE_TYPE_BASE + t]) {
			return yypcv[PARSE_TYPE_BASE + t];
		}
		return yypgoto[yypgbase[s] + t];
	}

public:

	inline yyparser_t(yylex_t plex = nullptr)
	: yyecode__(YYE_ALIVE)
	, yysize__(0)
	, yystart__(INITIAL)
	, yymore_flag__(false)
	, yyat_bol__(true)
	, yytext(nullptr)
	, yyleng(0)
	, yylaleng(0)
	, yyerr_flag__(false)
	, yyltok(PARSE_UNDEFSYMB_ID)
	, yylexer(plex)
	, yyerror(yyemit_error__) {

	}
	~yyparser_t(void) {

		if(yytext) {
			delete[] yytext;
		}

	}

	inline bool yylexinit__(const char *pchFile, bool bi) {

		YYPBUFFER pbuf = yy_new_filebuf(pchFile, bi);
		if( !pbuf ) {
			return false;
		}
		
		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(const char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_cstrbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_strbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	int yylex__(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
		
		if( !yy_has_buffer()) {yyecode__ = YYE_EOS; return 0;}

		int yylstate__ = LEX_ERROR_STATE;
		int yylrule__ = LEX_ERROR_RULE;
		int yyaccleng__ = 0;
		int yycchar__ = END_OF_FILE;
		bool yylast_at_bol__ = yyat_bol__;
		bool bwrap__ = false;
		
#line 209 "../meta/ulyac.upg"

	int c, i, j;
	string strMsg;

#line 1226 "ulyac.cpp"

		yymore_flag__ = false;
		yyecode__ = YYE_ALIVE;
		
		yyleng = 0;
		yylaleng = 0;
		yytext[0] = '\0';

		

		if(yyat_bol__) {
			yylstate__ = yydsc[yystart__];
		}
		else {
			yylstate__ = yydsc[yystart__ + 1];
		}

		while(yylex_is_running__()) {

			yycchar__ = yybufmgr__.get();
			yylstate__ = yynext_lexstate__(yylstate__, yycchar__);

			if(LEX_ERROR_STATE != yylstate__) {

				if(yylaleng >= yysize__ - 1) {
					renew_text__();
				}
				yytext[yylaleng] = (char)yycchar__;

				++yylaleng;

				if(yyget_lexrule__(yylstate__) != LEX_ERROR_RULE) {

					yylrule__ = yyget_lexrule__(yylstate__);
					yyaccleng__ = yylaleng;
				}
			}

			if(LEX_ERROR_STATE == yylstate__ || (yybufmgr__.isimod() 
					&& ('\n' == yycchar__ || END_OF_FILE == yycchar__))) {
				if(LEX_ERROR_RULE == yylrule__) {
					if(yylaleng == yyleng) {
						if(yycchar__ == END_OF_FILE) {
							yylrule__ = LEX_EOFRULE_BASE + yystart__ / 2;
						}
						else if(yycchar__ == END_OF_ALLFILE) {
							yylrule__ = LEX_EOAF_RULE;
						}
					}
				}
				else {
					if( LEX_ERROR_STATE == yylstate__) {
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);
					}
					yylaleng = yyaccleng__;
					yytext[yylaleng] = '\0';
				 yyleng = yylaleng;
				}

				if(LEX_ERROR_RULE != yylrule__) {
					if(yyleng > 0) yyat_bol__ = (yytext[yyleng - 1] == '\n');{
				int nline = yyget_lineno();
				int ncol = yyget_colno() - 1;
				int nt = yyget_tabsize();
				int ts, yyt1__;
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {
					if(yytext[yyt1__] == '\t') {

						ts = nt - ncol % nt;
						yybufmgr__.pushtsz(ts);
						ncol += ts;
					}
					else if(yytext[yyt1__] == '\n') {
						yybufmgr__.pushlsz(ncol + 1);
						ncol = 0;
						++nline;
					}
					else {
						++ncol;
					}
				}
				yylloc.firstLine = yyget_lineno();
				yylloc.firstColumn = yyget_colno();
				yylloc.lastLine  = nline;
				yylloc.lastColumn = (ncol < 0)?0: ncol;
				yyset_lineno(nline);
				yyset_colno(ncol + 1);
			}
				}

		bwrap__ = (yylrule__ >= LEX_EOFRULE_BASE
			&& yylrule__ < LEX_EOAF_RULE
			&& yywrap__(lexer, dtbl, grammar, ptbl, dmap, gsetup));

		if(!bwrap__) {
				switch(yylrule__) {
				
case 0:
{
	
#line 339 "../meta/ulyac.upg"
	{

		yy_set_bol(true);
	}
	

#line 1334 "ulyac.cpp"

	}
	break;
	
case 1:
{
	
#line 344 "../meta/ulyac.upg"
	{
		
		PROCESS_ACTION_1(c, '*', '/', NULL_ACTION)
	}
	

#line 1349 "ulyac.cpp"

	}
	break;
	
case 2:
{
	
#line 349 "../meta/ulyac.upg"
		{

		c = yyinput();
		while(END_OF_FILE != c) {
			if('\n' == c) {

				c = yyinput();
				
				if((' ' != c && '\t' != c) && ('\r' != c && '\n' != c)) {
					
					yyunput((char)c);
					yy_set_bol(true);
					break;
				}
			}
			else {
				c = yyinput();
			}
		}
		
		if( sn_pactDefHeader) {
			// definition header code, which is copied literally to generated source file
			dmap.insert(CKEY_DEF_HEADER, sn_pactDefHeader);
			sn_pactDefHeader = nullptr;
		}
		
		if( sn_pactDeclHeader) {
			// declaration header code, which is copied literally to generated header file
			dmap.insert(CKEY_DECL_HEADER, sn_pactDeclHeader);
			sn_pactDeclHeader = nullptr;
		}
		
		LEX_BEGIN(LEX_SC);
		return SECT_DELIM;
	}


#line 1395 "ulyac.cpp"

	}
	break;
	
case 3:
{
	
#line 385 "../meta/ulyac.upg"
		{

		LEX_BEGIN(PRS_SC);		
		return SECT_DELIM;
	}

#line 1410 "ulyac.cpp"

	}
	break;
	
case 4:
{
	
#line 390 "../meta/ulyac.upg"
		{
		
		// scanning code section comes here		
		action_t *pact = new action_t(yylloc.firstLine);
		
		while(END_OF_FILE != (c = yyinput())) {
			
			pact->addText((char)c);
		}
		
		// user code, all contents in fourth section of script
		dmap.insert(CKEY_USER_CODE, pact);
		
		return SECT_DELIM;
	}


#line 1436 "ulyac.cpp"

	}
	break;
	
case 5:
{
	
#line 406 "../meta/ulyac.upg"
	{

		int idx = 8;
		while(' ' == yytext[idx] || '\t' == yytext[idx]) {
		
			++idx;
		}
		
		yylval.m_pchVal = new char[yyleng + 1 - idx];
		strncpy(yylval.m_pchVal, &yytext[idx], yyleng - idx);
		yylval.m_pchVal[yyleng - idx] = '\0';

		if(yylval.m_pchVal[0] >= 'a' && yylval.m_pchVal[0] <= 'z') {
		
			yylval.m_pchVal[0] -= 32;
		}
		
		LEX_BEGIN(OPT_SC);
		
		return OPT_KEY;
	}
	

#line 1468 "ulyac.cpp"

	}
	break;
	
case 6:
{
	
#line 428 "../meta/ulyac.upg"
				{

		CRET
	}
	

#line 1483 "ulyac.cpp"

	}
	break;
	
case 7:
{
	
#line 433 "../meta/ulyac.upg"
		{
		if(!strhelper_t::toSnum(yytext, yylval.m_nVal)) {
			
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: integer value `";
			strMsg += yytext;
			strMsg += "\' is out of range. ";
			_ERROR(strMsg, ELEX(1));
			
			yylval.m_nVal = 1;
		}
		
		return INT;
	}
	

#line 1510 "ulyac.cpp"

	}
	break;
	
case 8:
{
	
#line 450 "../meta/ulyac.upg"
	{

		return KW_ON;
	}
	

#line 1525 "ulyac.cpp"

	}
	break;
	
case 9:
{
	
#line 455 "../meta/ulyac.upg"
	{

		return KW_OFF;
	}


#line 1540 "ulyac.cpp"

	}
	break;
	
case 10:

case 11:
{
	
#line 461 "../meta/ulyac.upg"
	{

		char *tx = yytext;
		int num = yyleng;
		if(yytext[0] == '\"') {
		
			yylval.m_pchVal = new char[yyleng - 1];
			++tx;
			num -= 2;
		}
		else {
			
			yylval.m_pchVal = new char[yyleng + 1];
		}
		i = 0, j = 0;
		for(; i < num; ++i, ++j) {
		
			if(i < num - 1 && tx[i] == '\\' && (tx[i + 1] == '\"' || tx[i + 1] == '\\')) {
				
				yylval.m_pchVal[j] = tx[i + 1];
				++i;
			}
			else {
			
				yylval.m_pchVal[j] = tx[i];
			}
		}
		yylval.m_pchVal[j] = '\0';
		
		return CSTR;
	}

#line 1583 "ulyac.cpp"

	}
	break;
	
case 12:
{
	
#line 492 "../meta/ulyac.upg"
		{
		
		LEX_BEGIN(INITIAL);
	}


#line 1598 "ulyac.cpp"

	}
	break;
	
case 13:

case 14:
{
	
#line 498 "../meta/ulyac.upg"
		{
		
		LEX_BEGIN(XISC_SC);
		if(yytext[1] == 'x' || yytext[1] == 'X') {
		
			return XSCLABEL;
		}
		else {
		
			return ISCLABEL;
		}
	}


#line 1623 "ulyac.cpp"

	}
	break;
	
case 15:
{
	
#line 511 "../meta/ulyac.upg"
		{
		
		yylval.m_pchVal = new char[yyleng + 1];
		strncpy(yylval.m_pchVal, yytext, yyleng);
		yylval.m_pchVal[yyleng] = '\0';

		LEX_BEGIN(INITIAL);
		
		return XISC;
	}

#line 1643 "ulyac.cpp"

	}
	break;
	
case 16:
{
	
#line 521 "../meta/ulyac.upg"


	

#line 1656 "ulyac.cpp"

	}
	break;
	
case 17:
{
	
#line 523 "../meta/ulyac.upg"
		{
	
		LEX_BEGIN(INITIAL);
	}


#line 1671 "ulyac.cpp"

	}
	break;
	
case 18:
{
	
#line 528 "../meta/ulyac.upg"
	{

		i = 7;
		for(; ' ' == yytext[i] || '\t' == yytext[i]; ++i) {}
		
		yylval.m_pchVal = new char[yyleng - i + 1];
		strncpy(yylval.m_pchVal, &yytext[i], yyleng - i);
		yylval.m_pchVal[yyleng - i] = '\0';
		
		// TODO: set start-symbol
		return START_LABEL;
	}


#line 1694 "ulyac.cpp"

	}
	break;
	
case 19:
{
	
#line 541 "../meta/ulyac.upg"
		{

		if(dmap.isAction(CKEY_LTYPE_DECLARE)) {
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: location type has already declared, ";
			strMsg += "this statement is discarded.";
			_WARNING(strMsg);
		}
		else {
		
			if(dmap.isAction(CKEY_LTYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: location type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);			
			}
			else {
					i = 10;
					for(; ' ' == yytext[i] || '\t' == yytext[i]; ++i); {;}
					action_t *pact = new action_t(yylloc.firstLine);
					
					pact->addText(&yytext[i]);
					
					bool b = dmap.insert(CKEY_LTYPE_NAME, pact);
					assert(b);
			}
		}
		
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);
		
	}


#line 1741 "ulyac.cpp"

	}
	break;
	
case 20:
{
	
#line 578 "../meta/ulyac.upg"
			{
		
		if(dmap.isAction(CKEY_STYPE_DECLARE)) {
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: semantic value type has already declared, ";
			strMsg += "this statement is discarded.";
			_WARNING(strMsg);
		}
		else {
		
			if( dmap.isAction(CKEY_STYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: semantic value type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);		
			}
			else {
			
				i = 7;
				for(; ' ' == yytext[i] || '\t' == yytext[i]; ++i); {;}
				
				action_t *pact = new action_t(yylloc.firstLine);
				
				pact->addText(&yytext[i]);
				
				bool b = dmap.insert(CKEY_STYPE_NAME, pact);
				assert(b);
				
			}
		}
		
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);
			
	}


#line 1791 "ulyac.cpp"

	}
	break;
	
case 21:

case 22:

case 23:

case 24:
{
	
#line 621 "../meta/ulyac.upg"
	{

		string strKey;
		int nlen = 0;
		switch(yytext[1]) {
		case 'a':
			strKey = CKEY_ACTUAL_PARAMETERS;
			nlen = 13;
			break;
		case 'f':
			strKey = CKEY_FORMAL_PARAMETERS;
			nlen = 13;
			break;
		case 'l':
			if(dmap.isAction(CKEY_LTYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: location type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);
			}
			else {
				strKey = CKEY_LTYPE_DECLARE;
				nlen = 9;
			}
			break;
			
		default:	// case 'u':
			if(dmap.isAction(CKEY_STYPE_NAME)) {
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: semantic value type has already been assigned, ";
				strMsg += "this statement is discarded.";
				_WARNING(strMsg);
			}
			else {			
				strKey = CKEY_STYPE_DECLARE;
				nlen = 6;
			}
			break;
		}
		
		if(nlen == 0 || dmap.isAction(strKey)) {
		
			if(nlen > 0) {
				yytext[nlen] = '\0';
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: `";
				strMsg += yytext;
				strMsg += "\' duplicated and discarded";
				_WARNING(strMsg);
			}

			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, NULL_ACTION)
		}
		else {
			
			action_t *pact = new action_t(yylloc.firstLine);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, pact->addText)
			
			if(c == END_OF_FILE) {
				
				_ERROR("description: lack of `%}\'.", ELEX(3));
			}

			bool b = dmap.insert(strKey, pact);
			assert(b);
		}
	}

	

#line 1883 "ulyac.cpp"

	}
	break;
	
case 25:

case 26:

case 27:
{
	
#line 699 "../meta/ulyac.upg"
		{

		bool bret;
		
		switch(yytext[1]) {
		case 'l':
			bret = dtbl.beginLexInit(yylloc.firstLine);
			yytext[9] = '\0';
			break;
		case 'p':
			bret = dtbl.beginPrematch(yylloc.firstLine);
			yytext[10] = '\0';
			break;
		default: // yytext[1] == 'y'
			bret = dtbl.beginWrap(yylloc.firstLine);
			yytext[7] = '\0';
			break;
		}

		if( ! bret)  {
		
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: `";
			strMsg += yytext;
			strMsg += "\' duplicated and discarded";
			_WARNING(strMsg);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, NULL_ACTION)
		}
		else {
		
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, dtbl.addActionText)
			
		}
		
		if(c == END_OF_FILE) {
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: lack of `%}\'.";
			_ERROR(strMsg, ELEX(4));
		}
	}



#line 1944 "ulyac.cpp"

	}
	break;
	
case 28:
{
	
#line 746 "../meta/ulyac.upg"
		{

		if( ! sn_pactDeclHeader) {
		
			sn_pactDeclHeader = new action_t(yylloc.firstLine);
		}

		PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, sn_pactDeclHeader->addText)
		
		sn_pactDeclHeader->addText('\n');
	}


#line 1966 "ulyac.cpp"

	}
	break;
	
case 29:
{
	
#line 758 "../meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TOK_SC);
		return TOKEN_LABEL;
	}

#line 1980 "ulyac.cpp"

	}
	break;
	
case 30:
{
	
#line 762 "../meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TOK_SC);
		return LEFT_LABEL;
	}

#line 1994 "ulyac.cpp"

	}
	break;
	
case 31:
{
	
#line 766 "../meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TOK_SC);
		return RIGHT_LABEL;
	}

#line 2008 "ulyac.cpp"

	}
	break;
	
case 32:
{
	
#line 770 "../meta/ulyac.upg"
		{
		LEX_PUSH_STATE(TOK_SC);
		return NONASSOC_LABEL;
	}

#line 2022 "ulyac.cpp"

	}
	break;
	
case 33:
{
	
#line 774 "../meta/ulyac.upg"
			{
		LEX_PUSH_STATE(TYP_SC);
		return TYPE_LABEL;
	}


#line 2037 "ulyac.cpp"

	}
	break;
	
case 34:

case 35:
{
	
#line 780 "../meta/ulyac.upg"
 {		
		yylval.m_pDstrct = new action_t(yylloc.firstLine);
		
		c = yyinput();
		while(c && c != END_OF_FILE) {
			if(LEX_ESCAPE_CHAR == c) {
				c = yyinput();
				if(c && c != END_OF_FILE) {
					yylval.m_pDstrct->addText(c);
				}
				else {
					yylval.m_pDstrct->addText(LEX_ESCAPE_CHAR);
					break;
				}
				c = yyinput();
			}
			else {
				if('%' == c) {
					c = yyinput();
					if('}' == c) { break; }
					else {	yylval.m_pDstrct->addText('%');	}
				}
				else if('$' == c) {
					c = yyinput();
					if('$' == c) {
						yylval.m_pDstrct->addMacroPH(SKEY_SVNAME_DSTRCT);
						c = yyinput();
					}
					else {
						yylval.m_pDstrct->addText('$');
					}
				}
				else if('@' == c) {
					c = yyinput();
					if('$' == c) {
						yylval.m_pDstrct->addMacro(SKEY_SVLOC_DSTRCT);
						c = yyinput();
					}
					else {
						yylval.m_pDstrct->addText('@');
					}
				}
				if(c && END_OF_FILE != c) {
					if('%' != c && '@' != c && '$' != c && LEX_ESCAPE_CHAR != c) {
						yylval.m_pDstrct->addText(c);
						c = yyinput();
					}
				}
			}
		}

		LEX_PUSH_STATE(DSCRD_SC);
		
		yylloc.lastLine = yyget_lineno();
		yylloc.lastColumn = yyget_colno() - 1;

		return DESTRUCTOR_LABEL;
	}

#line 2107 "ulyac.cpp"

	}
	break;
	
case 36:
{
	
#line 838 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 0;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2121 "ulyac.cpp"

	}
	break;
	
case 37:
{
	
#line 842 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 1;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2135 "ulyac.cpp"

	}
	break;
	
case 38:
{
	
#line 846 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 2;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2149 "ulyac.cpp"

	}
	break;
	
case 39:
{
	
#line 850 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 3;
		LEX_PUSH_STATE(PLVAR_SC);
	}
	

#line 2164 "ulyac.cpp"

	}
	break;
	
case 40:
{
	
#line 855 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 0;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2178 "ulyac.cpp"

	}
	break;
	
case 41:
{
	
#line 859 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 1;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2192 "ulyac.cpp"

	}
	break;
	
case 42:
{
	
#line 863 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 2;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2206 "ulyac.cpp"

	}
	break;
	
case 43:
{
	
#line 867 "../meta/ulyac.upg"
		{
		sn_nVarDeclInit = 3;
		LEX_PUSH_STATE(PLVAR_SC);
	}
	

#line 2221 "ulyac.cpp"

	}
	break;
	
case 44:
{
	
#line 872 "../meta/ulyac.upg"
			{
		sn_nVarDeclInit = 4;
		LEX_PUSH_STATE(PLVAR_SC);
	}

#line 2235 "ulyac.cpp"

	}
	break;
	
case 45:
{
	
#line 876 "../meta/ulyac.upg"
			{
		sn_nVarDeclInit = 5;
		LEX_PUSH_STATE(PLVAR_SC);
	}


#line 2250 "ulyac.cpp"

	}
	break;
	
case 46:
{
	
#line 881 "../meta/ulyac.upg"
		{

		string strKey;
		string strText;
		switch(sn_nVarDeclInit) {
		case 0:	// %lexvar-decl
			strKey = CKEY_LEXVAR_DECL;
			strText = "declaration block for yylex\'s local variables";
			break;
		case 1:	// %lexvar-init
			strKey = CKEY_LEXVAR_INIT;
			strText = "initialization block for yylex\'s local variables";
			break;
		case 2:	// %parsevar-decl
			strKey = CKEY_PARSEVAR_DECL;
			strText = "declaration block for yyparse\'s local variables";
			break;

		case 3:	// %parsevar-init
			strKey = CKEY_PARSEVAR_INIT;
			strText = "initialization block for yyparse\'s local variables";
			break;
		case 4: // %parse-init
			strKey = CKEY_PARSEINIT_ACTION;
			strText = "yyparse's entry action";
			break;
		case 5: 
			strKey = CKEY_PARSEEXIT_ACTION;
			strText = "yyparse's exit action";
			break;
		default:
			assert(false);
		}

		if(dmap.isAction(strKey)) {
		
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: ";
			strMsg += strText;
			strMsg += " duplicated and discarded";
			_WARNING(strMsg);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, NULL_ACTION)

		}
		else {
		
			action_t *pact = new action_t(yylloc.firstLine);
			
			PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, pact->addText)
			
			if(c == END_OF_FILE) {
				_ERROR("description: lack of `%}\'.", ELEX(3));
			}
			
			bool b = dmap.insert(strKey, pact);
			assert(b);
		}
		LEX_POP_STATE();
		
	}


#line 2324 "ulyac.cpp"

	}
	break;
	
case 47:
{
	
#line 945 "../meta/ulyac.upg"
		{
		
		if(! sn_pactDefHeader) {
		
			sn_pactDefHeader = new action_t(yylloc.firstLine);
		}
		
		PROCESS_UNTIL(c, '%', '}', LEX_ESCAPE_CHAR, sn_pactDefHeader->addText)
		
		sn_pactDefHeader->addText('\n');
	}


#line 2346 "ulyac.cpp"

	}
	break;
	
case 48:
{
	
#line 957 "../meta/ulyac.upg"
	{

		c = yyleng - 1;
		while(yytext[--c] == ' ' || yytext[c] == '\t');
		++c;
		yytext[c] = '\0';
		yylval.m_pchVal = new char[c + 1];
		strncpy(yylval.m_pchVal, yytext, c);
		yylval.m_pchVal[c] = '\0';
		
		return LFTID;
	}


#line 2369 "ulyac.cpp"

	}
	break;
	
case 49:
{
	
#line 970 "../meta/ulyac.upg"
	{

		yylval.m_pchVal = new char[yyleng + 1];
		strncpy(yylval.m_pchVal, yytext, yyleng);
		yylval.m_pchVal[yyleng] = '\0';
		
		return CID;
	}

#line 2387 "ulyac.cpp"

	}
	break;
	
case 50:
{
	
#line 978 "../meta/ulyac.upg"
	{
		CRET
	}

#line 2400 "ulyac.cpp"

	}
	break;
	
case 51:
{
	
#line 981 "../meta/ulyac.upg"
		{
		ESC2CHAR((&yytext[1]), yylval.m_cVal);
		return QCHAR;
	}

#line 2414 "ulyac.cpp"

	}
	break;
	
case 52:
{
	
#line 985 "../meta/ulyac.upg"
		{	
		yylval.m_cVal = (char)strhelper_t::ostr2Num(&yytext[1]);
		return QCHAR;
	}

#line 2428 "ulyac.cpp"

	}
	break;
	
case 53:
{
	
#line 989 "../meta/ulyac.upg"
		{
		yylval.m_cVal = (char)strhelper_t::hstr2Num(&yytext[1]);
		return QCHAR;
	}

#line 2442 "ulyac.cpp"

	}
	break;
	
case 54:
{
	
#line 993 "../meta/ulyac.upg"
	{
		yylval.m_cVal = yytext[1];
		return QCHAR;
	}

#line 2456 "ulyac.cpp"

	}
	break;
	
case 55:
{
	
#line 997 "../meta/ulyac.upg"
		{
		yylval.m_cVal = yytext[2];
		return QCHAR;
	}

#line 2470 "ulyac.cpp"

	}
	break;
	
case 56:
{
	
#line 1001 "../meta/ulyac.upg"
		{

		if(!strhelper_t::toSnum(yytext, yylval.m_nVal)) {		
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: integer value `";
			strMsg += yytext;
			strMsg += "\' is out of range.";
			_ERROR(strMsg, ELEX(2));
			
			yylval.m_nVal = 1;
		}
		return INT;
	}

#line 2495 "ulyac.cpp"

	}
	break;
	
case 57:
{
	
#line 1016 "../meta/ulyac.upg"
		{
		return yytext[0];
	}

#line 2508 "ulyac.cpp"

	}
	break;
	
case 58:
{
	
#line 1019 "../meta/ulyac.upg"
	{
		LEX_POP_STATE();
		return '\n';
	}
	

#line 2523 "ulyac.cpp"

	}
	break;
	
case 59:
{
	
#line 1024 "../meta/ulyac.upg"
		{

		strMsg = strhelper_t::fromInt(yylloc.firstLine);
		strMsg += ':';
		strMsg += strhelper_t::fromInt(yylloc.firstColumn);
		strMsg += "; description: option `";
		strMsg += yytext;
		strMsg += "\' unsupported and discarded";
		_WARNING(strMsg);
		
		while(0 != (c = yyinput())) {
		
			if('\n' == c || END_OF_FILE == c) {

				break;
			}
		}
		
		yy_set_bol(true);
	}


#line 2554 "ulyac.cpp"

	}
	break;
	
case 60:
{
	
#line 1045 "../meta/ulyac.upg"
		{

		LEX_PUSH_STATE(SCR_SC);
		
		CRET
	}

#line 2570 "ulyac.cpp"

	}
	break;
	
case 61:
{
	
#line 1051 "../meta/ulyac.upg"
	{

		return KW_INITIAL;
	}
	

#line 2585 "ulyac.cpp"

	}
	break;
	
case 62:
{
	
#line 1056 "../meta/ulyac.upg"
		{

		yylval.m_pchVal = new char[yyleng + 1];
		strncpy(yylval.m_pchVal, yytext, yyleng);
		yylval.m_pchVal[yyleng] = '\0';
		return CID;
	}
	

#line 2603 "ulyac.cpp"

	}
	break;
	
case 63:
{
	
#line 1064 "../meta/ulyac.upg"
			{

		CRET
	}
	

#line 2618 "ulyac.cpp"

	}
	break;
	
case 64:
{
	
#line 1069 "../meta/ulyac.upg"
			{

		LEX_POP_STATE();
		
		CRET
	}
	

#line 2635 "ulyac.cpp"

	}
	break;
	
case 65:
{
	
#line 1076 "../meta/ulyac.upg"
			{
		return KW_ALLSC;
	}


#line 2649 "ulyac.cpp"

	}
	break;
	
case 66:
{
	
#line 1080 "../meta/ulyac.upg"
		{
		return KW_EOF;
	}


#line 2663 "ulyac.cpp"

	}
	break;
	
case 67:
{
	
#line 1084 "../meta/ulyac.upg"
		{

		i = yyleng - 1;
		for(; i > 0 && (' ' == yytext[i] || '\t' == yytext[i]); --i) {
		}
		assert(i >= 0);
		++i;
		
		yylval.m_pchVal = new char[i + 1];
		strncpy(yylval.m_pchVal, yytext, i);
		yylval.m_pchVal[i] = '\0';

		
		LEX_PUSH_STATE(MAC_SC);
		
		return CID;
	}


#line 2691 "ulyac.cpp"

	}
	break;
	
case 68:
{
	
#line 1102 "../meta/ulyac.upg"
	{

		LEX_POP_STATE();
		return '\n';
	}


#line 2707 "ulyac.cpp"

	}
	break;
	
case 69:
{
	
#line 1108 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::ALNUM;
		
		return POSIX_SET;
	}


#line 2724 "ulyac.cpp"

	}
	break;
	
case 70:
{
	
#line 1115 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::ALPHA;
		
		return POSIX_SET;
	}
	

#line 2741 "ulyac.cpp"

	}
	break;
	
case 71:
{
	
#line 1122 "../meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::BLANK;
		
		return POSIX_SET;
	}
	

#line 2758 "ulyac.cpp"

	}
	break;
	
case 72:
{
	
#line 1129 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::CNTRL;
		
		return POSIX_SET;
	}
	

#line 2775 "ulyac.cpp"

	}
	break;
	
case 73:
{
	
#line 1136 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::DIGIT;
		
		return POSIX_SET;
	}
	

#line 2792 "ulyac.cpp"

	}
	break;
	
case 74:
{
	
#line 1143 "../meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::GRAPH;
		
		return POSIX_SET;
	}
	

#line 2809 "ulyac.cpp"

	}
	break;
	
case 75:
{
	
#line 1150 "../meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::LOWER;
		
		return POSIX_SET;
	}
	

#line 2826 "ulyac.cpp"

	}
	break;
	
case 76:
{
	
#line 1157 "../meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::PRINT;
		
		return POSIX_SET;
	}
	

#line 2843 "ulyac.cpp"

	}
	break;
	
case 77:
{
	
#line 1164 "../meta/ulyac.upg"
		{

		yylval.m_nPosix = charset_t::PUNCT;
		
		return POSIX_SET;
	}
	

#line 2860 "ulyac.cpp"

	}
	break;
	
case 78:
{
	
#line 1171 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::SPACE;
		
		return POSIX_SET;
	}
	

#line 2877 "ulyac.cpp"

	}
	break;
	
case 79:
{
	
#line 1178 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::UPPER;
		
		return POSIX_SET;
	}
	

#line 2894 "ulyac.cpp"

	}
	break;
	
case 80:
{
	
#line 1185 "../meta/ulyac.upg"
		{
		
		yylval.m_nPosix = charset_t::XDIGIT;
		
		return POSIX_SET;
	}

#line 2910 "ulyac.cpp"

	}
	break;
	
case 81:
{
	
#line 1191 "../meta/ulyac.upg"
			{
		
		yylval.m_nPosix = charset_t::CIDF;
		
		return POSIX_SET;
	}
	

#line 2927 "ulyac.cpp"

	}
	break;
	
case 82:
{
	
#line 1198 "../meta/ulyac.upg"
			{

		yylval.m_nPosix = charset_t::CIDS;
		
		return POSIX_SET;
	}
	

#line 2944 "ulyac.cpp"

	}
	break;
	
case 83:
{
	
#line 1205 "../meta/ulyac.upg"
		{

		LEX_PUSH_STATE(CSH_SC);	
		CRET
	}
	

#line 2960 "ulyac.cpp"

	}
	break;
	
case 84:
{
	
#line 1211 "../meta/ulyac.upg"
		{

		LEX_PUSH_STATE(CSH_SC);
		return NCS;
	}

#line 2975 "ulyac.cpp"

	}
	break;
	
case 85:
{
	
#line 1216 "../meta/ulyac.upg"
	{
		
		yylval.m_cVal = yytext[1];
		return CCHAR;
	}

#line 2990 "ulyac.cpp"

	}
	break;
	
case 86:
{
	
#line 1221 "../meta/ulyac.upg"
		{

		ESC2CHAR(yytext, yylval.m_cVal);
		return CCHAR;
	}
	

#line 3006 "ulyac.cpp"

	}
	break;
	
case 87:
{
	
#line 1227 "../meta/ulyac.upg"
		{
	
		yylval.m_cVal = (char)strhelper_t::ostr2Num(yytext);
		
		return CCHAR;
	}

#line 3022 "ulyac.cpp"

	}
	break;
	
case 88:
{
	
#line 1233 "../meta/ulyac.upg"
		{

		yylval.m_cVal = (char)strhelper_t::hstr2Num(yytext);
		
		return CCHAR;
	}

#line 3038 "ulyac.cpp"

	}
	break;
	
case 89:
{
	
#line 1239 "../meta/ulyac.upg"
	{

		if(yytext[0] == '\\') {
		
			assert(yyleng >= 2);
			yylval.m_cVal = yytext[1];
		}
		else {
		
			yylval.m_cVal = yytext[0];
		}
		return CCHAR;
	}
	

#line 3062 "ulyac.cpp"

	}
	break;
	
case 90:
{
	
#line 1253 "../meta/ulyac.upg"
			{
		CRET
	}


#line 3076 "ulyac.cpp"

	}
	break;
	
case 91:
{
	
#line 1257 "../meta/ulyac.upg"
			{

		LEX_POP_STATE();
		
		CRET
	}

#line 3092 "ulyac.cpp"

	}
	break;
	
case 92:
{
	
#line 1263 "../meta/ulyac.upg"
			{

		yylval.m_cVal = yytext[0];
		
		return CCHAR;
	}


#line 3109 "ulyac.cpp"

	}
	break;
	
case 93:
{
	
#line 1270 "../meta/ulyac.upg"
		{

		CRET
	}
	

#line 3124 "ulyac.cpp"

	}
	break;
	
case 94:
{
	
#line 1275 "../meta/ulyac.upg"
		{

		yylval.m_pchVal = new char[yyleng - 1];
		strncpy(yylval.m_pchVal, &yytext[1], yyleng - 2);
		yylval.m_pchVal[yyleng - 2] = '\0';
		
		return MCALL;
	}
	

#line 3143 "ulyac.cpp"

	}
	break;
	
case 95:
{
	
#line 1284 "../meta/ulyac.upg"
		{

		char cc = yytext[yyleng - 1];
		yytext[yyleng - 1] = '\0';
		
		int n;
		
		strhelper_t::toSnum(&yytext[1], n);
		
		yytext[yyleng - 1] = cc;	
		
		yylval.m_nRange.m_nLower = yylval.m_nRange.m_nUpper = (short)n;
		
		return RANGE_EQUAL;
	}


#line 3169 "ulyac.cpp"

	}
	break;
	
case 96:
{
	
#line 1300 "../meta/ulyac.upg"
		{

		char cc = yytext[yyleng - 1];
		yytext[yyleng - 1] = '\0';
		
		int n;
		strhelper_t::toSnum(&yytext[2], n);		
		
		yytext[yyleng - 1] = cc;
		yylval.m_nRange.m_nLower = 0;
		yylval.m_nRange.m_nUpper = (short)n;
		
		return RANGE_LESS;
	}
	

#line 3194 "ulyac.cpp"

	}
	break;
	
case 97:
{
	
#line 1315 "../meta/ulyac.upg"
		{
		
		char cc = yytext[yyleng - 2];
		yytext[yyleng - 2] = '\0';
		
		int n;
		strhelper_t::toSnum(&yytext[1], n);		
		
		yylval.m_nRange.m_nLower = (short)n;
		yylval.m_nRange.m_nUpper = INF;

		yytext[yyleng - 2] = cc;
		
		return RANGE_MORE;
	}
	

#line 3220 "ulyac.cpp"

	}
	break;
	
case 98:
{
	
#line 1331 "../meta/ulyac.upg"
		{

		int n;
		char cc;
		for(i = 2; isdigit(yytext[i]); ++i);
		
		cc = yytext[i];
		yytext[i] = '\0';
		
		strhelper_t::toSnum(&yytext[1], n);		
		yylval.m_nRange.m_nLower = (short)n;
		yytext[i] = cc;
		
		for(; !isdigit(yytext[i]); ++i);
		j = i;
		for(; isdigit(yytext[i]); ++i);
		
		cc = yytext[i];
		yytext[i] = '\0';
		
		strhelper_t::toSnum(&yytext[j], n);
		yylval.m_nRange.m_nUpper = (short)n;
		yytext[i] = cc;
		
		return RANGE_BET;
	}

#line 3256 "ulyac.cpp"

	}
	break;
	
case 99:
{
	
#line 1357 "../meta/ulyac.upg"
	{

		yylval.m_cVal = yytext[0];
		return CCHAR;
	}
	

#line 3272 "ulyac.cpp"

	}
	break;
	
case 100:

case 101:
{
	
#line 1364 "../meta/ulyac.upg"
	{

		yylval.m_pchVal = new char[yyleng - 1];
		strncpy(yylval.m_pchVal, &yytext[1], yyleng - 2);
		yylval.m_pchVal[yyleng - 2] = '\0';
		
		return CSTR;
	}
	

#line 3293 "ulyac.cpp"

	}
	break;
	
case 102:
{
	
#line 1373 "../meta/ulyac.upg"
	{

		if('\n' != yytext[yyleng - 1]) {
		
			string strIgnored;
		
			c = yyinput();
			while('\n' != c && END_OF_FILE != c) {
			
				if('\r' != c) {
				
					strIgnored += (char) c;
				}
				c = yyinput();
			}
			
			if(strIgnored.size() > 0) {
				
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: action `";
				strMsg += strIgnored;
				strMsg += "\' unsupported and discarded.";
				_WARNING(strMsg);
			}
		}

		return ENDP;
	}


#line 3334 "ulyac.cpp"

	}
	break;
	
case 103:

case 104:
{
	
#line 1405 "../meta/ulyac.upg"
		{

		c = yytext[yyleng - 1];
		
		if(c != '\n') {

			c = yyinput();
		}
		
		yylval.m_nVal = dtbl.addEmptyAction(yylloc.firstLine);
		
		dtbl.addActionText(yytext);
		
		while(END_OF_FILE != c) {
			
			if('\n' == c) {
				
				dtbl.addActionText(c);
				c = yyinput();
				
				if((' ' != c && '\t' != c) && ('\r' != c && '\n' != c)) {
					
					break;
				}
			}
			else {
			
				dtbl.addActionText(c);
				c = yyinput();
			}
		}
		
		yyunput((char)c);
		yy_set_bol(true);
		
		yylloc.lastLine = yyget_lineno();
		yylloc.lastColumn = yyget_colno() - 1;
		
		return LEX_ACTION;
	}
	

#line 3387 "ulyac.cpp"

	}
	break;
	
case 105:
{
	
#line 1446 "../meta/ulyac.upg"
		{
		CRET
	}


#line 3401 "ulyac.cpp"

	}
	break;
	
case 106:
{
	
#line 1450 "../meta/ulyac.upg"
	{

		return DPRE_LABEL;
	}

#line 3415 "ulyac.cpp"

	}
	break;
	
case 107:
{
	
#line 1454 "../meta/ulyac.upg"
		{

		return PREC_LABEL;
	}

#line 3429 "ulyac.cpp"

	}
	break;
	
case 108:
{
	
#line 1458 "../meta/ulyac.upg"
				{

		LEX_PUSH_STATE(PACT_SC);
		yylval.m_nVal = ptbl.addEmptyAction(yylloc.firstLine);
		
		return PACT_BEGIN;
	}

#line 3446 "ulyac.cpp"

	}
	break;
	
case 109:
{
	
#line 1465 "../meta/ulyac.upg"
		{

		LEX_POP_STATE();
		return PACT_END;
	}
	
	/* ` is considered as escape char during action processing */

#line 3463 "ulyac.cpp"

	}
	break;
	
case 110:

case 111:
{
	
#line 1473 "../meta/ulyac.upg"
		{

		ptbl.addActionText(&yytext[1]);
	}

#line 3479 "ulyac.cpp"

	}
	break;
	
case 112:
{
	
#line 1477 "../meta/ulyac.upg"
		{

		int nRuleID = grammar.getLastProdIndex();
		const prod_t *p = grammar.getProd(nRuleID);
		assert(p);
		
		switch(yytext[0]) {
		case '$': {
				string strSVT;
				bool bret = grammar.getSymbolSVT(nRuleID, -1, strSVT);
				assert(bret);
				if( ! strSVT.empty()) {
					ptbl.addActionMacro(SKEY_SVNAME_LEFT, strSVT);
				}
				else {
					strMsg = strhelper_t::fromInt(yylloc.firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt(yylloc.firstColumn);
					strMsg += "; description: semantic value type is needed.";
					_ERROR(strMsg, ELEX(5));
					
					// TODO: add default semantic value
				}
			}
			break;
		case '@': {
		
				if( ! gsetup.m_bLocCompute) {
					_ERROR("description: location computation disabled.", ELEX(5));
				}
				ptbl.addActionMacro(SKEY_SVLOC_LEFT);
			}
			break;
		default:
			break;
		}
	}

#line 3526 "ulyac.cpp"

	}
	break;
	
case 113:
{
	
#line 1514 "../meta/ulyac.upg"
		{
		yytext[yyleng - 2] = '\0';
		ptbl.addActionMacro(SKEY_SVNAME_LEFT, &yytext[2]);
		
		if(!grammar.setMidSVT(&yytext[2])) {
			yytext[yyleng - 2] = '>';
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: semantic value type set more than once, `";
			strMsg += yytext;
			strMsg += "\' will overwrite the former one.";
			_WARNING(strMsg);
		}
	}

#line 3551 "ulyac.cpp"

	}
	break;
	
case 114:
{
	
#line 1529 "../meta/ulyac.upg"
		{

		int nVal;
		if(!strhelper_t::toSnum(&yytext[1], nVal)) {
			
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: integer value `";
			strMsg += &yytext[1];
			strMsg += "\' is out of range.";
			_ERROR(strMsg, ELEX(6));
		}
		else {
		
			int nRuleID = grammar.getLastProdIndex();
			prod_t *pr = grammar.getProd(nRuleID);
			if(nVal < 0 || nVal > pr->getRightSize()) {
			
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: rule item index `";
				strMsg += &yytext[1];
				strMsg += "\' is out of range.";
				_ERROR(strMsg, ELEX(7));
			}
			else {
			
				switch(yytext[0]) {
				
				case '$': {
						string strSVT;
						bool bret = grammar.getSymbolSVT(nRuleID, nVal - 1, strSVT);
						assert(bret);
						if( ! strSVT.empty()) {
							ptbl.addActionMacro(SKEY_SVNAME_RIGHT,
								strhelper_t::fromInt(pr->getRightSize() - nVal), strSVT);
						}
						else {
							strMsg = strhelper_t::fromInt(yylloc.firstLine);
							strMsg += ':';
							strMsg += strhelper_t::fromInt(yylloc.firstColumn);
							strMsg += "; description: semantic value type is needed.";
							_ERROR(strMsg, ELEX(8));
						}
					}
					break;
				case '@': {
				
						if( ! gsetup.m_bLocCompute) {
							strMsg = strhelper_t::fromInt(yylloc.firstLine);
							strMsg += ':';
							strMsg += strhelper_t::fromInt(yylloc.firstColumn);
							strMsg += "; description: location computation disabled."; 
							_ERROR(strMsg, ELEX(5));
						}
						ptbl.addActionMacro(SKEY_SVLOC_RIGHT, strhelper_t::fromInt(pr->getRightSize() - nVal));
					}
					break;
				default:
					break;
				}
			}
		}
	}

#line 3627 "ulyac.cpp"

	}
	break;
	
case 115:
{
	
#line 1595 "../meta/ulyac.upg"
	{

		i = yyleng - 1;
		while(yytext[i] != '>') {--i;}
		assert(i > 2);
		
		int nVal;
		if(!strhelper_t::toSnum(&yytext[i + 1], nVal)) {
			
			strMsg = strhelper_t::fromInt(yylloc.firstLine);
			strMsg += ':';
			strMsg += strhelper_t::fromInt(yylloc.firstColumn);
			strMsg += "; description: rule item index `";
			strMsg += &yytext[i + 1];
			strMsg += "\' is out of range.";
			_ERROR(strMsg, ELEX(9));
		}
		else {
		
			yytext[i] = '\0';
			int nRuleID = grammar.getLastProdIndex();
			prod_t *pr = grammar.getProd(nRuleID);
			
			if(nVal < 0 || nVal > pr->getRightSize()) {
			
				strMsg = strhelper_t::fromInt(yylloc.firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt(yylloc.firstColumn);
				strMsg += "; description: rule item index `";
				strMsg += &yytext[i + 1];
				strMsg += "\' is out of range.";
				_ERROR(strMsg, ELEX(10));
			}
			else {
			string strSVT;
			bool bret = grammar.getSymbolSVT(nRuleID, nVal - 1, strSVT);
			assert(bret);
				
				if(strSVT != string(&yytext[2])) {
				
					strMsg = strhelper_t::fromInt(yylloc.firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt(yylloc.firstColumn);
					strMsg += "; description: semantic value `";
					strMsg += &yytext[2];
					strMsg += "\' is different from it declaration.";
					_WARNING(strMsg);
				}
						
				ptbl.addActionMacro(SKEY_SVNAME_RIGHT,
					strhelper_t::fromInt(pr->getRightSize() - nVal), &yytext[2]);
			}
		}
	}

#line 3691 "ulyac.cpp"

	}
	break;
	
case 116:
{
	
#line 1649 "../meta/ulyac.upg"
			{
		ptbl.addActionText(yytext[0]);
	}
	
	/********* default pattern ******/
	

#line 3707 "ulyac.cpp"

	}
	break;
	
case 117:
{
	
#line 1655 "../meta/ulyac.upg"



#line 3719 "ulyac.cpp"

	}
	break;
	
case 118:
{
	
#line 1656 "../meta/ulyac.upg"


	

#line 3732 "ulyac.cpp"

	}
	break;
	
case 119:
{
	
#line 1658 "../meta/ulyac.upg"
		{
		
		strMsg = strhelper_t::fromInt(yylloc.firstLine);
		strMsg += ':';
		strMsg += strhelper_t::fromInt(yylloc.firstColumn);
		strMsg += "; description: unknown symbol `";
		strMsg += yytext[0];
		strMsg += "\'";
		
		switch(YYSTART()) {
		case INITIAL:
			
			while(0 != (c = yyinput()) && END_OF_FILE != c) {
			
				if('\n' == c) {
				
					break;
				}
			}
			
			yy_set_bol(true);
			
			strMsg += ".";
			_ERROR(strMsg, ECMD(20));
			
			break;
				
		case OPT_SC:
		
			while(0 != (c = yyinput()) && END_OF_FILE != c) {
			
				if('\n' == c) {

					break;
				}
			}
			
			yy_set_bol(true);
			
			strMsg += " in option.";
			
			_ERROR(strMsg, ECMD(20));
			
			return KW_ON;
				
		case MAC_SC:
		
			while(0 != (c = yyinput()) && END_OF_FILE != c) {
			
				if('\n' == c) {

					break;
				}
			}
			
			yy_set_bol(true);
			
			strMsg += " in regular expression macro.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			
			return CCHAR;
				
		case LEX_SC:
			
			strMsg += " in sub regular expression.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			
			return CCHAR;

		case SCR_SC:
			
			strMsg += " in start-condition referrence.";
			_ERROR(strMsg, ECMD(20));
			return KW_INITIAL;
				
		case CSH_SC:
			strMsg += " in charset.";
			_ERROR(strMsg, ESYN(20));
			
			yylval.m_cVal = yytext[0];
			return CCHAR;
				
		case XISC_SC:
			strMsg += " in start-condition declaration.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_pchVal = new char[2];
			yylval.m_pchVal[0] = yytext[0];
			yylval.m_pchVal[1] = '\0';
			
			return XISC;
				
		case TOK_SC:
		
			strMsg += " in token declaration.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			return QCHAR;
				
		case TYP_SC:
		
			strMsg += " in type declaration.";
			_ERROR(strMsg, ECMD(20));
			
			strMsg = grammar.getFakeSymbol();
			yylval.m_pchVal = new char[strMsg.size() + 1];
			strncpy(yylval.m_pchVal, strMsg.c_str(), strMsg.size());
			yylval.m_pchVal[strMsg.size()] = '\0';
			
			return CID;
				
		case DSCRD_SC:
			strMsg += " in destructor declaration.";
			_ERROR(strMsg, ECMD(20));
			
			yylval.m_cVal = yytext[0];
			return QCHAR;
		
		//case PACT_SC:
		//case PRS_SC:
		default:
		
			strMsg += ".";
			_ERROR(strMsg, ECMD(20));
			return yytext[0];
		}
	}


#line 3875 "ulyac.cpp"

	}
	break;
	
case 120:
{
	
#line 0 "../meta/ulyac.upg"

#line 3885 "ulyac.cpp"

	}
	break;
	
case 121:
{
	
#line 0 "../meta/ulyac.upg"

#line 3895 "ulyac.cpp"

	}
	break;
	
case 122:
{
	
#line 0 "../meta/ulyac.upg"

#line 3905 "ulyac.cpp"

	}
	break;
	
case 123:
{
	
#line 0 "../meta/ulyac.upg"

#line 3915 "ulyac.cpp"

	}
	break;
	
case 124:
{
	
#line 0 "../meta/ulyac.upg"

#line 3925 "ulyac.cpp"

	}
	break;
	
case 125:
{
	
#line 0 "../meta/ulyac.upg"

#line 3935 "ulyac.cpp"

	}
	break;
	
case 126:
{
	
#line 0 "../meta/ulyac.upg"

#line 3945 "ulyac.cpp"

	}
	break;
	
case 127:
{
	
#line 0 "../meta/ulyac.upg"

#line 3955 "ulyac.cpp"

	}
	break;
	
case 128:
{
	
#line 0 "../meta/ulyac.upg"

#line 3965 "ulyac.cpp"

	}
	break;
	
case 129:
{
	
#line 0 "../meta/ulyac.upg"

#line 3975 "ulyac.cpp"

	}
	break;
	
case 130:
{
	
#line 0 "../meta/ulyac.upg"

#line 3985 "ulyac.cpp"

	}
	break;
	
case 131:
{
	
#line 0 "../meta/ulyac.upg"

#line 3995 "ulyac.cpp"

	}
	break;
	
case 132:
{
	
#line 0 "../meta/ulyac.upg"

#line 4005 "ulyac.cpp"

	}
	break;
	

				case LEX_EOAF_RULE: 
					yy_delete_buffer();
					yyecode__ = YYE_EOS;
					break;
				default:
					if(yyleng > 0)
						yyat_bol__ = (yytext[yyleng - 1] == '\n');
			
					YYMSG_UNMATCHED[28] = yycchar__;
					yyecode__ = YYE_UNMATCHED;
					if(yyerror)
						yyerror(YYMSG_UNMATCHED, lexer, dtbl, grammar, ptbl, dmap, gsetup);
				
				break;
				}
			}
				if(yylex_is_running__()) {

					yylast_at_bol__ = yyat_bol__;

					if(yyat_bol__) {
						yylstate__ = yydsc[yystart__];
					}
					else {
						yylstate__ = yydsc[yystart__ + 1];
					}

					yylrule__ = LEX_ERROR_RULE;

					if( ! yymore_flag__) {
						yyaccleng__ = 0;
						yylaleng = 0;
						yyleng = 0;
						yytext[yylaleng] = '\0';
					}
					else {
						yymore_flag__ = false;
					}
				}
			}
		}

		return (yyecode__ == YYE_EOS)? 0 : yyecode__;
	}

	int yyparse__(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {

		if( ! yylexer) {
			return YYE_ABORT;
		}

		yyecode__ = YYE_ALIVE;
		sstack_t<xstype_t> yys_sv__;
		xstype_t yyval;

		sstack_t<xltype_t> yys_loc__;

		xltype_t yyloc;
		sstack_t<int> yys_stt__;
		sstack_t<int> yys_symb__;

		int yyrplen__;
		bool yyreducing__;

		int yypstate__ = PARSE_START_STATE;
		int yyprule__ = PERROR_RULE;
		int yysidx__ = PARSE_UNDEFSYMB_INDEX;
		int yytok__ = PARSE_UNDEFSYMB_ID;
		
#line 214 "../meta/ulyac.upg"

	string strMsg;
	
	int s_nCurAssoc = ASSOC_UNKNOWN;
	int s_nCurPrec = DEFAULT_PREC;
	int s_nCounter = DEFAULT_PREC + 1;
	int s_nCurSVTID = DEFAULT_SVT_ID;

	s2i_map_t s_sname2Idx;
	vstr_t s_vstrSName;
	vint_t s_vnToken;
	string s_strStartSymbol;
	
	int s_nCurLeftSymbol = INVALID_INDEX;

#line 4098 "ulyac.cpp"


		yyltok = PARSE_UNDEFSYMB_ID;
		yyerr_flag__ = false;


		yys_stt__.push(yypstate__);

		while( ! yys_stt__.empty() && yyparse_is_running__(yypstate__)) {
			yyprule__ = yyget_defrule(yypstate__);
			if(is_valid_prule__(yyprule__)) {
				yyreducing__ = true;
			}
			else {
				if(PARSE_UNDEFSYMB_ID == yytok__) {
					if(PARSE_UNDEFSYMB_ID == yyltok) {
						yytok__ = (yylexer)(lexer, dtbl, grammar, ptbl, dmap, gsetup);
					}
					else  {
						yytok__ = yyltok;
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yysidx__ = (yytok__ < 0 || yytok__ >= PARSE_TOKENMAP_SIZE) ? PARSE_UNDEFSYMB_INDEX
						: yyptmap[yytok__];
				}


				yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);

				if(is_valid_pstate__(yypstate__)) {


					yys_symb__.push(yysidx__);
					yys_stt__.push(yypstate__);
					yys_sv__.push(yylval);

					yys_loc__.push(yylloc);
 
					yytok__ = PARSE_UNDEFSYMB_ID;
					yyreducing__ = false;
				}
				else {
					yyprule__ = yyget_prule__(yypstate__);
					yyreducing__ = true;
				}
			}

			if(yyreducing__) {
				switch(yyprule__) {
				
	case 0:
	{
#line 1793 "../meta/ulyac.upg"

#line 4153 "ulyac.cpp"

	}
	break;
	
	case 2:
	{
#line 1794 "../meta/ulyac.upg"

			if(_GETERR() >= ERRID_BASE) {
				YYABORT();
			}
			else {
			
				grammar.setTypeBase();
				for(s2i_cit_t cit = s_sname2Idx.begin();
					cit != s_sname2Idx.end(); ++cit) {
				
					grammar.addType(cit->first, cit->second);
				}
				grammar.setStartSymbol(s_strStartSymbol);
				s_sname2Idx.clear();
				s_nCounter = 0;
			}
		
#line 4178 "ulyac.cpp"

	}
	break;
	
	case 3:
	{
#line 1812 "../meta/ulyac.upg"

			if(_GETERR() >= ERRID_BASE) {
				YYABORT();
			}
		
#line 4191 "ulyac.cpp"

	}
	break;
	
	case 4:
	{
#line 1818 "../meta/ulyac.upg"


			if(_GETERR() >= ERRID_BASE) {
				YYABORT();
			}
		
#line 4205 "ulyac.cpp"

	}
	break;
	
	case 1:
	{
#line 1824 "../meta/ulyac.upg"

			if(s_vstrSName.size() > 0) {
				grammar.addTokens(s_vstrSName, s_vnToken);
			}
			
#ifdef UPGEN_TEST_VERSION
			cerr << "Before grammar adjusting" << endl;
			cerr << grammar << endl;
#endif
			grammar.adjust(ptbl, gsetup);
			if(grammar.isValid()) {

				grammar.updateTID();
				if( ! grammar.initDstrct(gsetup)) {
					
					YYABORT();
				}
				else {
					YYACCEPT();
				}
			}
			else {
				YYACCEPT();
			}
		
#line 4238 "ulyac.cpp"

	}
	break;
	
	case 5:
	{
#line 1850 "../meta/ulyac.upg"

#line 4247 "ulyac.cpp"

	}
	break;
	
	case 6:
	{
#line 1850 "../meta/ulyac.upg"

#line 4256 "ulyac.cpp"

	}
	break;
	
	case 7:
	{
#line 1853 "../meta/ulyac.upg"

			grammar.reset();
		
#line 4267 "ulyac.cpp"

	}
	break;
	
	case 8:
	{
#line 1857 "../meta/ulyac.upg"

#line 4276 "ulyac.cpp"

	}
	break;
	
	case 9:
	{
#line 1858 "../meta/ulyac.upg"

#line 4285 "ulyac.cpp"

	}
	break;
	
	case 10:
	{
#line 1861 "../meta/ulyac.upg"

#line 4294 "ulyac.cpp"

	}
	break;
	
	case 11:
	{
#line 1862 "../meta/ulyac.upg"

#line 4303 "ulyac.cpp"

	}
	break;
	
	case 12:
	{
#line 1863 "../meta/ulyac.upg"

#line 4312 "ulyac.cpp"

	}
	break;
	
	case 13:
	{
#line 1864 "../meta/ulyac.upg"

#line 4321 "ulyac.cpp"

	}
	break;
	
	case 14:
	{
#line 1865 "../meta/ulyac.upg"

#line 4330 "ulyac.cpp"

	}
	break;
	
	case 15:
	{
#line 1866 "../meta/ulyac.upg"

				
				if(!lexer.addXSC((yys_sv__[0].m_pchVal))) {
				
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: start-condition `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' duplicated and discarded.";
					_WARNING(strMsg);
				}
				delete[] (yys_sv__[0].m_pchVal);
			
#line 4352 "ulyac.cpp"

	}
	break;
	
	case 16:
	{
#line 1880 "../meta/ulyac.upg"

				
				if(!lexer.addISC((yys_sv__[0].m_pchVal)))  {
				
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: start-condition `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' duplicated and discarded.";
					_WARNING(strMsg);
				}
				delete[] (yys_sv__[0].m_pchVal);
			
#line 4374 "ulyac.cpp"

	}
	break;
	
	case 17:
	{
#line 1894 "../meta/ulyac.upg"

				if(s_strStartSymbol.empty()) {
					s_strStartSymbol = (yys_sv__[0].m_pchVal);
					s_sname2Idx.insert(s2i_pair_t(s_strStartSymbol, INVALID_INDEX));	
				}
				else {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: start symbol is already set as `";
					strMsg += s_strStartSymbol;
					strMsg += "\', this setting discarded.";
					_WARNING(strMsg);
				}
				delete[] (yys_sv__[0].m_pchVal);
			
#line 4398 "ulyac.cpp"

	}
	break;
	
	case 18:
	{
#line 1911 "../meta/ulyac.upg"

#line 4407 "ulyac.cpp"

	}
	break;
	
	case 19:
	{
#line 1912 "../meta/ulyac.upg"


			strMsg = "token name expected.";
			_ERROR(strMsg, ESYN(1));
			
			yyerrok();
		
#line 4422 "ulyac.cpp"

	}
	break;
	
	case 20:
	{
#line 1919 "../meta/ulyac.upg"


			strMsg = "semantic value type or token name expected.";
			_ERROR(strMsg, ESYN(1));
			
			yyerrok();
		
#line 4437 "ulyac.cpp"

	}
	break;
	
	case 21:
	{
#line 1927 "../meta/ulyac.upg"

			s_nCurAssoc = ASSOC_UNKNOWN;
			s_nCurPrec = DEFAULT_PREC;
			s_nCurSVTID = DEFAULT_SVT_ID;
		
#line 4450 "ulyac.cpp"

	}
	break;
	
	case 22:
	{
#line 1932 "../meta/ulyac.upg"

			s_nCurAssoc = ASSOC_LEFT;
			s_nCurPrec = s_nCounter;
			s_nCurSVTID = DEFAULT_SVT_ID;
			++s_nCounter;
		
#line 4464 "ulyac.cpp"

	}
	break;
	
	case 23:
	{
#line 1938 "../meta/ulyac.upg"

			s_nCurAssoc = ASSOC_RIGHT;
			s_nCurPrec = s_nCounter;
			s_nCurSVTID = DEFAULT_SVT_ID;
			++s_nCounter;
		
#line 4478 "ulyac.cpp"

	}
	break;
	
	case 24:
	{
#line 1944 "../meta/ulyac.upg"

			s_nCurAssoc = ASSOC_NO;
			s_nCurPrec = DEFAULT_PREC;
			s_nCurSVTID = DEFAULT_SVT_ID;
		
#line 4491 "ulyac.cpp"

	}
	break;
	
	case 26:
	{
#line 1950 "../meta/ulyac.upg"

			s_nCurSVTID = grammar.addSVT((yys_sv__[0].m_pchVal)).first;
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4504 "ulyac.cpp"

	}
	break;
	
	case 25:
	{
#line 1950 "../meta/ulyac.upg"

#line 4513 "ulyac.cpp"

	}
	break;
	
	case 27:
	{
#line 1956 "../meta/ulyac.upg"

#line 4522 "ulyac.cpp"

	}
	break;
	
	case 28:
	{
#line 1958 "../meta/ulyac.upg"

#line 4531 "ulyac.cpp"

	}
	break;
	
	case 29:
	{
#line 1959 "../meta/ulyac.upg"

#line 4540 "ulyac.cpp"

	}
	break;
	
	case 30:
	{
#line 1961 "../meta/ulyac.upg"

			if(s_sname2Idx.find((yys_sv__[0].m_pchVal)) != s_sname2Idx.end()) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: identifier `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' already be name of a symbol, this definition discarded.";
				_WARNING(strMsg);			
			}
			else {
				i2b_pair_t pairRet = grammar.addToken((yys_sv__[0].m_pchVal), s_nCurSVTID, s_nCurPrec, s_nCurAssoc);
				if(!pairRet.second) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: identifier `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' already be name of a token, this definition discarded.";
					_WARNING(strMsg);
				}
			}
			delete[] (yys_sv__[0].m_pchVal);		
		
#line 4572 "ulyac.cpp"

	}
	break;
	
	case 31:
	{
#line 1985 "../meta/ulyac.upg"

			i2b_pair_t pairRet = grammar.addToken(strhelper_t::quotedChar((yys_sv__[0].m_cVal)), (int)(yys_sv__[0].m_cVal),
				s_nCurSVTID, s_nCurPrec, s_nCurAssoc, false);
			if(!pairRet.second) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: character `";
				strMsg += (yys_sv__[0].m_cVal);
				strMsg += "\' already be name of a token, this definition discarded.";
				_WARNING(strMsg);
			}
		
#line 4593 "ulyac.cpp"

	}
	break;
	
	case 33:
	{
#line 1999 "../meta/ulyac.upg"

			s_nCurSVTID = grammar.addSVT((yys_sv__[0].m_pchVal)).first;
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4605 "ulyac.cpp"

	}
	break;
	
	case 32:
	{
#line 1999 "../meta/ulyac.upg"

#line 4614 "ulyac.cpp"

	}
	break;
	
	case 34:
	{
#line 2003 "../meta/ulyac.upg"

		
			strMsg = "semantic value type expected.";
			
			_ERROR(strMsg, ESYN(1));
			yyerrok();		
		
#line 4629 "ulyac.cpp"

	}
	break;
	
	case 35:
	{
#line 2010 "../meta/ulyac.upg"

		
			strMsg = "semantic value type or type name expected.";
			
			_ERROR(strMsg, ESYN(1));
			yyerrok();		
		
#line 4644 "ulyac.cpp"

	}
	break;
	
	case 36:
	{
#line 2018 "../meta/ulyac.upg"

			if(grammar.isToken((yys_sv__[0].m_pchVal))) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: identifier `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' is already name of a token, this definition discarded.";
				_WARNING(strMsg);
			}
			else {
				if(s_strStartSymbol == string((yys_sv__[0].m_pchVal))) {
					s2i_it_t it = s_sname2Idx.find(s_strStartSymbol);
					assert(it != s_sname2Idx.end());
					if(it->second == INVALID_INDEX) {
						it->second = s_nCurSVTID;
					}
					else {
						strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
						strMsg += ':';
						strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
						strMsg += "; description: identifier `";
						strMsg += (yys_sv__[0].m_pchVal);
						strMsg += "\' is already name of a type, this definition discarded.";
						_WARNING(strMsg);					
					}
				}
				else if( ! s_sname2Idx.insert(s2i_pair_t(string((yys_sv__[0].m_pchVal)), s_nCurSVTID)).second) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: identifier `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' is already name of a type, this definition discarded.";
					_WARNING(strMsg);
				}
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4691 "ulyac.cpp"

	}
	break;
	
	case 37:
	{
#line 2057 "../meta/ulyac.upg"

			if(grammar.isToken((yys_sv__[0].m_pchVal))) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: identifier `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' is already name of a token, this definition discarded.";
				_WARNING(strMsg);
			}
			else {
				if(s_strStartSymbol == string((yys_sv__[0].m_pchVal))) {
					s2i_it_t it = s_sname2Idx.find(s_strStartSymbol);
					assert(it != s_sname2Idx.end());
					if(it->second == INVALID_INDEX) {
						it->second = s_nCurSVTID;
					}
					else {
						strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
						strMsg += ':';
						strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
						strMsg += "; description: identifier `";
						strMsg += (yys_sv__[0].m_pchVal);
						strMsg += "\' is already name of a type, this definition discarded.";
						_WARNING(strMsg);					
					}
				}
				else if( !s_sname2Idx.insert(s2i_pair_t(string((yys_sv__[0].m_pchVal)), s_nCurSVTID)).second) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: identifier `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' is already name of a type, this definition discarded.";
					_WARNING(strMsg);			
				}
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4738 "ulyac.cpp"

	}
	break;
	
	case 38:
	{
#line 2098 "../meta/ulyac.upg"

		if( ! grammar.setUntagDstrct((yys_sv__[3].m_pDstrct))) {
			delete (yys_sv__[3].m_pDstrct);
		}
	
#line 4751 "ulyac.cpp"

	}
	break;
	
	case 39:
	{
#line 2103 "../meta/ulyac.upg"

		if( ! grammar.setOtherDstrct((yys_sv__[4].m_pDstrct))) {
			delete (yys_sv__[4].m_pDstrct);
		}
	
#line 4764 "ulyac.cpp"

	}
	break;
	
	case 40:
	{
#line 2108 "../meta/ulyac.upg"

	
		if( ! grammar.addDstrctBySVT((yys_sv__[4].m_pDstrct), (yys_sv__[2].m_pchVal))) {
			delete (yys_sv__[4].m_pDstrct);
		}
		else {
		
			for(int i = 0; i < (yys_sv__[4].m_pDstrct)->getPHCount(); ++i) {
				(yys_sv__[4].m_pDstrct)->updateMacroPH(i, (yys_sv__[2].m_pchVal));
			}
		}
		delete[] (yys_sv__[2].m_pchVal);
	
#line 4785 "ulyac.cpp"

	}
	break;
	
	case 41:
	{
#line 2121 "../meta/ulyac.upg"

		assert((yys_sv__[1].m_pvstrSymbs));
		if( ! grammar.addDstrctBySymbs((yys_sv__[2].m_pDstrct), *(yys_sv__[1].m_pvstrSymbs))) {
			delete (yys_sv__[2].m_pDstrct);
		}

		delete (yys_sv__[1].m_pvstrSymbs);
	
#line 4801 "ulyac.cpp"

	}
	break;
	
	case 42:
	{
#line 2129 "../meta/ulyac.upg"

		
		strMsg = "semantic value type or symbol name expected.";
		_ERROR(strMsg, ESYN(1));
		
		delete (yys_sv__[2].m_pDstrct);
		
		yyerrok();
	
#line 4818 "ulyac.cpp"

	}
	break;
	
	case 43:
	{
#line 2138 "../meta/ulyac.upg"

	
		strMsg = "semantic value type or symbol name expected.";
		_ERROR(strMsg, ESYN(1));
		
		delete (yys_sv__[3].m_pDstrct);
		delete (yys_sv__[2].m_pvstrSymbs);
		yyerrok();	
	
#line 4835 "ulyac.cpp"

	}
	break;
	
	case 44:
	{
#line 2149 "../meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = (yys_sv__[1].m_pvstrSymbs);
		assert((yyval.m_pvstrSymbs));
		(yyval.m_pvstrSymbs)->push_back((yys_sv__[0].m_pchVal));
		delete[] (yys_sv__[0].m_pchVal);
	
#line 4849 "ulyac.cpp"

	}
	break;
	
	case 45:
	{
#line 2155 "../meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = (yys_sv__[1].m_pvstrSymbs);
		assert((yyval.m_pvstrSymbs));
		(yyval.m_pvstrSymbs)->push_back(strhelper_t::quotedChar((yys_sv__[0].m_cVal)));
	
#line 4862 "ulyac.cpp"

	}
	break;
	
	case 46:
	{
#line 2160 "../meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = new vstr_t;
		(yyval.m_pvstrSymbs)->push_back((yys_sv__[0].m_pchVal));
		
		delete[] (yys_sv__[0].m_pchVal);
	
#line 4876 "ulyac.cpp"

	}
	break;
	
	case 47:
	{
#line 2166 "../meta/ulyac.upg"

		(yyval.m_pvstrSymbs) = new vstr_t;
		(yyval.m_pvstrSymbs)->push_back(strhelper_t::quotedChar((yys_sv__[0].m_cVal)));
	
#line 4888 "ulyac.cpp"

	}
	break;
	
	case 48:
	{
#line 2172 "../meta/ulyac.upg"

			
			if(! dmap.insert((yys_sv__[2].m_pchVal), (yys_sv__[0].m_pchVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}
			
			delete[] (yys_sv__[2].m_pchVal);
			delete[] (yys_sv__[0].m_pchVal);
		
#line 4912 "ulyac.cpp"

	}
	break;
	
	case 49:
	{
#line 2188 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[2].m_pchVal), (yys_sv__[0].m_nVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[2].m_pchVal);
		
#line 4935 "ulyac.cpp"

	}
	break;
	
	case 50:
	{
#line 2203 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[2].m_pchVal), false)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[2].m_pchVal);
		
#line 4958 "ulyac.cpp"

	}
	break;
	
	case 51:
	{
#line 2218 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[2].m_pchVal), true)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[2].m_pchVal);
		
#line 4981 "ulyac.cpp"

	}
	break;
	
	case 52:
	{
#line 2233 "../meta/ulyac.upg"

			
			if( ! dmap.insert((yys_sv__[1].m_pchVal), (yys_sv__[0].m_pchVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
			delete[] (yys_sv__[0].m_pchVal);
		
#line 5005 "ulyac.cpp"

	}
	break;
	
	case 53:
	{
#line 2249 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[1].m_pchVal), (yys_sv__[0].m_nVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
		
#line 5028 "ulyac.cpp"

	}
	break;
	
	case 54:
	{
#line 2264 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[1].m_pchVal), false)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
		
#line 5051 "ulyac.cpp"

	}
	break;
	
	case 55:
	{
#line 2279 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[1].m_pchVal), true)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[1].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete[] (yys_sv__[1].m_pchVal);
		
#line 5074 "ulyac.cpp"

	}
	break;
	
	case 56:
	{
#line 2294 "../meta/ulyac.upg"

		
			if( ! dmap.insert((yys_sv__[0].m_pchVal), true)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: option `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' duplicated and discarded.";
				_WARNING(strMsg);
			}

			delete (yys_sv__[0].m_pchVal);
		
#line 5097 "ulyac.cpp"

	}
	break;
	
	case 57:
	{
#line 2311 "../meta/ulyac.upg"


			if(!lexer.addMacro((yys_sv__[2].m_pchVal), (yys_sv__[1].m_pRENode))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: macro is duplicated and ignored `";
				strMsg += (yys_sv__[2].m_pchVal);
				strMsg += "\'";
				
				_ERROR(strMsg, ESYN(1));
			}
				
			delete[] (yys_sv__[2].m_pchVal);
		
#line 5121 "ulyac.cpp"

	}
	break;
	
	case 58:
	{
#line 2327 "../meta/ulyac.upg"


			lexer.addMacro((yys_sv__[3].m_pchVal), (yys_sv__[2].m_pRENode));
			
			strMsg = "invalid symbol.";
			
			_ERROR(strMsg, ESYN(1));

			delete[] (yys_sv__[3].m_pchVal);
			
			yyerrok();
		
#line 5141 "ulyac.cpp"

	}
	break;
	
	case 59:
	{
#line 2339 "../meta/ulyac.upg"

			
			strMsg = "invalid symbol.";
			
			_ERROR(strMsg, ESYN(1));

			delete[] (yys_sv__[2].m_pchVal);
			yyerrok();
		
#line 5158 "ulyac.cpp"

	}
	break;
	
	case 60:
	{
#line 2350 "../meta/ulyac.upg"

#line 5167 "ulyac.cpp"

	}
	break;
	
	case 61:
	{
#line 2351 "../meta/ulyac.upg"

#line 5176 "ulyac.cpp"

	}
	break;
	
	case 62:
	{
#line 2354 "../meta/ulyac.upg"

		
			assert((yys_sv__[1].m_prTrees));
			assert((yys_sv__[0].m_nVal) >= 0);
			
			for(unsigned int i = 0; i < (yys_sv__[1].m_prTrees)->size(); ++i) {
				
				lexer.attachAction((*(yys_sv__[1].m_prTrees))[i], (yys_sv__[0].m_nVal));
				dtbl.mapRule2Action(lexer.tree2Rule((*(yys_sv__[1].m_prTrees))[i]->getID()), (yys_sv__[0].m_nVal));
			}
			
			delete (yys_sv__[1].m_prTrees);
		
#line 5197 "ulyac.cpp"

	}
	break;
	
	case 63:
	{
#line 2367 "../meta/ulyac.upg"

		
			assert((yys_sv__[2].m_prTrees));
			
			strMsg = "invalid symbol.";
			
			_ERROR(strMsg, ESYN(2));
			
			delete (yys_sv__[2].m_prTrees);
			
			yyerrok();
		
#line 5217 "ulyac.cpp"

	}
	break;
	
	case 64:
	{
#line 2381 "../meta/ulyac.upg"


			assert((yys_sv__[0].m_pRETree));
			(yyval.m_prTrees) = new rtpool_t;
			(yyval.m_prTrees)->push_back((yys_sv__[0].m_pRETree));
		
#line 5231 "ulyac.cpp"

	}
	break;
	
	case 65:
	{
#line 2387 "../meta/ulyac.upg"

			
			assert((yys_sv__[2].m_prTrees) && (yys_sv__[0].m_pRETree));
			(yyval.m_prTrees) = (yys_sv__[2].m_prTrees);
			(yyval.m_prTrees)->push_back((yys_sv__[0].m_pRETree));
		
#line 5245 "ulyac.cpp"

	}
	break;
	
	case 66:
	{
#line 2395 "../meta/ulyac.upg"


			assert((yys_sv__[0].m_pRETree));
			
			if( ! (yys_sv__[1].m_pIndices)) {
			
				lexer.addSCTree((yys_sv__[0].m_pRETree)->getID());
			}
			else {
				
				for(unsigned int i = 0; i < (yys_sv__[1].m_pIndices)->size(); ++i) {

					lexer.addSCTree((*(yys_sv__[1].m_pIndices))[i], (yys_sv__[0].m_pRETree)->getID());
				}
				
				delete (yys_sv__[1].m_pIndices);
			}

			(yyval.m_pRETree) = (yys_sv__[0].m_pRETree);
			
			dtbl.mapRule2Line(lexer.tree2Rule((yys_sv__[0].m_pRETree)->getID()), (yys_loc__[0]).firstLine); 
		
#line 5275 "ulyac.cpp"

	}
	break;
	
	case 67:
	{
#line 2419 "../meta/ulyac.upg"


			(yyval.m_nVal) = (yys_sv__[0].m_nVal);
		
#line 5287 "ulyac.cpp"

	}
	break;
	
	case 68:
	{
#line 2423 "../meta/ulyac.upg"

		
			assert((yys_sv__[1].m_nVal) == (yys_sv__[0].m_nVal));
			(yyval.m_nVal) = (yys_sv__[1].m_nVal);
		
#line 5300 "ulyac.cpp"

	}
	break;
	
	case 69:
	{
#line 2430 "../meta/ulyac.upg"

			
			(yyval.m_pIndices) = (yys_sv__[1].m_pIndices);
		
#line 5312 "ulyac.cpp"

	}
	break;
	
	case 70:
	{
#line 2434 "../meta/ulyac.upg"

		
			(yyval.m_pIndices) = nullptr;
		
#line 5324 "ulyac.cpp"

	}
	break;
	
	case 71:
	{
#line 2438 "../meta/ulyac.upg"

		
			(yyval.m_pIndices) = new vint_t;
			(yyval.m_pIndices)->push_back(0);
		
#line 5337 "ulyac.cpp"

	}
	break;
	
	case 72:
	{
#line 2445 "../meta/ulyac.upg"


			(yyval.m_pIndices) = new vint_t;
			(yyval.m_pIndices)->push_back((yys_sv__[0].m_nVal));
		
#line 5350 "ulyac.cpp"

	}
	break;
	
	case 73:
	{
#line 2450 "../meta/ulyac.upg"

		
			assert((yys_sv__[2].m_pIndices));
			(yys_sv__[2].m_pIndices)->push_back((yys_sv__[0].m_nVal));
			(yyval.m_pIndices) = (yys_sv__[2].m_pIndices);
		
#line 5364 "ulyac.cpp"

	}
	break;
	
	case 74:
	{
#line 2458 "../meta/ulyac.upg"


			(yyval.m_nVal) = lexer.getSCIdx((yys_sv__[0].m_pchVal));
			if(_EQ(INVALID_INDEX, (yyval.m_nVal))) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: invalid start condition `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\'";
				
				(yyval.m_nVal) = 0;
				_ERROR(strMsg, ESYN(2));
			}
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 5390 "ulyac.cpp"

	}
	break;
	
	case 75:
	{
#line 2476 "../meta/ulyac.upg"

		
			(yyval.m_nVal) = 0;
		
#line 5402 "ulyac.cpp"

	}
	break;
	
	case 76:
	{
#line 2482 "../meta/ulyac.upg"


			(yys_sv__[0].m_pRENode) = lexer.addConcatNode((yys_sv__[0].m_pRENode), lexer.addEorNode(false));
			(yyval.m_pRETree) = lexer.addTree(dtbl.addRule(), (yys_sv__[0].m_pRENode), false);
			lexer.setLookaheadFlag(false);
		
#line 5416 "ulyac.cpp"

	}
	break;
	
	case 77:
	{
#line 2488 "../meta/ulyac.upg"

		
			(yys_sv__[0].m_pRENode) = lexer.addConcatNode((yys_sv__[0].m_pRENode), lexer.addEorNode(false));
			(yyval.m_pRETree) = lexer.addTree(dtbl.addRule(), (yys_sv__[0].m_pRENode), true);
			lexer.setLookaheadFlag(false);
		
#line 5430 "ulyac.cpp"

	}
	break;
	
	case 78:
	{
#line 2494 "../meta/ulyac.upg"

		
			(yyval.m_pRETree) = lexer.addTree(dtbl.addRule(), lexer.addEofNode(), false, true);
		
#line 5442 "ulyac.cpp"

	}
	break;
	
	case 79:
	{
#line 2500 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5454 "ulyac.cpp"

	}
	break;
	
	case 80:
	{
#line 2504 "../meta/ulyac.upg"

			lexer.setLookaheadFlag(true);
			(yyval.m_pRENode) = lexer.addLeafNode(new charset_t('\n'), false);
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yyval.m_pRENode));
		
#line 5467 "ulyac.cpp"

	}
	break;
	
	case 81:
	{
#line 2509 "../meta/ulyac.upg"
		
			
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5479 "ulyac.cpp"

	}
	break;
	
	case 82:
	{
#line 2515 "../meta/ulyac.upg"

		
			lexer.setLookaheadFlag(true);
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
		
#line 5492 "ulyac.cpp"

	}
	break;
	
	case 83:
	{
#line 2522 "../meta/ulyac.upg"


			(yyval.m_pRENode) = lexer.addUnionNode((yys_sv__[2].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5504 "ulyac.cpp"

	}
	break;
	
	case 84:
	{
#line 2526 "../meta/ulyac.upg"

		
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5516 "ulyac.cpp"

	}
	break;
	
	case 85:
	{
#line 2548 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5528 "ulyac.cpp"

	}
	break;
	
	case 86:
	{
#line 2552 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5540 "ulyac.cpp"

	}
	break;
	
	case 87:
	{
#line 2558 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nLower > 1; --((yys_sv__[0].m_nRange).m_nLower)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}			
		
#line 5557 "ulyac.cpp"

	}
	break;
	
	case 88:
	{
#line 2567 "../meta/ulyac.upg"

		
			(yys_sv__[1].m_pRENode)->setNullable(true);
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nUpper > 1; --((yys_sv__[0].m_nRange).m_nUpper)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}
		
#line 5575 "ulyac.cpp"

	}
	break;
	
	case 89:
	{
#line 2577 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nLower > 1; --((yys_sv__[0].m_nRange).m_nLower)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}
			
			(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.addStarNode(lexer.copySubtree((yys_sv__[1].m_pRENode))));
		
#line 5594 "ulyac.cpp"

	}
	break;
	
	case 90:
	{
#line 2588 "../meta/ulyac.upg"

		
			if((yys_sv__[0].m_nRange).m_nLower > (yys_sv__[0].m_nRange).m_nUpper || _EQ(0, (yys_sv__[0].m_nRange).m_nUpper)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: invalid range `{";
				strMsg += strhelper_t::fromInt((yys_sv__[0].m_nRange).m_nLower);
				strMsg += ",";
				strMsg += strhelper_t::fromInt((yys_sv__[0].m_nRange).m_nUpper);
				strMsg += "}\'";
				
				(yys_sv__[0].m_nRange).m_nLower = (yys_sv__[0].m_nRange).m_nUpper = 1;
				_ERROR(strMsg, ESYN(3));
			}
			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			int i = 1;
			
			if((yys_sv__[0].m_nRange).m_nLower <= 0) {
				(yys_sv__[1].m_pRENode)->setNullable(true);
			}
			else {
				for(; i < (yys_sv__[0].m_nRange).m_nLower; ++i) {
				
					(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
				}
			}
			
			for(; i < (yys_sv__[0].m_nRange).m_nUpper; ++i) {
			
				renode_t *pNode = lexer.copySubtree((yys_sv__[1].m_pRENode));
				pNode->setNullable(true);
				
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), pNode);
			}
		
#line 5640 "ulyac.cpp"

	}
	break;
	
	case 91:
	{
#line 2626 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = lexer.addStarNode((yys_sv__[1].m_pRENode));
		
#line 5652 "ulyac.cpp"

	}
	break;
	
	case 92:
	{
#line 2630 "../meta/ulyac.upg"

			
			renode_t *pNode = lexer.copySubtree((yys_sv__[1].m_pRENode));
			
			assert(pNode);
			
			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), lexer.addStarNode(pNode));			
		
#line 5668 "ulyac.cpp"

	}
	break;
	
	case 93:
	{
#line 2638 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			(yys_sv__[1].m_pRENode)->setNullable(true);
		
#line 5681 "ulyac.cpp"

	}
	break;
	
	case 94:
	{
#line 2643 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5693 "ulyac.cpp"

	}
	break;
	
	case 95:
	{
#line 2649 "../meta/ulyac.upg"


			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
		
#line 5705 "ulyac.cpp"

	}
	break;
	
	case 96:
	{
#line 2653 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5717 "ulyac.cpp"

	}
	break;
	
	case 97:
	{
#line 2659 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5729 "ulyac.cpp"

	}
	break;
	
	case 98:
	{
#line 2663 "../meta/ulyac.upg"
		
			
			(yyval.m_pRENode) = lexer.copyMacrotree((yys_sv__[0].m_pchVal));
			if(_EQ(nullptr, (yyval.m_pRENode))) {
				
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: undefined regular expression macro `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\'";	
				
				(yyval.m_pRENode) = lexer.addLeafNode('a');			
				_ERROR(strMsg, ESYN(4));
			}
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 5755 "ulyac.cpp"

	}
	break;
	
	case 99:
	{
#line 2682 "../meta/ulyac.upg"


			(yyval.m_pRENode) = lexer.addConcatNode((yys_sv__[1].m_pRENode), (yys_sv__[0].m_pRENode));
		
#line 5767 "ulyac.cpp"

	}
	break;
	
	case 100:
	{
#line 2686 "../meta/ulyac.upg"

		
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5779 "ulyac.cpp"

	}
	break;
	
	case 101:
	{
#line 2691 "../meta/ulyac.upg"

			
			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
			
			for(; (yys_sv__[0].m_nRange).m_nLower > 1; --((yys_sv__[0].m_nRange).m_nLower)) {
			
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.copySubtree((yys_sv__[1].m_pRENode)));
			}			
		
#line 5796 "ulyac.cpp"

	}
	break;
	
	case 102:
	{
#line 2700 "../meta/ulyac.upg"


			(yyval.m_pRENode) = (yys_sv__[1].m_pRENode);
		
#line 5808 "ulyac.cpp"

	}
	break;
	
	case 103:
	{
#line 2704 "../meta/ulyac.upg"

		
			(yyval.m_pRENode) = (yys_sv__[0].m_pRENode);
		
#line 5820 "ulyac.cpp"

	}
	break;
	
	case 104:
	{
#line 2710 "../meta/ulyac.upg"

			(yyval.m_pRENode) = lexer.addLeafNode((yys_sv__[0].m_pCS));
		
#line 5831 "ulyac.cpp"

	}
	break;
	
	case 105:
	{
#line 2713 "../meta/ulyac.upg"

			charset_t *pcs = new charset_t((yys_sv__[0].m_cVal));	
			if( ! gsetup.m_bCaseSensitive) {
				if((yys_sv__[0].m_cVal) >= 65 && (yys_sv__[0].m_cVal) <= 90) {
					pcs->set((yys_sv__[0].m_cVal) + 32);
				}
				else if((yys_sv__[0].m_cVal) >= 97 && (yys_sv__[0].m_cVal) <= 122) {
					pcs->set((yys_sv__[0].m_cVal) - 32);
				}
			}
			(yyval.m_pRENode) = lexer.addLeafNode(pcs);
		
#line 5851 "ulyac.cpp"

	}
	break;
	
	case 106:
	{
#line 2725 "../meta/ulyac.upg"

			if( ! gsetup.m_bCaseSensitive && (charset_t::LOWER == (yys_sv__[0].m_nPosix) || charset_t::UPPER == (yys_sv__[0].m_nPosix))) {
			
				(yys_sv__[0].m_nPosix) = charset_t::ALPHA;
			}
			(yyval.m_pRENode) = lexer.addLeafNode((yys_sv__[0].m_nPosix));
		
#line 5866 "ulyac.cpp"

	}
	break;
	
	case 107:
	{
#line 2732 "../meta/ulyac.upg"

		
			string str;
			
			bool bret =
				strhelper_t::ustr2Str((yys_sv__[0].m_pchVal), str);
			assert(bret);
			
			charset_t *pcs = nullptr;
			if(str.size() > 0) {
				
				pcs = new charset_t(str[0]);
				if( ! gsetup.m_bCaseSensitive) {
					if(str[0] >= 65 && str[0] <= 90) {
						pcs->set(str[0] + 32);
					}
					else if(str[0] >= 97 && str[0] <= 122) {
						pcs->set(str[0] - 32);
					}
				}
				(yyval.m_pRENode) = lexer.addLeafNode(pcs);
			}
			
			for(unsigned int i = 1; i < str.size(); ++i) {
			
				pcs = new charset_t(str[i]);
				if( ! gsetup.m_bCaseSensitive) {
					if(str[i] >= 65 && str[i] <= 90) {
						pcs->set(str[i] + 32);
					}
					else if(str[i] >= 97 && str[i] <= 122) {
						pcs->set(str[i] - 32);
					}
				}
				(yyval.m_pRENode) = lexer.addConcatNode((yyval.m_pRENode), lexer.addLeafNode(pcs));
			}
			delete (yys_sv__[0].m_pchVal);
		
#line 5912 "ulyac.cpp"

	}
	break;
	
	case 108:
	{
#line 2770 "../meta/ulyac.upg"

			
			const char cc[2] = {'\n', '\0'};
			(yyval.m_pRENode) = lexer.addLeafNode(cc, true);
		
#line 5925 "ulyac.cpp"

	}
	break;
	
	case 109:
	{
#line 2777 "../meta/ulyac.upg"


			(yyval.m_pCS) = (yys_sv__[1].m_pCS);
		
#line 5937 "ulyac.cpp"

	}
	break;
	
	case 110:
	{
#line 2781 "../meta/ulyac.upg"


			(yyval.m_pCS) = (yys_sv__[1].m_pCS);
			(yys_sv__[1].m_pCS)->flip();			
		
#line 5950 "ulyac.cpp"

	}
	break;
	
	case 111:
	{
#line 2788 "../meta/ulyac.upg"

		
			(yyval.m_pCS) = (yys_sv__[0].m_pCS);
		
#line 5962 "ulyac.cpp"

	}
	break;
	
	case 112:
	{
#line 2792 "../meta/ulyac.upg"

			
			*((yys_sv__[1].m_pCS)) |= *((yys_sv__[0].m_pCS));
			(yyval.m_pCS) = (yys_sv__[1].m_pCS);

			delete (yys_sv__[0].m_pCS);
		
#line 5977 "ulyac.cpp"

	}
	break;
	
	case 113:
	{
#line 2801 "../meta/ulyac.upg"

			
			(yyval.m_pCS) = new charset_t('\n', true);			
		
#line 5989 "ulyac.cpp"

	}
	break;
	
	case 114:
	{
#line 2805 "../meta/ulyac.upg"

		
			(yyval.m_pCS) = new charset_t((yys_sv__[0].m_cVal));
			
			if( ! gsetup.m_bCaseSensitive) {
				if((yys_sv__[0].m_cVal) >= 65 && (yys_sv__[0].m_cVal) <= 90) {
					(yyval.m_pCS)->set((yys_sv__[0].m_cVal) + 32);
				}
				else if((yys_sv__[0].m_cVal) >= 97 && (yys_sv__[0].m_cVal) <= 122) {
					(yyval.m_pCS)->set((yys_sv__[0].m_cVal) - 32);
				}
			}
		
#line 6010 "ulyac.cpp"

	}
	break;
	
	case 115:
	{
#line 2818 "../meta/ulyac.upg"

		
			if((unsigned char)(yys_sv__[2].m_cVal) > (unsigned char)(yys_sv__[0].m_cVal)) {
			
				strMsg = strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstColumn);
				strMsg += "; description: char range `";
				strMsg += (yys_sv__[2].m_cVal);
				strMsg += "-";
				strMsg += (yys_sv__[0].m_cVal);
				strMsg += "\' empty and ignored.";
				_ERROR(strMsg, ESYN(5));

				(yys_sv__[2].m_cVal) = (yys_sv__[0].m_cVal);
			}
			
			(yyval.m_pCS) = new charset_t((yys_sv__[2].m_cVal), (yys_sv__[0].m_cVal));
			if( ! gsetup.m_bCaseSensitive) {
				for(unsigned char c = (unsigned char)(yys_sv__[2].m_cVal); c <= 122 && c <= (unsigned char)(yys_sv__[0].m_cVal); ++c ) {
					
					if(c >= 65 && c <= 90) {
					
						(yyval.m_pCS)->set(c + 32);
					}
					else if(c >= 97 && c <= 122) {
					
						(yyval.m_pCS)->set(c - 32);
					}
				}
			} 
		
#line 6050 "ulyac.cpp"

	}
	break;
	
	case 116:
	{
#line 2850 "../meta/ulyac.upg"

		
			if( ! gsetup.m_bCaseSensitive && (charset_t::LOWER == (yys_sv__[0].m_nPosix) || charset_t::UPPER == (yys_sv__[0].m_nPosix))) {
			
				(yys_sv__[0].m_nPosix) = charset_t::ALPHA;
			}
			(yyval.m_pCS) = new charset_t((yys_sv__[0].m_nPosix));
		
#line 6066 "ulyac.cpp"

	}
	break;
	
	case 117:
	{
#line 2860 "../meta/ulyac.upg"

#line 6075 "ulyac.cpp"

	}
	break;
	
	case 118:
	{
#line 2861 "../meta/ulyac.upg"

#line 6084 "ulyac.cpp"

	}
	break;
	
	case 119:
	{
#line 2863 "../meta/ulyac.upg"

#line 6093 "ulyac.cpp"

	}
	break;
	
	case 120:
	{
#line 2864 "../meta/ulyac.upg"

				strMsg = strhelper_t::fromInt((yys_loc__[0]).lastLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).lastColumn);
				strMsg += "; description: lack of `;\'.";
				_WARNING(strMsg);
		
#line 6108 "ulyac.cpp"

	}
	break;
	
	case 121:
	{
#line 2871 "../meta/ulyac.upg"

				strMsg = "invalid syntactic rule.";
				_ERROR(strMsg, ESYN(5));
				yyerrok();
		
#line 6121 "ulyac.cpp"

	}
	break;
	
	case 122:
	{
#line 2877 "../meta/ulyac.upg"

			
			if( grammar.isToken((yys_sv__[0].m_pchVal))) {
				strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
				strMsg += ':';
				strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
				strMsg += "; description: declaration of type `";
				strMsg += (yys_sv__[0].m_pchVal);
				strMsg += "\' expected.";
				_ERROR(strMsg, ESYN(5));

				
				strMsg = grammar.getFakeSymbol();
				(yyval.m_nVal) = grammar.addType(strMsg, DEFAULT_SVT_ID).first;
			}
			else {
			
				(yyval.m_nVal) = grammar.getSymbolIndex((yys_sv__[0].m_pchVal));
				if(INVALID_INDEX == (yyval.m_nVal)) {
					(yyval.m_nVal) = grammar.addType((yys_sv__[0].m_pchVal), DEFAULT_SVT_ID).first;
					++s_nCounter;
				}
				else {
					(yyval.m_nVal) = grammar.getSymbolIndex((yys_sv__[0].m_pchVal));
				}
			}
				
			s_nCurLeftSymbol = (yyval.m_nVal);
			assert(s_nCurLeftSymbol != INVALID_INDEX);
			
			if(grammar.getRuleCount() == 0) {
				if(grammar.getStartSymbol() == INVALID_INDEX) {
					grammar.setStartSymbol(s_nCurLeftSymbol);
				}
				
				i2b_pair_t pairRet = grammar.addType(INTERNAL_ACCEPT_TYPE, DEFAULT_SVT_ID, false);
				++s_nCounter;
				assert(pairRet.second);
				grammar.setAcceptSymbol(pairRet.first);
				parser_ns::prod_t *pr = grammar.addEmptyRule(grammar.getAcceptSymbol());
				assert(pr);
				pr->addRight(grammar.getStartSymbol());
				pr->addRight(END_SYMBOL_INDEX);
				grammar.setAcceptRule(pr->getID());
				
				int nActID = ptbl.addEmptyAction((yys_loc__[0]).firstLine);
				ptbl.mapRule2Action(pr->getID(), nActID);			
				ptbl.mapRule2Line(pr->getID(), (yys_loc__[0]).firstLine);
			}
			
			delete[] (yys_sv__[0].m_pchVal);
		
#line 6181 "ulyac.cpp"

	}
	break;
	
	case 124:
	{
#line 2931 "../meta/ulyac.upg"


			grammar.addEmptyRule(s_nCurLeftSymbol);
		
#line 6193 "ulyac.cpp"

	}
	break;
	
	case 123:
	{
#line 2931 "../meta/ulyac.upg"

#line 6202 "ulyac.cpp"

	}
	break;
	
	case 126:
	{
#line 2936 "../meta/ulyac.upg"

			grammar.addEmptyRule(s_nCurLeftSymbol);
		
#line 6213 "ulyac.cpp"

	}
	break;
	
	case 125:
	{
#line 2936 "../meta/ulyac.upg"

#line 6222 "ulyac.cpp"

	}
	break;
	
	case 127:
	{
#line 2941 "../meta/ulyac.upg"

			
			(yyval.m_pProd) = (yys_sv__[4].m_pProd);
			(yyval.m_pProd)->setPrec((yys_sv__[2].m_nVal));
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));			
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[4]).firstLine);
			
//			string strMidSVT = grammar.getMidSVT();
//			if(!strMidSVT.empty()) {
//				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
//				strMsg += ':';
//				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
//				strMsg += "; description: semantic value type declaration `";
//				strMsg += strMidSVT;
//				strMsg += "\' unexpected, this may contribute problem of type incompatible.";
//				_WARNING(strMsg);
//			}
			
			grammar.clearMidSVT();
		
#line 6251 "ulyac.cpp"

	}
	break;
	
	case 128:
	{
#line 2962 "../meta/ulyac.upg"

			
			(yyval.m_pProd) = (yys_sv__[2].m_pProd);
			(yyval.m_pProd)->setPrec((yys_sv__[0].m_nVal));
			int nActID = ptbl.addEmptyAction((yys_loc__[2]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[2]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);
		
#line 6268 "ulyac.cpp"

	}
	break;
	
	case 129:
	{
#line 2971 "../meta/ulyac.upg"

		
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->setPrec((yys_sv__[2].m_nVal));
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[3]).firstLine);
//			string strMidSVT = grammar.getMidSVT();
//			if(!strMidSVT.empty()) {
//				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
//				strMsg += ':';
//				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
//				strMsg += "; description: semantic value type declaration `";
//				strMsg += strMidSVT;
//				strMsg += "\' unexpected, this may contribute problem of type incompatible.";
//				_WARNING(strMsg);
//			}
			
			grammar.clearMidSVT();
		
#line 6296 "ulyac.cpp"

	}
	break;
	
	case 130:
	{
#line 2991 "../meta/ulyac.upg"

		
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->setPrec((yys_sv__[0].m_nVal));
			int nActID = ptbl.addEmptyAction((yys_loc__[1]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[1]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);
		
#line 6313 "ulyac.cpp"

	}
	break;
	
	case 131:
	{
#line 3000 "../meta/ulyac.upg"

			
			(yyval.m_pProd) = (yys_sv__[2].m_pProd);
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[2]).firstLine);
//			string strMidSVT = grammar.getMidSVT();
//			if(!strMidSVT.empty()) {
//				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
//				strMsg += ':';
//				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
//				strMsg += "; description: semantic value type declaration `";
//				strMsg += strMidSVT;
//				strMsg += "\' unexpected, this may contribute problem of type incompatible.";
//				_WARNING(strMsg);
//			}
			
			grammar.clearMidSVT();
		
#line 6340 "ulyac.cpp"

	}
	break;
	
	case 132:
	{
#line 3019 "../meta/ulyac.upg"

			(yyval.m_pProd) = (yys_sv__[0].m_pProd);
			int nActID = ptbl.addEmptyAction((yys_loc__[0]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[0]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);
		
#line 6355 "ulyac.cpp"

	}
	break;
	
	case 133:
	{
#line 3026 "../meta/ulyac.upg"

			
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->setActionIndex((yys_sv__[1].m_nVal));
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), (yys_sv__[1].m_nVal));
			ptbl.mapRule2Line((yyval.m_pProd)->getID(), (yys_loc__[1]).firstLine);
//			string strMidSVT = grammar.getMidSVT();
//			if(!strMidSVT.empty()) {
//				strMsg = strhelper_t::fromInt((yys_loc__[1]).firstLine);
//				strMsg += ':';
//				strMsg += strhelper_t::fromInt((yys_loc__[1]).firstColumn);
//				strMsg += "; description: semantic value type declaration `";
//				strMsg += strMidSVT;
//				strMsg += "\' unexpected, this may contribute problem of type incompatible.";
//				_WARNING(strMsg);
//			}
			
			grammar.clearMidSVT();
		
#line 6382 "ulyac.cpp"

	}
	break;
	
	case 134:
	{
#line 3045 "../meta/ulyac.upg"

			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			int nActID = ptbl.addEmptyAction((yys_loc__[0]).firstLine);
			ptbl.mapRule2Action((yyval.m_pProd)->getID(), nActID);
			ptbl.mapRule2Line(nActID, (yys_loc__[0]).firstLine);
			(yyval.m_pProd)->setActionIndex(nActID);			
		
#line 6397 "ulyac.cpp"

	}
	break;
	
	case 135:
	{
#line 3053 "../meta/ulyac.upg"

			(yyval.m_pProd) = (yys_sv__[3].m_pProd);
			prod_t* pr = grammar.addMidRule((yys_sv__[2].m_nVal));
			assert(pr);
			(yyval.m_pProd)->addRight(pr->getLeft());
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			ptbl.mapRule2Action(pr->getID(), (yys_sv__[2].m_nVal));
			ptbl.mapRule2Line(pr->getID(), (yys_loc__[2]).firstLine);
			pr->setActionIndex((yys_sv__[2].m_nVal));
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6418 "ulyac.cpp"

	}
	break;
	
	case 136:
	{
#line 3066 "../meta/ulyac.upg"

			(yyval.m_pProd) = (yys_sv__[1].m_pProd);
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6432 "ulyac.cpp"

	}
	break;
	
	case 137:
	{
#line 3072 "../meta/ulyac.upg"

			prod_t* pr = grammar.addMidRule((yys_sv__[2].m_nVal));
			assert(pr);
			
			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->addRight(pr->getLeft());
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			ptbl.mapRule2Action(pr->getID(), (yys_sv__[2].m_nVal));
			ptbl.mapRule2Line(pr->getID(), (yys_loc__[2]).firstLine);
			pr->setActionIndex((yys_sv__[2].m_nVal));
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6454 "ulyac.cpp"

	}
	break;
	
	case 138:
	{
#line 3086 "../meta/ulyac.upg"

			(yyval.m_pProd) = grammar.getProd(grammar.getLastProdIndex());
			(yyval.m_pProd)->addRight((yys_sv__[0].m_pPItem)->m_nSymbol, (yys_sv__[0].m_pPItem)->m_nPrec, (yys_sv__[0].m_pPItem)->m_nAssoc);
			
			delete (yys_sv__[0].m_pPItem);
		
#line 6468 "ulyac.cpp"

	}
	break;
	
	case 139:
	{
#line 3093 "../meta/ulyac.upg"

			if((yys_sv__[2].m_nVal) >= grammar.getTypeBase()) {
				strMsg = "at line ";
				strMsg += strhelper_t::fromInt((yys_loc__[2]).firstLine);
				strMsg += "; description: %prec can not apply to types, ignored.";
				_WARNING(strMsg);
				
				(yyval.m_pPItem) = new prod_item_t((yys_sv__[2].m_nVal));
			}
			else {
				const symbol_t* psym = grammar.getSymbolObj((yys_sv__[0].m_pchVal));
				if( ! psym) {
					strMsg = strhelper_t::fromInt((yys_loc__[0]).firstLine);
					strMsg += ':';
					strMsg += strhelper_t::fromInt((yys_loc__[0]).firstColumn);
					strMsg += "; description: declaration of token `";
					strMsg += (yys_sv__[0].m_pchVal);
					strMsg += "\' expected.";
					_ERROR(strMsg, ESYN(6));
					
					psym = grammar.getSymbolObj(1);
				}
				assert(psym->isToken());
				(const_cast<symbol_t*>(psym))->setUsed(true);
				(yyval.m_pPItem) = new prod_item_t((yys_sv__[2].m_nVal), psym->getPrec(), psym->getAssoc());
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 6504 "ulyac.cpp"

	}
	break;
	
	case 140:
	{
#line 3121 "../meta/ulyac.upg"

		
			if((yys_sv__[0].m_nVal) >= grammar.getTypeBase()) {				
				(yyval.m_pPItem) = new prod_item_t((yys_sv__[0].m_nVal));
			}
			else {
				if((yys_sv__[0].m_nVal) < 0) {
					(yyval.m_pPItem) = new prod_item_t((yys_sv__[0].m_nVal));
				}
				else {
					const symbol_t* psym = grammar.getSymbolObj((yys_sv__[0].m_nVal));
					assert(psym && psym->isToken());
					(yyval.m_pPItem) = new prod_item_t((yys_sv__[0].m_nVal), psym->getPrec(), psym->getAssoc());					
				}
			}
		
#line 6528 "ulyac.cpp"

	}
	break;
	
	case 141:
	{
#line 3138 "../meta/ulyac.upg"

			(yyval.m_nVal) = grammar.getSymbolIndex((yys_sv__[0].m_pchVal));
			if(INVALID_INDEX == (yyval.m_nVal)) {
				(yyval.m_nVal) = grammar.addType((yys_sv__[0].m_pchVal), DEFAULT_SVT_ID).first;
				++s_nCounter;
			}
			delete[] (yys_sv__[0].m_pchVal);
		
#line 6544 "ulyac.cpp"

	}
	break;
	
	case 142:
	{
#line 3146 "../meta/ulyac.upg"

				string strSName = strhelper_t::quotedChar((yys_sv__[0].m_cVal));
				(yyval.m_nVal) = grammar.getSymbolIndex(strSName);
				if(INVALID_INDEX == (yyval.m_nVal)) {
				
						s2i_cit_t cit = s_sname2Idx.find(strSName);
						if(cit == s_sname2Idx.end()) {
							
							s_vstrSName.push_back(strSName);
							s_vnToken.push_back((int)(yys_sv__[0].m_cVal));
							
							(yyval.m_nVal) = (int)s_vstrSName.size();
							(yyval.m_nVal) = - (yyval.m_nVal);
							s_sname2Idx.insert(s2i_pair_t(strSName, (yyval.m_nVal)));
						}
						else {
							(yyval.m_nVal) = cit->second;
						}
				}
		
#line 6572 "ulyac.cpp"

	}
	break;
	
				default:

					if( ! yyerr_flag__ || PARSE_ENDSYMB_ID == yytok__) {
						if(! yyerr_flag__) {
							if(yyerror) {

char yycc[MAX_MSG_LENG];
sprintf(yycc, "Error: syntax error at %d:%d.", yylloc.firstLine, yylloc.firstColumn);
yyerror(yycc, lexer, dtbl, grammar, ptbl, dmap, gsetup);
				}

							yyecode__ = YYE_PERROR;
						}
						else {
							yyecode__ = YYE_NOINPUT;
						}
						
						yyerr_flag__ = true;
						yyltok = yytok__;
					}
					else {
					
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yytok__ = PARSE_ERRORSYMB_ID;
					yysidx__ = PARSE_ERRORSYMB_INDEX;

					while(! yys_sv__.empty())  {
						yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);
						if(is_valid_pstate__(yypstate__)) {
							break;
						}
			

						yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top(), lexer, dtbl, grammar, ptbl, dmap, gsetup);
						yys_loc__.pop(1);


						yys_symb__.pop(1);
						yys_sv__.pop(1);
						yys_stt__.pop(1);
					}

					if( yys_sv__.empty()) {
						yys_stt__.pop(1);
					}

					break;
				}

				if(is_valid_prule__(yyprule__) || YYE_ACCEPT == yyecode__) {
					yyrplen__ = yyprnum[yyprule__];
					yypstate__ = yynext_goto__(yys_stt__[yyrplen__], yyplid[yyprule__]);


					if(YYE_ACCEPT != yyecode__) {
						yys_stt__.pop(yyrplen__);
						yys_symb__.pop(yyrplen__);
						yys_sv__.pop(yyrplen__);

						if(yyrplen__ == 0) {
							yyloc.firstLine = yyloc.lastLine = yys_loc__[0].lastLine;
							yyloc.firstColumn = yyloc.lastColumn = yys_loc__[0].lastColumn;
						}
						else {
							yyloc.firstLine = yys_loc__[yyrplen__ - 1].firstLine;
							yyloc.lastLine = yys_loc__[0].lastLine;
							yyloc.firstColumn = yys_loc__[yyrplen__ - 1].firstColumn;
							yyloc.lastColumn = yys_loc__[0].lastColumn;
						}
						yys_loc__.pop(yyrplen__);
						yys_loc__.push(yyloc);

						yys_stt__.push(yypstate__);
						yys_symb__.push(yyplid[yyprule__] + PARSE_TYPE_BASE);
						yys_sv__.push(yyval);
					}
				}
			}
		}

		while( ! yys_sv__.empty()) {

			yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top(), lexer, dtbl, grammar, ptbl, dmap, gsetup);

			yys_sv__.pop(1);
			yys_symb__.pop(1);
		}

		if(YYE_ACCEPT == yyecode__) {


			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE, lexer, dtbl, grammar, ptbl, dmap, gsetup);

			yyecode__ = YYE_ACCEPT;
		}

		return (yyecode__ == YYE_ACCEPT)? 0: yyecode__;
	}

public:
	inline void yyclearall__(void) {
		yyecode__ = YYE_ALIVE;
		yystart__ = INITIAL;		
		yymore_flag__ = false;
		yyat_bol__ = true;
		
		yyleng = 0;
		yylaleng = 0;
		if(yytext) {
			yytext[0] = '\0';
		}
		yybufmgr__.destroyall();

		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;

	}

private:

	// user interfaces
	// easy way to print matched string
	inline void YYECHO(void) const {
		ECHO();
	}
	inline void ECHO(void) const {
		fprintf(stdout, "%s", yytext);
	}

	// start-condition operations
	// switch start-condition
	inline void YYBEGIN(int sc) {
		BEGIN(sc);
	}
	inline void BEGIN(int sc) {
		yystart__ = sc;
	}
	// return current start-condition
	inline int YYSTART(void) const {
		return yystart__;
	}
	// save current start-condition and switch to new start-condition
	inline void yy_push_state(int nsc) {
		yyscstk__.push(yystart__);
		yystart__ = nsc;
	}
	// switch to last saved start-condition
	inline bool yy_pop_state(void) {

		if(yyscstk__.empty()) {
			return false;
		}
		yystart__ = yyscstk__.top();
		yyscstk__.pop(1);
		return true;
	}
	// return last saved start-condition
	inline int yy_top_state(void) {

		if(yyscstk__.empty()) {
			return INITIAL;
		}
		return yyscstk__.top();
	}

	// get/set flag of beginning-of-line
	inline bool yy_get_bol(void) const {
		return yyat_bol__;
	}
	inline void yy_set_bol(bool b) {
		yyat_bol__ = b;
	}

	// buffer operations
	inline YYPBUFFER yy_current_buffer(void) const {
		return yybufmgr__.current();
	}
	// 
	inline bool yy_has_buffer(void) const {
		return ! yybufmgr__.empty();
	}
	inline void yy_push_buffer(YYPBUFFER pbuffer) {
		yybufmgr__.switchto(pbuffer);
	}
	inline YYPBUFFER yy_pop_buffer(void) {
		return yybufmgr__.pop();
	}
	inline YYPBUFFER yy_new_filebuf(const char *strfile, bool bi = false) {
		if( !strfile ) {
			return yybufmgr__.newbuf(stdin, bi);
		}

	 	FILE *pfile = fopen(strfile, "r");
	 	if( !pfile) return nullptr;
		return yybufmgr__.newbuf(pfile);
	}

	inline YYPBUFFER yy_new_cstrbuf(const char *cstrbuffer, int size) {
		if( ! cstrbuffer || size < 1) {
			return nullptr;
		}
		return yybufmgr__.newbuf(cstrbuffer, size);
	}
	inline YYPBUFFER yy_new_strbuf(char *strbuffer, int size) {
		if( ! strbuffer || size < 1) {
			return nullptr;
		}
		return yybufmgr__.newbuf(strbuffer, size);
	}
	inline void yy_delete_buffer(void) {
		yybufmgr__.destroytop();
	}
	inline void yy_switch_buffer(YYPBUFFER buf) {
		yybufmgr__.switchto(buf);
	}
	inline void yyrestart(void) {

		yystart__ = INITIAL;
		yyecode__ = YYE_ALIVE;
		yymore_flag__ = false;
		
		yyleng = 0;
		yylaleng = 0;
		if( yytext ) {
			yytext[0] = '\0';
		}

		yyscstk__.clear();
		yybufmgr__.reset();
	}

	inline void yymore(void) {

		yymore_flag__ = true;
		yylaleng = yyleng;
	}
	inline int yyless(int n) {

		if(n > 0 && n < yyleng) {

			yytext[n] = '\0';
			n = yyleng - n;
			yyleng -= n;
			yylaleng = yyleng;
			return yybufmgr__.unget(n);
		}
		yylaleng = yyleng;
		yytext[yylaleng] = '\0';

		return 0;
	}

	inline int yyinput(void) {

		int c = yybufmgr__.get();
		if(c < END_OF_FILE) {
			if(c == '\t') {
				int nt = yyget_tabsize();
				nt -= (yyget_colno() + nt - 1) % nt;
				yybufmgr__.pushtsz(nt);
				yyadd_colno(nt);
			}
			else if(c == '\n') {
				yybufmgr__.pushlsz(yyget_colno());
				yyset_colno(1);
				yyadd_lineno(1);
			}
			else {
				yyadd_colno(1);
			}
		}	
		return c;
	}
	inline bool yyunput(char c) {
		int oldc = yybufmgr__.put(c);
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;
	}
	inline bool yyunget(void) {
		int oldc = yybufmgr__.unget();
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}		
		return oldc < END_OF_FILE;		
	}
	inline void yyterminate(void) {
		yyecode__ = YYE_TERM;
	}
	inline void yyadd_lineno(int nline) {
		yybufmgr__.setlineno(yybufmgr__.getlineno() + nline);
	}
	inline void yyadd_colno(int ncol) {
		yybufmgr__.setcolno(yybufmgr__.getcolno() + ncol);
	}
	inline int yyget_lineno(void) const {
		return yybufmgr__.getlineno();
	}
	inline void yyset_lineno(int nline) {
		yybufmgr__.setlineno(nline);
	}
	inline int yyget_colno(void) const {
		return yybufmgr__.getcolno();
	}
	inline void yyset_colno(int ncol) {
		yybufmgr__.setcolno(ncol);
	}
	inline int yyget_tabsize(void) const {
		return yybufmgr__.gettabsize();
	}
	inline void yyset_tabsize(int ntab) {
		yybufmgr__.settabsize(ntab);
	}
	bool yywrap__(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
		
			return false;
	}


private:

	int yyecode__;


	// buffer manager
	bufmgr_t yybufmgr__;
	// start-condition stack
	sstack_t<int, 32, 16> yyscstk__;
	int yysize__;
	int yystart__;

	bool yymore_flag__;
	bool yyat_bol__;

	char *yytext;
	int yyleng;
	int yylaleng;

	
	bool yyerr_flag__;
	int yyltok;
	yylex_t yylexer;

	yyerror_t yyerror;
	
private:
	

///////////////////////////////////////////////////////////////////////////
	// lexical tables
	// start states of DFAs
	static const int yydsc[26];

	// @yydcmap is a char map: char -> transition-label,
	// that is, chars are grouped, transition label is
	// representation of equivalent class of chars
	static const int yydcmap[258];

	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,
	// that is, transition-label in @yydcmap are further grouped in order to save space
	static const int yydmeta[76];

	// use next-check-base-default scheme to store DFAs
	// 
	static const int yydbase[647];
	static const int yyddef[647];
	// next table is an indeed transition table
	static const int yydnxt[2486];
	static const int yydchk[2486];
	static const int yydaccpt[557];
	
	static char YYMSG_UNMATCHED[];

///////////////////////////////////////////////////////////////////////////////
	// LALR parse tables
	// token map: token ID --> token index in token ID table
	// in fact, it acts like inverse table of token ID table
	static const int yyptmap[294];
	// token ID table, which contains token IDs
	//static const int yyptid[58];
	// number of symbols in a grammar rule
	static const int yyprnum[143];
	// index of left symbol in a grammar rule
	static const int yyplid[143];
	// parse action table
	static const int yypact[574];

	// base array for parse action table
	// which is used to determine the base location of the entries
	// for each state stored in the yypack table
	static const int yypabase[205];
	static const int yypgoto[35];
	static const int yypgbase[205];

	// check table for parse action table
	static const by_te_t yyvbmap[1640];
	static const int yyparv[205];
	static const int yyparn[205];

	static const int yypcv[112];
	static const int yypcn[112];
	static const int yypgrv[205];
	static const int yypgrn[205];

///////////////////////////////////////////////////////////////////////////////////
	// optional tables, they are available only under certain conditions

	// lookahead distant table, only available when there are some lookahead patterns
	// each pattern has its entry of the table
	

};


char yyparser_t::YYMSG_UNMATCHED[] = "Error: unmatched character ` \'.";

const int yyparser_t::yydsc[26] = {
517,	475,	554,	554,	556,	556,	390,	389,
	518,	518,	555,	555,	472,	472,	542,	542,
	387,	387,	323,	324,	534,	534,	388,	388,
	476,	476
};

const int yyparser_t::yydcmap[258] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	1,	2,	0,	0,	3,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	1,	4,	5,	4,	6,	7,	8,	9,
	10,	10,	11,	12,	13,	14,	15,	16,
	17,	18,	18,	18,	19,	19,	19,	19,
	20,	20,	21,	22,	23,	24,	25,	26,
	27,	28,	29,	29,	29,	30,	31,	4,
	4,	32,	4,	4,	33,	4,	34,	35,
	4,	4,	36,	37,	38,	39,	4,	4,
	40,	41,	4,	42,	43,	44,	45,	4,
	46,	47,	48,	49,	50,	51,	52,	53,
	54,	55,	4,	56,	57,	58,	59,	60,
	61,	4,	62,	63,	64,	65,	66,	67,
	68,	69,	4,	70,	71,	72,	4,	73,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	74,	74,	74,	74,	74,	74,	74,	74,
	75,	75
};

const int yyparser_t::yydmeta[76] = {
0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	7,	10,	10,	7,	10,	11,
	12,	13,	13,	13,	13,	14,	15,	16,
	17,	16,	18,	4,	4,	4,	4,	4,
	4,	4,	4,	4,	4,	4,	4,	4,
	4,	4,	19,	20,	7,	10,	8,	4,
	4,	4,	4,	4,	4,	4,	4,	4,
	4,	4,	4,	4,	4,	4,	4,	4,
	4,	4,	4,	4,	4,	4,	21,	22,
	7,	23,	24,	25
};

const int yyparser_t::yydbase[647] = {
2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	2410,	2410,
	2410,	2410,	2410,	2410,	2410,	2410,	1203,	1196,
	1193,	1194,	1240,	1190,	1178,	1169,	1168,	1167,
	1235,	1174,	1164,	1231,	1170,	1161,	1166,	1165,
	1177,	1165,	1154,	1200,	1199,	1222,	1194,	1162,
	1162,	1164,	1171,	1170,	1152,	1155,	1159,	1212,
	1161,	1142,	1150,	1159,	1150,	1145,	1144,	1156,
	1140,	1178,	1200,	1194,	1156,	1138,	1196,	1136,
	1195,	1193,	1193,	1133,	1130,	1136,	1133,	1119,
	1131,	1115,	1184,	1123,	1114,	1113,	1180,	1127,
	1108,	1177,	1114,	1168,	1163,	1154,	1130,	1129,
	1128,	1127,	1126,	1125,	1159,	1158,	1122,	1121,
	1120,	1119,	1141,	1117,	1096,	1134,	1133,	1126,
	1144,	1143,	1081,	1078,	1114,	1139,	1097,	1125,
	1143,	1142,	1113,	1087,	1074,	1093,	1086,	1083,
	1087,	1072,	1088,	1064,	1123,	1080,	1081,	1080,
	1069,	1076,	1065,	1104,	1103,	1102,	1101,	1096,
	1037,	1012,	970,	926,	924,	908,	899,	865,
	826,	850,	866,	858,	790,	783,	769,	706,
	682,	681,	664,	646,	648,	622,	604,	596,
	563,	520,	519,	483,	422,	427,	392,	387,
	352,	353,	312,	303,	268,	217,	178,	218,
	176,	69,	56,	57,	10,	1113,	1111,	607,
	1090,	1068,	1059,	1055,	1057,	1051,	1047,	1050,
	1048,	753,	964,	892,	1047,	961,	960,	1046,
	885,	850,	1045,	859,	786,	761,	730,	673,
	680,	885,	600,	602,	573,	559,	97,	585,
	567,	555,	529,	554,	333,	501,	447,	101,
	536,	507,	40,	341,	477,	349,	208,	465,
	469,	306,	266,	173,	232,	186,	203,	81,
	22,	155,	140,	155,	9,	104,	1,	1080,
	1077,	1074,	1070,	1026,	1028,	1019,	1016,	1013,
	1015,	1010,	1001,	918,	1008,	995,	905,	990,
	987,	834,	994,	993,	980,	977,	976,	702,
	975,	972,	633,	971,	958,	957,	956,	953,
	952,	939,	772,	496,	936,	426,	401,	933,
	162,	111,	573,	488,	872,	424,	972,	969,
	851,	835,	806,	173,	982,	795,	719,	696,
	978,	383,	373,	223,	965,	711,	580,	393,
	30,	944,	544,	508,	931,	653,	322,	641,
	375,	61,	296,	432,	415,	328,	239,	117,
	33,	205,	65,	745,	152,	311,	908,	890,
	885,	96,	253,	884,	879,	861,	860,	855,
	849,	842,	837,	831,	816,	810,	808,	802,
	787,	781,	779,	773,	758,	752,	750,	744,
	726,	127,	732,	724,	713,	659,	113,	425,
	304,	301,	244,	276,	3,	30,	207,	721,
	705,	685,	683,	668,	203,	642,	630,	618,
	606,	601,	594,	576,	564,	105,	102,	558,
	544,	522,	508,	486,	472,	448,	469,	417,
	411,	375,	369,	317,	285,	269,	233,	197,
	10,	136,	120,	75,	0,	2410,	1276,	1264,
	1261,	1302,	1279,	1767,	1505,	1430,	1405,	1380,
	2391,	2383,	2380,	2372,	2364,	2361,	2353,	1269,
	2345,	2342,	2334,	2326,	2323,	2315,	2304,	2293,
	2282,	2271,	2260,	2249,	2238,	2227,	2216,	2205,
	2194,	2183,	2172,	2161,	2150,	2139,	2128,	2117,
	2106,	2095,	2084,	2073,	2062,	2051,	2040,	2029,
	2018,	2007,	1996,	1985,	1974,	1963,	1339,	1294,
	1944,	1925,	1906,	1885,	1865,	1841,	1817,	1793,
	1768,	1743,	1723,	1702,	1678,	1654,	1630,	1606,
	1582,	1558,	1533,	1508,	1483,	1458,	1433,	1408,
	1383,	1358,	1338,	1317,	1293,	1272,	1247
};

const int yyparser_t::yyddef[647] = {
557,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	571,	572,	96,	457,	573,	100,	477,	477,
	477,	477,	477,	477,	477,	477,	477,	477,
	477,	477,	477,	477,	477,	477,	477,	457,
	477,	477,	381,	181,	376,	438,	439,	439,
	439,	439,	438,	438,	438,	482,	393,	444,
	535,	452,	535,	535,	535,	547,	448,	442,
	458,	474,	563,	564,	568,	570,	558,	559,
	560,	582,	621,	622,	561,	562,	620,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	578,	579,	577,	576,	574,	592,
	593,	598,	599,	600,	601,	602,	603,	565,
	604,	605,	606,	608,	609,	610,	611,	613,
	614,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	612,	590,	612,	612,	612,
	590,	607,	590,	590,	607,	612,	612,	582,
	558,	561,	562,	643,	643,	0,	0,	0,
	594,	594,	589,	594,	589,	589,	584,	594,
	589,	594,	588,	584,	589,	588,	588,	589,
	588,	588,	589,	584,	584,	588,	584,	584,
	594,	589,	589,	588,	589,	589,	0,	0,
	0,	0,	0,	589,	588,	594,	0,	0,
	0,	0,	0,	0,	584,	0,	585,	584,
	633,	634,	584,	584,	597,	580,	589,	597,
	585,	625,	625,	636,	636,	646,	646,	0,
	0,	0,	0,	587,	596,	587,	587,	587,
	596,	596,	587,	596,	586,	587,	596,	587,
	587,	596,	586,	586,	587,	587,	586,	596,
	586,	586,	591,	586,	587,	586,	586,	586,
	586,	587,	586,	596,	587,	596,	596,	587,
	586,	586,	591,	591,	0,	591,	627,	628,
	0,	566,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	567,	0,	628,	627,	627,
	628,	569,	0,	0,	569,	569,	0,	569,
	569,	569,	0,	0,	617,	616,	617,	616,
	635,	0,	0,	637,	637,	581,	583,	583,
	583,	0,	623,	583,	583,	583,	583,	583,
	583,	595,	583,	583,	583,	583,	583,	583,
	583,	583,	583,	583,	583,	583,	583,	583,
	583,	583,	595,	595,	595,	595,	575,	595,
	595,	581,	581,	581,	581,	638,	639,	624,
	624,	624,	624,	624,	624,	581,	581,	581,
	581,	581,	581,	581,	581,	581,	641,	619,
	619,	619,	619,	619,	619,	0,	640,	0,
	0,	0,	0,	618,	626,	629,	630,	632,
	631,	615,	645,	642,	644,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0
};

const int yyparser_t::yydnxt[2486] = {
95,	137,	40,	294,	319,	154,	43,	43,
	203,	155,	43,	43,	43,	43,	43,	43,
	43,	443,	158,	56,	84,	43,	42,	43,
	369,	43,	43,	129,	129,	129,	129,	87,
	91,	162,	208,	94,	209,	553,	129,	129,
	129,	129,	361,	547,	43,	43,	370,	128,
	128,	128,	113,	60,	87,	470,	113,	87,
	377,	129,	129,	129,	129,	129,	129,	113,
	473,	113,	145,	26,	256,	113,	510,	43,
	43,	312,	44,	93,	89,	91,	206,	147,
	93,	93,	93,	356,	93,	93,	93,	93,
	93,	85,	93,	93,	146,	182,	119,	119,
	93,	89,	93,	119,	93,	93,	92,	66,
	65,	225,	449,	321,	322,	224,	467,	43,
	215,	459,	459,	459,	459,	255,	141,	86,
	93,	444,	35,	290,	66,	376,	394,	368,
	156,	157,	228,	358,	358,	358,	454,	454,
	142,	133,	133,	133,	133,	429,	138,	61,
	34,	93,	93,	93,	367,	93,	428,	536,
	113,	143,	538,	540,	113,	550,	539,	220,
	113,	519,	113,	327,	95,	113,	95,	113,
	95,	52,	400,	113,	536,	112,	113,	32,
	104,	523,	113,	538,	540,	113,	90,	422,
	539,	550,	384,	373,	194,	519,	192,	331,
	535,	514,	113,	189,	313,	513,	190,	485,
	383,	423,	53,	523,	104,	193,	75,	67,
	87,	91,	162,	113,	69,	355,	132,	132,
	132,	132,	535,	319,	88,	113,	82,	169,
	451,	132,	132,	132,	132,	87,	170,	113,
	81,	140,	172,	337,	140,	515,	53,	464,
	469,	136,	140,	68,	132,	132,	132,	132,
	132,	132,	130,	130,	130,	130,	140,	169,
	456,	456,	113,	114,	140,	130,	130,	130,
	130,	315,	172,	136,	140,	113,	482,	482,
	482,	482,	335,	68,	469,	191,	56,	552,
	130,	130,	130,	130,	130,	130,	126,	126,
	126,	126,	237,	113,	420,	39,	236,	512,
	325,	126,	126,	126,	126,	113,	462,	466,
	419,	76,	113,	552,	72,	171,	186,	237,
	470,	392,	392,	392,	126,	126,	126,	126,
	126,	126,	47,	113,	113,	546,	47,	113,
	237,	530,	489,	78,	248,	248,	134,	393,
	113,	248,	113,	392,	392,	392,	113,	46,
	248,	455,	455,	248,	382,	248,	373,	248,
	113,	546,	113,	113,	493,	544,	113,	113,
	47,	113,	113,	414,	47,	47,	486,	492,
	551,	47,	67,	113,	435,	113,	450,	412,
	47,	113,	76,	47,	304,	47,	107,	47,
	449,	544,	545,	545,	545,	545,	215,	169,
	253,	253,	253,	253,	551,	545,	545,	545,
	545,	113,	172,	253,	253,	253,	253,	119,
	119,	463,	438,	438,	438,	119,	188,	375,
	545,	545,	545,	545,	545,	545,	253,	253,
	253,	253,	253,	253,	543,	543,	543,	543,
	453,	453,	4,	4,	4,	4,	184,	543,
	543,	543,	543,	29,	102,	4,	4,	4,
	4,	117,	251,	251,	251,	32,	113,	549,
	502,	113,	543,	543,	543,	543,	543,	543,
	4,	4,	4,	4,	4,	4,	87,	58,
	218,	106,	36,	404,	113,	113,	158,	113,
	405,	113,	424,	549,	118,	314,	144,	144,
	144,	144,	113,	87,	57,	113,	57,	216,
	214,	359,	213,	289,	140,	212,	415,	537,
	1,	211,	535,	140,	140,	360,	229,	207,
	326,	205,	140,	508,	254,	140,	201,	140,
	140,	140,	520,	113,	537,	459,	459,	459,
	459,	363,	258,	535,	140,	140,	140,	113,
	140,	113,	140,	140,	105,	109,	140,	524,
	140,	140,	140,	201,	520,	483,	140,	113,
	113,	136,	480,	140,	140,	140,	140,	258,
	140,	458,	458,	458,	458,	447,	113,	140,
	524,	140,	140,	221,	522,	295,	136,	140,
	541,	445,	140,	140,	140,	140,	140,	167,
	140,	297,	140,	509,	305,	140,	306,	522,
	140,	140,	140,	436,	140,	125,	125,	125,
	50,	166,	450,	140,	140,	140,	140,	441,
	304,	113,	140,	113,	140,	165,	380,	113,
	328,	140,	140,	446,	140,	113,	113,	113,
	113,	250,	113,	113,	113,	259,	113,	440,
	299,	29,	33,	421,	113,	173,	113,	491,
	264,	113,	113,	451,	265,	113,	54,	507,
	113,	170,	140,	309,	113,	113,	113,	113,
	113,	113,	292,	298,	113,	113,	496,	113,
	55,	113,	113,	113,	113,	113,	113,	29,
	113,	460,	119,	119,	6,	113,	113,	119,
	113,	113,	113,	269,	113,	119,	457,	119,
	30,	113,	113,	119,	113,	113,	511,	270,
	113,	447,	136,	113,	37,	140,	113,	221,
	113,	271,	140,	140,	113,	113,	344,	113,
	39,	140,	431,	535,	386,	288,	140,	136,
	446,	140,	140,	140,	140,	140,	250,	113,
	127,	127,	127,	113,	140,	140,	140,	140,
	535,	108,	140,	287,	386,	293,	140,	140,
	521,	113,	87,	140,	140,	140,	140,	385,
	371,	286,	140,	113,	140,	407,	113,	140,
	140,	370,	140,	411,	113,	113,	33,	399,
	413,	140,	521,	40,	385,	378,	410,	113,
	113,	113,	140,	398,	113,	113,	432,	113,
	113,	140,	140,	433,	113,	30,	113,	195,
	113,	113,	477,	113,	445,	113,	113,	113,
	113,	113,	167,	113,	113,	353,	529,	442,
	113,	113,	307,	113,	113,	267,	115,	95,
	113,	113,	113,	113,	354,	113,	113,	113,
	113,	113,	113,	113,	348,	113,	113,	484,
	113,	113,	347,	113,	441,	113,	113,	285,
	113,	113,	165,	116,	532,	113,	113,	284,
	113,	113,	113,	113,	440,	113,	113,	113,
	113,	113,	173,	113,	38,	113,	113,	332,
	113,	54,	120,	113,	35,	113,	113,	283,
	395,	436,	103,	113,	80,	113,	343,	166,
	113,	244,	113,	113,	113,	113,	243,	113,
	113,	351,	113,	113,	113,	113,	113,	113,
	334,	408,	113,	310,	113,	113,	316,	113,
	333,	6,	113,	113,	113,	113,	113,	434,
	113,	113,	113,	113,	113,	533,	113,	113,
	241,	37,	113,	113,	113,	187,	308,	113,
	113,	239,	113,	113,	336,	113,	113,	113,
	113,	317,	372,	113,	113,	113,	55,	113,
	113,	238,	113,	497,	113,	113,	113,	113,
	113,	396,	113,	318,	526,	113,	113,	113,
	200,	113,	113,	119,	119,	119,	452,	49,
	222,	465,	9,	113,	113,	339,	113,	113,
	119,	119,	119,	142,	25,	257,	119,	135,
	38,	291,	439,	439,	439,	131,	131,	131,
	406,	113,	113,	113,	113,	374,	113,	183,
	113,	113,	113,	416,	113,	505,	113,	113,
	364,	311,	501,	113,	185,	494,	10,	113,
	113,	516,	113,	113,	504,	113,	113,	330,
	113,	113,	113,	437,	113,	113,	113,	113,
	113,	235,	111,	113,	430,	113,	113,	113,
	199,	113,	113,	113,	342,	345,	113,	402,
	113,	403,	113,	113,	113,	113,	409,	113,
	113,	113,	234,	349,	525,	113,	113,	113,
	397,	498,	113,	113,	113,	113,	495,	113,
	113,	113,	499,	401,	113,	113,	113,	113,
	500,	113,	506,	350,	113,	113,	346,	113,
	217,	217,	217,	391,	391,	391,	268,	268,
	268,	3,	3,	3,	113,	113,	113,	113,
	113,	113,	113,	527,	352,	196,	329,	341,
	113,	487,	113,	113,	124,	233,	140,	365,
	479,	531,	232,	231,	230,	240,	223,	219,
	174,	175,	176,	177,	74,	113,	80,	296,
	303,	366,	226,	263,	274,	273,	272,	252,
	25,	26,	541,	302,	73,	247,	5,	31,
	79,	78,	124,	338,	140,	246,	245,	28,
	242,	11,	204,	12,	21,	13,	14,	77,
	77,	15,	16,	17,	18,	19,	20,	282,
	467,	76,	281,	91,	63,	280,	49,	33,
	80,	279,	58,	2,	362,	32,	266,	262,
	261,	260,	210,	94,	210,	300,	91,	301,
	22,	24,	23,	27,	121,	110,	379,	418,
	478,	417,	340,	490,	503,	191,	427,	426,
	357,	198,	197,	425,	488,	528,	461,	168,
	320,	481,	51,	275,	276,	277,	278,	37,
	163,	72,	39,	164,	168,	54,	55,	6,
	160,	161,	91,	8,	159,	7,	548,	95,
	474,	23,	202,	41,	154,	43,	43,	41,
	155,	43,	43,	43,	41,	43,	42,	43,
	41,	43,	361,	547,	510,	448,	41,	44,
	139,	178,	152,	178,	139,	151,	139,	139,
	139,	139,	139,	139,	139,	62,	139,	178,
	139,	150,	139,	139,	152,	139,	139,	139,
	139,	41,	113,	0,	113,	41,	113,	0,
	113,	113,	41,	113,	59,	0,	41,	0,
	113,	0,	0,	151,	41,	95,	87,	91,
	162,	381,	95,	381,	95,	95,	158,	95,
	95,	370,	144,	70,	71,	95,	95,	381,
	95,	95,	95,	70,	95,	95,	83,	113,
	0,	113,	83,	113,	0,	113,	113,	83,
	113,	0,	0,	83,	0,	113,	64,	0,
	0,	83,	64,	64,	0,	64,	64,	64,
	64,	64,	64,	64,	64,	0,	64,	64,
	64,	64,	64,	64,	64,	64,	64,	95,
	97,	0,	97,	100,	95,	100,	95,	95,
	0,	95,	95,	95,	0,	95,	97,	0,
	95,	100,	95,	95,	95,	95,	95,	95,
	95,	149,	0,	149,	99,	95,	99,	95,
	95,	95,	95,	95,	95,	95,	95,	149,
	95,	95,	99,	95,	95,	95,	95,	95,
	95,	95,	148,	0,	148,	123,	95,	123,
	95,	95,	95,	95,	95,	0,	95,	95,
	148,	95,	95,	123,	95,	95,	95,	95,
	95,	95,	95,	0,	91,	162,	95,	95,
	95,	95,	95,	95,	95,	95,	0,	95,
	95,	87,	95,	95,	95,	95,	95,	0,
	95,	95,	95,	95,	87,	58,	218,	100,
	95,	100,	95,	95,	0,	95,	95,	95,
	95,	95,	87,	57,	95,	100,	95,	95,
	95,	95,	95,	95,	95,	179,	0,	179,
	96,	95,	96,	95,	95,	95,	95,	95,
	95,	95,	95,	179,	95,	95,	96,	95,
	95,	95,	95,	95,	95,	377,	377,	0,
	0,	377,	377,	377,	377,	377,	377,	377,
	377,	377,	377,	377,	377,	377,	377,	377,
	377,	377,	377,	377,	377,	377,	124,	124,
	0,	0,	124,	0,	124,	124,	124,	124,
	124,	124,	124,	124,	124,	124,	124,	124,
	124,	124,	0,	124,	124,	124,	124,	131,
	0,	0,	131,	0,	131,	131,	131,	0,
	131,	131,	131,	0,	131,	131,	131,	131,
	131,	131,	0,	131,	131,	131,	131,	439,
	0,	0,	439,	0,	439,	439,	439,	0,
	439,	439,	439,	0,	439,	439,	439,	439,
	439,	439,	0,	439,	439,	439,	439,	131,
	0,	0,	131,	0,	131,	131,	131,	0,
	131,	131,	131,	0,	131,	131,	131,	131,
	131,	131,	0,	131,	131,	131,	131,	439,
	0,	0,	439,	0,	439,	439,	439,	0,
	439,	439,	439,	0,	439,	439,	439,	439,
	439,	439,	0,	439,	439,	439,	439,	439,
	0,	0,	439,	0,	439,	439,	439,	56,
	439,	439,	439,	439,	439,	439,	439,	439,
	439,	439,	470,	439,	439,	439,	439,	131,
	0,	0,	131,	53,	131,	131,	131,	0,
	131,	131,	131,	131,	131,	131,	131,	131,
	131,	131,	469,	131,	131,	131,	131,	227,
	0,	227,	227,	227,	0,	227,	227,	227,
	227,	227,	227,	227,	227,	0,	227,	140,
	227,	227,	227,	140,	0,	140,	140,	140,
	140,	140,	140,	140,	140,	140,	140,	140,
	0,	140,	140,	325,	140,	140,	140,	140,
	140,	0,	0,	180,	140,	180,	140,	140,
	140,	140,	140,	140,	140,	140,	140,	140,
	140,	180,	140,	140,	325,	140,	140,	140,
	140,	140,	0,	0,	0,	140,	0,	140,
	140,	140,	140,	140,	140,	140,	0,	140,
	140,	140,	0,	140,	140,	0,	140,	140,
	140,	140,	439,	0,	0,	439,	0,	439,
	439,	439,	0,	439,	439,	439,	439,	439,
	439,	439,	439,	439,	439,	468,	439,	439,
	439,	439,	131,	0,	0,	131,	0,	131,
	131,	131,	0,	131,	131,	131,	131,	131,
	131,	131,	131,	131,	131,	471,	131,	131,
	131,	131,	249,	0,	0,	249,	249,	249,
	249,	249,	249,	249,	249,	249,	249,	249,
	249,	249,	249,	249,	249,	140,	249,	249,
	0,	140,	0,	140,	140,	140,	140,	140,
	140,	140,	140,	140,	140,	140,	0,	140,
	140,	325,	140,	140,	140,	140,	48,	0,
	45,	45,	48,	0,	45,	45,	45,	48,
	45,	45,	45,	48,	0,	45,	0,	45,
	45,	439,	439,	439,	439,	439,	439,	439,
	439,	439,	439,	439,	439,	439,	439,	439,
	439,	439,	439,	439,	131,	131,	131,	131,
	131,	131,	131,	131,	131,	131,	131,	131,
	131,	131,	131,	131,	131,	131,	131,	113,
	0,	113,	0,	113,	0,	113,	113,	0,
	113,	0,	113,	0,	113,	113,	113,	0,
	113,	113,	0,	113,	0,	113,	0,	113,
	113,	113,	0,	113,	113,	0,	113,	0,
	113,	0,	113,	113,	113,	0,	113,	113,
	0,	113,	0,	113,	0,	113,	113,	113,
	0,	113,	113,	0,	113,	0,	113,	0,
	113,	113,	113,	0,	113,	113,	0,	113,
	0,	113,	0,	113,	113,	113,	0,	113,
	113,	0,	113,	0,	113,	0,	113,	113,
	113,	0,	113,	113,	0,	113,	0,	113,
	0,	113,	113,	113,	0,	113,	113,	0,
	113,	0,	113,	0,	113,	113,	113,	0,
	113,	113,	0,	113,	0,	113,	0,	113,
	113,	113,	0,	113,	113,	0,	113,	0,
	113,	0,	113,	113,	113,	0,	113,	113,
	0,	113,	0,	113,	0,	113,	113,	113,
	0,	113,	113,	0,	113,	0,	113,	0,
	113,	113,	113,	0,	113,	113,	0,	113,
	0,	113,	0,	113,	113,	113,	0,	113,
	113,	0,	113,	0,	113,	0,	113,	113,
	113,	0,	113,	113,	0,	113,	0,	113,
	0,	113,	113,	113,	0,	113,	113,	0,
	113,	0,	113,	0,	113,	113,	113,	0,
	113,	113,	0,	113,	0,	113,	0,	113,
	113,	113,	0,	113,	113,	0,	113,	0,
	113,	0,	113,	113,	113,	0,	113,	113,
	0,	113,	0,	113,	0,	113,	113,	113,
	0,	113,	113,	0,	113,	0,	113,	0,
	113,	113,	113,	0,	113,	113,	0,	113,
	0,	113,	0,	113,	113,	113,	0,	113,
	113,	0,	113,	0,	113,	0,	113,	113,
	113,	0,	113,	113,	0,	113,	0,	113,
	0,	113,	113,	113,	0,	113,	113,	0,
	113,	0,	113,	0,	113,	113,	113,	0,
	113,	113,	0,	113,	0,	113,	0,	113,
	113,	113,	0,	113,	113,	0,	113,	0,
	113,	0,	113,	113,	113,	0,	113,	113,
	0,	113,	0,	113,	0,	113,	113,	113,
	0,	113,	113,	0,	113,	0,	113,	0,
	113,	113,	113,	0,	113,	113,	0,	113,
	0,	113,	0,	113,	113,	113,	0,	113,
	113,	0,	113,	0,	153,	0,	153,	113,
	153,	0,	153,	153,	0,	153,	0,	113,
	0,	113,	153,	113,	0,	113,	113,	122,
	113,	122,	179,	0,	179,	113,	122,	0,
	122,	179,	178,	179,	178,	122,	0,	0,
	179,	178,	180,	178,	180,	181,	0,	181,
	178,	180,	0,	180,	181,	119,	181,	119,
	180,	0,	0,	181,	119,	101,	119,	101,
	97,	0,	97,	119,	101,	0,	101,	97,
	98,	97,	98,	101,	0,	0,	97,	98,
	149,	98,	149,	119,	0,	119,	98,	149,
	0,	149,	119,	148,	119,	148,	149,	0,
	0,	119,	148,	0,	148,	0,	0,	0,
	0,	148,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0
};

const int yyparser_t::yydchk[2486] = {
556,	556,	556,	556,	516,	556,	556,	556,
	390,	556,	556,	556,	556,	556,	556,	556,
	556,	324,	388,	552,	388,	556,	556,	556,
	390,	556,	556,	552,	552,	552,	552,	517,
	517,	517,	472,	472,	472,	517,	552,	552,
	552,	552,	556,	556,	556,	556,	517,	456,
	456,	456,	516,	370,	517,	552,	516,	472,
	370,	552,	552,	552,	552,	552,	552,	516,
	323,	516,	474,	474,	474,	516,	556,	556,
	556,	384,	556,	555,	555,	555,	555,	322,
	555,	555,	555,	384,	555,	555,	555,	555,
	555,	555,	555,	555,	321,	465,	465,	465,
	555,	555,	555,	465,	555,	555,	481,	534,
	534,	534,	533,	367,	534,	534,	358,	389,
	533,	481,	481,	481,	481,	555,	555,	555,
	555,	554,	554,	554,	534,	554,	510,	389,
	367,	534,	510,	510,	510,	510,	471,	471,
	474,	554,	554,	554,	554,	383,	554,	553,
	554,	555,	555,	555,	534,	555,	383,	554,
	533,	476,	554,	554,	533,	471,	554,	476,
	433,	554,	433,	554,	387,	533,	387,	533,
	476,	358,	433,	533,	554,	553,	505,	533,
	553,	386,	505,	554,	554,	505,	320,	553,
	554,	471,	553,	381,	553,	554,	553,	505,
	385,	553,	505,	553,	553,	553,	553,	553,
	553,	553,	551,	386,	553,	553,	553,	381,
	518,	518,	518,	432,	473,	432,	551,	551,
	551,	551,	385,	319,	518,	432,	476,	443,
	451,	551,	551,	551,	551,	518,	451,	379,
	518,	524,	443,	318,	524,	379,	550,	518,
	551,	524,	524,	443,	551,	551,	551,	551,
	551,	551,	550,	550,	550,	550,	524,	473,
	470,	470,	382,	374,	524,	550,	550,	550,
	550,	382,	473,	524,	524,	374,	482,	482,
	482,	482,	317,	473,	550,	515,	549,	470,
	550,	550,	550,	550,	550,	550,	549,	549,
	549,	549,	548,	514,	380,	451,	548,	514,
	482,	549,	549,	549,	549,	380,	548,	548,
	514,	466,	514,	470,	377,	377,	514,	548,
	549,	466,	466,	466,	549,	549,	549,	549,
	549,	549,	547,	515,	378,	548,	547,	515,
	548,	316,	378,	462,	548,	548,	547,	547,
	515,	548,	515,	462,	462,	462,	515,	547,
	548,	469,	469,	548,	513,	548,	373,	548,
	513,	548,	512,	512,	512,	547,	477,	512,
	547,	513,	477,	513,	547,	547,	315,	513,
	469,	547,	373,	477,	512,	477,	450,	314,
	547,	477,	546,	547,	450,	547,	364,	547,
	449,	547,	546,	546,	546,	546,	449,	371,
	545,	545,	545,	545,	469,	546,	546,	546,
	546,	364,	371,	545,	545,	545,	545,	464,
	464,	464,	455,	455,	455,	464,	313,	312,
	546,	546,	546,	546,	546,	546,	545,	545,
	545,	545,	545,	545,	544,	544,	544,	544,
	468,	468,	543,	543,	543,	543,	437,	544,
	544,	544,	544,	450,	311,	543,	543,	543,
	543,	310,	467,	467,	467,	449,	430,	468,
	430,	430,	544,	544,	544,	544,	544,	544,
	543,	543,	543,	543,	543,	543,	542,	542,
	542,	437,	376,	511,	511,	511,	542,	429,
	511,	429,	429,	468,	309,	308,	542,	542,
	542,	542,	437,	542,	542,	511,	542,	541,
	541,	541,	541,	366,	540,	541,	435,	540,
	467,	541,	540,	540,	540,	541,	366,	541,
	376,	541,	539,	365,	541,	539,	369,	540,
	539,	539,	539,	375,	540,	459,	459,	459,
	459,	375,	369,	540,	540,	539,	540,	372,
	538,	435,	539,	538,	307,	372,	538,	538,
	538,	539,	539,	368,	539,	427,	537,	427,
	427,	537,	435,	538,	537,	537,	537,	368,
	538,	458,	458,	458,	458,	532,	365,	538,
	538,	537,	538,	532,	536,	306,	537,	536,
	361,	531,	536,	536,	536,	537,	537,	531,
	537,	305,	535,	434,	362,	535,	362,	536,
	535,	535,	535,	530,	536,	454,	454,	454,
	361,	530,	529,	536,	536,	535,	536,	528,
	529,	363,	535,	532,	327,	528,	357,	532,
	363,	535,	535,	527,	535,	357,	434,	531,
	532,	527,	532,	531,	356,	360,	532,	526,
	360,	304,	532,	356,	531,	526,	531,	434,
	359,	530,	531,	525,	359,	530,	531,	418,
	529,	525,	327,	355,	529,	528,	530,	354,
	530,	528,	303,	302,	530,	529,	354,	529,
	530,	527,	528,	529,	528,	527,	355,	529,
	528,	463,	463,	463,	528,	526,	527,	463,
	527,	526,	418,	301,	527,	461,	461,	461,
	527,	525,	526,	461,	526,	525,	352,	300,
	526,	447,	523,	418,	526,	523,	525,	447,
	525,	299,	523,	523,	525,	509,	509,	509,
	525,	522,	509,	521,	522,	298,	521,	523,
	446,	522,	522,	521,	521,	523,	446,	509,
	453,	453,	453,	351,	523,	523,	522,	520,
	521,	351,	520,	297,	522,	296,	521,	520,
	520,	352,	475,	522,	522,	521,	521,	519,
	475,	295,	519,	415,	520,	415,	415,	519,
	519,	475,	520,	508,	508,	508,	447,	337,
	508,	520,	520,	294,	519,	504,	507,	507,
	507,	504,	519,	507,	504,	508,	506,	506,
	506,	519,	519,	506,	350,	446,	504,	503,
	507,	504,	350,	503,	445,	502,	503,	501,
	506,	502,	445,	501,	502,	500,	501,	442,
	503,	500,	349,	503,	500,	442,	502,	475,
	501,	502,	337,	501,	499,	426,	500,	426,
	499,	500,	498,	499,	497,	349,	498,	426,
	497,	498,	496,	497,	441,	499,	496,	293,
	499,	496,	441,	498,	348,	497,	498,	292,
	497,	495,	348,	496,	440,	495,	496,	494,
	495,	493,	440,	494,	291,	493,	494,	492,
	493,	445,	495,	492,	290,	495,	492,	289,
	494,	436,	493,	494,	442,	493,	491,	436,
	492,	288,	491,	492,	490,	491,	287,	409,
	490,	409,	409,	490,	489,	489,	489,	491,
	488,	489,	491,	345,	488,	490,	487,	488,
	490,	441,	487,	486,	485,	487,	489,	486,
	485,	488,	486,	485,	488,	347,	345,	487,
	286,	440,	487,	347,	486,	485,	484,	486,
	485,	285,	484,	483,	480,	484,	344,	483,
	480,	479,	483,	480,	353,	479,	436,	484,
	479,	284,	484,	353,	483,	480,	339,	483,
	480,	344,	479,	478,	339,	479,	406,	478,
	406,	406,	478,	460,	460,	460,	452,	452,
	452,	460,	283,	403,	478,	403,	403,	478,
	457,	457,	457,	448,	448,	448,	457,	444,
	444,	444,	439,	439,	439,	438,	438,	438,
	431,	431,	431,	428,	428,	428,	425,	425,
	425,	424,	423,	424,	423,	422,	421,	422,
	421,	342,	341,	424,	423,	338,	282,	422,
	421,	420,	420,	420,	419,	417,	419,	417,
	416,	414,	416,	414,	342,	341,	419,	417,
	338,	281,	416,	414,	413,	413,	413,	412,
	412,	412,	411,	410,	411,	410,	408,	408,
	408,	407,	407,	407,	411,	410,	405,	405,
	405,	404,	280,	404,	402,	402,	402,	401,
	335,	401,	401,	404,	400,	331,	400,	400,
	399,	399,	399,	398,	398,	398,	397,	397,
	397,	396,	329,	396,	396,	395,	395,	395,
	394,	394,	394,	393,	393,	393,	392,	392,
	392,	391,	391,	391,	346,	343,	340,	336,
	328,	334,	333,	346,	343,	340,	336,	334,
	332,	333,	330,	335,	326,	279,	325,	332,
	331,	330,	278,	277,	276,	275,	274,	273,
	272,	271,	270,	269,	268,	329,	267,	266,
	265,	264,	263,	262,	261,	260,	259,	258,
	257,	256,	255,	254,	253,	252,	251,	250,
	249,	248,	326,	328,	325,	247,	246,	245,
	244,	243,	242,	241,	240,	239,	238,	237,
	236,	235,	234,	233,	232,	231,	230,	229,
	228,	227,	226,	225,	224,	223,	222,	221,
	220,	219,	218,	217,	216,	215,	214,	213,
	212,	211,	210,	209,	208,	207,	206,	205,
	204,	203,	202,	201,	200,	199,	198,	197,
	196,	195,	194,	193,	192,	191,	190,	189,
	188,	187,	186,	185,	184,	183,	182,	181,
	180,	179,	178,	177,	176,	175,	174,	173,
	172,	171,	170,	169,	168,	167,	166,	165,
	164,	163,	162,	161,	160,	159,	158,	646,
	646,	646,	646,	646,	646,	646,	646,	646,
	646,	646,	646,	646,	646,	646,	646,	646,
	646,	646,	646,	646,	646,	646,	646,	646,
	645,	575,	560,	575,	645,	559,	645,	645,
	645,	645,	645,	645,	645,	562,	645,	575,
	645,	558,	645,	645,	562,	645,	645,	645,
	645,	644,	615,	644,	615,	644,	615,	644,
	615,	615,	644,	615,	561,	644,	644,	644,
	615,	644,	644,	561,	644,	643,	643,	643,
	643,	643,	643,	643,	643,	643,	643,	643,
	643,	643,	643,	643,	643,	643,	643,	643,
	643,	643,	643,	643,	643,	643,	642,	614,
	642,	614,	642,	614,	642,	614,	614,	642,
	614,	642,	642,	642,	642,	614,	641,	642,
	642,	642,	641,	641,	641,	641,	641,	641,
	641,	641,	641,	641,	641,	641,	641,	641,
	641,	641,	641,	641,	641,	641,	641,	640,
	567,	640,	567,	640,	640,	640,	640,	640,
	640,	640,	640,	640,	640,	640,	567,	640,
	640,	640,	640,	640,	640,	640,	640,	640,
	639,	566,	639,	566,	639,	639,	639,	639,
	639,	639,	639,	639,	639,	639,	639,	566,
	639,	639,	639,	639,	639,	639,	639,	639,
	639,	638,	565,	638,	565,	638,	638,	638,
	638,	638,	638,	638,	638,	638,	638,	638,
	565,	638,	638,	638,	638,	638,	638,	638,
	638,	638,	637,	637,	637,	637,	637,	637,
	637,	637,	637,	637,	637,	637,	637,	637,
	637,	637,	637,	637,	637,	637,	637,	637,
	637,	637,	637,	636,	636,	636,	636,	636,
	636,	636,	636,	636,	636,	636,	636,	636,
	636,	636,	636,	636,	636,	636,	636,	636,
	636,	636,	636,	636,	635,	564,	635,	564,
	635,	635,	635,	635,	635,	635,	635,	635,
	635,	635,	635,	564,	635,	635,	635,	635,
	635,	635,	635,	635,	635,	634,	634,	634,
	634,	634,	634,	634,	634,	634,	634,	634,
	634,	634,	634,	634,	634,	634,	634,	634,
	634,	634,	634,	634,	634,	634,	633,	633,
	633,	633,	633,	633,	633,	633,	633,	633,
	633,	633,	633,	633,	633,	633,	633,	633,
	633,	633,	633,	633,	633,	633,	633,	632,
	632,	632,	632,	632,	632,	632,	632,	632,
	632,	632,	632,	632,	632,	632,	632,	632,
	632,	632,	632,	632,	632,	632,	632,	631,
	631,	631,	631,	631,	631,	631,	631,	631,
	631,	631,	631,	631,	631,	631,	631,	631,
	631,	631,	631,	631,	631,	631,	631,	630,
	630,	630,	630,	630,	630,	630,	630,	630,
	630,	630,	630,	630,	630,	630,	630,	630,
	630,	630,	630,	630,	630,	630,	630,	629,
	629,	629,	629,	629,	629,	629,	629,	629,
	629,	629,	629,	629,	629,	629,	629,	629,
	629,	629,	629,	629,	629,	629,	629,	628,
	628,	628,	628,	628,	628,	628,	628,	628,
	628,	628,	628,	628,	628,	628,	628,	628,
	628,	628,	628,	628,	628,	628,	628,	627,
	627,	627,	627,	627,	627,	627,	627,	627,
	627,	627,	627,	627,	627,	627,	627,	627,
	627,	627,	627,	627,	627,	627,	627,	626,
	626,	626,	626,	626,	626,	626,	626,	626,
	626,	626,	626,	626,	626,	626,	626,	625,
	626,	626,	626,	625,	625,	625,	625,	625,
	625,	625,	625,	625,	625,	625,	625,	625,
	625,	625,	625,	625,	625,	625,	625,	625,
	624,	624,	624,	563,	624,	563,	624,	624,
	624,	624,	624,	624,	624,	624,	624,	624,
	624,	563,	624,	624,	624,	624,	624,	624,
	624,	623,	623,	623,	623,	623,	623,	623,
	623,	623,	623,	623,	623,	623,	623,	623,
	623,	623,	623,	623,	623,	623,	623,	623,
	623,	623,	622,	622,	622,	622,	622,	622,
	622,	622,	622,	622,	622,	622,	622,	622,
	622,	622,	622,	622,	622,	622,	622,	622,
	622,	622,	621,	621,	621,	621,	621,	621,
	621,	621,	621,	621,	621,	621,	621,	621,
	621,	621,	621,	621,	621,	621,	621,	621,
	621,	621,	620,	620,	620,	620,	620,	620,
	620,	620,	620,	620,	620,	620,	620,	620,
	620,	620,	620,	620,	620,	619,	620,	620,
	619,	619,	619,	619,	619,	619,	619,	619,
	619,	619,	619,	619,	619,	619,	619,	619,
	619,	619,	619,	619,	619,	619,	618,	618,
	618,	618,	618,	618,	618,	618,	618,	618,
	618,	618,	618,	618,	618,	618,	618,	618,
	618,	617,	617,	617,	617,	617,	617,	617,
	617,	617,	617,	617,	617,	617,	617,	617,
	617,	617,	617,	617,	616,	616,	616,	616,
	616,	616,	616,	616,	616,	616,	616,	616,
	616,	616,	616,	616,	616,	616,	616,	613,
	613,	613,	613,	613,	613,	613,	613,	613,
	613,	613,	612,	613,	612,	613,	612,	612,
	612,	612,	612,	612,	612,	611,	612,	611,
	612,	611,	611,	611,	611,	611,	611,	611,
	610,	611,	610,	611,	610,	610,	610,	610,
	610,	610,	610,	609,	610,	609,	610,	609,
	609,	609,	609,	609,	609,	609,	608,	609,
	608,	609,	608,	608,	608,	608,	608,	608,
	608,	607,	608,	607,	608,	607,	607,	607,
	607,	607,	607,	607,	606,	607,	606,	607,
	606,	606,	606,	606,	606,	606,	606,	605,
	606,	605,	606,	605,	605,	605,	605,	605,
	605,	605,	604,	605,	604,	605,	604,	604,
	604,	604,	604,	604,	604,	603,	604,	603,
	604,	603,	603,	603,	603,	603,	603,	603,
	602,	603,	602,	603,	602,	602,	602,	602,
	602,	602,	602,	601,	602,	601,	602,	601,
	601,	601,	601,	601,	601,	601,	600,	601,
	600,	601,	600,	600,	600,	600,	600,	600,
	600,	599,	600,	599,	600,	599,	599,	599,
	599,	599,	599,	599,	598,	599,	598,	599,
	598,	598,	598,	598,	598,	598,	598,	597,
	598,	597,	598,	597,	597,	597,	597,	597,
	597,	597,	596,	597,	596,	597,	596,	596,
	596,	596,	596,	596,	596,	595,	596,	595,
	596,	595,	595,	595,	595,	595,	595,	595,
	594,	595,	594,	595,	594,	594,	594,	594,
	594,	594,	594,	593,	594,	593,	594,	593,
	593,	593,	593,	593,	593,	593,	592,	593,
	592,	593,	592,	592,	592,	592,	592,	592,
	592,	591,	592,	591,	592,	591,	591,	591,
	591,	591,	591,	591,	590,	591,	590,	591,
	590,	590,	590,	590,	590,	590,	590,	589,
	590,	589,	590,	589,	589,	589,	589,	589,
	589,	589,	588,	589,	588,	589,	588,	588,
	588,	588,	588,	588,	588,	587,	588,	587,
	588,	587,	587,	587,	587,	587,	587,	587,
	586,	587,	586,	587,	586,	586,	586,	586,
	586,	586,	586,	585,	586,	585,	586,	585,
	585,	585,	585,	585,	585,	585,	584,	585,
	584,	585,	584,	584,	584,	584,	584,	584,
	584,	583,	584,	583,	584,	583,	583,	583,
	583,	583,	583,	583,	582,	583,	582,	583,
	582,	582,	582,	582,	582,	582,	582,	581,
	582,	581,	582,	581,	581,	581,	581,	580,
	581,	580,	579,	581,	579,	581,	580,	580,
	580,	579,	578,	579,	578,	580,	579,	579,
	579,	578,	577,	578,	577,	576,	578,	576,
	578,	577,	577,	577,	576,	574,	576,	574,
	577,	576,	576,	576,	574,	573,	574,	573,
	572,	574,	572,	574,	573,	573,	573,	572,
	571,	572,	571,	573,	572,	572,	572,	571,
	570,	571,	570,	569,	571,	569,	571,	570,
	570,	570,	569,	568,	569,	568,	570,	569,
	569,	569,	568,	568,	568,	568,	568,	568,
	568,	568,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557,	557,	557,
	557,	557,	557,	557,	557,	557
};

const int yyparser_t::yydaccpt[557] = {
-1,	97,	96,	87,	88,	98,	22,	106,
	107,	81,	82,	69,	70,	71,	72,	73,
	74,	75,	76,	77,	78,	79,	80,	104,
	3,	102,	104,	65,	66,	26,	34,	35,
	23,	24,	6,	12,	10,	25,	12,	21,
	68,	89,	93,	93,	99,	85,	85,	86,
	89,	68,	84,	94,	95,	100,	28,	27,
	101,	50,	58,	110,	1,	2,	112,	109,
	116,	116,	116,	48,	108,	4,	105,	105,
	0,	53,	52,	47,	55,	51,	51,	54,
	46,	64,	46,	89,	57,	90,	91,	117,
	63,	92,	111,	118,	113,	92,	17,	119,
	15,	19,	15,	62,	49,	49,	38,	30,
	13,	42,	59,	59,	43,	31,	32,	29,
	14,	59,	33,	39,	37,	36,	40,	62,
	41,	44,	49,	119,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	7,	86,	-1,
	9,	117,	11,	11,	11,	92,	102,	117,
	56,	103,	-1,	-1,	18,	20,	111,	110,
	114,	5,	119,	119,	-1,	116,	119,	-1,
	-1,	-1,	119,	-1,	-1,	-1,	-1,	-1,
	67,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	62,	59,
	59,	59,	59,	59,	59,	59,	59,	-1,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	-1,	119,	93,	-1,	-1,	92,	-1,
	16,	119,	16,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	119,	-1,	119,	-1,	-1,	-1,
	116,	116,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	54,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	92,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	119,	-1,	-1,	-1,	119,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	-1,
	-1,	-1,	116,	-1,	-1,	-1,	-1,	119,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	-1,	-1,
	-1,	83,	-1,	59,	59,	59,	-1,	116,
	93,	60,	119,	119,	59,	-1,	59,	59,
	119,	-1,	59,	59,	59,	49,	59,	59,
	59,	11,	11,	-1,	-1,	-1,	-1,	-1,
	-1,	89,	-1,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	-1,	59,	-1,	-1,
	-1,	-1,	-1,	119,	117,	-1,	-1,	-1,
	93,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	61,	56,	115,	62,	62,	-1,	62,
	62,	62,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	119,	103,	-1,	-1,	45,	59,	59,
	59,	-1,	7,	59,	59,	14,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	93,	59,
	59,	59,	59,	59,	59,	-1,	-1,	11,
	11,	11,	11,	11,	11,	59,	59,	59,
	59,	59,	59,	59,	59,	59,	-1,	8,
	11,	11,	11,	11,	11,	-1,	-1,	-1,
	89,	-1,	-1,	119,	-1,	-1,	-1,	-1,
	-1,	119,	-1,	-1,	-1
};

// token map: token ID --> token index in token ID table
// in fact, it acts like inverse table of token ID table
const int yyparser_t::yyptmap[294] = {
0,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	43,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	49,	2,	2,	2,
	51,	52,	40,	41,	47,	56,	53,	50,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	57,	44,	46,	45,	42,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	54,	2,	55,	48,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	39,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	2,	2,	2,	2,	2,	2,	2,	2,
	1,	2,	3,	4,	5,	6,	7,	8,
	9,	10,	11,	12,	13,	14,	15,	16,
	17,	18,	19,	20,	21,	22,	23,	24,
	25,	26,	27,	28,	29,	30,	31,	32,
	33,	34,	35,	36,	37,	38
};
/*
// token ID table, containing token IDs
const int yyparser_t::yyptid[58] = {
0,	256,	257,	258,	259,	260,	261,	262,
	263,	264,	265,	266,	267,	268,	269,	270,
	271,	272,	273,	274,	275,	276,	277,	278,
	279,	280,	281,	282,	283,	284,	285,	286,
	287,	288,	289,	290,	291,	292,	293,	124,
	42,	43,	63,	10,	60,	62,	61,	44,
	94,	36,	47,	40,	41,	46,	91,	93,
	45,	59
};
*/
// prnum table, its element is number of symbols in right part of corresponding grammar rule
const int yyparser_t::yyprnum[143] = {
2,	10,	0,	0,	0,	0,	1,	0,
	2,	0,	1,	1,	1,	1,	1,	2,
	2,	1,	3,	4,	3,	1,	1,	1,
	1,	5,	0,	1,	2,	1,	1,	1,
	7,	0,	4,	3,	2,	1,	4,	5,
	5,	3,	3,	4,	2,	2,	1,	1,
	3,	3,	3,	3,	2,	2,	2,	2,
	1,	3,	4,	3,	0,	2,	2,	3,
	1,	3,	2,	1,	2,	3,	1,	0,
	1,	3,	1,	1,	1,	2,	1,	1,
	2,	2,	2,	3,	1,	2,	1,	2,
	2,	2,	2,	2,	2,	2,	1,	3,
	1,	1,	1,	2,	1,	2,	3,	1,
	1,	1,	1,	1,	1,	3,	3,	1,
	2,	1,	1,	3,	1,	2,	0,	3,
	2,	2,	1,	4,	0,	2,	0,	5,
	3,	4,	2,	3,	1,	2,	0,	4,
	2,	3,	1,	3,	1,	1,	1
};

// plid table, its element is the index of left part of corresponding grammar rule in token ID table
const int yyparser_t::yyplid[143] = {
28,	26,	31,	33,	36,	35,	35,	29,
	30,	30,	37,	37,	37,	37,	37,	37,
	37,	37,	39,	39,	39,	42,	42,	42,
	42,	43,	44,	43,	45,	45,	46,	46,
	40,	47,	40,	40,	48,	48,	41,	41,
	41,	41,	41,	41,	27,	27,	27,	27,
	38,	38,	38,	38,	38,	38,	38,	38,
	38,	5,	5,	5,	32,	32,	49,	49,
	6,	6,	11,	0,	0,	25,	25,	25,
	23,	23,	24,	24,	22,	22,	22,	20,
	20,	20,	21,	19,	19,	18,	18,	13,
	13,	13,	13,	13,	13,	13,	13,	14,
	14,	12,	12,	17,	17,	16,	16,	16,
	15,	15,	15,	15,	15,	3,	3,	2,
	2,	1,	1,	1,	1,	34,	34,	50,
	50,	50,	4,	51,	52,	51,	53,	7,
	7,	7,	7,	7,	7,	7,	7,	9,
	9,	9,	9,	8,	8,	10,	10
};

// parse action table
const int yyparser_t::yypact[574] = {
208,	50,	93,	72,	100,	48,	8,	9,
	66,	67,	10,	69,	89,	11,	349,	349,
	34,	35,	73,	64,	36,	349,	65,	55,
	62,	92,	12,	13,	14,	15,	16,	37,
	38,	17,	18,	262,	31,	32,	90,	53,
	57,	262,	262,	74,	49,	262,	99,	29,
	262,	70,	30,	54,	58,	68,	170,	39,
	120,	40,	41,	70,	72,	262,	262,	262,
	262,	262,	51,	59,	262,	262,	34,	35,
	116,	349,	36,	73,	292,	57,	292,	120,
	95,	349,	119,	177,	349,	37,	38,	292,
	292,	58,	211,	292,	349,	349,	173,	292,
	96,	134,	78,	135,	74,	349,	292,	292,
	349,	171,	349,	233,	97,	39,	349,	40,
	41,	349,	292,	82,	133,	349,	292,	290,
	349,	290,	94,	57,	292,	292,	292,	292,
	292,	292,	34,	35,	210,	164,	36,	58,
	210,	349,	290,	209,	349,	349,	349,	277,
	106,	37,	38,	277,	277,	233,	165,	277,
	349,	349,	349,	349,	349,	290,	72,	72,
	349,	290,	277,	277,	349,	231,	349,	290,
	290,	39,	290,	40,	41,	73,	73,	349,
	34,	35,	349,	107,	36,	57,	349,	277,
	349,	349,	277,	349,	277,	277,	349,	37,
	38,	58,	291,	349,	291,	349,	74,	74,
	113,	117,	349,	349,	349,	291,	291,	231,
	349,	291,	34,	35,	349,	291,	36,	39,
	78,	40,	41,	137,	291,	291,	349,	34,
	35,	37,	38,	36,	349,	349,	349,	349,
	291,	82,	349,	349,	291,	349,	37,	38,
	349,	349,	291,	291,	291,	291,	291,	291,
	349,	39,	349,	40,	41,	349,	349,	289,
	349,	289,	349,	138,	349,	349,	39,	349,
	40,	41,	34,	35,	349,	349,	36,	268,
	349,	349,	289,	268,	268,	349,	349,	268,
	268,	37,	38,	268,	34,	35,	349,	150,
	36,	349,	349,	349,	349,	289,	268,	268,
	349,	289,	349,	349,	38,	349,	349,	289,
	289,	39,	289,	40,	41,	277,	106,	268,
	349,	277,	277,	268,	349,	277,	268,	349,
	268,	268,	285,	157,	285,	40,	41,	349,
	277,	277,	349,	349,	349,	349,	269,	349,
	349,	349,	269,	269,	349,	285,	269,	269,
	349,	107,	269,	349,	349,	277,	150,	349,
	277,	349,	277,	277,	349,	269,	269,	349,
	70,	287,	349,	287,	326,	326,	349,	349,
	326,	349,	154,	155,	34,	35,	269,	349,
	36,	349,	269,	349,	287,	269,	326,	269,
	269,	34,	35,	349,	38,	36,	349,	349,
	349,	306,	349,	306,	349,	349,	349,	349,
	349,	38,	349,	179,	306,	306,	349,	349,
	306,	349,	349,	157,	306,	40,	41,	170,
	349,	305,	349,	305,	306,	178,	349,	349,
	157,	349,	40,	41,	305,	305,	349,	349,
	305,	340,	340,	349,	305,	340,	349,	170,
	349,	349,	349,	306,	305,	306,	306,	349,
	349,	349,	181,	340,	349,	349,	182,	349,
	338,	338,	349,	349,	338,	349,	183,	349,
	349,	349,	349,	305,	184,	305,	305,	349,
	340,	181,	338,	340,	340,	192,	349,	340,
	339,	339,	336,	336,	339,	183,	336,	349,
	349,	349,	340,	191,	181,	340,	349,	338,
	182,	181,	339,	349,	336,	349,	349,	197,
	183,	349,	349,	334,	334,	183,	184,	334,
	349,	338,	340,	349,	337,	337,	349,	339,
	337,	336,	349,	349,	349,	334,	349,	349,
	202,	349,	349,	349,	340,	181,	337,	349,
	349,	339,	349,	336,	349,	349,	349,	349,
	349,	183,	334,	349,	349,	349,	349,	349,
	349,	349,	349,	337,	349,	349,	349,	349,
	349,	349,	349,	349,	334,	349,	349,	349,
	349,	349,	349,	349,	349,	337
};

// base array for parse action table
// which is used to determine the base location of the entries
// for each state stored in the yypack table
const int yyparser_t::yypabase[205] = {
0,	0,	0,	0,	0,	-4,	0,	0,
	0,	0,	31,	4,	0,	0,	0,	0,
	0,	0,	22,	0,	0,	0,	0,	0,
	23,	0,	0,	0,	3,	0,	0,	0,
	0,	10,	-10,	0,	0,	0,	0,	58,
	0,	47,	0,	0,	75,	0,	0,	118,
	0,	0,	-5,	-15,	79,	0,	0,	0,
	3,	0,	0,	0,	106,	0,	0,	135,
	0,	0,	0,	0,	0,	0,	164,	145,
	0,	0,	0,	0,	20,	146,	0,	0,
	0,	0,	0,	0,	0,	193,	0,	0,
	39,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	96,	0,	211,	0,
	254,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	267,	0,	0,	301,
	0,	0,	198,	321,	0,	272,	0,	0,
	0,	0,	60,	132,	0,	0,	0,	330,
	0,	0,	0,	0,	360,	373,	0,	392,
	62,	164,	90,	0,	0,	0,	0,	0,
	416,	31,	0,	0,	0,	0,	0,	364,
	433,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	456,	0,	475,	480,	482,	0,
	0,	0,	0,	0,	0,	0,	507,	516,
	0,	0,	0,	0,	0
};

const int yyparser_t::yypgoto[35] = {
44,	85,	46,	46,	349,	47,	33,	44,
	85,	46,	46,	349,	47,	76,	44,	44,
	46,	46,	349,	112,	47,	139,	140,	44,
	349,	46,	158,	159,	47,	139,	153,	158,
	168,	158,	169
};

const int yyparser_t::yypgbase[205] = {
0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	-13,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	-6,
	0,	0,	0,	0,	0,	0,	0,	-12,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	1,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	2,	0,
	-5,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	10,	0,	0,	11,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	16,	18,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0
};

const by_te_t yyparser_t::yyvbmap[1640] = {
0,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	0,	0,	0,	0,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	128,	0,	0,	0,	0,	0,	0,
	0,	128,	0,	0,	0,	0,	0,	0,
	112,	76,	11,	192,	103,	64,	0,	0,
	2,	48,	1,	24,	0,	0,	104,	0,
	2,	0,	2,	32,	0,	16,	0,	0,
	2,	0,	2,	32,	0,	16,	0,	0,
	2,	0,	2,	32,	0,	16,	0,	0,
	2,	0,	2,	32,	0,	16,	0,	0,
	2,	0,	0,	0,	0,	16,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	2,	0,	2,	32,	0,	16,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	2,	0,	2,	32,	0,	16,	0,	0,
	16,	51,	1,	24,	0,	16,	105,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	96,	0,	9,	0,	0,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	2,	0,	0,	0,	128,	8,	0,	0,
	0,	32,	0,	16,	0,	0,	32,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	0,	48,	1,	24,	0,	0,	104,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	0,	32,	0,	16,	0,	0,	32,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	0,	0,	2,	0,	0,	0,	0,	0,
	0,	0,	2,	0,	0,	8,	0,	0,
	0,	0,	2,	0,	0,	33,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	2,	0,	0,	0,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	0,	0,	2,	0,	0,	0,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	16,	51,	1,	24,	0,	16,	105,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	0,	48,	1,	24,	0,	0,	104,	0,
	0,	32,	0,	16,	0,	0,	160,	0,
	0,	32,	0,	16,	0,	0,	160,	0,
	0,	32,	0,	16,	0,	0,	160,	1,
	0,	32,	0,	16,	0,	0,	160,	0,
	0,	32,	0,	16,	0,	0,	160,	0,
	0,	0,	0,	0,	128,	0,	16,	0,
	0,	32,	0,	16,	0,	0,	160,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	10,	48,	145,	31,	128,	15,	126,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	0,	0,	2,	0,	0,	8,	0,	0,
	0,	0,	2,	0,	0,	8,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	0,	0,	0,	0,	0,	0,	0,
	16,	51,	1,	24,	0,	16,	105,	0,
	0,	49,	1,	24,	0,	0,	105,	0,
	128,	0,	2,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	49,	1,	24,	0,	0,	105,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	0,	32,	0,	16,	0,	0,	160,	0,
	0,	0,	0,	16,	0,	0,	0,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	10,	48,	17,	24,	128,	8,	126,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	2,	0,	0,	8,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	0,	0,	0,	0,	0,	8,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	160,	0,	0,
	0,	0,	0,	0,	0,	160,	0,	0,
	0,	0,	0,	0,	0,	160,	0,	0,
	0,	0,	0,	0,	0,	160,	0,	0,
	16,	51,	17,	24,	0,	16,	105,	0,
	16,	51,	17,	24,	0,	16,	105,	0,
	0,	0,	16,	0,	0,	0,	0,	0,
	0,	51,	1,	24,	0,	16,	105,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	48,	1,	24,	0,	0,	104,	0,
	10,	0,	16,	0,	128,	0,	6,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	48,	1,	16,	0,	0,	104,	0,
	0,	32,	0,	16,	0,	0,	160,	0,
	0,	0,	2,	0,	0,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	0,	0,	2,	32,	0,	0,	0,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	0,	49,	1,	24,	0,	0,	105,	0,
	128,	0,	2,	0,	0,	0,	0,	0,
	16,	51,	17,	24,	0,	16,	105,	0,
	16,	51,	17,	24,	0,	16,	105,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	10,	0,	16,	0,	0,	0,	0,	0,
	0,	48,	1,	16,	0,	0,	104,	0,
	10,	48,	17,	16,	0,	0,	104,	0,
	0,	48,	1,	16,	0,	0,	104,	0,
	10,	48,	145,	16,	0,	0,	120,	0,
	10,	48,	145,	16,	0,	0,	104,	0,
	0,	0,	2,	0,	0,	8,	0,	0,
	2,	0,	2,	32,	0,	8,	0,	0,
	17,	0,	0,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	2,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	38,	32,	8,	0,	0,	2,
	0,	0,	0,	0,	0,	160,	0,	0,
	10,	48,	145,	16,	0,	0,	104,	0,
	0,	0,	128,	0,	0,	0,	16,	0,
	10,	48,	145,	16,	0,	0,	120,	0,
	16,	76,	2,	192,	103,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	1,	0,	0,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	128,	0,	0,	2,
	19,	0,	38,	32,	136,	0,	0,	2,
	10,	48,	145,	16,	0,	0,	104,	0,
	19,	0,	4,	0,	0,	0,	0,	0,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	4,	0,	128,	0,	0,	2,
	19,	0,	38,	32,	152,	0,	0,	2,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	32,	152,	0,	0,	2,
	0,	0,	8,	0,	0,	0,	0,	0,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	38,	32,	152,	0,	0,	2,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	6,	32,	128,	0,	0,	2,
	19,	0,	36,	0,	128,	0,	0,	2,
	0,	0,	8,	0,	0,	0,	0,	0,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	32,	136,	0,	0,	2,
	0,	0,	2,	0,	0,	0,	0,	0,
	19,	0,	4,	0,	128,	0,	0,	2,
	19,	0,	38,	32,	136,	0,	0,	2,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	36,	0,	128,	0,	0,	2,
	19,	0,	6,	32,	128,	0,	0,	2,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	4,	0,	128,	0,	0,	2,
	0,	0,	64,	0,	0,	0,	0,	0,
	19,	0,	38,	32,	136,	0,	0,	2,
	19,	0,	4,	0,	128,	0,	0,	2
};

const int yyparser_t::yyparv[205] = {
349,	213,	4,	215,	206,	349,	25,	214,
	26,	27,	349,	349,	227,	229,	228,	230,
	349,	223,	349,	217,	216,	218,	219,	220,
	349,	266,	222,	221,	349,	258,	259,	260,
	261,	349,	349,	312,	313,	304,	311,	349,
	314,	349,	310,	302,	349,	300,	303,	349,
	86,	87,	349,	349,	349,	252,	253,	98,
	349,	236,	237,	101,	349,	235,	103,	349,
	254,	255,	256,	257,	263,	111,	349,	349,
	322,	320,	319,	317,	349,	349,	293,	294,
	295,	296,	297,	298,	299,	349,	265,	239,
	349,	243,	241,	121,	122,	123,	247,	124,
	250,	251,	248,	224,	125,	232,	234,	226,
	127,	267,	276,	130,	349,	270,	349,	264,
	349,	316,	318,	142,	301,	315,	143,	240,
	242,	244,	144,	145,	249,	225,	146,	324,
	148,	281,	280,	278,	349,	273,	133,	349,
	272,	284,	349,	349,	282,	349,	321,	89,
	245,	246,	349,	349,	275,	130,	274,	349,
	271,	283,	286,	288,	349,	349,	309,	349,
	349,	349,	349,	323,	174,	328,	332,	279,
	349,	349,	307,	238,	207,	212,	327,	349,
	349,	308,	325,	330,	331,	347,	189,	348,
	190,	344,	349,	346,	349,	349,	349,	198,
	199,	342,	200,	329,	343,	201,	349,	349,
	345,	335,	204,	341,	333
};


const int yyparser_t::yyparn[205] = {
32,	0,	0,	0,	0,	32,	0,	0,
	0,	0,	32,	32,	0,	0,	0,	0,
	32,	0,	32,	0,	0,	0,	0,	0,
	32,	0,	0,	0,	32,	0,	0,	0,
	0,	32,	32,	0,	0,	0,	0,	32,
	0,	32,	0,	0,	32,	0,	0,	32,
	0,	0,	32,	32,	32,	0,	0,	0,
	32,	0,	0,	0,	32,	0,	0,	32,
	0,	0,	0,	0,	0,	0,	32,	32,
	0,	2,	0,	0,	32,	32,	0,	0,
	0,	0,	0,	0,	0,	32,	0,	0,
	32,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	2,	32,	0,	32,	0,
	32,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	0,	0,	0,	0,	0,	0,
	2,	0,	0,	0,	32,	0,	0,	32,
	0,	0,	32,	32,	0,	32,	0,	0,
	0,	0,	32,	32,	0,	2,	0,	32,
	0,	0,	0,	0,	32,	32,	0,	32,
	32,	32,	32,	0,	0,	0,	0,	0,
	32,	32,	0,	0,	0,	0,	0,	32,
	32,	0,	0,	0,	0,	0,	0,	0,
	0,	0,	32,	2,	32,	32,	32,	0,
	0,	0,	0,	0,	0,	0,	32,	32,
	0,	0,	0,	0,	0
};

const int yyparser_t::yypcv[112] = {
349,	349,	349,	349,	349,	349,	349,	129,
	349,	349,	349,	349,	349,	349,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	349,
	79,	80,	81,	349,	349,	349,	349,	349,
	349,	349,	349,	349,	194,	349,	349,	349,
	349,	83,	84,	349,	349,	91,	28,	149,
	349,	349,	349,	349,	349,	349,	349,	349,
	115,	349,	349,	75,	349,	42,	166,	19,
	108,	349,	185,	186,	187,	349,	43,	349,
	45,	349,	349,	156,	349,	349,	349,	141,
	136,	128,	131,	110,	2,	349,	349,	3,
	349,	6,	349,	104,	349,	349,	162,	7,
	20,	21,	22,	23,	24,	56,	349,	349,
	61,	349,	349,	105,	163,	175,	349,	176
};

const int yyparser_t::yypcn[112] = {
32,	32,	32,	32,	32,	32,	32,	1,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	1,	1,	1,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	1,	32,	32,	32,
	32,	1,	1,	32,	32,	3,	1,	1,
	32,	32,	32,	32,	32,	32,	32,	32,
	1,	32,	32,	1,	32,	1,	1,	1,
	1,	32,	3,	1,	1,	32,	1,	32,
	1,	32,	32,	1,	32,	32,	32,	1,
	1,	1,	1,	1,	1,	32,	32,	1,
	32,	1,	32,	1,	32,	32,	1,	1,
	1,	1,	1,	1,	1,	1,	32,	32,
	1,	32,	32,	1,	1,	1,	32,	1
};


const int yyparser_t::yypgrv[205] = {
349,	349,	349,	5,	349,	349,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	349,
	349,	349,	52,	349,	349,	349,	349,	349,
	60,	63,	349,	349,	349,	349,	349,	349,
	349,	349,	71,	349,	349,	349,	349,	349,
	349,	77,	349,	349,	349,	349,	349,	349,
	349,	349,	88,	349,	349,	349,	349,	349,
	349,	349,	349,	349,	102,	349,	349,	109,
	349,	349,	349,	349,	349,	349,	349,	114,
	349,	349,	349,	349,	349,	114,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	118,
	349,	349,	349,	349,	349,	349,	349,	349,
	349,	349,	349,	349,	349,	126,	349,	349,
	349,	349,	349,	349,	132,	349,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	147,
	349,	349,	349,	349,	349,	349,	151,	152,
	349,	349,	349,	349,	349,	349,	349,	160,
	349,	349,	161,	349,	349,	167,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	349,
	349,	102,	172,	349,	349,	349,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	349,
	180,	349,	349,	188,	349,	349,	349,	349,
	349,	349,	193,	349,	195,	196,	349,	349,
	349,	349,	349,	349,	349,	349,	349,	203,
	349,	349,	349,	349,	349
};

const int yyparser_t::yypgrn[205] = {
32,	32,	32,	0,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	0,	32,	32,	32,	32,	32,
	2,	0,	32,	32,	32,	32,	32,	32,
	32,	32,	2,	32,	32,	32,	32,	32,
	32,	2,	32,	32,	32,	32,	32,	32,
	32,	32,	0,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	0,	32,	32,	2,
	32,	32,	32,	32,	32,	32,	32,	0,
	32,	32,	32,	32,	32,	0,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	0,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	0,	32,	32,
	32,	32,	32,	32,	0,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	0,
	32,	32,	32,	32,	32,	32,	0,	2,
	32,	32,	32,	32,	32,	32,	32,	0,
	32,	32,	2,	32,	32,	0,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	32,	0,	0,	32,	32,	32,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	32,
	4,	32,	32,	0,	32,	32,	32,	32,
	32,	32,	2,	32,	4,	2,	32,	32,
	32,	32,	32,	32,	32,	32,	32,	2,
	32,	32,	32,	32,	32
};


// get global parser object,
// it's invisiable to user
static yyparser_t& getTheParser(void) {

	static yyparser_t yyp(yylex);
	return yyp;
}

// assign new error-reporter and return the old one
yyerror_t yyseterror(yyerror_t perror) {

	yyparser_t& yyp = getTheParser();
	yyerror_t pold = yyp.yyerror;
	yyp.yyerror = perror;

	return pold;
}

// reset all (both scanner and parser, if they are available)
void yyclearall(void) {
	getTheParser().yyclearall__();
}


// initializing file buffer before parsing or patter-matching
int yylexfile(const char* pchFile, bool iMod) {
	
	return getTheParser().yylexinit__(pchFile, iMod)? 0: -1;
}
// initializing string buffer before parsing or patter-matching
int yylexstr(char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}
// initializing const string buffer before parsing or patter-matching
int yylexcstr(const char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}

// generated scanner, can be replaced
int yylex(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {

	return getTheParser().yylex__(lexer, dtbl, grammar, ptbl, dmap, gsetup);
} 

// assign new scanner and return the old one 
yylex_t yysetlex(yylex_t plex) {
	
	yyparser_t& yyp = getTheParser();
	yylex_t pold = yyp.yylexer;
	yyp.yylexer = plex;

	return pold;
}

// generated parser, it should not be replaced
int yyparse(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {
	return getTheParser().yyparse__(lexer, dtbl, grammar, ptbl, dmap, gsetup);
}
#line 3169 "../meta/ulyac.upg"


int debug_yyparse(lexer_ns::lexer_t &lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup) {

	int nRet = yyparse(lexer, dtbl, grammar, ptbl, dmap, gsetup);
	
	return nRet;
}

#line 8624 "ulyac.cpp"


