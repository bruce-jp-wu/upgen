/*******************************************************************************
A parser program in C++, generated by Upgen 0.5.1.
******************************************************************************/

#ifndef CLASS_yyPARSE_T_FILE_ulyac_H__
#define CLASS_yyPARSE_T_FILE_ulyac_H__

#line 1 "../meta/ulyac.upg"

/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2016  Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "../main/upgmain.h"
#include "../lexer/token.h"
using lexer_ns::token_t;

#include "../lexer/dtable.h"
using lexer_ns::dtable_t;

#include "../lexer/lexer.h"
using lexer_ns::lexer_t;

#include "../parser/defines.h"
#include "../parser/grammar.h"
using parser_ns::grammar_t;
#include "../parser/ptable.h"
using parser_ns::ptable_t;

#include "../coder/dmmap.h"
using coder_ns::dmmap_t;


#line 51 "ulyac.h"

// token ID definition
#define ENDP 258
#define SECT_DELIM 259
#define KW_OFF 260
#define KW_ON 261
#define KW_INITIAL 262
#define KW_EOF 263
#define KW_ALLSC 264
#define ISCLABEL 265
#define XSCLABEL 266
#define NCS 267
#define POSIX_SET 268
#define OPT_KEY 269
#define XISC 270
#define CSTR 271
#define CID 272
#define LFTID 273
#define INT 274
#define LEX_ACTION 275
#define PACT_BEGIN 276
#define PACT_END 277
#define RANGE_EQUAL 278
#define RANGE_LESS 279
#define RANGE_MORE 280
#define RANGE_BET 281
#define MCALL 282
#define CCHAR 283
#define QCHAR 284
#define TOKEN_LABEL 285
#define RIGHT_LABEL 286
#define LEFT_LABEL 287
#define NONASSOC_LABEL 288
#define TYPE_LABEL 289
#define DPRE_LABEL 290
#define PREC_LABEL 291
#define START_LABEL 292
#define DESTRUCTOR_LABEL 293

// function type for error-reporting
typedef void(*yyerror_t)(const char* msg, lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup);

// assign new error-reporter and return the old one
yyerror_t yyseterror(yyerror_t);
// reset all (both scanner and parser, if they are available)
void yyclearall(void);

// location defines here
struct yyltype_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	
};

// semantic value type defined by user as token_t
typedef token_t xstype_t;
typedef yyltype_t xltype_t;
// function type for scanning
typedef int (*yylex_t)(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup);

// assign new scanner and return the old one
yylex_t yysetlex(yylex_t);

// initializing file buffer before parsing or patter-matching
int yylexfile(const char* pchFile, bool iMod = false);
// initializing string buffer before parsing or patter-matching
int yylexstr(char *strbuffer, int size);
// initializing const string buffer before parsing or patter-matching
int yylexcstr(const char *strbuffer, int size);

// generated scanner, can be replaced
int yylex(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup);


// generated parser, it should not be replaced
int yyparse(lexer_ns::lexer_t& lexer, lexer_ns::dtable_t &dtbl,
	parser_ns::grammar_t &grammar, parser_ns::ptable_t &ptbl,
	dmmap_t &dmap, gsetting_t &gsetup);

extern xstype_t yylval;
extern xltype_t yylloc;

#endif
