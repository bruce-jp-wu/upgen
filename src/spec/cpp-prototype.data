<?Setup DefinitionExtName=".cpp" DeclarationExtName=".h"/><Macros>
	<Macro "$FreeToUse">
<![[/*******************************************************************************
A parser program in C++, generated by ]]>
<String #0/><![[ ]]><String #1/><![[.
******************************************************************************/
]]></Macro>

	<Macro "$YY">
	<Scalar "Prefix"/><Text #0/>
	</Macro>

	<Macro "$ActionLine">
	<Case EnableLineNo><![[
#line ]]><ActLine #0/><![[ "]]><Scalar "ScriptFileName"/><![["
]]></Case>
	</Macro>

	<Macro "$HeaderLine">
	<Case EnableLineNo><![[
#line ]]><SrcLine/><![[ "]]><Scalar "DeclareFileName"/><![["
]]></Case>
	</Macro>
	
	<Macro "$DeclareAction">
	<Case Has><$ActionLine #0/><Action #0/><$HeaderLine/></Case>
	</Macro>
	
	<Macro "$SourceLine">
	<Case EnableLineNo><![[
#line ]]><SrcLine/><![[ "]]><Scalar "DefineFileName"/><![["
]]></Case>
	</Macro>


	<Macro "$SingleAction">
	<Case Has><$ActionLine #0/><Action #0/><$SourceLine/></Case>
	</Macro>
	
	<Macro "$CodeBlock">
	<Case Has><![[{
	]]><$ActionLine #0/><Action #0/><$SourceLine/>
	<![[
	}
]]></Case>
	</Macro>

	<Macro "$UserLexActions">
<Case End><GoFirst/></Case>
<Case GroupFlag><![[{
	]]><$SingleAction #1/><Skip #0/><![[
	}
	break;
	]]><$UserLexActions/></Case>
<Default><![[
case ]]><Integer #0/><![[:
]]><$UserLexActions/></Default>
	</Macro>

	<Macro "$UserParseActions">
<Case End><GoFirst/></Case>
<Case GroupFlag><![[{]]><$SingleAction #1/><Skip #0/><![[
	}
	break;
	]]><$UserParseActions/></Case>
<Default><![[
	case ]]><Integer #0/><![[:
	]]><$UserParseActions/></Default>
	</Macro>

	<Macro "$UserDiscardActions">
<Case End><GoFirst/></Case>
<Case GroupFlag><![[{]]><$SingleAction #1/><Skip #0/><![[
	}
	break;
	]]><$UserDiscardActions/></Case>
<Default><![[
case ]]><Integer #0/><![[:]]><$UserDiscardActions/></Default>
	</Macro>

	<Macro "$IntArray">
<Case Last><Integer #0/><GoFirst/></Case>
<Case Mod?8><Integer #0/><![[,
	]]><$IntArray/></Case>
<Default><Integer #0/><![[,	]]><$IntArray/></Default>
	</Macro>

	<Macro "$QStrArray">
<Case Last><![["]]><String #0/><![["]]><GoFirst/></Case>
<Case Mod?8><![["]]><String #0/><![[",
	]]><$QStrArray/></Case>
<Default><![["]]><String #0/><![[",	]]><$QStrArray/></Default>
	</Macro>

	<Macro "$ConstsDefine">
<Case End><GoFirst/></Case>
<Default><String #0/><![[ = ]]><Integer #1/><![[,
]]><$ConstsDefine/></Default>
	</Macro>
	
	<Macro "$StrIntMapDefine">
<Case End><GoFirst/></Case>
<Default><![[{"]]><String #0/><![[", ]]><Integer #1/><![[},]]><$StrIntMapDefine/></Default>
	</Macro>

	<Macro "$SVNAME_LEFT"><![[(yyval.]]><Text #0/><![[)]]></Macro>
	<Macro "$SVNAME_RIGHT"><![[(yys_sv__[]]><Text #0/><![[].]]><Text #1/><![[)]]></Macro>
	<Macro "$SVLOC_LEFT"><![[(yyloc)]]></Macro>
	<Macro "$SVLOC_RIGHT"><![[(yys_loc__[]]><Text #0/><![[])]]></Macro>
	<Macro "$SVNAME_DSTRCT"><![[(yydval.]]><Text #0/><![[)]]></Macro>
	<Macro "$SVLOC_DSTRCT"><![[(yydloc)]]></Macro>

	<Macro "$TypeName">
		<Case Has><Action #0/></Case>
		<Default><Scalar "Prefix"/><Text #1/></Default>
	</Macro>
</Macros>

<Program>

<Declare/>
<$FreeToUse "SoftwareName" "SoftwareVersion"/>

<Define/>
<$FreeToUse "SoftwareName" "SoftwareVersion"/>
<![[
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
// update 14/12/17
#include <vector>
#include <unordered_map>
#include <string>
]]>
<![[
namespace ]]><$YY "nsx"/><![[ {
typedef unsigned char by_te_t;
}]]>
<If EnableScanner><![[
namespace ]]><$YY "nsx"/><![[ {
]]><![[
class bufbase_t;
typedef bufbase_t *YYPBUFFER;
}
]]></If>
<If EnableDeclare><![[
#include "./]]><String "DeclareFileName"/><![["
]]>
<Declare/>
<![[
#ifndef CLASS_]]><$YY "PARSE_T_FILE_"/><String "FileBaseName"/><![[_H__
#define CLASS_]]><$YY "PARSE_T_FILE_"/><String "FileBaseName"/><![[_H__
]]>
<$DeclareAction "DeclareHeader"/>
<![[namespace ]]><$YY "nsx"/><![[ {
]]>
</If>
<Else>
<$DeclareAction "DeclareHeader"/>
</Else>
<If EnableParser><![[
// token ID definition
enum {
]]><$ConstsDefine "ParseTokenNames" "ParseTokenValues"/>
<![[
__UPGEN_GENERATED_PARSE_TOKEN_VALUE = 0
};
]]></If>

<Define/>
<$SingleAction "DefineHeader"/>
<![[namespace ]]><$YY "nsx"/><![[ {
enum {]]>
<If EnableScanner>
<![[
INC_YYTEXT_SIZE = 4096,
END_OF_FILE = 256,
END_OF_ALLFILE = 257,

// start-condition names
]]><$ConstsDefine "LexStartLabels" "LexStartIndexes"/><![[
// number of DFA states of scanner
LEX_STATE_COUNT = ]]><Integer "LexDefaultState"/><![[,

// DFA trap-state of scanner
LEX_ERROR_STATE = ]]><Integer "LexErrorState"/><![[,

// ID of invalid rule for scanner,
// indicating current string can not be matched by any pattern
LEX_ERROR_RULE = ]]><Integer "LexErrorRule"/><![[,

// this constant used by computing index of a rule that matches EOF
// for example, in start-condition INITIAL, index of the rule that
// matches EOF is 
//	LEX_EOFRULE_BASE + INITIAL
LEX_EOFRULE_BASE = ]]><Integer "LexEOFRuleBase"/><![[,

// index of the rule that matches EOAF (end of all files, or end of input)
LEX_EOAF_RULE = ]]><Integer "LexEOFARuleIndex"/><![[,

]]>
</If>
<![[
// index of symbol `$end' in symbol table
PARSE_ENDSYMB_INDEX = ]]><Integer "ParseEndSymbIdx"/><![[,
// index of symbol `error' in symbol table
PARSE_ERRORSYMB_INDEX = ]]><Integer "ParseErrorSymbIdx"/><![[,
// index of symbol `$undef' in symbol table
PARSE_UNDEFSYMB_INDEX = ]]><Integer "ParseUndefSymbIdx"/><![[,

// ID of symbol `$end'
PARSE_ENDSYMB_ID = ]]><Integer "ParseEndSymbID"/><![[,
// ID of symbol `error'
PARSE_ERRORSYMB_ID = ]]><Integer "ParseErrorSymbID"/><![[,
// ID of symbol '$undef'
PARSE_UNDEFSYMB_ID = ]]><Integer "ParseUndefSymbID"/><![[,
]]>

<If EnableParser>
<![[
// row size(in byte) of non-error bitmap of parse table
PARSE_BMAP_ROWSIZE = ]]><Integer "ParseBMapRowSize"/><![[,
// base address of indexes of types (aka non-terminals or variables)
PARSE_TYPE_BASE = ]]><Integer "ParseTypeBase"/><![[,
// number of symbols in parser
PARSE_SYMBOL_COUNT = ]]><Integer "ParseSymbolNum"/><![[,

// number of symbols in parser
PARSE_TOKENMAP_SIZE = ]]><Size "ParseTokenMap"/><![[,

// start state of parser
PARSE_START_STATE = ]]><Integer "ParseStartState"/><![[,

// accept state of parser
PARSE_ACCEPT_STATE = ]]><Integer "ParseAcceptState"/><![[,

// illegal state for parser
PARSE_ERROR_STATE  = ]]><Integer "ParseErrorState"/><![[,

// special ID of invalid rule for parser, indicating current lookahead
// symbol can not be shifted
PERROR_RULE = ]]><Integer "ParseErrorRule"/><![[,
]]></If>
<![[

MAX_MSG_LENG = 128,
};

// macros for wrapped new operator
#define MYNEW(var, type) {\
	var = new type;\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYNEWS(var, type, size) {\
	var = new type[size];\
	if(! var) {\
		exit_on_oom();\
	}\
}
#define MYRENEW(var, type, size, osize) {\
	type *p = new type[size];\
	if(!p) {\
		exit_on_oom();\
	}\
	memcpy(p, var, sizeof(type) * osize);\
	delete[] var;\
	var = p;\
}

// error IDs
enum {
	// grammar is accepted by automation
	YYE_ACCEPT =	1,
	// indicate automation is alive
	YYE_ALIVE =	2,
	// run out of all buffers,
	// and token `$end' will be sent to parser
	YYE_EOS =	3,
	// lexical analysis terminated manually,
	// and token `$end' will be sent to parser
	YYE_TERM =	3,
	// syntactic error occurs, and try to error-recover
	YYE_PERROR =	4,

	// can not match any pattern, token `$undef' will
	// be sent to parser
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID,

	// out of memory
	YYE_OOM = 	-1,
	// out of range
	YYE_OOR =	-2,
	// I/O error
	YYE_IO =	-3,
	// parsing aborted
	YYE_ABORT = 	-4,
	YYE_NOINPUT =	-5,
};
]]>
<If EnableScanner><![[
class bufbase_t;
typedef bufbase_t *YYPBUFFER;
]]><![[
class bufbase_t {

public:
	virtual ~bufbase_t(void){}
	virtual int get(void) = 0;
	virtual int peek(void) = 0;
	virtual int unget(void) = 0;
	virtual int unget(int num) = 0;
	virtual int put(char) = 0;

	inline void reset(void) {
		xreset();]]>
	<If EnableLocation>
		<If EnableColumn><![[
		stlsz.clear();
		sttsz.clear();]]>
		</If>
	</If><![[
	}
	inline bool iseof(void) const { return gptr == gend;}
	inline bool iseos(void) const { return eos;	}
	inline bool isimod(void) const { return imod;}
	inline void setimod(bool bi) { imod = bi;}
	inline int getlineno(void) const { return line;}
	inline void setlineno(int nline) { line = nline;}
	inline int getcolno(void) const { return col;}
	inline void setcolno(int ncol) { col = ncol;}
	inline int gettabsize(void) const { return tab;}
	inline void settabsize(int ntab) { tab = (ntab > 0)? ntab : 1;}

	inline void* getdata(void) const { return pvoid; }
	inline void setdata(void* pv) { pvoid = pv; }
protected:
	virtual void xreset(void) = 0;

	by_te_t *pbase;
	by_te_t *gptr;
	by_te_t *gend;
	bool eos;
	// interactive mode
	bool imod;
	int line;
	int col;
	int tab;
	
	void *pvoid;
]]>
	<If EnableLocation>
		<If EnableColumn><![[
public:
    // update 14/12/17
    inline void pushlsz(int nlsize) {
        stlsz.push_back(nlsize);
    }
    inline int poplsz(void) {
        if(stlsz.empty()) {
            return 0;
        }
        auto n = stlsz.back();
        stlsz.pop_back();
        return n;
    }

    inline void pushtsz(int ntsize) {
        // update 14/12/17
        sttsz.push_back(ntsize);
    }
    inline int poptsz(void) {
        if(sttsz.empty()) {
            return 0;
        }
        auto n = sttsz.back();
        sttsz.pop_back();
        return n;
    }
protected:
    // update 14/12/17
    std::vector<int> stlsz;
    std::vector<int> sttsz;
]]>
		</If>
	</If><![[
};
]]></If>

<If EnableDeclare><Declare/></If>
<![[
// function type for error-reporting
typedef void(*]]><$YY "error_t"/><![[)(const char* msg]]><If Has?"FormalParams"><![[, ]]><Action "FormalParams"/></If><![[);

// assign new log stream
void ]]><$YY "setstream"/><![[(FILE *poutput, FILE *plogger);
// assign new error-reporter and return the old one
]]><$YY "error_t"/><![[ ]]><$YY "seterror"/><![[(]]><$YY "error_t"/><![[);
// reset all (both scanner and parser, if they are available)
void ]]><$YY "clearall"/><![[(void);
]]>
<If EnableParser>
<If Has?"LTypeName">
<![[
// location type is defined by user as ]]><Action "LTypeName"/></If>
<Else><![[
// location defines here
struct ]]><$YY "ltype_t"/><![[ {
	]]>
<If Has?"LTypeDeclare"><Action "LTypeDeclare"/></If>
<Else><![[int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	]]></Else>
<![[
};
]]></Else>
<If Has?"STypeName"><![[
// semantic value type defined by user as ]]><Action "STypeName"/></If>
<Else><![[
// semantic value type define here
struct ]]><$YY "stype_t"/><![[ {
	]]>
<If Has?"STypeDeclare"><Action "STypeDeclare"/></If>
<Else><![[int nVal;]]></Else>
<![[
};
]]></Else>
<![[
typedef ]]><$TypeName "STypeName" "stype_t"/><![[ xstype_t;
typedef ]]><$TypeName "LTypeName" "ltype_t"/><![[ xltype_t;
// function type for scanning
typedef int (*]]><$YY "lex_t"/><![[)(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[);

// assign new scanner and return the old one
]]><$YY "lex_t"/><![[ ]]><$YY "setlex"/><![[(]]><$YY "lex_t"/><![[);
]]>
</If>

<If EnableScanner><![[
// initializing file buffer before parsing or patter-matching
int ]]><$YY "lexfile"/><![[(const char* pchFile, bool iMod = false);
// initializing string buffer before parsing or patter-matching
int ]]><$YY "lexstr"/><![[(char *strbuffer, int size);
// initializing const string buffer before parsing or patter-matching
int ]]><$YY "lexcstr"/><![[(const char *strbuffer, int size);

// generated scanner, can be replaced
int ]]><$YY "lex"/><![[(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[);

]]></If><If EnableParser><![[
// generated parser, it should not be replaced
int ]]><$YY "parse"/><![[(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[);
]]>
</If>

<Declare/>
<If EnableParser><![[
extern xstype_t ]]><$YY "lval"/><![[;
extern xltype_t ]]><$YY "lloc"/><![[;
]]></If>
<If EnableDeclare><![[
} // namespace
#endif
]]></If>

<Define/>
<If EnableParser><![[
xstype_t ]]><$YY "lval"/><![[;
xltype_t ]]><$YY "lloc"/><![[;

]]></If>
<![[
// program abort due to out of memory
inline static void exit_on_oom(void) {
	exit(-1);
}
static char stext__[24] = "unprintable-char{";
inline static const char* sym_text__(const char* ps) {
	
	by_te_t b = (by_te_t)*ps, i = 17, t;
	if( !ps[1] && (b < 32 || b >= 127)) {
		if((t = b / 100) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 100;
		}
		if((t = b / 10) > 0) {
			stext__[i++] = (char)(t + 48);
			b %= 10;
		}
		stext__[i++] = (char)(b + 48);
		stext__[i++] = '}';
		stext__[i] = '\0';
		return stext__;
	}
	return ps;
}

static void yyemit_error__(const char *s]]><If Has?"FormalParams"><![[, ]]><Action "FormalParams"/></If><![[);

class ]]><$YY "parser_t"/><![[ {

	friend void ]]><$YY "setstream"/><![[(FILE *poutput, FILE *plogger);
	friend ]]><$YY "error_t"/><![[ ]]><$YY "seterror"/><![[(]]><$YY "error_t"/><![[);
	]]><If EnableParser><![[friend ]]><$YY "lex_t"/><![[ ]]><$YY "setlex"/><![[(]]><$YY "lex_t"/><![[);
]]></If>
<If EnableScanner><![[
private:

	// class bufmgr_t class define HERE
	class bufmgr_t {

	public:

		enum {
			// half size of buffer
			BUF_HALF_SIZE = 4096,
			// fullsize of buffer
			BUF_FULL_SIZE = BUF_HALF_SIZE * 2
		};

	private:
		class filebuf_t: public bufbase_t {

			friend class bufmgr_t;
		private:

			inline void init(void) {

				gptr = pbase = &buf[BUF_FULL_SIZE - 1];
				gend = &buf[0];
				eos = false;
				bpeeked = false;
			}

		public:

			filebuf_t(FILE* pf = stdin)
			: pfile(pf) {
				imod = (pf == stdin);
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
				init();
			}

			virtual ~filebuf_t(void) {

				if(pfile != stdin) {

					fclose(pfile);
				}
			}

			virtual void xreset(void) {

				if(pfile != stdin) {
					fseek(pfile, 0, SEEK_SET);
				}
				init();
			}

			virtual int get(void) {

				if(gptr == gend) {

					eos = true;
					return END_OF_ALLFILE;
				}

				gptr = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(gptr == gend && !bpeeked) {

					fill(gptr);
				}

				bpeeked = false;

				return iseof()? END_OF_FILE: (int)(*gptr);
			}

			virtual int peek(void) {

				if(gptr == gend) {

					return END_OF_ALLFILE;
				}

				by_te_t *p = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;

				if(p == gend) {

					fill(p);
				}

				bpeeked = true;

				return (p == gend)? END_OF_FILE: (int)(*p);
			}

			virtual int unget(void) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

			virtual int unget(int num) {

				if(eos || gptr == pbase) {
					return 0;
				}
				int n = ((gptr - pbase) + BUF_FULL_SIZE) % BUF_FULL_SIZE;

				if(n > num) {
					n = num;
				}
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - n) % BUF_FULL_SIZE;

				return n;
			}
		
			virtual int put(char c) {

				if(eos || gptr == pbase) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);
				*gptr = (by_te_t)c;
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;

				return oldc;
			}

		private:

			int fill(by_te_t *p) {

				int ncnt = 0;
				int vacents = ((pbase + BUF_FULL_SIZE) - gend) % BUF_FULL_SIZE;
				if(stdin != pfile) {
					while((ncnt = fread(p, 1, BUF_HALF_SIZE, pfile)) == 0 && ferror(pfile)) {
						if(errno != EINTR) {
							// IO error
							return 0;
						}
						clearerr(pfile);
						errno = 0;
					}
					gend = buf + (p - buf + ncnt) % BUF_FULL_SIZE;
				}
				else {
					for(int c = 0; '\n' !=  c && ncnt < BUF_HALF_SIZE;
						gend = buf + ((gend - buf) + 1) % BUF_FULL_SIZE, ++ncnt) {

						c = fgetc(stdin);
						*gend = (by_te_t)c;
						if(EOF == c && feof(pfile)) {
							break;
						}
					}
				}
				if(ncnt > vacents) {
					pbase = buf + ((gend - buf) + 1) % BUF_FULL_SIZE;
				}
				return ncnt;
			}

		private:

			bool bpeeked;
			FILE *pfile;
			by_te_t buf[BUF_FULL_SIZE];
		};

	private:

		class strbuf_t: public bufbase_t {

			friend class bufmgr_t;
		public:

			// nSize is length of string including terminating NULL
			strbuf_t(const char *pchBuf, int nSize)
			: bowner(true) {

				MYNEWS(pbase, by_te_t, nSize);
				memcpy(pbase, pchBuf, sizeof(char)*(nSize - 1));
				pbase[nSize - 1] = '\0';

				gend = pbase + nSize - 1;
				xreset();
				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
			}

			strbuf_t(char *pchBuf, int nSize)
			: bowner(false) {

				pbase = (by_te_t*)pchBuf;
				gend = pbase + nSize - 1;
				xreset();

				imod = false;
				line = 1;
				col = 1;
				tab = 4;
				pvoid = NULL;
			}

			virtual ~strbuf_t(void) {
				if(bowner) {
					delete [] pbase;
				}
			}

		public:

			virtual void xreset(void) {

				gptr = pbase - 1;
				eos = false;
			}
			virtual int get(void) {

				if(gptr == gend) {
					eos = true;
					return END_OF_ALLFILE;
				}
				++gptr;

				return (gptr == gend)? END_OF_FILE : (int)(*gptr);
			}

			virtual int peek(void) {

				return (gptr == gend) ? (eos ? END_OF_ALLFILE: END_OF_FILE) : 
					(int)(*(gptr + 1));
			}
			virtual int unget(void) {
				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}
				return (int)(*gptr--);
			}
			virtual int unget(int num) {

				if(eos || (pbase - 1 == gptr)) {
					return 0;
				}
				int n = gptr - pbase + 1;
				if(n > num) {
					n = num;
				}
				gptr -= n;

				return n;
			}

			virtual int put(char c) {

				if(eos || (pbase - 1 == gptr)) {
					return END_OF_FILE;
				}

				int oldc = (int)(*gptr);

				*gptr-- = (by_te_t)c;

				return oldc;
			}

		private:
			bool bowner;
		};

	private:

		struct link_t {

			link_t(bufbase_t *pxb, link_t *plnk = NULL)
			: pxbuf(pxb)
			, plink(plnk){}

			bufbase_t *pxbuf;
			link_t *plink;
		};

	public:

		bufmgr_t(void)
		: phead(NULL) {

			MYNEW(pstdin, filebuf_t);
			MYNEW(pavail, link_t(pstdin, NULL));
		}
		~bufmgr_t(void) {

			while(pavail) {

				link_t *p = pavail->plink;

				delete pavail->pxbuf;
				delete pavail;

				pavail = p;
			}			
		}

	public:

		inline int get(void) {
			return phead? phead->pxbuf->get(): END_OF_ALLFILE;
		}
		inline int peek(void) {
			return phead? phead->pxbuf->peek(): END_OF_ALLFILE;
		}
		inline int unget(void) {
			return phead? phead->pxbuf->unget(): END_OF_FILE;
		}
		inline int unget(int num) {
			return phead? phead->pxbuf->unget(num): 0;
		}
		inline int put(char c) {
			return phead? phead->pxbuf->put(c): END_OF_FILE;
		}
		inline bool iseof(void) const {
			return phead? phead->pxbuf->iseof(): true;
		}
		inline bool iseos(void) const {
			return phead? phead->pxbuf->iseos(): true;
		}
		inline bool isimod(void) const {
			return phead? phead->pxbuf->isimod(): false;
		}
		inline int getlineno(void) const {
			 return phead? phead->pxbuf->getlineno(): 0;
		}
		inline void setlineno(int nline) {
			if(phead) {
				phead->pxbuf->setlineno(nline);
			}
		}
		inline int getcolno(void) const {
			return phead? phead->pxbuf->getcolno(): 0;
		}
		inline void setcolno(int ncol) {
			if(phead) {
				phead->pxbuf->setcolno(ncol);
			}
		}
		inline int gettabsize(void) const {
			return phead? phead->pxbuf->gettabsize(): 0;
		}
		inline void settabsize(int ntab) {
			if(phead) {
				phead->pxbuf->settabsize(ntab);
			}
		}
		inline void reset(void) {
			if(phead) {
				phead->pxbuf->reset();
			}
		}]]>
	<If EnableLocation>
		<If EnableColumn><![[
		inline void pushlsz(int nlsize) {
			if(phead) {
				phead->pxbuf->pushlsz(nlsize);
			}
		}
		inline int poplsz(void) {
			if(phead) {
				return phead->pxbuf->poplsz();
			}
			return 0;
		}
		inline void pushtsz(int ntsize) {
			if(phead) {
				phead->pxbuf->pushtsz(ntsize);
			}
		}
		inline int poptsz(void) {
			if(phead) {
				return phead->pxbuf->poptsz();
			}
			return 0;
		}
]]>
		</If>
	</If><![[

		inline bufbase_t* current(void) const {
			return phead ? phead->pxbuf : NULL;
		}

		inline bool empty(void) const {
			return ! phead;
		}

		inline bufbase_t* newbuf(FILE *pfile, bool iMod = false) {

			bufbase_t *p;
			if(pfile == stdin) {
				p = pstdin;
				p->reset();
			}
			else {
				MYNEW(p, filebuf_t(pfile));
				MYNEW(pavail->plink, link_t(p, pavail->plink));
			}
			
			p->setimod(iMod);
			
			return p;
		}
		inline bufbase_t* newbuf(char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		inline bufbase_t* newbuf(const char * pchBuffer, int nSize) {
		
			strbuf_t *p;
			MYNEW(p, strbuf_t(pchBuffer, nSize));
			MYNEW(pavail->plink, link_t(p, pavail->plink));

			return p;
		}
		
		inline bufbase_t* switchto(bufbase_t* pbuf) {

			bufbase_t *pold = phead ? phead->pxbuf : NULL;
			link_t* p = rmwork(pbuf);
			if( ! p) {
				MYNEW(phead, link_t(pbuf, phead));
			}
			else {
				p->plink = phead;
				phead = p;
			}
			
			return pold;
		}
		
		inline bufbase_t* pop(void) {
			
			if(! phead) {
				return NULL;
			}
			
			link_t *p = phead;
			bufbase_t* pbuf = p->pxbuf;
			phead = phead->plink;
			
			delete p;
			
			return pbuf;
		}

		void destroytop(void) {
			
			bufbase_t *pxb = pop();
			if( pxb && pxb != pstdin) {

				link_t *p = pavail;
				
				while(p->plink && p->plink->pxbuf != pxb) {
					p = p->plink;
				}
				if(p->plink) {
					link_t *q = p->plink;
					p->plink = q->plink;

					delete pxb;
					delete q;
				}
			}
		}
		
		void destroyall(void) {

			while(pavail->plink) {
				link_t *p = pavail->plink;
				pavail->plink = p->plink;
				if(p->pxbuf) {
					delete p->pxbuf;
				}
				delete p;
			}
			
			phead = NULL;
		}

	private:

		link_t* rmwork(bufbase_t* pxb) {

			link_t *p = phead;
			// then check if @pxb is in the list, if so, then remove it
			if(p) {

				if(pxb == phead->pxbuf) {
					phead = phead->plink;
					return p;
				}
				else {
					while(p->plink && p->plink->pxbuf != pxb) {
						p = p->plink;
					}
					if(p->plink) {
						link_t *q = p->plink;
						p->plink = q->plink;
						return q;
					}
				}
			}

			return NULL;
		}

	private:

		// working buffer stack
		link_t *phead;
		// available buffer stack
		link_t *pavail;
		// stdin buffer
		bufbase_t *pstdin;
	};

]]></If><![[
    template<class ElemType, int INIT_SIZE = 4096>
    class sstack_t {
    public:
        inline sstack_t(void) {

        }

        inline void push(void) {
            mStk.push_back(ElemType());
        }
        inline void push(const ElemType &e) {
            mStk.push_back(e);
        }
        inline ElemType& top(void) {
            return mStk.back();
        }
        inline const ElemType& top(void) const {
            return mStk.back();
        }
        inline void pop(int n) {
            while(n > 0 && !mStk.empty()) {
                mStk.pop_back();
                n--;
            }
        }
        inline ElemType& operator[](int down) {
            const auto sz = (int) mStk.size();
            return mStk[sz - 1 - down];
        }
        inline const ElemType& operator[](int down) const {
            const auto sz = (int) mStk.size();
            return mStk[sz - 1 - down];
        }

        inline bool empty(void) const {
            return mStk.empty();
        }

        inline int count(void) const {
            return (int)mStk.size();
        }

        inline void clear(void) {
            mStk.clear();
        }
    private:
        std::vector<ElemType> mStk;
    };
]]><If EnableScanner><![[

private:

	inline void renew_text__(void) {

		MYRENEW(yytext, char, INC_YYTEXT_SIZE + yysize__, yysize__);
		yysize__ += INC_YYTEXT_SIZE;
		yytext[yysize__ - 1] = '\0';
	}

	inline bool yylex_is_running__(void) const {
		return yyecode__ == YYE_ALIVE;
	}
	inline int yyget_lexrule__(int s) const{
		return yydaccpt[s];
	}

	int yynext_lexstate__(int s, int c) const {

		int d = yydcmap[c];
		while(s < LEX_STATE_COUNT && yydchk[ yydbase[s] + d] != s) {
			s = yyddef[s];
		}

		if(s > LEX_STATE_COUNT) {
			return yydchk[yydbase[s] + yydmeta[d]] == s?
				yydnxt[ yydbase[s] + yydmeta[d]] : LEX_ERROR_STATE;
		}
		else {
			return yydnxt[ yydbase[s] + d];
		}
	}
]]></If><![[
	friend void yyemit_error__(const char *s]]><If Has?"FormalParams"><![[, ]]><Action "FormalParams"/></If><![[);
]]><If EnableParser><![[
private:
	// update 16/12/17
    int YYSTOKEN(const std::string& lexeme) const {
		if(lexeme.size() == 1) {
			return (int)lexeme[0];
		}
        auto cit = yyslexemID.find(lexeme);
        if(cit == yyslexemID.cend()) {
			return PARSE_UNDEFSYMB_ID;
		}
        return cit->second;
	}

	inline void YYACCEPT(void) {
		yyecode__ = YYE_ACCEPT;
	}
	inline void YYABORT(void) {
		yyecode__ = YYE_ABORT;
	}
	inline void yyerrok(void) {
		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;
	}

	inline bool yyparse_is_running__(int s) const {
		return yyecode__ > YYE_ACCEPT && s != PARSE_ACCEPT_STATE;
	}
	inline int yyget_defrule(int s) const {
		if(0 == yyparn[s] && is_valid_prule__(yyget_prule__(yyparv[s])) ) {
			return yyget_prule__(yyparv[s]);
		}
		return PERROR_RULE;
	}
	inline bool is_valid_pstate__(int s) const {
		return s < PARSE_ERROR_STATE;
	}
	inline bool is_valid_prule__(int r) const {
		return r >= 0 && r < PERROR_RULE;
	}
	inline int yyget_prule__(int s) const {
		return s - (PARSE_ERROR_STATE + 1);
	}
	inline void yydiscard__(xstype_t &yydval, xltype_t  &yydloc, int yydsymb]]>
		<If Has?"FormalParams"><![[, ]]><Action "FormalParams"/></If><![[) {
	]]><If Has?"DestructorActions"><![[
		switch(yydsymb) {
		]]><$UserDiscardActions "DestructorSymbols" "DestructorActions"/><![[
		default:
			break;
		}]]></If><![[
	}
	inline int yynext_pstate__(int s, int t) const {
		if(yyvbmap[s * PARSE_BMAP_ROWSIZE + t / 8] & (1 << (t % 8))) {
			if(yyparn[s] < yypcn[t]) {
				return yyparv[s];
			}
			else if(yyparn[s] > yypcn[t]) {
				return yypcv[t];
			}
			return yypact[yypabase[s] + t];
		}
		return PARSE_ERROR_STATE;
	}
	inline int yynext_goto__(int s, int t) const {
		if(yypgrn[s] < yypcn[PARSE_TYPE_BASE + t]) {
			return yypgrv[s];
		}
		else if(yypgrn[s] > yypcn[PARSE_TYPE_BASE + t]) {
			return yypcv[PARSE_TYPE_BASE + t];
		}
		return yypgoto[yypgbase[s] + t];
	}
]]></If><![[
public:

	inline ]]><$YY "parser_t"/><![[(]]>
<If EnableParser><$YY "lex_t"/><![[ plex = NULL]]></If>
<Else><![[void]]></Else><![[)
	: yyecode__(YYE_ALIVE)]]>
<If EnableScanner><![[
	, yysize__(0)
	, yystart__(INITIAL)
	, yymore_flag__(false)
	, yyat_bol__(true)
	, yytext(NULL)
	, yyleng(0)
	, yylaleng(0)]]>
</If>
<If EnableParser><![[
	, yyerr_flag__(false)
	, yyltok(PARSE_UNDEFSYMB_ID)
	, yylexer(plex)]]>
</If><![[
	, yyoutput(stdout)
	, yylogger(stderr)
	, yyerror(yyemit_error__) {

	}
	~]]><$YY "parser_t"/><![[(void) {
]]><If EnableScanner><![[
		if(yytext) {
			delete[] yytext;
		}
]]></If><![[
	}
]]><If EnableScanner><![[
	inline bool yylexinit__(const char *pchFile, bool bi) {

		YYPBUFFER pbuf = yy_new_filebuf(pchFile, bi);
		if( !pbuf ) {
			return false;
		}
		
		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(const char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_cstrbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	inline bool yylexinit__(char *strbuffer, int size) {

		YYPBUFFER pbuf = yy_new_strbuf(strbuffer, size);

		if(!pbuf) {
			return false;
		}

		yy_switch_buffer(pbuf);

		if(!yytext) {
			renew_text__();
		}
		return yy_has_buffer();
	}

	int yylex__(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[) {
		
		if( !yy_has_buffer()) {yyecode__ = YYE_EOS; return 0;}

		int yylstate__ = LEX_ERROR_STATE;
		int yylrule__ = LEX_ERROR_RULE;
		int yyaccleng__ = 0;
		int yycchar__ = END_OF_FILE;
		bool yylast_at_bol__ = yyat_bol__;
		bool bwrap__ = false;
		]]>
	<$SingleAction "LexVarDecl"/><![[
		yymore_flag__ = false;
		yyecode__ = YYE_ALIVE;
		]]>
	<$SingleAction "LexVarInit"/><![[
		yyleng = 0;
		yylaleng = 0;
		yytext[0] = '\0';

		]]>
	<$CodeBlock "LexInitAction"/><![[

		if(yyat_bol__) {
			yylstate__ = yydsc[yystart__];
		}
		else {
			yylstate__ = yydsc[yystart__ + 1];
		}

		while(yylex_is_running__()) {

			yycchar__ = yybufmgr__.get();
			yylstate__ = yynext_lexstate__(yylstate__, yycchar__);

			if(LEX_ERROR_STATE != yylstate__) {

				if(yylaleng >= yysize__ - 1) {
					renew_text__();
				}
				yytext[yylaleng] = (char)yycchar__;

				++yylaleng;

				if(yyget_lexrule__(yylstate__) != LEX_ERROR_RULE) {

					yylrule__ = yyget_lexrule__(yylstate__);
					yyaccleng__ = yylaleng;
				}
			}

			if(LEX_ERROR_STATE == yylstate__ || (yybufmgr__.isimod() 
					&& ('\n' == yycchar__ || END_OF_FILE == yycchar__))) {
				if(LEX_ERROR_RULE == yylrule__) {
					if(yylaleng == yyleng) {
						if(yycchar__ == END_OF_FILE) {
							yylrule__ = LEX_EOFRULE_BASE + yystart__ / 2;
						}
						else if(yycchar__ == END_OF_ALLFILE) {
							yylrule__ = LEX_EOAF_RULE;
						}
					}
				}
				else {
					if( LEX_ERROR_STATE == yylstate__) {
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);
					}
					yylaleng = yyaccleng__;
					yytext[yylaleng] = '\0';
				]]>
	<If Has?"LexDFALookaheads"><![[
					yyleng = yylaleng - yylad[yylrule__];
					if(yylaleng > yyleng) {
						yybufmgr__.unget(yylaleng - yyleng);
					}]]>
	</If>
	<Else><![[ yyleng = yylaleng;]]>
	</Else><![[
				}

				if(LEX_ERROR_RULE != yylrule__) {
					if(yyleng > 0) yyat_bol__ = (yytext[yyleng - 1] == '\n');]]>
	<If LexDebugMode><![[
				if(yylogger) {
					if(yylrule__ >= LEX_EOFRULE_BASE) {
						if(yylrule__ < LEX_EOAF_RULE) {
							if(yydline[yylrule__] > 0) {
								fprintf(yylogger, ".................... accept {EOF}, rule at line: %d\n", yydline[yylrule__]);
							}
							else {
								fprintf(yylogger, ".................... EOF reached\n");
							}
						}
						else {
							fprintf(yylogger, ".................... EOS reached\n");
						}
					}
					else {
						if(yyleng == 1 && ((by_te_t)yytext[0] < 32 || (by_te_t)yytext[0] >= 127)) {
							fprintf(yylogger, ".................... accept unprintable-char{%d}, rule at line: %d \n",
								 (int)((by_te_t)yytext[0]), yydline[yylrule__]);
						}
						else {
							fprintf(yylogger, ".................... accept {`%s\'}, rule at line: %d \n",
								yytext, yydline[yylrule__]);
						}
					}
				}]]>
	</If>
	<$CodeBlock "PremacthAction"/>
	<If EnableLocation>
		<If EnableColumn><![[{
				int nline = yyget_lineno();
				int ncol = yyget_colno() - 1;
				int nt = yyget_tabsize();
				int ts, yyt1__;
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {
					if(yytext[yyt1__] == '\t') {

						ts = nt - ncol % nt;
						yybufmgr__.pushtsz(ts);
						ncol += ts;
					}
					else if(yytext[yyt1__] == '\n') {
						yybufmgr__.pushlsz(ncol + 1);
						ncol = 0;
						++nline;
					}
					else {
						++ncol;
					}
				}]]><If EnableParser><![[
				]]><$YY "lloc"/><![[.firstLine = yyget_lineno();
				]]><$YY "lloc"/><![[.firstColumn = yyget_colno();
				]]><$YY "lloc"/><![[.lastLine  = nline;
				]]><$YY "lloc"/><![[.lastColumn = (ncol < 0)?0: ncol;
				]]></If><![[yyset_lineno(nline);
				yyset_colno(ncol + 1);
			}]]>
		</If>
		<Else><![[{
				int nline = yyget_lineno();
				int yyt1__;
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {
					if(yytext[yyt1__] == '\n') {
						++nline;
					}
				}]]><If EnableParser><![[
				]]><$YY "lloc"/><![[.firstLine = yyget_lineno();
				]]><$YY "lloc"/><![[.firstColumn = 0;
				]]><$YY "lloc"/><![[.lastLine  = nline;
				]]><$YY "lloc"/><![[.lastColumn = 0;
				]]></If><![[yyset_lineno(nline);
				yyset_colno(0);
			}]]>
		</Else>
	</If><![[
				}

		bwrap__ = (yylrule__ >= LEX_EOFRULE_BASE
			&& yylrule__ < LEX_EOAF_RULE
			&& yywrap__(]]><If Has?"ActualParams"><Action "ActualParams"/></If><![[));

		if(!bwrap__) {
				switch(yylrule__) {
				]]><$UserLexActions "LexRule2Actions" "LexActions"
						"LexRule2Lines" "ScriptFileName"/><![[

				case LEX_EOAF_RULE: 
					yy_delete_buffer();
					yyecode__ = YYE_EOS;
					break;
				default:
					if(yyleng > 0)
						yyat_bol__ = (yytext[yyleng - 1] == '\n');
			]]><If EnableDefaultAction><![[
				/* do nothing */]]></If>
			<Else><![[
					YYMSG_UNMATCHED[28] = yycchar__;
					yyecode__ = YYE_UNMATCHED;
					if(yyerror)
						yyerror(YYMSG_UNMATCHED]]><If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
				]]></Else><![[
				break;
				}
			}
				if(yylex_is_running__()) {

					yylast_at_bol__ = yyat_bol__;

					if(yyat_bol__) {
						yylstate__ = yydsc[yystart__];
					}
					else {
						yylstate__ = yydsc[yystart__ + 1];
					}

					yylrule__ = LEX_ERROR_RULE;

					if( ! yymore_flag__) {
						yyaccleng__ = 0;
						yylaleng = 0;
						yyleng = 0;
						yytext[yylaleng] = '\0';
					}
					else {
						yymore_flag__ = false;
					}
				}
			}
		}

		return (yyecode__ == YYE_EOS)? 0 : yyecode__;
	}
]]></If><If EnableParser><![[
	int yyparse__(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[) {

		if( ! yylexer) {
			return YYE_ABORT;
		}

		yyecode__ = YYE_ALIVE;
		sstack_t<xstype_t> yys_sv__;
		xstype_t yyval;
]]><If EnableLocation><![[
		sstack_t<xltype_t> yys_loc__;
]]></If><![[
		xltype_t yyloc;
		sstack_t<int> yys_stt__;
		sstack_t<int> yys_symb__;

		int yyrplen__;
		bool yyreducing__;

		int yypstate__ = PARSE_START_STATE;
		int yyprule__ = PERROR_RULE;
		int yysidx__ = PARSE_UNDEFSYMB_INDEX;
		int yytok__ = PARSE_UNDEFSYMB_ID;
		]]><$SingleAction "ParseVarDecl"/><![[

		yyltok = PARSE_UNDEFSYMB_ID;
		yyerr_flag__ = false;
]]><$SingleAction "ParseVarInit"/><![[
]]><$CodeBlock "ParseInitAction"/><![[
		yys_stt__.push(yypstate__);

		while( ! yys_stt__.empty() && yyparse_is_running__(yypstate__)) {
			yyprule__ = yyget_defrule(yypstate__);
			if(is_valid_prule__(yyprule__)) {
				yyreducing__ = true;
			}
			else {
				if(PARSE_UNDEFSYMB_ID == yytok__) {
					if(PARSE_UNDEFSYMB_ID == yyltok) {
						yytok__ = (yylexer)(]]><If Has?"ActualParams"><Action "ActualParams"/></If><![[);
					}
					else  {
						yytok__ = yyltok;
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yysidx__ = (yytok__ < 0 || yytok__ >= PARSE_TOKENMAP_SIZE) ? PARSE_UNDEFSYMB_INDEX
						: yyptmap[yytok__];
				}

]]><If ParseDebugMode><![[
if(yylogger)
	fprintf(yylogger, "Next symbol is %s\n", sym_text__(yypsnam[yysidx__]));
]]></If><![[
				yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);

				if(is_valid_pstate__(yypstate__)) {

]]><If ParseDebugMode><![[
if(yylogger)
	fprintf(yylogger, "Shift %s, go to state %d\n", sym_text__(yypsnam[yysidx__]), yypstate__);
]]></If><![[
					yys_symb__.push(yysidx__);
					yys_stt__.push(yypstate__);
					yys_sv__.push(]]><$YY "lval"/><![[);
]]><If EnableLocation><![[
					yys_loc__.push(]]><$YY "lloc"/><![[);
]]></If><![[ 
					yytok__ = PARSE_UNDEFSYMB_ID;
					yyreducing__ = false;
				}
				else {
					yyprule__ = yyget_prule__(yypstate__);
					yyreducing__ = true;
				}
			}

			if(yyreducing__) {
				switch(yyprule__) {
				]]><$UserParseActions "PraseRule2Actions" "ParseActions"
						"ParseRule2Lines" "ScriptFileName"/><![[
				default:

					if( ! yyerr_flag__ || PARSE_ENDSYMB_ID == yytok__) {
						if(! yyerr_flag__) {
							if(yyerror) {
]]><If EnableLocation><![[
char yycc[MAX_MSG_LENG];
sprintf(yycc, "Error: syntax error at %d:%d.", ]]>
	<$YY "lloc"/><![[.firstLine, ]]>
	<$YY "lloc"/><![[.firstColumn);
yyerror(yycc]]><If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></If><Else><![[
yyerror("Error: syntax error."]]><If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></Else><![[				}

							yyecode__ = YYE_PERROR;
						}
						else {
							yyecode__ = YYE_NOINPUT;
						}
						
						yyerr_flag__ = true;
						yyltok = yytok__;
					}
					else {
					]]><If ParseDebugMode><![[
if(yylogger)
	fprintf(yylogger, "Error recovery : discard current token %s\n",
	sym_text__(yypsnam[yysidx__]));
]]></If><![[
						yyltok = PARSE_UNDEFSYMB_ID;
					}
					yytok__ = PARSE_ERRORSYMB_ID;
					yysidx__ = PARSE_ERRORSYMB_INDEX;

					while(! yys_sv__.empty())  {
						yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);
						if(is_valid_pstate__(yypstate__)) {
							break;
						}
			]]><If ParseDebugMode><![[
if(yylogger) {
	fprintf(yylogger, "Error recovery : Pop up %s from stack\n",
	sym_text__(yypsnam[yys_symb__.top()]));
	fprintf(yylogger, "Now state stack: ");			
	for(int yyt1__ = yyerr_flag__? 1 : 0; yyt1__ < yys_stt__.count(); ++yyt1__) {
		fprintf(yylogger, "%5d", yys_stt__[yyt1__]);
	}
	fprintf(yylogger, "\n");
	}]]></If><![[
]]><If EnableLocation><![[
						yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top()]]>
							<If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
						yys_loc__.pop(1);
]]></If><Else><![[
						yydiscard__(yys_sv__.top(), ]]><$YY "lloc"/><![[, yys_symb__.top()]]>
							<If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></Else><![[

						yys_symb__.pop(1);
						yys_sv__.pop(1);
						yys_stt__.pop(1);
					}

					if( yys_sv__.empty()) {
						yys_stt__.pop(1);
					}

					break;
				}

				if(is_valid_prule__(yyprule__) || YYE_ACCEPT == yyecode__) {
					yyrplen__ = yyprnum[yyprule__];
					yypstate__ = yynext_goto__(yys_stt__[yyrplen__], yyplid[yyprule__]);
]]><If ParseDebugMode><![[
if(yylogger){
	fprintf(yylogger, "Reduce action: ");
	for(int yyt2__ = yyrplen__ - 1; yyt2__ >= 0; --yyt2__) {
	int yyt1__ = yys_symb__[yyt2__];
		fprintf(yylogger, "%s ", sym_text__(yypsnam[yyt1__]));
	}
	fprintf(yylogger, "=> %s, go to state %d by rule at %d.\n",
	yypsnam[yyplid[yyprule__] + PARSE_TYPE_BASE], yypstate__, yypline[yyprule__]);
}]]></If><![[

					if(YYE_ACCEPT != yyecode__) {
						yys_stt__.pop(yyrplen__);
						yys_symb__.pop(yyrplen__);
						yys_sv__.pop(yyrplen__);
]]><If EnableLocation><![[
						if(!yys_loc__.empty()) {
							if(yyrplen__ == 0) {
								yyloc.firstLine = yyloc.lastLine = yys_loc__[0].lastLine;
								yyloc.firstColumn = yyloc.lastColumn = yys_loc__[0].lastColumn;
							}
							else {
								yyloc.firstLine = yys_loc__[yyrplen__ - 1].firstLine;
								yyloc.lastLine = yys_loc__[0].lastLine;
								yyloc.firstColumn = yys_loc__[yyrplen__ - 1].firstColumn;
								yyloc.lastColumn = yys_loc__[0].lastColumn;
							}
						}
						yys_loc__.pop(yyrplen__);
						yys_loc__.push(yyloc);
]]></If><![[
						yys_stt__.push(yypstate__);
						yys_symb__.push(yyplid[yyprule__] + PARSE_TYPE_BASE);
						yys_sv__.push(yyval);
					}
				}
			}
		}

		while( ! yys_sv__.empty()) {
]]><If ParseDebugMode><![[
if(yylogger)
	fprintf(yylogger, "Clearup : Pop up %s from stack\n", sym_text__(yypsnam[yys_symb__.top()]));
]]></If>
<If EnableLocation><![[
			yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top()]]>
				<If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></If><Else><![[
			yydiscard__(yys_sv__.top(), ]]><$YY "lloc"/><![[, yys_symb__.top()]]>
				<If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></Else><![[
			yys_sv__.pop(1);
			yys_symb__.pop(1);
		}

		if(YYE_ACCEPT == yyecode__) {

]]><If EnableLocation><![[
			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE]]>
				<If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></If><Else><![[
			yydiscard__(yyval, ]]><$YY "lloc"/><![[, yyplid[yyprule__] + PARSE_TYPE_BASE]]>
				<If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]></Else><![[
		}
]]><$CodeBlock "ParseExitAction"/><![[
		return (yyecode__ == YYE_EOS || yyecode__ == YYE_ACCEPT )? 0: yyecode__;
	}
]]></If><![[
public:
	inline void yyclearall__(void) {
		yyecode__ = YYE_ALIVE;]]>
<If EnableScanner><![[
		yystart__ = INITIAL;		
		yymore_flag__ = false;
		yyat_bol__ = true;
		
		yyleng = 0;
		yylaleng = 0;
		if(yytext) {
			yytext[0] = '\0';
		}
		yybufmgr__.destroyall();
]]></If>
<If EnableParser><![[
		yyerr_flag__ = false;
		yyltok = PARSE_UNDEFSYMB_ID;
]]></If><![[
	}

private:
]]><If EnableScanner><![[
	// user interfaces
	// easy way to print matched string
	inline void YYECHO(void) const {
		ECHO();
	}
	inline void ECHO(void) const {
		if(yyoutput)
			fprintf(yyoutput, "%s", yytext);
	}

	// start-condition operations
	// switch start-condition
	inline void YYBEGIN(int sc) {
		BEGIN(sc);
	}
	inline void BEGIN(int sc) {
		yystart__ = sc;
	}
	// return current start-condition
	inline int YYSTART(void) const {
		return yystart__;
	}
	// save current start-condition and switch to new start-condition
	inline void yy_push_state(int nsc) {
		yyscstk__.push(yystart__);
		yystart__ = nsc;
	}
	// switch to last saved start-condition
	inline bool yy_pop_state(void) {

		if(yyscstk__.empty()) {
			return false;
		}
		yystart__ = yyscstk__.top();
		yyscstk__.pop(1);
		return true;
	}
	// return last saved start-condition
	inline int yy_top_state(void) {

		if(yyscstk__.empty()) {
			return INITIAL;
		}
		return yyscstk__.top();
	}

	// get/set flag of beginning-of-line
	inline bool yy_get_bol(void) const {
		return yyat_bol__;
	}
	inline void yy_set_bol(bool b) {
		yyat_bol__ = b;
	}

	// buffer operations
	inline YYPBUFFER yy_current_buffer(void) const {
		return yybufmgr__.current();
	}
	// 
	inline bool yy_has_buffer(void) const {
		return ! yybufmgr__.empty();
	}
	inline void yy_push_buffer(YYPBUFFER pbuffer) {
		yybufmgr__.switchto(pbuffer);
	}
	inline YYPBUFFER yy_pop_buffer(void) {
		return yybufmgr__.pop();
	}
	inline YYPBUFFER yy_new_filebuf(const char *strfile, bool bi = false) {
		if( !strfile ) {
			return yybufmgr__.newbuf(stdin, bi);
		}

	 	FILE *pfile = fopen(strfile, "r");
	 	if( !pfile) return NULL;
		return yybufmgr__.newbuf(pfile);
	}

	inline YYPBUFFER yy_new_cstrbuf(const char *cstrbuffer, int size) {
		if( ! cstrbuffer || size < 1) {
			return NULL;
		}
		return yybufmgr__.newbuf(cstrbuffer, size);
	}
	inline YYPBUFFER yy_new_strbuf(char *strbuffer, int size) {
		if( ! strbuffer || size < 1) {
			return NULL;
		}
		return yybufmgr__.newbuf(strbuffer, size);
	}
	inline void yy_delete_buffer(void) {
		yybufmgr__.destroytop();
	}
	inline void yy_switch_buffer(YYPBUFFER buf) {
		yybufmgr__.switchto(buf);
	}
	inline void yyrestart(void) {

		yystart__ = INITIAL;
		yyecode__ = YYE_ALIVE;
		yymore_flag__ = false;
		
		yyleng = 0;
		yylaleng = 0;
		if( yytext ) {
			yytext[0] = '\0';
		}

		yyscstk__.clear();
		yybufmgr__.reset();
	}

	inline void yymore(void) {

		yymore_flag__ = true;
		yylaleng = yyleng;
	}
	inline int yyless(int n) {

		if(n > 0 && n < yyleng) {

			yytext[n] = '\0';
			n = yyleng - n;
			yyleng -= n;
			yylaleng = yyleng;
			return yybufmgr__.unget(n);
		}
		yylaleng = yyleng;
		yytext[yylaleng] = '\0';

		return 0;
	}

	inline int yyinput(void) {

		int c = yybufmgr__.get();]]>
	<If EnableLocation>
		<If EnableColumn><![[
		if(c < END_OF_FILE) {
			if(c == '\t') {
				int nt = yyget_tabsize();
				nt -= (yyget_colno() + nt - 1) % nt;
				yybufmgr__.pushtsz(nt);
				yyadd_colno(nt);
			}
			else if(c == '\n') {
				yybufmgr__.pushlsz(yyget_colno());
				yyset_colno(1);
				yyadd_lineno(1);
			}
			else {
				yyadd_colno(1);
			}
		}]]>
		</If>
	</If><![[	
		return c;
	}
	inline bool yyunput(char c) {
		int oldc = yybufmgr__.put(c);]]>
	<If EnableLocation>
		<If EnableColumn><![[
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}]]>
		</If>
	</If><![[		
		return oldc < END_OF_FILE;
	}
	inline bool yyunget(void) {
		int oldc = yybufmgr__.unget();]]>
	<If EnableLocation>
		<If EnableColumn><![[
		if(oldc < END_OF_FILE) {
			int s;
			if(oldc == '\t') {
				s = yybufmgr__.poptsz();
				yyadd_colno((s == 0)? -1: -s);
			}
			else if(oldc == '\n') {
				s = yybufmgr__.poplsz();
				yyset_colno(s);
				yyadd_lineno(-1);
			}
			else {
				yyadd_colno(-1);
			}
		}]]>
		</If>
	</If><![[		
		return oldc < END_OF_FILE;		
	}
	inline void yyterminate(void) {
		yyecode__ = YYE_TERM;
	}
	inline void yyadd_lineno(int nline) {
		yybufmgr__.setlineno(yybufmgr__.getlineno() + nline);
	}
	inline void yyadd_colno(int ncol) {
		yybufmgr__.setcolno(yybufmgr__.getcolno() + ncol);
	}
	inline int yyget_lineno(void) const {
		return yybufmgr__.getlineno();
	}
	inline void yyset_lineno(int nline) {
		yybufmgr__.setlineno(nline);
	}
	inline int yyget_colno(void) const {
		return yybufmgr__.getcolno();
	}
	inline void yyset_colno(int ncol) {
		yybufmgr__.setcolno(ncol);
	}
	inline int yyget_tabsize(void) const {
		return yybufmgr__.gettabsize();
	}
	inline void yyset_tabsize(int ntab) {
		yybufmgr__.settabsize(ntab);
	}
	bool yywrap__(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[) {
		]]><If Has?"EOAFAction"><![[
		// line: ]]><ActLine "EOAFAction"/><![[
		]]><Action "EOAFAction"/></If>
		<Else><![[
			return false;]]></Else><![[
	}
]]></If><![[

private:

	int yyecode__;
]]><If EnableScanner><![[

	// buffer manager
	bufmgr_t yybufmgr__;
	// start-condition stack
    sstack_t<int, 32> yyscstk__;
	int yysize__;
	int yystart__;

	bool yymore_flag__;
	bool yyat_bol__;

	char *yytext;
	int yyleng;
	int yylaleng;

	]]></If><If EnableParser><![[
	bool yyerr_flag__;
	int yyltok;
	]]><$YY "lex_t"/><![[ yylexer;
]]></If><![[
	FILE* yyoutput;
	FILE* yylogger;
	]]><$YY "error_t"/><![[ yyerror;
	
private:
	
]]><If EnableScanner><![[
///////////////////////////////////////////////////////////////////////////
	// lexical tables
	// start states of DFAs
	static const int yydsc[]]><Size "LexStartStates"/><![[];

	// @yydcmap is a char map: char -> transition-label,
	// that is, chars are grouped, transition label is
	// representation of equivalent class of chars
	static const int yydcmap[]]><Size "LexCharMap"/><![[];

	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,
	// that is, transition-label in @yydcmap are further grouped in order to save space
	static const int yydmeta[]]><Size "LexMetaChars"/><![[];

	// use next-check-base-default scheme to store DFAs
	// 
	static const int yydbase[]]><Size "LexDFABases"/><![[];
	static const int yyddef[]]><Size "LexDFADefaults"/><![[];
	// next table is an indeed transition table
	static const int yydnxt[]]><Size "LexDFANexts"/><![[];
	static const int yydchk[]]><Size "LexDFAChecks"/><![[];
	static const int yydaccpt[]]><Size "LexDFAAccepts"/><![[];
	
	static char YYMSG_UNMATCHED[];
]]></If><If EnableParser><![[
///////////////////////////////////////////////////////////////////////////////
	// LALR parse tables
	// token map: token ID --> token index in token ID table
	// in fact, it acts like inverse table of token ID table
	static const int yyptmap[]]><Size "ParseTokenMap"/><![[];
	// token ID table, which contains token IDs
	//static const int yyptid[]]><Size "ParseTokenID"/><![[];
	// number of symbols in a grammar rule
	static const int yyprnum[]]><Size "ParseRPNum"/><![[];
	// index of left symbol in a grammar rule
	static const int yyplid[]]><Size "ParseLPID"/><![[];
	// parse action table
	static const int yypact[]]><Size "ParseActEntries"/><![[];

	// base array for parse action table
	// which is used to determine the base location of the entries
	// for each state stored in the yypack table
	static const int yypabase[]]><Size "PActionBases"/><![[];
	static const int yypgoto[]]><Size "ParseGotos"/><![[];
	static const int yypgbase[]]><Size "PGotoBases"/><![[];

	// check table for parse action table
	static const by_te_t yyvbmap[]]><Size "ParseValidBMap"/><![[];
	static const int yyparv[]]><Size "ParseActRowVal"/><![[];
	static const int yyparn[]]><Size "ParseActRowNice"/><![[];

	static const int yypcv[]]><Size "ParseColVal"/><![[];
	static const int yypcn[]]><Size "ParseColNice"/><![[];
	static const int yypgrv[]]><Size "ParseGotoRowVal"/><![[];
	static const int yypgrn[]]><Size "ParseGotoRowNice"/><![[];
	static const std::unordered_map<std::string, int> yyslexemID;
]]></If><![[
///////////////////////////////////////////////////////////////////////////////////
	// optional tables, they are available only under certain conditions
]]><If EnableScanner><![[
	// lookahead distant table, only available when there are some lookahead patterns
	// each pattern has its entry of the table
	]]><If Has?"LexDFALookaheads"><![[
	static const int yylad[]]><Size "LexDFALookaheads"/><![[];]]></If>
	<If LexDebugMode><![[
	static const char* yydscnam[]]><Size "LexStartLabels"/><![[];
	static const int yydline[]]><Size "LexRule2Lines"/><![[];]]></If>
</If><If EnableParser><If ParseDebugMode><![[
	static const char* yypsnam[]]><Size "ParseSymName"/><![[];
	static const int yyprpbase[]]><Size "ParseRPBases"/><![[];
	static const int yyprpidx[]]><Size "ParseRPIndexes"/><![[];
	static const int yypline[]]><Size "ParseRule2Lines"/><![[];]]></If><![[
]]></If><![[
};

]]><If EnableScanner><![[
char ]]><$YY "parser_t"/><![[::YYMSG_UNMATCHED[] = "Error: unmatched character ` \'.";

const int ]]><$YY "parser_t"/><![[::yydsc[]]><Size "LexStartStates"/><![[] = {
]]>
<$IntArray "LexStartStates"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yydcmap[]]><Size "LexCharMap"/><![[] = {
]]>
<$IntArray "LexCharMap"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yydmeta[]]><Size "LexMetaChars"/><![[] = {
]]>
<$IntArray "LexMetaChars"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yydbase[]]><Size "LexDFABases"/><![[] = {
]]>
<$IntArray "LexDFABases"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yyddef[]]><Size "LexDFADefaults"/><![[] = {
]]>
<$IntArray "LexDFADefaults"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yydnxt[]]><Size "LexDFANexts"/><![[] = {
]]>
<$IntArray "LexDFANexts"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yydchk[]]><Size "LexDFAChecks"/><![[] = {
]]>
<$IntArray "LexDFAChecks"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yydaccpt[]]><Size "LexDFAAccepts"/><![[] = {
]]>
<$IntArray "LexDFAAccepts"/>
<![[
};
]]></If><If EnableParser><![[
// token map: token ID --> token index in token ID table
// in fact, it acts like inverse table of token ID table
const int ]]><$YY "parser_t"/><![[::yyptmap[]]><Size "ParseTokenMap"/><![[] = {
]]>
<$IntArray "ParseTokenMap"/>
<![[
};
/*
// token ID table, containing token IDs
const int ]]><$YY "parser_t"/><![[::yyptid[]]><Size "ParseTokenID"/><![[] = {
]]>
<$IntArray "ParseTokenID"/>
<![[
};
*/
// prnum table, its element is number of symbols in right part of corresponding grammar rule
const int ]]><$YY "parser_t"/><![[::yyprnum[]]><Size "ParseRPNum"/><![[] = {
]]>
<$IntArray "ParseRPNum"/>
<![[
};

// plid table, its element is the index of left part of corresponding grammar rule in token ID table
const int ]]><$YY "parser_t"/><![[::yyplid[]]><Size "ParseLPID"/><![[] = {
]]>
<$IntArray "ParseLPID"/>
<![[
};

// parse action table
const int ]]><$YY "parser_t"/><![[::yypact[]]><Size "ParseActEntries"/><![[] = {
]]>
<$IntArray "ParseActEntries"/>
<![[
};

// base array for parse action table
// which is used to determine the base location of the entries
// for each state stored in the yypack table
const int ]]><$YY "parser_t"/><![[::yypabase[]]><Size "PActionBases"/><![[] = {
]]>
<$IntArray "PActionBases"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yypgoto[]]><Size "ParseGotos"/><![[] = {
]]>
<$IntArray "ParseGotos"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yypgbase[]]><Size "PGotoBases"/><![[] = {
]]>
<$IntArray "PGotoBases"/>
<![[
};

const by_te_t ]]><$YY "parser_t"/><![[::yyvbmap[]]><Size "ParseValidBMap"/><![[] = {
]]>
<$IntArray "ParseValidBMap"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yyparv[]]><Size "ParseActRowVal"/><![[] = {
]]>
<$IntArray "ParseActRowVal"/>
<![[
};


const int ]]><$YY "parser_t"/><![[::yyparn[]]><Size "ParseActRowNice"/><![[] = {
]]>
<$IntArray "ParseActRowNice"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yypcv[]]><Size "ParseColVal"/><![[] = {
]]>
<$IntArray "ParseColVal"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yypcn[]]><Size "ParseColNice"/><![[] = {
]]>
<$IntArray "ParseColNice"/>
<![[
};


const int ]]><$YY "parser_t"/><![[::yypgrv[]]><Size "ParseGotoRowVal"/><![[] = {
]]>
<$IntArray "ParseGotoRowVal"/>
<![[
};

const int ]]><$YY "parser_t"/><![[::yypgrn[]]><Size "ParseGotoRowNice"/><![[] = {
]]>
<$IntArray "ParseGotoRowNice"/>
<![[
};

const std::unordered_map<std::string, int> ]]><$YY "parser_t"/><![[::yyslexemID{
]]>
<$StrIntMapDefine "ParseStrTokenNames" "ParseStrTokenValues"/>
<![[
};
]]></If>
<If EnableScanner>
<If Has?"LexDFALookaheads"><![[
const int ]]><$YY "parser_t"/><![[::yylad[]]><Size "LexDFALookaheads"/><![[] = {
]]><$IntArray "LexDFALookaheads"/><![[
};]]></If>

<If LexDebugMode><![[
const char* ]]><$YY "parser_t"/><![[::yydscnam[]]><Size "LexStartLabels"/><![[] = {
]]><$QStrArray "LexStartLabels"/><![[
};

const int ]]><$YY "parser_t"/><![[::yydline[]]><Size "LexRule2Lines"/><![[] = {
]]><$IntArray "LexRule2Lines"/><![[
};]]></If></If>
<If EnableParser>
<If ParseDebugMode><![[
const char* ]]><$YY "parser_t"/><![[::yypsnam[]]><Size "ParseSymName"/><![[] = {
]]><$QStrArray "ParseSymName"/><![[
};

const int ]]><$YY "parser_t"/><![[::yyprpbase[]]><Size "ParseRPBases"/><![[] = {
]]><$IntArray "ParseRPBases"/><![[
};

const int ]]><$YY "parser_t"/><![[::yyprpidx[]]><Size "ParseRPIndexes"/><![[] = {
]]><$IntArray "ParseRPIndexes"/><![[
};

const int ]]><$YY "parser_t"/><![[::yypline[]]><Size "ParseRule2Lines"/><![[] = {
]]><$IntArray "ParseRule2Lines"/><![[
};]]></If></If>

<![[

// get global parser object,
// it's invisiable to user
static ]]><$YY "parser_t"/><![[& getTheParser(void) {

	static ]]><$YY "parser_t"/><![[ yyp]]>
		<If EnableParser><If EnableScanner><![[(]]><$YY "lex"/><![[)]]></If></If>
	<![[;
	return yyp;
}

// assign new log stream
void ]]><$YY "setstream"/><![[(FILE *poutput, FILE *plogger) {

	]]><$YY "parser_t"/><![[& yyp = getTheParser();
	yyp.yyoutput = poutput;
	yyp.yylogger = plogger;
}

void yyemit_error__(const char *s]]><If Has?"FormalParams"><![[, ]]><Action "FormalParams"/></If><![[) {
	]]><$YY "parser_t"/><![[& yyp = getTheParser();
	if(yyp.yylogger) 
		fprintf(yyp.yylogger, "%s\n", s);
}

// assign new error-reporter and return the old one
]]><$YY "error_t"/><![[ ]]><$YY "seterror"/><![[(]]><$YY "error_t"/><![[ perror) {

	]]><$YY "parser_t"/><![[& yyp = getTheParser();
	]]><$YY "error_t"/><![[ pold = yyp.yyerror;
	yyp.yyerror = perror;

	return pold;
}

// reset all (both scanner and parser, if they are available)
void ]]><$YY "clearall"/><![[(void) {
	getTheParser().yyclearall__();
}
]]>
<If EnableScanner><![[

// initializing file buffer before parsing or patter-matching
int ]]><$YY "lexfile"/><![[(const char* pchFile, bool iMod) {
	
	return getTheParser().yylexinit__(pchFile, iMod)? 0: -1;
}
// initializing string buffer before parsing or patter-matching
int ]]><$YY "lexstr"/><![[(char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}
// initializing const string buffer before parsing or patter-matching
int ]]><$YY "lexcstr"/><![[(const char *strbuffer, int size) {
	return getTheParser().yylexinit__(strbuffer, size)? 0: -1;
}

// generated scanner, can be replaced
int ]]><$YY "lex"/><![[(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[) {

	return getTheParser().yylex__(]]><If Has?"ActualParams"><Action "ActualParams"/></If><![[);
} 
]]></If>

<If EnableParser><![[
// assign new scanner and return the old one 
]]><$YY "lex_t"/><![[ ]]><$YY "setlex"/><![[(]]><$YY "lex_t"/><![[ plex) {
	
	]]><$YY "parser_t"/><![[& yyp = getTheParser();
	]]><$YY "lex_t"/><![[ pold = yyp.yylexer;
	yyp.yylexer = plex;

	return pold;
}

// generated parser, it should not be replaced
int ]]><$YY "parse"/><![[(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[) {
	return getTheParser().yyparse__(]]><If Has?"ActualParams"><Action "ActualParams"/></If><![[);
}]]></If>
<![[
} // namspace
]]>
<$SingleAction "UserCode"/><![[

]]>
</Program>
