/*
    Upgen -- a scanner and parser generator.
    Copyright (C) 2016  Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "./spec.h"

namespace spec_ns {

char sn_cppSpec[CPP_SPEC_SIZE] = "<\?Setup DefinitionExtName=\".cpp\" DeclarationExtName=\".h\"/><Macros>\n\
	<Macro \"$FreeToUse\">\n\
<![[/*******************************************************************************\n\
A parser program in C++, generated by ]]>\n\
<String #0/><![[ ]]><String #1/><![[.\n\
******************************************************************************/\n\
]]></Macro>\n\
\n\
	<Macro \"$YY\">\n\
	<Scalar \"Prefix\"/><Text #0/>\n\
	</Macro>\n\
\n\
	<Macro \"$ActionLine\">\n\
	<Case EnableLineNo><![[\n\
#line ]]><ActLine #0/><![[ \"]]><Scalar \"ScriptFileName\"/><![[\"\n\
]]></Case>\n\
	</Macro>\n\
\n\
	<Macro \"$HeaderLine\">\n\
	<Case EnableLineNo><![[\n\
#line ]]><SrcLine/><![[ \"]]><Scalar \"DeclareFileName\"/><![[\"\n\
]]></Case>\n\
	</Macro>\n\
	\n\
	<Macro \"$DeclareAction\">\n\
	<Case Has><$ActionLine #0/><Action #0/><$HeaderLine/></Case>\n\
	</Macro>\n\
	\n\
	<Macro \"$SourceLine\">\n\
	<Case EnableLineNo><![[\n\
#line ]]><SrcLine/><![[ \"]]><Scalar \"DefineFileName\"/><![[\"\n\
]]></Case>\n\
	</Macro>\n\
\n\
\n\
	<Macro \"$SingleAction\">\n\
	<Case Has><$ActionLine #0/><Action #0/><$SourceLine/></Case>\n\
	</Macro>\n\
	\n\
	<Macro \"$CodeBlock\">\n\
	<Case Has><![[{\n\
	]]><$ActionLine #0/><Action #0/><$SourceLine/>\n\
	<![[\n\
	}\n\
]]></Case>\n\
	</Macro>\n\
\n\
	<Macro \"$UserLexActions\">\n\
<Case End><GoFirst/></Case>\n\
<Case GroupFlag><![[{\n\
	]]><$SingleAction #1/><Skip #0/><![[\n\
	}\n\
	break;\n\
	]]><$UserLexActions/></Case>\n\
<Default><![[\n\
case ]]><Integer #0/><![[:\n\
]]><$UserLexActions/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$UserParseActions\">\n\
<Case End><GoFirst/></Case>\n\
<Case GroupFlag><![[{]]><$SingleAction #1/><Skip #0/><![[\n\
	}\n\
	break;\n\
	]]><$UserParseActions/></Case>\n\
<Default><![[\n\
	case ]]><Integer #0/><![[:\n\
	]]><$UserParseActions/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$UserDiscardActions\">\n\
<Case End><GoFirst/></Case>\n\
<Case GroupFlag><![[{]]><$SingleAction #1/><Skip #0/><![[\n\
	}\n\
	break;\n\
	]]><$UserDiscardActions/></Case>\n\
<Default><![[\n\
case ]]><Integer #0/><![[:]]><$UserDiscardActions/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$IntArray\">\n\
<Case Last><Integer #0/><GoFirst/></Case>\n\
<Case Mod\?8><Integer #0/><![[,\n\
	]]><$IntArray/></Case>\n\
<Default><Integer #0/><![[,	]]><$IntArray/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$QStrArray\">\n\
<Case Last><![[\"]]><String #0/><![[\"]]><GoFirst/></Case>\n\
<Case Mod\?8><![[\"]]><String #0/><![[\",\n\
	]]><$QStrArray/></Case>\n\
<Default><![[\"]]><String #0/><![[\",	]]><$QStrArray/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$ConstsDefine\">\n\
<Case End><GoFirst/></Case>\n\
<Default><![[#define ]]><String #0/><![[ ]]><Integer #1/><![[\n\
]]><$ConstsDefine/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$SVNAME_LEFT\"><![[(yyval.]]><Text #0/><![[)]]></Macro>\n\
	<Macro \"$SVNAME_RIGHT\"><![[(yys_sv__[]]><Text #0/><![[].]]><Text #1/><![[)]]></Macro>\n\
	<Macro \"$SVLOC_LEFT\"><![[(yyloc)]]></Macro>\n\
	<Macro \"$SVLOC_RIGHT\"><![[(yys_loc__[]]><Text #0/><![[])]]></Macro>\n\
	<Macro \"$SVNAME_DSTRCT\"><![[(yydval.]]><Text #0/><![[)]]></Macro>\n\
	<Macro \"$SVLOC_DSTRCT\"><![[(yydloc)]]></Macro>\n\
\n\
	<Macro \"$TypeName\">\n\
		<Case Has><Action #0/></Case>\n\
		<Default><Scalar \"Prefix\"/><Text #1/></Default>\n\
	</Macro>\n\
</Macros>\n\
\n\
<Program>\n\
\n\
<Declare/>\n\
<$FreeToUse \"SoftwareName\" \"SoftwareVersion\"/>\n\
\n\
<Define/>\n\
<$FreeToUse \"SoftwareName\" \"SoftwareVersion\"/>\n\
<![[\n\
#include <stdio.h>\n\
#include <stdlib.h>\n\
#include <errno.h>\n\
#include <string.h>\n\
#include <sys/stat.h>\n\
typedef unsigned char by_te_t;\n\
]]>\n\
<If EnableScanner><![[\n\
class bufbase_t;\n\
typedef bufbase_t *YYPBUFFER;\n\
]]></If>\n\
<If EnableDeclare><![[\n\
#include \"./]]><String \"DeclareFileName\"/><![[\"\n\
]]>\n\
<Declare/>\n\
<![[\n\
#ifndef CLASS_]]><$YY \"PARSE_T_FILE_\"/><String \"FileBaseName\"/><![[_H__\n\
#define CLASS_]]><$YY \"PARSE_T_FILE_\"/><String \"FileBaseName\"/><![[_H__\n\
]]>\n\
<$DeclareAction \"DeclareHeader\"/>\n\
</If>\n\
<Else>\n\
<$DeclareAction \"DeclareHeader\"/>\n\
</Else>\n\
\n\
<If EnableParser><![[\n\
// token ID definition\n\
]]><$ConstsDefine \"ParseTokenNames\" \"ParseTokenValues\"/></If>\n\
\n\
<Define/>\n\
<$SingleAction \"DefineHeader\"/>\n\
<If EnableScanner>\n\
<![[\n\
#define	INC_YYTEXT_SIZE		4096\n\
#define LINESIZE_STACK_LENG	32\n\
#define TABSIZE_STACK_LENG	64\n\
#define END_OF_FILE			256\n\
#define END_OF_ALLFILE		257\n\
\n\
// start-condition names\n\
]]><$ConstsDefine \"LexStartLabels\" \"LexStartIndexes\"/><![[\n\
// number of DFA states of scanner\n\
#define LEX_STATE_COUNT   ]]><Integer \"LexDefaultState\"/>\n\
<![[\n\
\n\
// DFA trap-state of scanner\n\
#define LEX_ERROR_STATE    ]]><Integer \"LexErrorState\"/>\n\
<![[\n\
\n\
// ID of invalid rule for scanner,\n\
// indicating current string can not be matched by any pattern\n\
#define LEX_ERROR_RULE    ]]><Integer \"LexErrorRule\"/>\n\
<![[\n\
\n\
// this constant used by computing index of a rule that matches EOF\n\
// for example, in start-condition INITIAL, index of the rule that\n\
// matches EOF is \n\
//	LEX_EOFRULE_BASE + INITIAL\n\
#define LEX_EOFRULE_BASE   ]]><Integer \"LexEOFRuleBase\"/>\n\
<![[\n\
\n\
// index of the rule that matches EOAF (end of all files, or end of input)\n\
#define LEX_EOAF_RULE   ]]><Integer \"LexEOFARuleIndex\"/><![[\n\
\n\
]]>\n\
</If>\n\
<![[\n\
// index of symbol `$end\' in symbol table\n\
#define PARSE_ENDSYMB_INDEX   ]]><Integer \"ParseEndSymbIdx\"/>\n\
<![[\n\
// index of symbol `error\' in symbol table\n\
#define PARSE_ERRORSYMB_INDEX   ]]><Integer \"ParseErrorSymbIdx\"/>\n\
<![[\n\
// index of symbol `$undef\' in symbol table\n\
#define PARSE_UNDEFSYMB_INDEX   ]]><Integer \"ParseUndefSymbIdx\"/>\n\
<![[\n\
\n\
// ID of symbol `$end\'\n\
#define PARSE_ENDSYMB_ID   ]]><Integer \"ParseEndSymbID\"/>\n\
<![[\n\
// ID of symbol `error\'\n\
#define PARSE_ERRORSYMB_ID   ]]><Integer \"ParseErrorSymbID\"/>\n\
<![[\n\
// ID of symbol \'$undef\'\n\
#define PARSE_UNDEFSYMB_ID   ]]><Integer \"ParseUndefSymbID\"/><![[\n\
]]>\n\
\n\
<If EnableParser>\n\
<![[\n\
// row size(in byte) of non-error bitmap of parse table\n\
#define PARSE_BMAP_ROWSIZE	]]><Integer \"ParseBMapRowSize\"/>\n\
<![[\n\
// base address of indexes of types (aka non-terminals or variables)\n\
#define PARSE_TYPE_BASE   ]]><Integer \"ParseTypeBase\"/>\n\
<![[\n\
// number of symbols in parser\n\
#define PARSE_SYMBOL_COUNT   ]]><Integer \"ParseSymbolNum\"/>\n\
<![[\n\
\n\
// number of symbols in parser\n\
#define PARSE_TOKENMAP_SIZE   ]]><Size \"ParseTokenMap\"/>\n\
<![[\n\
\n\
// start state of parser\n\
#define PARSE_START_STATE   ]]><Integer \"ParseStartState\"/>\n\
<![[\n\
\n\
// accept state of parser\n\
#define PARSE_ACCEPT_STATE   ]]><Integer \"ParseAcceptState\"/>\n\
<![[\n\
\n\
// illegal state for parser\n\
#define PARSE_ERROR_STATE   ]]><Integer \"ParseErrorState\"/>\n\
<![[\n\
\n\
// special ID of invalid rule for parser, indicating current lookahead\n\
// symbol can not be shifted\n\
#define PERROR_RULE   ]]><Integer \"ParseErrorRule\"/>\n\
</If>\n\
<![[\n\
\n\
#define	MAX_MSG_LENG 		128\n\
\n\
// macros for wrapped new operator\n\
#define MYNEW(var, type) {\\\n\
	var = new type;\\\n\
	if(! var) {\\\n\
		exit_on_oom();\\\n\
	}\\\n\
}\n\
#define MYNEWS(var, type, size) {\\\n\
	var = new type[size];\\\n\
	if(! var) {\\\n\
		exit_on_oom();\\\n\
	}\\\n\
}\n\
#define MYRENEW(var, type, size, osize) {\\\n\
	type *p = new type[size];\\\n\
	if(!p) {\\\n\
		exit_on_oom();\\\n\
	}\\\n\
	memcpy(p, var, sizeof(type) * osize);\\\n\
	delete[] var;\\\n\
	var = p;\\\n\
}\n\
\n\
// error IDs\n\
enum {\n\
	// grammar is accepted by automation\n\
	YYE_ACCEPT =	1,\n\
	// indicate automation is alive\n\
	YYE_ALIVE =	2,\n\
	// run out of all buffers,\n\
	// and token `$end\' will be sent to parser\n\
	YYE_EOS =	3,\n\
	// lexical analysis terminated manually,\n\
	// and token `$end\' will be sent to parser\n\
	YYE_TERM =	3,\n\
	// syntactic error occurs, and try to error-recover\n\
	YYE_PERROR =	4,\n\
\n\
	// can not match any pattern, token `$undef\' will\n\
	// be sent to parser\n\
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID,\n\
\n\
	// out of memory\n\
	YYE_OOM = 	-1,\n\
	// out of range\n\
	YYE_OOR =	-2,\n\
	// I/O error\n\
	YYE_IO =	-3,\n\
	// parsing aborted\n\
	YYE_ABORT = 	-4,\n\
	YYE_NOINPUT =	-5,\n\
};\n\
]]>\n\
<If EnableScanner>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
\n\
template<class INT_TYPE, int STACK_SIZE>\n\
class cycstack_t {\n\
\n\
public:\n\
	inline cycstack_t(void)\n\
	: m_nBase(0)\n\
	, m_nTop(0) {\n\
	}\n\
	inline void push(INT_TYPE a_nSize) {\n\
		m_nTop = (m_nTop + 1) % STACK_SIZE;\n\
		m_nElem[m_nTop] = a_nSize;\n\
		if(m_nTop == m_nBase) {\n\
			m_nBase = (m_nTop + 1) % STACK_SIZE;\n\
		}\n\
	}\n\
	inline INT_TYPE pop(void) {\n\
		if(m_nTop != m_nBase) {\n\
			INT_TYPE sz = m_nElem[m_nTop];\n\
			m_nTop = (m_nTop + STACK_SIZE - 1) % STACK_SIZE;\n\
			return sz;\n\
		}\n\
		return 0;\n\
	}\n\
	inline void clear(void) {\n\
		m_nTop = m_nBase;\n\
	}	\n\
private:\n\
	INT_TYPE m_nElem[STACK_SIZE];\n\
	short m_nBase, m_nTop;\n\
};\n\
]]>\n\
		</If>\n\
	</If><![[\n\
class bufbase_t {\n\
\n\
public:\n\
	virtual ~bufbase_t(void){}\n\
	virtual int get(void) = 0;\n\
	virtual int peek(void) = 0;\n\
	virtual int unget(void) = 0;\n\
	virtual int unget(int num) = 0;\n\
	virtual int put(char) = 0;\n\
\n\
	inline void reset(void) {\n\
		xreset();]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		stlsz.clear();\n\
		sttsz.clear();]]>\n\
		</If>\n\
	</If><![[\n\
	}\n\
	inline bool iseof(void) const { return gptr == gend;}\n\
	inline bool iseos(void) const { return eos;	}\n\
	inline bool isimod(void) const { return imod;}\n\
	inline void setimod(bool bi) { imod = bi;}\n\
	inline int getlineno(void) const { return line;}\n\
	inline void setlineno(int nline) { line = nline;}\n\
	inline int getcolno(void) const { return col;}\n\
	inline void setcolno(int ncol) { col = ncol;}\n\
	inline int gettabsize(void) const { return tab;}\n\
	inline void settabsize(int ntab) { tab = (ntab > 0)\? ntab : 1;}\n\
\n\
	inline void* getdata(void) const { return pvoid; }\n\
	inline void setdata(void* pv) { pvoid = pv; }\n\
protected:\n\
	virtual void xreset(void) = 0;\n\
\n\
	by_te_t *pbase;\n\
	by_te_t *gptr;\n\
	by_te_t *gend;\n\
	bool eos;\n\
	// interactive mode\n\
	bool imod;\n\
	int line;\n\
	int col;\n\
	int tab;\n\
	\n\
	void *pvoid;\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
public:\n\
	inline void pushlsz(int nlsize) {\n\
		stlsz.push((short)nlsize);\n\
	}\n\
	inline int poplsz(void) {\n\
		return stlsz.pop();\n\
	}\n\
	inline void pushtsz(int ntsize) {\n\
		sttsz.push((by_te_t)ntsize);\n\
	}\n\
	inline int poptsz(void) {\n\
		return sttsz.pop();\n\
	}\n\
protected:\n\
	cycstack_t<short, LINESIZE_STACK_LENG> stlsz;\n\
	cycstack_t<by_te_t, TABSIZE_STACK_LENG> sttsz;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
};\n\
]]></If>\n\
\n\
<If EnableDeclare><Declare/></If>\n\
<![[\n\
// function type for error-reporting\n\
typedef void(*]]><$YY \"error_t\"/><![[)(const char* msg]]><If Has\?\"FormalParams\"><![[, ]]><Action \"FormalParams\"/></If><![[);\n\
\n\
// assign new log stream\n\
void ]]><$YY \"setstream\"/><![[(FILE *poutput, FILE *plogger);\n\
// assign new error-reporter and return the old one\n\
]]><$YY \"error_t\"/><![[ ]]><$YY \"seterror\"/><![[(]]><$YY \"error_t\"/><![[);\n\
// reset all (both scanner and parser, if they are available)\n\
void ]]><$YY \"clearall\"/><![[(void);\n\
]]>\n\
<If EnableParser>\n\
<If Has\?\"LTypeName\">\n\
<![[\n\
// location type is defined by user as ]]><Action \"LTypeName\"/></If>\n\
<Else><![[\n\
// location defines here\n\
struct ]]><$YY \"ltype_t\"/><![[ {\n\
	]]>\n\
<If Has\?\"LTypeDeclare\"><Action \"LTypeDeclare\"/></If>\n\
<Else><![[int firstLine;\n\
	int firstColumn;\n\
	int lastLine;\n\
	int lastColumn;\n\
	]]></Else>\n\
<![[\n\
};\n\
]]></Else>\n\
<If Has\?\"STypeName\"><![[\n\
// semantic value type defined by user as ]]><Action \"STypeName\"/></If>\n\
<Else><![[\n\
// semantic value type define here\n\
struct ]]><$YY \"stype_t\"/><![[ {\n\
	]]>\n\
<If Has\?\"STypeDeclare\"><Action \"STypeDeclare\"/></If>\n\
<Else><![[int nVal;]]></Else>\n\
<![[\n\
};\n\
]]></Else>\n\
<![[\n\
typedef ]]><$TypeName \"STypeName\" \"stype_t\"/><![[ xstype_t;\n\
typedef ]]><$TypeName \"LTypeName\" \"ltype_t\"/><![[ xltype_t;\n\
// function type for scanning\n\
typedef int (*]]><$YY \"lex_t\"/><![[)(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[);\n\
\n\
// assign new scanner and return the old one\n\
]]><$YY \"lex_t\"/><![[ ]]><$YY \"setlex\"/><![[(]]><$YY \"lex_t\"/><![[);\n\
]]>\n\
</If>\n\
\n\
<If EnableScanner><![[\n\
// initializing file buffer before parsing or patter-matching\n\
int ]]><$YY \"lexfile\"/><![[(const char* pchFile, bool iMod = false);\n\
// initializing string buffer before parsing or patter-matching\n\
int ]]><$YY \"lexstr\"/><![[(char *strbuffer, int size);\n\
// initializing const string buffer before parsing or patter-matching\n\
int ]]><$YY \"lexcstr\"/><![[(const char *strbuffer, int size);\n\
\n\
// generated scanner, can be replaced\n\
int ]]><$YY \"lex\"/><![[(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[);\n\
\n\
]]></If><If EnableParser><![[\n\
// generated parser, it should not be replaced\n\
int ]]><$YY \"parse\"/><![[(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[);\n\
]]>\n\
</If>\n\
\n\
<Declare/>\n\
<If EnableParser><![[\n\
extern xstype_t ]]><$YY \"lval\"/><![[;\n\
extern xltype_t ]]><$YY \"lloc\"/><![[;\n\
]]></If>\n\
<If EnableDeclare><![[\n\
#endif\n\
]]></If>\n\
\n\
<Define/>\n\
<If EnableParser><![[\n\
xstype_t ]]><$YY \"lval\"/><![[;\n\
xltype_t ]]><$YY \"lloc\"/><![[;\n\
\n\
]]></If>\n\
<![[\n\
// program abort due to out of memory\n\
inline static void exit_on_oom(void) {\n\
	exit(-1);\n\
}\n\
static char stext__[24] = \"unprintable-char{\";\n\
inline static const char* sym_text__(const char* ps) {\n\
	\n\
	by_te_t b = (by_te_t)*ps, i = 17, t;\n\
	if( !ps[1] && (b < 32 || b >= 127)) {\n\
		if((t = b / 100) > 0) {\n\
			stext__[i++] = (char)(t + 48);\n\
			b %= 100;\n\
		}\n\
		if((t = b / 10) > 0) {\n\
			stext__[i++] = (char)(t + 48);\n\
			b %= 10;\n\
		}\n\
		stext__[i++] = (char)(b + 48);\n\
		stext__[i++] = \'}\';\n\
		stext__[i] = \'\\0\';\n\
		return stext__;\n\
	}\n\
	return ps;\n\
}\n\
\n\
static void yyemit_error__(const char *s]]><If Has\?\"FormalParams\"><![[, ]]><Action \"FormalParams\"/></If><![[);\n\
\n\
class ]]><$YY \"parser_t\"/><![[ {\n\
\n\
	friend void ]]><$YY \"setstream\"/><![[(FILE *poutput, FILE *plogger);\n\
	friend ]]><$YY \"error_t\"/><![[ ]]><$YY \"seterror\"/><![[(]]><$YY \"error_t\"/><![[);\n\
	]]><If EnableParser><![[friend ]]><$YY \"lex_t\"/><![[ ]]><$YY \"setlex\"/><![[(]]><$YY \"lex_t\"/><![[);\n\
]]></If>\n\
<If EnableScanner><![[\n\
private:\n\
\n\
	// class bufmgr_t class define HERE\n\
	class bufmgr_t {\n\
\n\
	public:\n\
\n\
		enum {\n\
			// half size of buffer\n\
			BUF_HALF_SIZE = 4096,\n\
			// fullsize of buffer\n\
			BUF_FULL_SIZE = BUF_HALF_SIZE * 2\n\
		};\n\
\n\
	private:\n\
		class filebuf_t: public bufbase_t {\n\
\n\
			friend class bufmgr_t;\n\
		private:\n\
\n\
			inline void init(void) {\n\
\n\
				gptr = pbase = &buf[BUF_FULL_SIZE - 1];\n\
				gend = &buf[0];\n\
				eos = false;\n\
				bpeeked = false;\n\
			}\n\
\n\
		public:\n\
\n\
			filebuf_t(FILE* pf = stdin)\n\
			: pfile(pf) {\n\
				imod = (pf == stdin);\n\
				line = 1;\n\
				col = 1;\n\
				tab = 4;\n\
				pvoid = nullptr;\n\
				init();\n\
			}\n\
\n\
			virtual ~filebuf_t(void) {\n\
\n\
				if(pfile != stdin) {\n\
\n\
					fclose(pfile);\n\
				}\n\
			}\n\
\n\
			virtual void xreset(void) {\n\
\n\
				if(pfile != stdin) {\n\
					fseek(pfile, 0, SEEK_SET);\n\
				}\n\
				init();\n\
			}\n\
\n\
			virtual int get(void) {\n\
\n\
				if(gptr == gend) {\n\
\n\
					eos = true;\n\
					return END_OF_ALLFILE;\n\
				}\n\
\n\
				gptr = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;\n\
\n\
				if(gptr == gend && !bpeeked) {\n\
\n\
					fill(gptr);\n\
				}\n\
\n\
				bpeeked = false;\n\
\n\
				return iseof()\? END_OF_FILE: (int)(*gptr);\n\
			}\n\
\n\
			virtual int peek(void) {\n\
\n\
				if(gptr == gend) {\n\
\n\
					return END_OF_ALLFILE;\n\
				}\n\
\n\
				by_te_t *p = buf + ((gptr - buf) + 1) % BUF_FULL_SIZE;\n\
\n\
				if(p == gend) {\n\
\n\
					fill(p);\n\
				}\n\
\n\
				bpeeked = true;\n\
\n\
				return (p == gend)\? END_OF_FILE: (int)(*p);\n\
			}\n\
\n\
			virtual int unget(void) {\n\
\n\
				if(eos || gptr == pbase) {\n\
					return END_OF_FILE;\n\
				}\n\
\n\
				int oldc = (int)(*gptr);\n\
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;\n\
\n\
				return oldc;\n\
			}\n\
\n\
			virtual int unget(int num) {\n\
\n\
				if(eos || gptr == pbase) {\n\
					return 0;\n\
				}\n\
				int n = ((gptr - pbase) + BUF_FULL_SIZE) % BUF_FULL_SIZE;\n\
\n\
				if(n > num) {\n\
					n = num;\n\
				}\n\
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - n) % BUF_FULL_SIZE;\n\
\n\
				return n;\n\
			}\n\
		\n\
			virtual int put(char c) {\n\
\n\
				if(eos || gptr == pbase) {\n\
					return END_OF_FILE;\n\
				}\n\
\n\
				int oldc = (int)(*gptr);\n\
				*gptr = (by_te_t)c;\n\
				gptr = buf + ((gptr - buf) + BUF_FULL_SIZE - 1) % BUF_FULL_SIZE;\n\
\n\
				return oldc;\n\
			}\n\
\n\
		private:\n\
\n\
			int fill(by_te_t *p) {\n\
\n\
				int ncnt = 0;\n\
				int vacents = ((pbase + BUF_FULL_SIZE) - gend) % BUF_FULL_SIZE;\n\
				if(stdin != pfile) {\n\
					while((ncnt = fread(p, 1, BUF_HALF_SIZE, pfile)) == 0 && ferror(pfile)) {\n\
						if(errno != EINTR) {\n\
							// IO error\n\
							return 0;\n\
						}\n\
						clearerr(pfile);\n\
						errno = 0;\n\
					}\n\
					gend = buf + (p - buf + ncnt) % BUF_FULL_SIZE;\n\
				}\n\
				else {\n\
					for(int c = 0; \'\\n\' !=  c && ncnt < BUF_HALF_SIZE;\n\
						gend = buf + ((gend - buf) + 1) % BUF_FULL_SIZE, ++ncnt) {\n\
\n\
						c = fgetc(stdin);\n\
						*gend = (by_te_t)c;\n\
						if(EOF == c && feof(pfile)) {\n\
							break;\n\
						}\n\
					}\n\
				}\n\
				if(ncnt > vacents) {\n\
					pbase = buf + ((gend - buf) + 1) % BUF_FULL_SIZE;\n\
				}\n\
				return ncnt;\n\
			}\n\
\n\
		private:\n\
\n\
			bool bpeeked;\n\
			FILE *pfile;\n\
			by_te_t buf[BUF_FULL_SIZE];\n\
		};\n\
\n\
	private:\n\
\n\
		class strbuf_t: public bufbase_t {\n\
\n\
			friend class bufmgr_t;\n\
		public:\n\
\n\
			// nSize is length of string including terminating nullptr\n\
			strbuf_t(const char *pchBuf, int nSize)\n\
			: bowner(true) {\n\
\n\
				MYNEWS(pbase, by_te_t, nSize);\n\
				memcpy(pbase, pchBuf, sizeof(char)*(nSize - 1));\n\
				pbase[nSize - 1] = \'\\0\';\n\
\n\
				gend = pbase + nSize - 1;\n\
				xreset();\n\
				imod = false;\n\
				line = 1;\n\
				col = 1;\n\
				tab = 4;\n\
				pvoid = nullptr;\n\
			}\n\
\n\
			strbuf_t(char *pchBuf, int nSize)\n\
			: bowner(false) {\n\
\n\
				pbase = (by_te_t*)pchBuf;\n\
				gend = pbase + nSize - 1;\n\
				xreset();\n\
\n\
				imod = false;\n\
				line = 1;\n\
				col = 1;\n\
				tab = 4;\n\
				pvoid = nullptr;\n\
			}\n\
\n\
			virtual ~strbuf_t(void) {\n\
				if(bowner) {\n\
					delete [] pbase;\n\
				}\n\
			}\n\
\n\
		public:\n\
\n\
			virtual void xreset(void) {\n\
\n\
				gptr = pbase - 1;\n\
				eos = false;\n\
			}\n\
			virtual int get(void) {\n\
\n\
				if(gptr == gend) {\n\
					eos = true;\n\
					return END_OF_ALLFILE;\n\
				}\n\
				++gptr;\n\
\n\
				return (gptr == gend)\? END_OF_FILE : (int)(*gptr);\n\
			}\n\
\n\
			virtual int peek(void) {\n\
\n\
				return (gptr == gend) \? (eos \? END_OF_ALLFILE: END_OF_FILE) : \n\
					(int)(*(gptr + 1));\n\
			}\n\
			virtual int unget(void) {\n\
				if(eos || (pbase - 1 == gptr)) {\n\
					return END_OF_FILE;\n\
				}\n\
				return (int)(*gptr--);\n\
			}\n\
			virtual int unget(int num) {\n\
\n\
				if(eos || (pbase - 1 == gptr)) {\n\
					return 0;\n\
				}\n\
				int n = gptr - pbase + 1;\n\
				if(n > num) {\n\
					n = num;\n\
				}\n\
				gptr -= n;\n\
\n\
				return n;\n\
			}\n\
\n\
			virtual int put(char c) {\n\
\n\
				if(eos || (pbase - 1 == gptr)) {\n\
					return END_OF_FILE;\n\
				}\n\
\n\
				int oldc = (int)(*gptr);\n\
\n\
				*gptr-- = (by_te_t)c;\n\
\n\
				return oldc;\n\
			}\n\
\n\
		private:\n\
			bool bowner;\n\
		};\n\
\n\
	private:\n\
\n\
		struct link_t {\n\
\n\
			link_t(bufbase_t *pxb, link_t *plnk = nullptr)\n\
			: pxbuf(pxb)\n\
			, plink(plnk){}\n\
\n\
			bufbase_t *pxbuf;\n\
			link_t *plink;\n\
		};\n\
\n\
	public:\n\
\n\
		bufmgr_t(void)\n\
		: phead(nullptr) {\n\
\n\
			MYNEW(pstdin, filebuf_t);\n\
			MYNEW(pavail, link_t(pstdin, nullptr));\n\
		}\n\
		~bufmgr_t(void) {\n\
\n\
			while(pavail) {\n\
\n\
				link_t *p = pavail->plink;\n\
\n\
				delete pavail->pxbuf;\n\
				delete pavail;\n\
\n\
				pavail = p;\n\
			}			\n\
		}\n\
\n\
	public:\n\
\n\
		inline int get(void) {\n\
			return phead\? phead->pxbuf->get(): END_OF_ALLFILE;\n\
		}\n\
		inline int peek(void) {\n\
			return phead\? phead->pxbuf->peek(): END_OF_ALLFILE;\n\
		}\n\
		inline int unget(void) {\n\
			return phead\? phead->pxbuf->unget(): END_OF_FILE;\n\
		}\n\
		inline int unget(int num) {\n\
			return phead\? phead->pxbuf->unget(num): 0;\n\
		}\n\
		inline int put(char c) {\n\
			return phead\? phead->pxbuf->put(c): END_OF_FILE;\n\
		}\n\
		inline bool iseof(void) const {\n\
			return phead\? phead->pxbuf->iseof(): true;\n\
		}\n\
		inline bool iseos(void) const {\n\
			return phead\? phead->pxbuf->iseos(): true;\n\
		}\n\
		inline bool isimod(void) const {\n\
			return phead\? phead->pxbuf->isimod(): false;\n\
		}\n\
		inline int getlineno(void) const {\n\
			 return phead\? phead->pxbuf->getlineno(): 0;\n\
		}\n\
		inline void setlineno(int nline) {\n\
			if(phead) {\n\
				phead->pxbuf->setlineno(nline);\n\
			}\n\
		}\n\
		inline int getcolno(void) const {\n\
			return phead\? phead->pxbuf->getcolno(): 0;\n\
		}\n\
		inline void setcolno(int ncol) {\n\
			if(phead) {\n\
				phead->pxbuf->setcolno(ncol);\n\
			}\n\
		}\n\
		inline int gettabsize(void) const {\n\
			return phead\? phead->pxbuf->gettabsize(): 0;\n\
		}\n\
		inline void settabsize(int ntab) {\n\
			if(phead) {\n\
				phead->pxbuf->settabsize(ntab);\n\
			}\n\
		}\n\
		inline void reset(void) {\n\
			if(phead) {\n\
				phead->pxbuf->reset();\n\
			}\n\
		}]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		inline void pushlsz(int nlsize) {\n\
			if(phead) {\n\
				phead->pxbuf->pushlsz(nlsize);\n\
			}\n\
		}\n\
		inline int poplsz(void) {\n\
			if(phead) {\n\
				return phead->pxbuf->poplsz();\n\
			}\n\
			return 0;\n\
		}\n\
		inline void pushtsz(int ntsize) {\n\
			if(phead) {\n\
				phead->pxbuf->pushtsz(ntsize);\n\
			}\n\
		}\n\
		inline int poptsz(void) {\n\
			if(phead) {\n\
				return phead->pxbuf->poptsz();\n\
			}\n\
			return 0;\n\
		}\n\
]]>\n\
		</If>\n\
	</If><![[\n\
\n\
		inline bufbase_t* current(void) const {\n\
			return phead \? phead->pxbuf : nullptr;\n\
		}\n\
\n\
		inline bool empty(void) const {\n\
			return ! phead;\n\
		}\n\
\n\
		inline bufbase_t* newbuf(FILE *pfile, bool iMod = false) {\n\
\n\
			bufbase_t *p;\n\
			if(pfile == stdin) {\n\
				p = pstdin;\n\
				p->reset();\n\
			}\n\
			else {\n\
				MYNEW(p, filebuf_t(pfile));\n\
				MYNEW(pavail->plink, link_t(p, pavail->plink));\n\
			}\n\
			\n\
			p->setimod(iMod);\n\
			\n\
			return p;\n\
		}\n\
		inline bufbase_t* newbuf(char * pchBuffer, int nSize) {\n\
		\n\
			strbuf_t *p;\n\
			MYNEW(p, strbuf_t(pchBuffer, nSize));\n\
			MYNEW(pavail->plink, link_t(p, pavail->plink));\n\
\n\
			return p;\n\
		}\n\
		inline bufbase_t* newbuf(const char * pchBuffer, int nSize) {\n\
		\n\
			strbuf_t *p;\n\
			MYNEW(p, strbuf_t(pchBuffer, nSize));\n\
			MYNEW(pavail->plink, link_t(p, pavail->plink));\n\
\n\
			return p;\n\
		}\n\
		\n\
		inline bufbase_t* switchto(bufbase_t* pbuf) {\n\
\n\
			bufbase_t *pold = phead \? phead->pxbuf : nullptr;\n\
			link_t* p = rmwork(pbuf);\n\
			if( ! p) {\n\
				MYNEW(phead, link_t(pbuf, phead));\n\
			}\n\
			else {\n\
				p->plink = phead;\n\
				phead = p;\n\
			}\n\
			\n\
			return pold;\n\
		}\n\
		\n\
		inline bufbase_t* pop(void) {\n\
			\n\
			if(! phead) {\n\
				return nullptr;\n\
			}\n\
			\n\
			link_t *p = phead;\n\
			bufbase_t* pbuf = p->pxbuf;\n\
			phead = phead->plink;\n\
			\n\
			delete p;\n\
			\n\
			return pbuf;\n\
		}\n\
\n\
		void destroytop(void) {\n\
			\n\
			bufbase_t *pxb = pop();\n\
			if( pxb && pxb != pstdin) {\n\
\n\
				link_t *p = pavail;\n\
				\n\
				while(p->plink && p->plink->pxbuf != pxb) {\n\
					p = p->plink;\n\
				}\n\
				if(p->plink) {\n\
					link_t *q = p->plink;\n\
					p->plink = q->plink;\n\
\n\
					delete pxb;\n\
					delete q;\n\
				}\n\
			}\n\
		}\n\
		\n\
		void destroyall(void) {\n\
\n\
			while(pavail->plink) {\n\
				link_t *p = pavail->plink;\n\
				pavail->plink = p->plink;\n\
				if(p->pxbuf) {\n\
					delete p->pxbuf;\n\
				}\n\
				delete p;\n\
			}\n\
			\n\
			phead = nullptr;\n\
		}\n\
\n\
	private:\n\
\n\
		link_t* rmwork(bufbase_t* pxb) {\n\
\n\
			link_t *p = phead;\n\
			// then check if @pxb is in the list, if so, then remove it\n\
			if(p) {\n\
\n\
				if(pxb == phead->pxbuf) {\n\
					phead = phead->plink;\n\
					return p;\n\
				}\n\
				else {\n\
					while(p->plink && p->plink->pxbuf != pxb) {\n\
						p = p->plink;\n\
					}\n\
					if(p->plink) {\n\
						link_t *q = p->plink;\n\
						p->plink = q->plink;\n\
						return q;\n\
					}\n\
				}\n\
			}\n\
\n\
			return nullptr;\n\
		}\n\
\n\
	private:\n\
\n\
		// working buffer stack\n\
		link_t *phead;\n\
		// available buffer stack\n\
		link_t *pavail;\n\
		// stdin buffer\n\
		bufbase_t *pstdin;\n\
	};\n\
\n\
]]></If><![[\n\
	template<class ElemType, int INIT_SIZE = 4096, int INC_SIZE = 1024>\n\
	class sstack_t {\n\
	private:\n\
		ElemType *pbase;\n\
		int size;\n\
		int ntop;\n\
\n\
	public:\n\
		inline sstack_t(void)\n\
		: pbase(nullptr)\n\
		, size(INIT_SIZE)\n\
		, ntop(-1) {\n\
			MYNEWS(pbase, ElemType, INIT_SIZE);\n\
		}\n\
		inline ~sstack_t(void) {\n\
			if(pbase) {\n\
				delete[] pbase;\n\
			}\n\
		}\n\
\n\
		inline void push(void) {\n\
			if(ntop == size - 1) {\n\
				MYRENEW(pbase, ElemType, INC_SIZE + size, size);\n\
				size += INC_SIZE;\n\
			}\n\
			++ntop;\n\
		}\n\
		inline void push(const ElemType &e) {\n\
			if(ntop == size - 1) {\n\
				MYRENEW(pbase, ElemType, INC_SIZE + size, size);\n\
				size += INC_SIZE;\n\
			}\n\
			pbase[++ntop] = e;\n\
		}\n\
		inline ElemType& top(void) {\n\
			return pbase[ntop];\n\
		}\n\
		inline const ElemType& top(void) const {\n\
			return pbase[ntop];\n\
		}\n\
		inline void pop(int n) {\n\
			ntop -= n;\n\
		}\n\
		inline ElemType& operator[](int down) {\n\
			return pbase[ntop - down];\n\
		}\n\
		inline const ElemType& operator[](int down) const {\n\
			return pbase[ntop - down];\n\
		}\n\
\n\
		inline bool empty(void) const {\n\
			return ntop < 0;\n\
		}\n\
\n\
		inline int count(void) const {\n\
			return ntop + 1;\n\
		}\n\
\n\
		inline void clear(void) {\n\
			ntop = -1;\n\
		}\n\
	};\n\
]]><If EnableScanner><![[\n\
\n\
private:\n\
\n\
	inline void renew_text__(void) {\n\
\n\
		MYRENEW(yytext, char, INC_YYTEXT_SIZE + yysize__, yysize__);\n\
		yysize__ += INC_YYTEXT_SIZE;\n\
		yytext[yysize__ - 1] = \'\\0\';\n\
	}\n\
\n\
	inline bool yylex_is_running__(void) const {\n\
		return yyecode__ == YYE_ALIVE;\n\
	}\n\
	inline int yyget_lexrule__(int s) const{\n\
		return yydaccpt[s];\n\
	}\n\
\n\
	int yynext_lexstate__(int s, int c) const {\n\
\n\
		int d = yydcmap[c];\n\
		while(s < LEX_STATE_COUNT && yydchk[ yydbase[s] + d] != s) {\n\
			s = yyddef[s];\n\
		}\n\
\n\
		if(s > LEX_STATE_COUNT) {\n\
			return yydchk[yydbase[s] + yydmeta[d]] == s\?\n\
				yydnxt[ yydbase[s] + yydmeta[d]] : LEX_ERROR_STATE;\n\
		}\n\
		else {\n\
			return yydnxt[ yydbase[s] + d];\n\
		}\n\
	}\n\
]]></If><![[\n\
	friend void yyemit_error__(const char *s]]><If Has\?\"FormalParams\"><![[, ]]><Action \"FormalParams\"/></If><![[);\n\
]]><If EnableParser><![[\n\
private:\n\
\n\
	inline void YYACCEPT(void) {\n\
		yyecode__ = YYE_ACCEPT;\n\
	}\n\
	inline void YYABORT(void) {\n\
		yyecode__ = YYE_ABORT;\n\
	}\n\
	inline void yyerrok(void) {\n\
		yyerr_flag__ = false;\n\
		yyltok = PARSE_UNDEFSYMB_ID;\n\
	}\n\
\n\
	inline bool yyparse_is_running__(int s) const {\n\
		return yyecode__ > YYE_ACCEPT && s != PARSE_ACCEPT_STATE;\n\
	}\n\
	inline int yyget_defrule(int s) const {\n\
		if(0 == yyparn[s] && is_valid_prule__(yyget_prule__(yyparv[s])) ) {\n\
			return yyget_prule__(yyparv[s]);\n\
		}\n\
		return PERROR_RULE;\n\
	}\n\
	inline bool is_valid_pstate__(int s) const {\n\
		return s < PARSE_ERROR_STATE;\n\
	}\n\
	inline bool is_valid_prule__(int r) const {\n\
		return r >= 0 && r < PERROR_RULE;\n\
	}\n\
	inline int yyget_prule__(int s) const {\n\
		return s - (PARSE_ERROR_STATE + 1);\n\
	}\n\
	inline void yydiscard__(xstype_t &yydval, xltype_t  &yydloc, int yydsymb]]>\n\
		<If Has\?\"FormalParams\"><![[, ]]><Action \"FormalParams\"/></If><![[) {\n\
	]]><If Has\?\"DestructorActions\"><![[\n\
		switch(yydsymb) {\n\
		]]><$UserDiscardActions \"DestructorSymbols\" \"DestructorActions\"/><![[\n\
		default:\n\
			break;\n\
		}]]></If><![[\n\
	}\n\
	inline int yynext_pstate__(int s, int t) const {\n\
		if(yyvbmap[s * PARSE_BMAP_ROWSIZE + t / 8] & (1 << (t % 8))) {\n\
			if(yyparn[s] < yypcn[t]) {\n\
				return yyparv[s];\n\
			}\n\
			else if(yyparn[s] > yypcn[t]) {\n\
				return yypcv[t];\n\
			}\n\
			return yypact[yypabase[s] + t];\n\
		}\n\
		return PARSE_ERROR_STATE;\n\
	}\n\
	inline int yynext_goto__(int s, int t) const {\n\
		if(yypgrn[s] < yypcn[PARSE_TYPE_BASE + t]) {\n\
			return yypgrv[s];\n\
		}\n\
		else if(yypgrn[s] > yypcn[PARSE_TYPE_BASE + t]) {\n\
			return yypcv[PARSE_TYPE_BASE + t];\n\
		}\n\
		return yypgoto[yypgbase[s] + t];\n\
	}\n\
]]></If><![[\n\
public:\n\
\n\
	inline ]]><$YY \"parser_t\"/><![[(]]>\n\
<If EnableParser><$YY \"lex_t\"/><![[ plex = nullptr]]></If>\n\
<Else><![[void]]></Else><![[)\n\
	: yyecode__(YYE_ALIVE)]]>\n\
<If EnableScanner><![[\n\
	, yysize__(0)\n\
	, yystart__(INITIAL)\n\
	, yymore_flag__(false)\n\
	, yyat_bol__(true)\n\
	, yytext(nullptr)\n\
	, yyleng(0)\n\
	, yylaleng(0)]]>\n\
</If>\n\
<If EnableParser><![[\n\
	, yyerr_flag__(false)\n\
	, yyltok(PARSE_UNDEFSYMB_ID)\n\
	, yylexer(plex)]]>\n\
</If><![[\n\
	, yyoutput(stdout)\n\
	, yylogger(stderr)\n\
	, yyerror(yyemit_error__) {\n\
\n\
	}\n\
	~]]><$YY \"parser_t\"/><![[(void) {\n\
]]><If EnableScanner><![[\n\
		if(yytext) {\n\
			delete[] yytext;\n\
		}\n\
]]></If><![[\n\
	}\n\
]]><If EnableScanner><![[\n\
	inline bool yylexinit__(const char *pchFile, bool bi) {\n\
\n\
		YYPBUFFER pbuf = yy_new_filebuf(pchFile, bi);\n\
		if( !pbuf ) {\n\
			return false;\n\
		}\n\
		\n\
		yy_switch_buffer(pbuf);\n\
\n\
		if(!yytext) {\n\
			renew_text__();\n\
		}\n\
		return yy_has_buffer();\n\
	}\n\
\n\
	inline bool yylexinit__(const char *strbuffer, int size) {\n\
\n\
		YYPBUFFER pbuf = yy_new_cstrbuf(strbuffer, size);\n\
\n\
		if(!pbuf) {\n\
			return false;\n\
		}\n\
\n\
		yy_switch_buffer(pbuf);\n\
\n\
		if(!yytext) {\n\
			renew_text__();\n\
		}\n\
		return yy_has_buffer();\n\
	}\n\
\n\
	inline bool yylexinit__(char *strbuffer, int size) {\n\
\n\
		YYPBUFFER pbuf = yy_new_strbuf(strbuffer, size);\n\
\n\
		if(!pbuf) {\n\
			return false;\n\
		}\n\
\n\
		yy_switch_buffer(pbuf);\n\
\n\
		if(!yytext) {\n\
			renew_text__();\n\
		}\n\
		return yy_has_buffer();\n\
	}\n\
\n\
	int yylex__(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[) {\n\
		\n\
		if( !yy_has_buffer()) {yyecode__ = YYE_EOS; return 0;}\n\
\n\
		int yylstate__ = LEX_ERROR_STATE;\n\
		int yylrule__ = LEX_ERROR_RULE;\n\
		int yyaccleng__ = 0;\n\
		int yycchar__ = END_OF_FILE;\n\
		bool yylast_at_bol__ = yyat_bol__;\n\
		bool bwrap__ = false;\n\
		]]>\n\
	<$SingleAction \"LexVarDecl\"/><![[\n\
		yymore_flag__ = false;\n\
		yyecode__ = YYE_ALIVE;\n\
		]]>\n\
	<$SingleAction \"LexVarInit\"/><![[\n\
		yyleng = 0;\n\
		yylaleng = 0;\n\
		yytext[0] = \'\\0\';\n\
\n\
		]]>\n\
	<$CodeBlock \"LexInitAction\"/><![[\n\
\n\
		if(yyat_bol__) {\n\
			yylstate__ = yydsc[yystart__];\n\
		}\n\
		else {\n\
			yylstate__ = yydsc[yystart__ + 1];\n\
		}\n\
\n\
		while(yylex_is_running__()) {\n\
\n\
			yycchar__ = yybufmgr__.get();\n\
			yylstate__ = yynext_lexstate__(yylstate__, yycchar__);\n\
\n\
			if(LEX_ERROR_STATE != yylstate__) {\n\
\n\
				if(yylaleng >= yysize__ - 1) {\n\
					renew_text__();\n\
				}\n\
				yytext[yylaleng] = (char)yycchar__;\n\
\n\
				++yylaleng;\n\
\n\
				if(yyget_lexrule__(yylstate__) != LEX_ERROR_RULE) {\n\
\n\
					yylrule__ = yyget_lexrule__(yylstate__);\n\
					yyaccleng__ = yylaleng;\n\
				}\n\
			}\n\
\n\
			if(LEX_ERROR_STATE == yylstate__ || (yybufmgr__.isimod() \n\
					&& (\'\\n\' == yycchar__ || END_OF_FILE == yycchar__))) {\n\
				if(LEX_ERROR_RULE == yylrule__) {\n\
					if(yylaleng == yyleng) {\n\
						if(yycchar__ == END_OF_FILE) {\n\
							yylrule__ = LEX_EOFRULE_BASE + yystart__ / 2;\n\
						}\n\
						else if(yycchar__ == END_OF_ALLFILE) {\n\
							yylrule__ = LEX_EOAF_RULE;\n\
						}\n\
					}\n\
				}\n\
				else {\n\
					if( LEX_ERROR_STATE == yylstate__) {\n\
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);\n\
					}\n\
					yylaleng = yyaccleng__;\n\
					yytext[yylaleng] = \'\\0\';\n\
				]]>\n\
	<If Has\?\"LexDFALookaheads\"><![[\n\
					yyleng = yylaleng - yylad[yylrule__];\n\
					if(yylaleng > yyleng) {\n\
						yybufmgr__.unget(yylaleng - yyleng);\n\
					}]]>\n\
	</If>\n\
	<Else><![[ yyleng = yylaleng;]]>\n\
	</Else><![[\n\
				}\n\
\n\
				if(LEX_ERROR_RULE != yylrule__) {\n\
					if(yyleng > 0) yyat_bol__ = (yytext[yyleng - 1] == \'\\n\');]]>\n\
	<If LexDebugMode><![[\n\
				if(yylogger) {\n\
					if(yylrule__ >= LEX_EOFRULE_BASE) {\n\
						if(yylrule__ < LEX_EOAF_RULE) {\n\
							if(yydline[yylrule__] > 0) {\n\
								fprintf(yylogger, \".................... accept {EOF}, rule at line: %d\\n\", yydline[yylrule__]);\n\
							}\n\
							else {\n\
								fprintf(yylogger, \".................... EOF reached\\n\");\n\
							}\n\
						}\n\
						else {\n\
							fprintf(yylogger, \".................... EOS reached\\n\");\n\
						}\n\
					}\n\
					else {\n\
						if(yyleng == 1 && ((by_te_t)yytext[0] < 32 || (by_te_t)yytext[0] >= 127)) {\n\
							fprintf(yylogger, \".................... accept unprintable-char{%d}, rule at line: %d \\n\",\n\
								 (int)((by_te_t)yytext[0]), yydline[yylrule__]);\n\
						}\n\
						else {\n\
							fprintf(yylogger, \".................... accept {`%s\\\'}, rule at line: %d \\n\",\n\
								yytext, yydline[yylrule__]);\n\
						}\n\
					}\n\
				}]]>\n\
	</If>\n\
	<$CodeBlock \"PremacthAction\"/>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[{\n\
				int nline = yyget_lineno();\n\
				int ncol = yyget_colno() - 1;\n\
				int nt = yyget_tabsize();\n\
				int ts, yyt1__;\n\
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {\n\
					if(yytext[yyt1__] == \'\\t\') {\n\
\n\
						ts = nt - ncol % nt;\n\
						yybufmgr__.pushtsz(ts);\n\
						ncol += ts;\n\
					}\n\
					else if(yytext[yyt1__] == \'\\n\') {\n\
						yybufmgr__.pushlsz(ncol + 1);\n\
						ncol = 0;\n\
						++nline;\n\
					}\n\
					else {\n\
						++ncol;\n\
					}\n\
				}]]><If EnableParser><![[\n\
				]]><$YY \"lloc\"/><![[.firstLine = yyget_lineno();\n\
				]]><$YY \"lloc\"/><![[.firstColumn = yyget_colno();\n\
				]]><$YY \"lloc\"/><![[.lastLine  = nline;\n\
				]]><$YY \"lloc\"/><![[.lastColumn = (ncol < 0)\?0: ncol;\n\
				]]></If><![[yyset_lineno(nline);\n\
				yyset_colno(ncol + 1);\n\
			}]]>\n\
		</If>\n\
		<Else><![[{\n\
				int nline = yyget_lineno();\n\
				int yyt1__;\n\
				for(yyt1__ = 0; yyt1__ < yyleng; ++yyt1__) {\n\
					if(yytext[yyt1__] == \'\\n\') {\n\
						++nline;\n\
					}\n\
				}]]><If EnableParser><![[\n\
				]]><$YY \"lloc\"/><![[.firstLine = yyget_lineno();\n\
				]]><$YY \"lloc\"/><![[.firstColumn = 0;\n\
				]]><$YY \"lloc\"/><![[.lastLine  = nline;\n\
				]]><$YY \"lloc\"/><![[.lastColumn = 0;\n\
				]]></If><![[yyset_lineno(nline);\n\
				yyset_colno(0);\n\
			}]]>\n\
		</Else>\n\
	</If><![[\n\
				}\n\
\n\
		bwrap__ = (yylrule__ >= LEX_EOFRULE_BASE\n\
			&& yylrule__ < LEX_EOAF_RULE\n\
			&& yywrap__(]]><If Has\?\"ActualParams\"><Action \"ActualParams\"/></If><![[));\n\
\n\
		if(!bwrap__) {\n\
				switch(yylrule__) {\n\
				]]><$UserLexActions \"LexRule2Actions\" \"LexActions\"\n\
						\"LexRule2Lines\" \"ScriptFileName\"/><![[\n\
\n\
				case LEX_EOAF_RULE: \n\
					yy_delete_buffer();\n\
					yyecode__ = YYE_EOS;\n\
					break;\n\
				default:\n\
					if(yyleng > 0)\n\
						yyat_bol__ = (yytext[yyleng - 1] == \'\\n\');\n\
			]]><If EnableDefaultAction><![[\n\
				/* do nothing */]]></If>\n\
			<Else><![[\n\
					YYMSG_UNMATCHED[28] = yycchar__;\n\
					yyecode__ = YYE_UNMATCHED;\n\
					if(yyerror)\n\
						yyerror(YYMSG_UNMATCHED]]><If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
				]]></Else><![[\n\
				break;\n\
				}\n\
			}\n\
				if(yylex_is_running__()) {\n\
\n\
					yylast_at_bol__ = yyat_bol__;\n\
\n\
					if(yyat_bol__) {\n\
						yylstate__ = yydsc[yystart__];\n\
					}\n\
					else {\n\
						yylstate__ = yydsc[yystart__ + 1];\n\
					}\n\
\n\
					yylrule__ = LEX_ERROR_RULE;\n\
\n\
					if( ! yymore_flag__) {\n\
						yyaccleng__ = 0;\n\
						yylaleng = 0;\n\
						yyleng = 0;\n\
						yytext[yylaleng] = \'\\0\';\n\
					}\n\
					else {\n\
						yymore_flag__ = false;\n\
					}\n\
				}\n\
			}\n\
		}\n\
\n\
		return (yyecode__ == YYE_EOS)\? 0 : yyecode__;\n\
	}\n\
]]></If><If EnableParser><![[\n\
	int yyparse__(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[) {\n\
\n\
		if( ! yylexer) {\n\
			return YYE_ABORT;\n\
		}\n\
\n\
		yyecode__ = YYE_ALIVE;\n\
		sstack_t<xstype_t> yys_sv__;\n\
		xstype_t yyval;\n\
]]><If EnableLocation><![[\n\
		sstack_t<xltype_t> yys_loc__;\n\
]]></If><![[\n\
		xltype_t yyloc;\n\
		sstack_t<int> yys_stt__;\n\
		sstack_t<int> yys_symb__;\n\
\n\
		int yyrplen__;\n\
		bool yyreducing__;\n\
\n\
		int yypstate__ = PARSE_START_STATE;\n\
		int yyprule__ = PERROR_RULE;\n\
		int yysidx__ = PARSE_UNDEFSYMB_INDEX;\n\
		int yytok__ = PARSE_UNDEFSYMB_ID;\n\
		]]><$SingleAction \"ParseVarDecl\"/><![[\n\
\n\
		yyltok = PARSE_UNDEFSYMB_ID;\n\
		yyerr_flag__ = false;\n\
]]><$SingleAction \"ParseVarInit\"/><![[\n\
]]><$CodeBlock \"ParseInitAction\"/><![[\n\
		yys_stt__.push(yypstate__);\n\
\n\
		while( ! yys_stt__.empty() && yyparse_is_running__(yypstate__)) {\n\
			yyprule__ = yyget_defrule(yypstate__);\n\
			if(is_valid_prule__(yyprule__)) {\n\
				yyreducing__ = true;\n\
			}\n\
			else {\n\
				if(PARSE_UNDEFSYMB_ID == yytok__) {\n\
					if(PARSE_UNDEFSYMB_ID == yyltok) {\n\
						yytok__ = (yylexer)(]]><If Has\?\"ActualParams\"><Action \"ActualParams\"/></If><![[);\n\
					}\n\
					else  {\n\
						yytok__ = yyltok;\n\
						yyltok = PARSE_UNDEFSYMB_ID;\n\
					}\n\
					yysidx__ = (yytok__ < 0 || yytok__ >= PARSE_TOKENMAP_SIZE) \? PARSE_UNDEFSYMB_INDEX\n\
						: yyptmap[yytok__];\n\
				}\n\
\n\
]]><If ParseDebugMode><![[\n\
if(yylogger)\n\
	fprintf(yylogger, \"Next symbol is %s\\n\", sym_text__(yypsnam[yysidx__]));\n\
]]></If><![[\n\
				yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);\n\
\n\
				if(is_valid_pstate__(yypstate__)) {\n\
\n\
]]><If ParseDebugMode><![[\n\
if(yylogger)\n\
	fprintf(yylogger, \"Shift %s, go to state %d\\n\", sym_text__(yypsnam[yysidx__]), yypstate__);\n\
]]></If><![[\n\
					yys_symb__.push(yysidx__);\n\
					yys_stt__.push(yypstate__);\n\
					yys_sv__.push(]]><$YY \"lval\"/><![[);\n\
]]><If EnableLocation><![[\n\
					yys_loc__.push(]]><$YY \"lloc\"/><![[);\n\
]]></If><![[ \n\
					yytok__ = PARSE_UNDEFSYMB_ID;\n\
					yyreducing__ = false;\n\
				}\n\
				else {\n\
					yyprule__ = yyget_prule__(yypstate__);\n\
					yyreducing__ = true;\n\
				}\n\
			}\n\
\n\
			if(yyreducing__) {\n\
				switch(yyprule__) {\n\
				]]><$UserParseActions \"PraseRule2Actions\" \"ParseActions\"\n\
						\"ParseRule2Lines\" \"ScriptFileName\"/><![[\n\
				default:\n\
\n\
					if( ! yyerr_flag__ || PARSE_ENDSYMB_ID == yytok__) {\n\
						if(! yyerr_flag__) {\n\
							if(yyerror) {\n\
]]><If EnableLocation><![[\n\
char yycc[MAX_MSG_LENG];\n\
sprintf(yycc, \"Error: syntax error at %d:%d.\", ]]>\n\
	<$YY \"lloc\"/><![[.firstLine, ]]>\n\
	<$YY \"lloc\"/><![[.firstColumn);\n\
yyerror(yycc]]><If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></If><Else><![[\n\
yyerror(\"Error: syntax error.\"]]><If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></Else><![[				}\n\
\n\
							yyecode__ = YYE_PERROR;\n\
						}\n\
						else {\n\
							yyecode__ = YYE_NOINPUT;\n\
						}\n\
						\n\
						yyerr_flag__ = true;\n\
						yyltok = yytok__;\n\
					}\n\
					else {\n\
					]]><If ParseDebugMode><![[\n\
if(yylogger)\n\
	fprintf(yylogger, \"Error recovery : discard current token %s\\n\",\n\
	sym_text__(yypsnam[yysidx__]));\n\
]]></If><![[\n\
						yyltok = PARSE_UNDEFSYMB_ID;\n\
					}\n\
					yytok__ = PARSE_ERRORSYMB_ID;\n\
					yysidx__ = PARSE_ERRORSYMB_INDEX;\n\
\n\
					while(! yys_sv__.empty())  {\n\
						yypstate__ = yynext_pstate__(yys_stt__.top(), yysidx__);\n\
						if(is_valid_pstate__(yypstate__)) {\n\
							break;\n\
						}\n\
			]]><If ParseDebugMode><![[\n\
if(yylogger) {\n\
	fprintf(yylogger, \"Error recovery : Pop up %s from stack\\n\",\n\
	sym_text__(yypsnam[yys_symb__.top()]));\n\
	fprintf(yylogger, \"Now state stack: \");			\n\
	for(int yyt1__ = yyerr_flag__\? 1 : 0; yyt1__ < yys_stt__.count(); ++yyt1__) {\n\
		fprintf(yylogger, \"%5d\", yys_stt__[yyt1__]);\n\
	}\n\
	fprintf(yylogger, \"\\n\");\n\
	}]]></If><![[\n\
]]><If EnableLocation><![[\n\
						yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top()]]>\n\
							<If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
						yys_loc__.pop(1);\n\
]]></If><Else><![[\n\
						yydiscard__(yys_sv__.top(), ]]><$YY \"lloc\"/><![[, yys_symb__.top()]]>\n\
							<If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></Else><![[\n\
\n\
						yys_symb__.pop(1);\n\
						yys_sv__.pop(1);\n\
						yys_stt__.pop(1);\n\
					}\n\
\n\
					if( yys_sv__.empty()) {\n\
						yys_stt__.pop(1);\n\
					}\n\
\n\
					break;\n\
				}\n\
\n\
				if(is_valid_prule__(yyprule__) || YYE_ACCEPT == yyecode__) {\n\
					yyrplen__ = yyprnum[yyprule__];\n\
					yypstate__ = yynext_goto__(yys_stt__[yyrplen__], yyplid[yyprule__]);\n\
]]><If ParseDebugMode><![[\n\
if(yylogger){\n\
	fprintf(yylogger, \"Reduce action: \");\n\
	for(int yyt2__ = yyrplen__ - 1; yyt2__ >= 0; --yyt2__) {\n\
	int yyt1__ = yys_symb__[yyt2__];\n\
		fprintf(yylogger, \"%s \", sym_text__(yypsnam[yyt1__]));\n\
	}\n\
	fprintf(yylogger, \"=> %s, go to state %d by rule at %d.\\n\",\n\
	yypsnam[yyplid[yyprule__] + PARSE_TYPE_BASE], yypstate__, yypline[yyprule__]);\n\
}]]></If><![[\n\
\n\
					if(YYE_ACCEPT != yyecode__) {\n\
						yys_stt__.pop(yyrplen__);\n\
						yys_symb__.pop(yyrplen__);\n\
						yys_sv__.pop(yyrplen__);\n\
]]><If EnableLocation><![[\n\
						if(yyrplen__ == 0) {\n\
							yyloc.firstLine = yyloc.lastLine = yys_loc__[0].lastLine;\n\
							yyloc.firstColumn = yyloc.lastColumn = yys_loc__[0].lastColumn;\n\
						}\n\
						else {\n\
							yyloc.firstLine = yys_loc__[yyrplen__ - 1].firstLine;\n\
							yyloc.lastLine = yys_loc__[0].lastLine;\n\
							yyloc.firstColumn = yys_loc__[yyrplen__ - 1].firstColumn;\n\
							yyloc.lastColumn = yys_loc__[0].lastColumn;\n\
						}\n\
						yys_loc__.pop(yyrplen__);\n\
						yys_loc__.push(yyloc);\n\
]]></If><![[\n\
						yys_stt__.push(yypstate__);\n\
						yys_symb__.push(yyplid[yyprule__] + PARSE_TYPE_BASE);\n\
						yys_sv__.push(yyval);\n\
					}\n\
				}\n\
			}\n\
		}\n\
\n\
		while( ! yys_sv__.empty()) {\n\
]]><If ParseDebugMode><![[\n\
if(yylogger)\n\
	fprintf(yylogger, \"Clearup : Pop up %s from stack\\n\", sym_text__(yypsnam[yys_symb__.top()]));\n\
]]></If>\n\
<If EnableLocation><![[\n\
			yydiscard__(yys_sv__.top(), yys_loc__.top(), yys_symb__.top()]]>\n\
				<If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></If><Else><![[\n\
			yydiscard__(yys_sv__.top(), ]]><$YY \"lloc\"/><![[, yys_symb__.top()]]>\n\
				<If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></Else><![[\n\
			yys_sv__.pop(1);\n\
			yys_symb__.pop(1);\n\
		}\n\
\n\
		if(YYE_ACCEPT == yyecode__) {\n\
\n\
]]><If EnableLocation><![[\n\
			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE]]>\n\
				<If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></If><Else><![[\n\
			yydiscard__(yyval, ]]><$YY \"lloc\"/><![[, yyplid[yyprule__] + PARSE_TYPE_BASE]]>\n\
				<If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]></Else><![[\n\
		}\n\
]]><$CodeBlock \"ParseExitAction\"/><![[\n\
		return (yyecode__ == YYE_EOS || yyecode__ == YYE_ACCEPT )\? 0: yyecode__;\n\
	}\n\
]]></If><![[\n\
public:\n\
	inline void yyclearall__(void) {\n\
		yyecode__ = YYE_ALIVE;]]>\n\
<If EnableScanner><![[\n\
		yystart__ = INITIAL;		\n\
		yymore_flag__ = false;\n\
		yyat_bol__ = true;\n\
		\n\
		yyleng = 0;\n\
		yylaleng = 0;\n\
		if(yytext) {\n\
			yytext[0] = \'\\0\';\n\
		}\n\
		yybufmgr__.destroyall();\n\
]]></If>\n\
<If EnableParser><![[\n\
		yyerr_flag__ = false;\n\
		yyltok = PARSE_UNDEFSYMB_ID;\n\
]]></If><![[\n\
	}\n\
\n\
private:\n\
]]><If EnableScanner><![[\n\
	// user interfaces\n\
	// easy way to print matched string\n\
	inline void YYECHO(void) const {\n\
		ECHO();\n\
	}\n\
	inline void ECHO(void) const {\n\
		if(yyoutput)\n\
			fprintf(yyoutput, \"%s\", yytext);\n\
	}\n\
\n\
	// start-condition operations\n\
	// switch start-condition\n\
	inline void YYBEGIN(int sc) {\n\
		BEGIN(sc);\n\
	}\n\
	inline void BEGIN(int sc) {\n\
		yystart__ = sc;\n\
	}\n\
	// return current start-condition\n\
	inline int YYSTART(void) const {\n\
		return yystart__;\n\
	}\n\
	// save current start-condition and switch to new start-condition\n\
	inline void yy_push_state(int nsc) {\n\
		yyscstk__.push(yystart__);\n\
		yystart__ = nsc;\n\
	}\n\
	// switch to last saved start-condition\n\
	inline bool yy_pop_state(void) {\n\
\n\
		if(yyscstk__.empty()) {\n\
			return false;\n\
		}\n\
		yystart__ = yyscstk__.top();\n\
		yyscstk__.pop(1);\n\
		return true;\n\
	}\n\
	// return last saved start-condition\n\
	inline int yy_top_state(void) {\n\
\n\
		if(yyscstk__.empty()) {\n\
			return INITIAL;\n\
		}\n\
		return yyscstk__.top();\n\
	}\n\
\n\
	// get/set flag of beginning-of-line\n\
	inline bool yy_get_bol(void) const {\n\
		return yyat_bol__;\n\
	}\n\
	inline void yy_set_bol(bool b) {\n\
		yyat_bol__ = b;\n\
	}\n\
\n\
	// buffer operations\n\
	inline YYPBUFFER yy_current_buffer(void) const {\n\
		return yybufmgr__.current();\n\
	}\n\
	// \n\
	inline bool yy_has_buffer(void) const {\n\
		return ! yybufmgr__.empty();\n\
	}\n\
	inline void yy_push_buffer(YYPBUFFER pbuffer) {\n\
		yybufmgr__.switchto(pbuffer);\n\
	}\n\
	inline YYPBUFFER yy_pop_buffer(void) {\n\
		return yybufmgr__.pop();\n\
	}\n\
	inline YYPBUFFER yy_new_filebuf(const char *strfile, bool bi = false) {\n\
		if( !strfile ) {\n\
			return yybufmgr__.newbuf(stdin, bi);\n\
		}\n\
\n\
	 	FILE *pfile = fopen(strfile, \"r\");\n\
	 	if( !pfile) return nullptr;\n\
		return yybufmgr__.newbuf(pfile);\n\
	}\n\
\n\
	inline YYPBUFFER yy_new_cstrbuf(const char *cstrbuffer, int size) {\n\
		if( ! cstrbuffer || size < 1) {\n\
			return nullptr;\n\
		}\n\
		return yybufmgr__.newbuf(cstrbuffer, size);\n\
	}\n\
	inline YYPBUFFER yy_new_strbuf(char *strbuffer, int size) {\n\
		if( ! strbuffer || size < 1) {\n\
			return nullptr;\n\
		}\n\
		return yybufmgr__.newbuf(strbuffer, size);\n\
	}\n\
	inline void yy_delete_buffer(void) {\n\
		yybufmgr__.destroytop();\n\
	}\n\
	inline void yy_switch_buffer(YYPBUFFER buf) {\n\
		yybufmgr__.switchto(buf);\n\
	}\n\
	inline void yyrestart(void) {\n\
\n\
		yystart__ = INITIAL;\n\
		yyecode__ = YYE_ALIVE;\n\
		yymore_flag__ = false;\n\
		\n\
		yyleng = 0;\n\
		yylaleng = 0;\n\
		if( yytext ) {\n\
			yytext[0] = \'\\0\';\n\
		}\n\
\n\
		yyscstk__.clear();\n\
		yybufmgr__.reset();\n\
	}\n\
\n\
	inline void yymore(void) {\n\
\n\
		yymore_flag__ = true;\n\
		yylaleng = yyleng;\n\
	}\n\
	inline int yyless(int n) {\n\
\n\
		if(n > 0 && n < yyleng) {\n\
\n\
			yytext[n] = \'\\0\';\n\
			n = yyleng - n;\n\
			yyleng -= n;\n\
			yylaleng = yyleng;\n\
			return yybufmgr__.unget(n);\n\
		}\n\
		yylaleng = yyleng;\n\
		yytext[yylaleng] = \'\\0\';\n\
\n\
		return 0;\n\
	}\n\
\n\
	inline int yyinput(void) {\n\
\n\
		int c = yybufmgr__.get();]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		if(c < END_OF_FILE) {\n\
			if(c == \'\\t\') {\n\
				int nt = yyget_tabsize();\n\
				nt -= (yyget_colno() + nt - 1) % nt;\n\
				yybufmgr__.pushtsz(nt);\n\
				yyadd_colno(nt);\n\
			}\n\
			else if(c == \'\\n\') {\n\
				yybufmgr__.pushlsz(yyget_colno());\n\
				yyset_colno(1);\n\
				yyadd_lineno(1);\n\
			}\n\
			else {\n\
				yyadd_colno(1);\n\
			}\n\
		}]]>\n\
		</If>\n\
	</If><![[	\n\
		return c;\n\
	}\n\
	inline bool yyunput(char c) {\n\
		int oldc = yybufmgr__.put(c);]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		if(oldc < END_OF_FILE) {\n\
			int s;\n\
			if(oldc == \'\\t\') {\n\
				s = yybufmgr__.poptsz();\n\
				yyadd_colno((s == 0)\? -1: -s);\n\
			}\n\
			else if(oldc == \'\\n\') {\n\
				s = yybufmgr__.poplsz();\n\
				yyset_colno(s);\n\
				yyadd_lineno(-1);\n\
			}\n\
			else {\n\
				yyadd_colno(-1);\n\
			}\n\
		}]]>\n\
		</If>\n\
	</If><![[		\n\
		return oldc < END_OF_FILE;\n\
	}\n\
	inline bool yyunget(void) {\n\
		int oldc = yybufmgr__.unget();]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		if(oldc < END_OF_FILE) {\n\
			int s;\n\
			if(oldc == \'\\t\') {\n\
				s = yybufmgr__.poptsz();\n\
				yyadd_colno((s == 0)\? -1: -s);\n\
			}\n\
			else if(oldc == \'\\n\') {\n\
				s = yybufmgr__.poplsz();\n\
				yyset_colno(s);\n\
				yyadd_lineno(-1);\n\
			}\n\
			else {\n\
				yyadd_colno(-1);\n\
			}\n\
		}]]>\n\
		</If>\n\
	</If><![[		\n\
		return oldc < END_OF_FILE;		\n\
	}\n\
	inline void yyterminate(void) {\n\
		yyecode__ = YYE_TERM;\n\
	}\n\
	inline void yyadd_lineno(int nline) {\n\
		yybufmgr__.setlineno(yybufmgr__.getlineno() + nline);\n\
	}\n\
	inline void yyadd_colno(int ncol) {\n\
		yybufmgr__.setcolno(yybufmgr__.getcolno() + ncol);\n\
	}\n\
	inline int yyget_lineno(void) const {\n\
		return yybufmgr__.getlineno();\n\
	}\n\
	inline void yyset_lineno(int nline) {\n\
		yybufmgr__.setlineno(nline);\n\
	}\n\
	inline int yyget_colno(void) const {\n\
		return yybufmgr__.getcolno();\n\
	}\n\
	inline void yyset_colno(int ncol) {\n\
		yybufmgr__.setcolno(ncol);\n\
	}\n\
	inline int yyget_tabsize(void) const {\n\
		return yybufmgr__.gettabsize();\n\
	}\n\
	inline void yyset_tabsize(int ntab) {\n\
		yybufmgr__.settabsize(ntab);\n\
	}\n\
	bool yywrap__(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[) {\n\
		]]><If Has\?\"EOAFAction\"><![[\n\
		// line: ]]><ActLine \"EOAFAction\"/><![[\n\
		]]><Action \"EOAFAction\"/></If>\n\
		<Else><![[\n\
			return false;]]></Else><![[\n\
	}\n\
]]></If><![[\n\
\n\
private:\n\
\n\
	int yyecode__;\n\
]]><If EnableScanner><![[\n\
\n\
	// buffer manager\n\
	bufmgr_t yybufmgr__;\n\
	// start-condition stack\n\
	sstack_t<int, 32, 16> yyscstk__;\n\
	int yysize__;\n\
	int yystart__;\n\
\n\
	bool yymore_flag__;\n\
	bool yyat_bol__;\n\
\n\
	char *yytext;\n\
	int yyleng;\n\
	int yylaleng;\n\
\n\
	]]></If><If EnableParser><![[\n\
	bool yyerr_flag__;\n\
	int yyltok;\n\
	]]><$YY \"lex_t\"/><![[ yylexer;\n\
]]></If><![[\n\
	FILE* yyoutput;\n\
	FILE* yylogger;\n\
	]]><$YY \"error_t\"/><![[ yyerror;\n\
	\n\
private:\n\
	\n\
]]><If EnableScanner><![[\n\
///////////////////////////////////////////////////////////////////////////\n\
	// lexical tables\n\
	// start states of DFAs\n\
	static const int yydsc[]]><Size \"LexStartStates\"/><![[];\n\
\n\
	// @yydcmap is a char map: char -> transition-label,\n\
	// that is, chars are grouped, transition label is\n\
	// representation of equivalent class of chars\n\
	static const int yydcmap[]]><Size \"LexCharMap\"/><![[];\n\
\n\
	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,\n\
	// that is, transition-label in @yydcmap are further grouped in order to save space\n\
	static const int yydmeta[]]><Size \"LexMetaChars\"/><![[];\n\
\n\
	// use next-check-base-default scheme to store DFAs\n\
	// \n\
	static const int yydbase[]]><Size \"LexDFABases\"/><![[];\n\
	static const int yyddef[]]><Size \"LexDFADefaults\"/><![[];\n\
	// next table is an indeed transition table\n\
	static const int yydnxt[]]><Size \"LexDFANexts\"/><![[];\n\
	static const int yydchk[]]><Size \"LexDFAChecks\"/><![[];\n\
	static const int yydaccpt[]]><Size \"LexDFAAccepts\"/><![[];\n\
	\n\
	static char YYMSG_UNMATCHED[];\n\
]]></If><If EnableParser><![[\n\
///////////////////////////////////////////////////////////////////////////////\n\
	// LALR parse tables\n\
	// token map: token ID --> token index in token ID table\n\
	// in fact, it acts like inverse table of token ID table\n\
	static const int yyptmap[]]><Size \"ParseTokenMap\"/><![[];\n\
	// token ID table, which contains token IDs\n\
	//static const int yyptid[]]><Size \"ParseTokenID\"/><![[];\n\
	// number of symbols in a grammar rule\n\
	static const int yyprnum[]]><Size \"ParseRPNum\"/><![[];\n\
	// index of left symbol in a grammar rule\n\
	static const int yyplid[]]><Size \"ParseLPID\"/><![[];\n\
	// parse action table\n\
	static const int yypact[]]><Size \"ParseActEntries\"/><![[];\n\
\n\
	// base array for parse action table\n\
	// which is used to determine the base location of the entries\n\
	// for each state stored in the yypack table\n\
	static const int yypabase[]]><Size \"PActionBases\"/><![[];\n\
	static const int yypgoto[]]><Size \"ParseGotos\"/><![[];\n\
	static const int yypgbase[]]><Size \"PGotoBases\"/><![[];\n\
\n\
	// check table for parse action table\n\
	static const by_te_t yyvbmap[]]><Size \"ParseValidBMap\"/><![[];\n\
	static const int yyparv[]]><Size \"ParseActRowVal\"/><![[];\n\
	static const int yyparn[]]><Size \"ParseActRowNice\"/><![[];\n\
\n\
	static const int yypcv[]]><Size \"ParseColVal\"/><![[];\n\
	static const int yypcn[]]><Size \"ParseColNice\"/><![[];\n\
	static const int yypgrv[]]><Size \"ParseGotoRowVal\"/><![[];\n\
	static const int yypgrn[]]><Size \"ParseGotoRowNice\"/><![[];\n\
]]></If><![[\n\
///////////////////////////////////////////////////////////////////////////////////\n\
	// optional tables, they are available only under certain conditions\n\
]]><If EnableScanner><![[\n\
	// lookahead distant table, only available when there are some lookahead patterns\n\
	// each pattern has its entry of the table\n\
	]]><If Has\?\"LexDFALookaheads\"><![[\n\
	static const int yylad[]]><Size \"LexDFALookaheads\"/><![[];]]></If>\n\
	<If LexDebugMode><![[\n\
	static const char* yydscnam[]]><Size \"LexStartLabels\"/><![[];\n\
	static const int yydline[]]><Size \"LexRule2Lines\"/><![[];]]></If>\n\
</If><If EnableParser><If ParseDebugMode><![[\n\
	static const char* yypsnam[]]><Size \"ParseSymName\"/><![[];\n\
	static const int yyprpbase[]]><Size \"ParseRPBases\"/><![[];\n\
	static const int yyprpidx[]]><Size \"ParseRPIndexes\"/><![[];\n\
	static const int yypline[]]><Size \"ParseRule2Lines\"/><![[];]]></If><![[\n\
]]></If><![[\n\
};\n\
\n\
]]><If EnableScanner><![[\n\
char ]]><$YY \"parser_t\"/><![[::YYMSG_UNMATCHED[] = \"Error: unmatched character ` \\\'.\";\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydsc[]]><Size \"LexStartStates\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexStartStates\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydcmap[]]><Size \"LexCharMap\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexCharMap\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydmeta[]]><Size \"LexMetaChars\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexMetaChars\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydbase[]]><Size \"LexDFABases\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexDFABases\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yyddef[]]><Size \"LexDFADefaults\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexDFADefaults\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydnxt[]]><Size \"LexDFANexts\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexDFANexts\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydchk[]]><Size \"LexDFAChecks\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexDFAChecks\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydaccpt[]]><Size \"LexDFAAccepts\"/><![[] = {\n\
]]>\n\
<$IntArray \"LexDFAAccepts\"/>\n\
<![[\n\
};\n\
]]></If><If EnableParser><![[\n\
// token map: token ID --> token index in token ID table\n\
// in fact, it acts like inverse table of token ID table\n\
const int ]]><$YY \"parser_t\"/><![[::yyptmap[]]><Size \"ParseTokenMap\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseTokenMap\"/>\n\
<![[\n\
};\n\
/*\n\
// token ID table, containing token IDs\n\
const int ]]><$YY \"parser_t\"/><![[::yyptid[]]><Size \"ParseTokenID\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseTokenID\"/>\n\
<![[\n\
};\n\
*/\n\
// prnum table, its element is number of symbols in right part of corresponding grammar rule\n\
const int ]]><$YY \"parser_t\"/><![[::yyprnum[]]><Size \"ParseRPNum\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseRPNum\"/>\n\
<![[\n\
};\n\
\n\
// plid table, its element is the index of left part of corresponding grammar rule in token ID table\n\
const int ]]><$YY \"parser_t\"/><![[::yyplid[]]><Size \"ParseLPID\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseLPID\"/>\n\
<![[\n\
};\n\
\n\
// parse action table\n\
const int ]]><$YY \"parser_t\"/><![[::yypact[]]><Size \"ParseActEntries\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseActEntries\"/>\n\
<![[\n\
};\n\
\n\
// base array for parse action table\n\
// which is used to determine the base location of the entries\n\
// for each state stored in the yypack table\n\
const int ]]><$YY \"parser_t\"/><![[::yypabase[]]><Size \"PActionBases\"/><![[] = {\n\
]]>\n\
<$IntArray \"PActionBases\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypgoto[]]><Size \"ParseGotos\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseGotos\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypgbase[]]><Size \"PGotoBases\"/><![[] = {\n\
]]>\n\
<$IntArray \"PGotoBases\"/>\n\
<![[\n\
};\n\
\n\
const by_te_t ]]><$YY \"parser_t\"/><![[::yyvbmap[]]><Size \"ParseValidBMap\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseValidBMap\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yyparv[]]><Size \"ParseActRowVal\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseActRowVal\"/>\n\
<![[\n\
};\n\
\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yyparn[]]><Size \"ParseActRowNice\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseActRowNice\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypcv[]]><Size \"ParseColVal\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseColVal\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypcn[]]><Size \"ParseColNice\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseColNice\"/>\n\
<![[\n\
};\n\
\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypgrv[]]><Size \"ParseGotoRowVal\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseGotoRowVal\"/>\n\
<![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypgrn[]]><Size \"ParseGotoRowNice\"/><![[] = {\n\
]]>\n\
<$IntArray \"ParseGotoRowNice\"/>\n\
<![[\n\
};\n\
]]></If>\n\
<If EnableScanner>\n\
<If Has\?\"LexDFALookaheads\"><![[\n\
const int ]]><$YY \"parser_t\"/><![[::yylad[]]><Size \"LexDFALookaheads\"/><![[] = {\n\
]]><$IntArray \"LexDFALookaheads\"/><![[\n\
};]]></If>\n\
\n\
<If LexDebugMode><![[\n\
const char* ]]><$YY \"parser_t\"/><![[::yydscnam[]]><Size \"LexStartLabels\"/><![[] = {\n\
]]><$QStrArray \"LexStartLabels\"/><![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yydline[]]><Size \"LexRule2Lines\"/><![[] = {\n\
]]><$IntArray \"LexRule2Lines\"/><![[\n\
};]]></If></If>\n\
<If EnableParser>\n\
<If ParseDebugMode><![[\n\
const char* ]]><$YY \"parser_t\"/><![[::yypsnam[]]><Size \"ParseSymName\"/><![[] = {\n\
]]><$QStrArray \"ParseSymName\"/><![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yyprpbase[]]><Size \"ParseRPBases\"/><![[] = {\n\
]]><$IntArray \"ParseRPBases\"/><![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yyprpidx[]]><Size \"ParseRPIndexes\"/><![[] = {\n\
]]><$IntArray \"ParseRPIndexes\"/><![[\n\
};\n\
\n\
const int ]]><$YY \"parser_t\"/><![[::yypline[]]><Size \"ParseRule2Lines\"/><![[] = {\n\
]]><$IntArray \"ParseRule2Lines\"/><![[\n\
};]]></If></If>\n\
\n\
<![[\n\
\n\
// get global parser object,\n\
// it\'s invisiable to user\n\
static ]]><$YY \"parser_t\"/><![[& getTheParser(void) {\n\
\n\
	static ]]><$YY \"parser_t\"/><![[ yyp]]>\n\
		<If EnableParser><If EnableScanner><![[(]]><$YY \"lex\"/><![[)]]></If></If>\n\
	<![[;\n\
	return yyp;\n\
}\n\
\n\
// assign new log stream\n\
void ]]><$YY \"setstream\"/><![[(FILE *poutput, FILE *plogger) {\n\
\n\
	]]><$YY \"parser_t\"/><![[& yyp = getTheParser();\n\
	yyp.yyoutput = poutput;\n\
	yyp.yylogger = plogger;\n\
}\n\
\n\
void yyemit_error__(const char *s]]><If Has\?\"FormalParams\"><![[, ]]><Action \"FormalParams\"/></If><![[) {\n\
	]]><$YY \"parser_t\"/><![[& yyp = getTheParser();\n\
	if(yyp.yylogger) \n\
		fprintf(yyp.yylogger, \"%s\\n\", s);\n\
}\n\
\n\
// assign new error-reporter and return the old one\n\
]]><$YY \"error_t\"/><![[ ]]><$YY \"seterror\"/><![[(]]><$YY \"error_t\"/><![[ perror) {\n\
\n\
	]]><$YY \"parser_t\"/><![[& yyp = getTheParser();\n\
	]]><$YY \"error_t\"/><![[ pold = yyp.yyerror;\n\
	yyp.yyerror = perror;\n\
\n\
	return pold;\n\
}\n\
\n\
// reset all (both scanner and parser, if they are available)\n\
void ]]><$YY \"clearall\"/><![[(void) {\n\
	getTheParser().yyclearall__();\n\
}\n\
]]>\n\
<If EnableScanner><![[\n\
\n\
// initializing file buffer before parsing or patter-matching\n\
int ]]><$YY \"lexfile\"/><![[(const char* pchFile, bool iMod) {\n\
	\n\
	return getTheParser().yylexinit__(pchFile, iMod)\? 0: -1;\n\
}\n\
// initializing string buffer before parsing or patter-matching\n\
int ]]><$YY \"lexstr\"/><![[(char *strbuffer, int size) {\n\
	return getTheParser().yylexinit__(strbuffer, size)\? 0: -1;\n\
}\n\
// initializing const string buffer before parsing or patter-matching\n\
int ]]><$YY \"lexcstr\"/><![[(const char *strbuffer, int size) {\n\
	return getTheParser().yylexinit__(strbuffer, size)\? 0: -1;\n\
}\n\
\n\
// generated scanner, can be replaced\n\
int ]]><$YY \"lex\"/><![[(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[) {\n\
\n\
	return getTheParser().yylex__(]]><If Has\?\"ActualParams\"><Action \"ActualParams\"/></If><![[);\n\
} \n\
]]></If>\n\
\n\
<If EnableParser><![[\n\
// assign new scanner and return the old one \n\
]]><$YY \"lex_t\"/><![[ ]]><$YY \"setlex\"/><![[(]]><$YY \"lex_t\"/><![[ plex) {\n\
	\n\
	]]><$YY \"parser_t\"/><![[& yyp = getTheParser();\n\
	]]><$YY \"lex_t\"/><![[ pold = yyp.yylexer;\n\
	yyp.yylexer = plex;\n\
\n\
	return pold;\n\
}\n\
\n\
// generated parser, it should not be replaced\n\
int ]]><$YY \"parse\"/><![[(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[) {\n\
	return getTheParser().yyparse__(]]><If Has\?\"ActualParams\"><Action \"ActualParams\"/></If><![[);\n\
}]]></If>\n\
<$SingleAction \"UserCode\"/><![[\n\
\n\
]]>\n\
</Program>\n\
\0\0";


}
