<?Setup DefinitionExtName=".pas"/><Macros>
	<Macro "$FreeToUse">
<![[{
A parser program in Object Pascal, generated by ]]>
<String #0/><![[ ]]><String #1/><![[.
}
]]></Macro>

	<Macro "$YY">
	<Scalar "Prefix"/><Text #0/>
	</Macro>

	<Macro "$ActionLine">
	<Case EnableLineNo><![[
//]]><ActLine #0/><![[ "]]><Scalar "ScriptFileName"/><![["
]]></Case>
	</Macro>
	
	<Macro "$HeaderLine">
	<Case EnableLineNo><![[
//]]><SrcLine/><![[ "]]><Scalar "DeclareFileName"/><![["
]]></Case>
	</Macro>
	
	<Macro "$DeclareAction">
	<Case Has><$ActionLine #0/><Action #0/><$HeaderLine/></Case>
	</Macro>
	
	<Macro "$SourceLine">
	<Case EnableLineNo><![[
//]]><SrcLine/><![[ "]]><Scalar "DefineFileName"/><![["
]]></Case>
	</Macro>

	<Macro "$SingleAction">
	<Case Has><$ActionLine #0/><Action #0/><$SourceLine/></Case>
	</Macro>

	<Macro "$CodeBlock">
	<Case Has><![[begin
	]]><$ActionLine #0/><Action #0/><$SourceLine/>
	<![[
	end;
]]></Case>
	</Macro>

	<Macro "$UserLexActions">
<Case End><GoFirst/></Case>
<Case GroupFlag><![[: begin
	]]><$SingleAction #1/><Skip #0/><![[
	end;
	]]><$UserLexActions/></Case>
<Case GroupFirst><Integer #0/><$UserLexActions/></Case>
<Default><![[, ]]><Integer #0/><$UserLexActions/></Default>
	</Macro>

	<Macro "$UserParseActions">
<Case End><GoFirst/></Case>
<Case GroupFlag><![[: begin ]]><$SingleAction #1/><Skip #0/><![[
	end;
	]]><$UserParseActions/></Case>
<Case GroupFirst><Integer #0/><$UserParseActions/></Case>
<Default><![[, ]]><Integer #0/><$UserParseActions/></Default>
	</Macro>

	<Macro "$UserDiscardActions">
<Case End><GoFirst/></Case>
<Case GroupFlag><![[: begin ]]><$SingleAction #1/><Skip #0/><![[ end;
	]]><$UserDiscardActions/></Case>
<Case GroupFirst><Integer #0/><$UserDiscardActions/></Case>
<Default><![[, ]]><Integer #0/><$UserDiscardActions/></Default>
	</Macro>

	<Macro "$IntArray">
<Case Last><Integer #0/><GoFirst/></Case>
<Case Mod?8><Integer #0/><![[,
	]]><$IntArray/></Case>
<Default><Integer #0/><![[,	]]><$IntArray/></Default>
	</Macro>

	<Macro "$QStrArray">
<Case Last><![[']]><String #0/><![[']]><GoFirst/></Case>
<Case Mod?8><![[']]><String #0/><![[',
	]]><$QStrArray/></Case>
<Default><![[']]><String #0/><![[',	]]><$QStrArray/></Default>
	</Macro>

	<Macro "$ConstsDefine">
<Case End><GoFirst/></Case>
<Default><String #0/><![[ = ]]><Integer #1/><![[;
]]><$ConstsDefine/></Default>
	</Macro>

	<Macro "$SVNAME_LEFT"><![[yyval.]]><Text #0/></Macro>
	<Macro "$SVNAME_RIGHT"><![[yys_sv__.getat(]]><Text #0/><![[)^.sv.]]><Text #1/></Macro>
	<Macro "$SVLOC_LEFT"><![[yyloc]]></Macro>
	<Macro "$SVLOC_RIGHT"><![[yys_loc__.getat(]]><Text #0/><![[)^]]></Macro>
	<Macro "$SVNAME_DSTRCT"><![[yydval.]]><Text #0/></Macro>
	<Macro "$SVLOC_DSTRCT"><![[yydloc]]></Macro>

	<Macro "$TypeName">
		<Case Has><Action #0/></Case>
		<Default><Scalar "Prefix"/><Text #1/></Default>
	</Macro>
</Macros>

<Program>
<Define/>
<$FreeToUse "SoftwareName" "SoftwareVersion"/>
<![[
unit ]]><String "FileBaseName"/><![[;
interface
]]><$DeclareAction "DeclareHeader"/><![[
const
	PAS_EOF = #26; {ctrl+z}
]]>
<If EnableParser><![[
//token ID definition
]]><$ConstsDefine "ParseTokenNames" "ParseTokenValues"/>
</If>
<If EnableScanner><![[
	END_OF_FILE = 256;
	END_OF_ALLFILE = 257;

// start-condition names
]]><$ConstsDefine "LexStartLabels" "LexStartIndexes"/><![[
// number of DFA states of scanner
	LEX_STATE_COUNT = ]]><Integer "LexDefaultState"/><![[;

// DFA trap-state of scanner
	LEX_ERROR_STATE = ]]><Integer "LexErrorState"/><![[;

// ID of invalid rule for scanner,
// indicating current string can not be matched by any pattern
	LEX_ERROR_RULE = ]]><Integer "LexErrorRule"/><![[;

// this constant used by computing index of a rule that matches EOF
// for example, in start-condition INITIAL, index of the rule that
// matches EOF is 
//	LEX_EOFRULE_BASE + INITIAL
	LEX_EOFRULE_BASE = ]]><Integer "LexEOFRuleBase"/><![[;

// index of the rule that matches EOAF (end of all files, or end of input)
	LEX_EOAF_RULE = ]]><Integer "LexEOFARuleIndex"/><![[;
]]>
</If><![[
// index of symbol `$end' in symbol table
	PARSE_ENDSYMB_INDEX = ]]><Integer "ParseEndSymbIdx"/><![[;
// index of symbol `error' in symbol table
	PARSE_ERRORSYMB_INDEX = ]]><Integer "ParseErrorSymbIdx"/><![[;
// index of symbol `$undef' in symbol table
	PARSE_UNDEFSYMB_INDEX = ]]><Integer "ParseUndefSymbIdx"/><![[;

// ID of symbol `$end'
	PARSE_ENDSYMB_ID = ]]><Integer "ParseEndSymbID"/><![[;
// ID of symbol `error'
	PARSE_ERRORSYMB_ID = ]]><Integer "ParseErrorSymbID"/><![[;
// ID of symbol '$undef'
	PARSE_UNDEFSYMB_ID = ]]><Integer "ParseUndefSymbID"/><![[;
]]>
<If EnableParser><![[
// row size(in byte) of non-error bitmap of parse table
	PARSE_BMAP_ROWSIZE = ]]><Integer "ParseBMapRowSize"/><![[;
// base address of indexes of types (aka non-terminals or variables)
	PARSE_TYPE_BASE = ]]><Integer "ParseTypeBase"/><![[;
// number of symbols in parser
	PARSE_SYMBOL_COUNT = ]]><Integer "ParseSymbolNum"/><![[;

// number of symbols in parser
	PARSE_TOKENMAP_SIZE = ]]><Size "ParseTokenMap"/><![[;

// start state of parser
	PARSE_START_STATE = ]]><Integer "ParseStartState"/><![[;

// accept state of parser
	PARSE_ACCEPT_STATE = ]]><Integer "ParseAcceptState"/><![[;

// illegal state for parser
	PARSE_ERROR_STATE = ]]><Integer "ParseErrorState"/><![[;

// special ID of invalid rule for parser, indicating current lookahead
// symbol can not be shifted
	PERROR_RULE = ]]><Integer "ParseErrorRule"/><![[;
]]>
</If><![[	
type
// function type for error-reporting
	]]><$YY "error_t"/><![[ = procedure (msg: string]]><If Has?"FormalParams"><![[; ]]><Action "FormalParams"/></If><![[);
]]>
<If EnableParser><![[// function type for scanning
	]]><$YY "lex_t"/><![[ = function (]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[): integer;
]]>
	<If Has?"LTypeName"><![[
// location type is defined by user as ]]><Action "LTypeName"/>
	</If>
	<Else><![[
// location defines here
	]]><$YY "ltype_t"/><![[ = record
	]]><If Has?"LTypeDeclare"><Action "LTypeDeclare"/></If>
		<Else><![[firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
	]]>
		</Else><![[
	end;
]]>
	</Else>
	<If Has?"STypeName"><![[
// semantic value type defined by user as ]]><Action "STypeName"/>
	</If>
	<Else><![[
// semantic value type define here
	]]><$YY "stype_t"/><![[ = record
	]]>
		<If Has?"STypeDeclare"><Action "STypeDeclare"/>
		</If>
		<Else><![[nVal: integer;]]>
		</Else><![[
	end;

]]>
	</Else><![[
	xstype_t = ]]><$TypeName "STypeName" "stype_t"/><![[;
	xltype_t = ]]><$TypeName "LTypeName" "ltype_t"/><![[;
]]>
</If>

<If EnableScanner><![[
// initializing file buffer before parsing or patter-matching
	function ]]><$YY "lexfile"/><![[(pchFile: string; iMod: boolean = false): integer;
// initializing string buffer before parsing or patter-matching
	function ]]><$YY "lexstr"/><![[(strbuf: pchar; size: integer): integer;
// initializing const string buffer before parsing or patter-matching
	function ]]><$YY "lexcstr"/><![[(strbuf: pchar; size: integer): integer;

// generated scanner, can be replaced
	function ]]><$YY "lex"/><If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: integer;

]]>
</If>
<If EnableParser><![[
// generated parser, it should not be replaced
	function ]]><$YY "parse"/><![[(]]><If Has?"FormalParams"><Action "FormalParams"/></If><![[): integer;
// assign new scanner and return the old one
	function ]]><$YY "setlex"/><![[(plex: ]]><$YY "lex_t"/><![[):]]><$YY "lex_t"/><![[;
]]>
</If><![[
// assign new error-reporter and return the old one
	function ]]><$YY "seterror"/><![[(perror: ]]><$YY "error_t"/><![[): ]]><$YY "error_t"/><![[;
// reset all (both scanner and parser, if they are available)
	procedure ]]><$YY "clearall"/><![[;
]]>
<If EnableParser><![[
var
	]]><$YY "lval"/><![[: xstype_t;
	]]><$YY "lloc"/><![[: xltype_t;
]]>
</If>
<If EnableScanner><![[
const
	CYCSTACK_SIZE = 64;
	
type
	pfile_t = ^file;
	bufbase_t = class;
	YYPBUFFER = bufbase_t;
]]>
	<If EnableLocation>
		<If EnableColumn><![[
	cycstack_t = class
	private
		el: array [0..CYCSTACK_SIZE - 1] of smallint;
		bs: smallint;
		tp: smallint;
	public
		constructor create;
		procedure push(n: integer);
		function pop: integer;
		procedure clear;
	end;]]>
		</If>
	</If><![[
	bufbase_t = class
	protected
		pbase, gptr, gend: pchar;
		eos, imod: boolean;
		line, col, tab: integer;
		pvoid: pointer;

	public
		constructor create;
		procedure reset; virtual;
		function get: integer; virtual; abstract;
		function peek: integer; virtual; abstract;
		function unget: integer; overload; virtual; abstract;
		function unget(num: integer): integer; overload; virtual; abstract;
		function put(c: char): integer; virtual; abstract;

		function iseof: boolean;
		function iseos: boolean;
		function isimod: boolean;
		procedure setimod(bi: boolean);
		function getlineno: integer;
		procedure setlineno(nline: integer);
		function getcolno: integer;
		procedure setcolno(ncol: integer);
		function gettabsize: integer;
		procedure settabsize(ntab: integer);
		function getdata: pointer;
		procedure setdata(pv: pointer);
]]>
	<If EnableLocation>
		<If EnableColumn><![[
	private
		stlsz: cycstack_t;
		sttsz: cycstack_t;
	public
		procedure pushlsz(nlsize: integer);
		function poplsz: integer;
		procedure pushtsz(ntsize: integer);
		function poptsz: integer;]]>
		</If>
	</If><![[
	end;
]]></If>
<![[
implementation
]]>
<$SingleAction "DefineHeader"/>
<![[
const
	PAS_EOF__ = #26; {ctrl+z}
	MAX_MSG_LENG = 64;
	INIT_YYTEXT_SIZE = 4096;
	INC_YYTEXT_SIZE = 2048;
	SSTACK_INIT_SIZE = 1024;
	SSTACK_INC_SIZE = 1024;
	BUF_HALF_SIZE = 8192;
	BUF_FULL_SIZE = BUF_HALF_SIZE * 2;

	// grammar is accepted by automation
	YYE_ACCEPT = 1;
	// indicate automation is alive
	YYE_ALIVE = 2;
	// run out of all buffers,
	// and token `$end' will be sent to parser
	YYE_EOS = 3;
	// lexical analysis terminated manually,
	// and token `$end' will be sent to parser
	YYE_TERM = 3;
	// syntactic error occurs, and try to error-recover
	YYE_PERROR = 4;

	// can not match any pattern, token `$undef' will
	// be sent to parser
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID;

	// out of memory
	YYE_OOM = -1;
	// out of range
	YYE_OOR = -2;
	// I/O error
	YYE_IO = -3;
	// parsing aborted
	YYE_ABORT = -4;
	YYE_NOINPUT = -5;
	
]]>
<If EnableScanner><![[
///////////////////////////////////////////////////////////////////////////
	// lexical tables
	// start states of DFAs
	yydsc: array[0..]]><Size "LexStartStates"/><![[ - 1] of integer = (
	]]><$IntArray "LexStartStates"/>
	<![[	
	);

	// @yydcmap is a char map: char -> transition-label,
	// that is, chars are grouped, transition label is
	// representation of equivalent class of chars
	yydcmap: array[0..]]><Size "LexCharMap"/><![[ - 1] of integer = (
	]]><$IntArray "LexCharMap"/>
	<![[
	);

	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,
	// that is, transition-label in @yydcmap are further grouped in order to save space
	yydmeta: array[0..]]><Size "LexMetaChars"/><![[ - 1] of integer = (
	]]><$IntArray "LexMetaChars"/>
	<![[	
	);

	// use next-check-base-default scheme to store DFAs
	// 
	yydbase: array[0..]]><Size "LexDFABases"/><![[ - 1] of integer = (
	]]><$IntArray "LexDFABases"/>
	<![[	
	);
	yyddef: array[0..]]><Size "LexDFADefaults"/><![[ - 1] of integer = (
	]]><$IntArray "LexDFADefaults"/>
	<![[	
	);
	// next table is an indeed transition table
	yydnxt: array[0..]]><Size "LexDFANexts"/><![[ - 1] of integer = (
	]]><$IntArray "LexDFANexts"/>
	<![[	
	);
	yydchk: array[0..]]><Size "LexDFAChecks"/><![[ - 1] of integer = (
	]]><$IntArray "LexDFAChecks"/>
	<![[	
	);
	yydaccpt: array[0..]]><Size "LexDFAAccepts"/><![[ - 1] of integer = (
	]]><$IntArray "LexDFAAccepts"/>
	<![[	
	);
	YYMSG_UNMATCHED: pchar = 'Error: unmatched character ` ''.';
]]>
	<If Has?"LexDFALookaheads"><![[
	yylad: array[0..]]><Size "LexDFALookaheads"/><![[ - 1] of integer = (
	]]><$IntArray "LexDFALookaheads"/><![[
	);]]>
	</If>

	<If LexDebugMode><![[
	yydscnam: array[0..]]><Size "LexStartLabels"/><![[ - 1] of pchar = (
	]]><$QStrArray "LexStartLabels"/><![[
	);

	yydline: array[0..]]><Size "LexRule2Lines"/><![[ - 1] of integer = (
	]]><$IntArray "LexRule2Lines"/><![[
	);]]>
	</If>
</If>
<If EnableParser><![[
	// token map: token ID --> token index in token ID table
	// in fact, it acts like inverse table of token ID table
	yyptmap: array[0..]]><Size "ParseTokenMap"/><![[ - 1] of integer = (
	]]><$IntArray "ParseTokenMap"/>
<![[
	);
{
	// token ID table, containing token IDs
	yyptid: array[0..]]><Size "ParseTokenID"/><![[ - 1] of integer = (
	]]><$IntArray "ParseTokenID"/>
<![[
	);
}
	// prnum table, its element is number of symbols in right part of corresponding grammar rule
	yyprnum: array[0..]]><Size "ParseRPNum"/><![[ - 1] of integer = (
	]]><$IntArray "ParseRPNum"/>
<![[
	);

	// plid table, its element is the index of left part of corresponding grammar rule in token ID table
	yyplid: array[0..]]><Size "ParseLPID"/><![[ - 1] of integer = (
	]]><$IntArray "ParseLPID"/>
<![[
	);

	// parse action table
	yypact: array[0..]]><Size "ParseActEntries"/><![[ - 1] of integer = (
	]]><$IntArray "ParseActEntries"/>
<![[
	);

	// base array for parse action table
	// which is used to determine the base location of the entries
	// for each state stored in the yypack table
	yypabase: array[0..]]><Size "PActionBases"/><![[ - 1] of integer = (
	]]><$IntArray "PActionBases"/>
<![[
	);

	yypgoto: array[0..]]><Size "ParseGotos"/><![[ - 1] of integer = (
	]]><$IntArray "ParseGotos"/>
<![[
	);

	yypgbase: array[0..]]><Size "PGotoBases"/><![[ - 1] of integer = (
	]]><$IntArray "PGotoBases"/>
<![[
	);

	yyvbmap: array[0..]]><Size "ParseValidBMap"/><![[ - 1] of byte = (
	]]><$IntArray "ParseValidBMap"/>
<![[
	);

	yyparv: array[0..]]><Size "ParseActRowVal"/><![[ - 1] of integer = (
	]]><$IntArray "ParseActRowVal"/>
<![[
	);


	yyparn: array[0..]]><Size "ParseActRowNice"/><![[ - 1] of integer = (
	]]><$IntArray "ParseActRowNice"/>
<![[
	);

	yypcv: array[0..]]><Size "ParseColVal"/><![[ - 1] of integer = (
	]]><$IntArray "ParseColVal"/>
<![[
	);

	yypcn: array[0..]]><Size "ParseColNice"/><![[ - 1] of integer = (
	]]><$IntArray "ParseColNice"/>
<![[
	);


	yypgrv: array[0..]]><Size "ParseGotoRowVal"/><![[ - 1] of integer = (
	]]><$IntArray "ParseGotoRowVal"/>
<![[
	);

	yypgrn: array[0..]]><Size "ParseGotoRowNice"/><![[ - 1] of integer = (
	]]><$IntArray "ParseGotoRowNice"/>
<![[
	);
]]>
	<If ParseDebugMode><![[
	yypsnam: array[0..]]><Size "ParseSymName"/><![[ - 1] of pchar = (
	]]><$QStrArray "ParseSymName"/><![[
	);

	yyprpbase: array[0..]]><Size "ParseRPBases"/><![[ - 1] of integer = (
	]]><$IntArray "ParseRPBases"/><![[
	);

	yyprpidx: array[0..]]><Size "ParseRPIndexes"/><![[ - 1] of integer = (
	]]><$IntArray "ParseRPIndexes"/><![[
	);

	yypline: array[0..]]><Size "ParseRule2Lines"/><![[ - 1] of integer = (
	]]><$IntArray "ParseRule2Lines"/><![[
	);]]>
	</If>
</If><![[
type
]]>
<If EnableScanner><![[
	
	filebuf_t = class(bufbase_t)
	private
		bpeeked: boolean;
		pfile: pfile_t;
		_buf: array[0..BUF_FULL_SIZE - 1] of char;
		buf: pchar;
	private
		procedure init;
		function fill(p: pchar): integer;
	public
		constructor create(pf: pfile_t = nil; bm: boolean = false);
		destructor destroy; override;
	public
		procedure reset; override;
		function get: integer; override;
		function peek: integer; override;
		function unget: integer; override;
		function unget(num: integer): integer; override;
		function put(c: char): integer; override;
	end;
  
	strbuf_t = class(bufbase_t)
	private
		bowner: boolean;
	public
		constructor create(pchbuf: pchar; nsize: integer;
		  bown: boolean = false);
		destructor destroy; override;
	public
		procedure reset; override;
		function get: integer; override;
		function peek: integer; override;
		function unget: integer; override;
		function unget(num: integer): integer; override;
		function put(c: char): integer; override;
	end;

	plink_t = ^link_t;
	link_t = record
		pxbuf: YYPBUFFER;
		plink: plink_t;
	end;
  
	bufmgr_t = class
	private
		phead, pavail: plink_t;
		xstdin: bufbase_t;
		oldfmode: byte;
	public
		constructor create;
		destructor destroy; override;
		function get: integer;
		function peek: integer;
		function unget: integer; overload;
		function unget(num: integer): integer; overload;
		function put(c: char): integer;
		function iseof: boolean;
		function iseos: boolean;
		function isimod: boolean;
		function getlineno: integer;
		procedure setlineno(nline: integer);
		function getcolno: integer;
		procedure setcolno(ncol: integer);
		function gettabsize: integer;
		procedure settabsize(ntab: integer);
		procedure reset;
]]>
	<If EnableLocation>
		<If EnableColumn><![[
		procedure pushlsz(nlsize: integer);
		function poplsz: integer;
		procedure pushtsz(ntsize: integer);
		function poptsz: integer;]]>
		</If>
	</If><![[	
		function current: YYPBUFFER;
		function empty: boolean;
		function newbuf(pf: pfile_t; im: boolean = false): YYPBUFFER; overload;
		function newbuf(pcbuf: pchar; nsize: integer;
		  bown: boolean = false): YYPBUFFER; overload;
		function switchto(pbuf: YYPBUFFER): YYPBUFFER;
		function pop: YYPBUFFER;
		procedure destroytop;
		procedure destroyall;
	private
		function rmwork(pxb: YYPBUFFER): plink_t;
  end;
]]>
</If>
<![[
	istack_item_t = integer;
	pistack_item_t = ^istack_item_t;
	
	istack_t = class
	private
		el: pistack_item_t;
		tp: integer;
		sz: integer;
	public
		constructor create;
		destructor destroy; override;
		procedure push; overload;
		procedure push(ss: integer); overload;
		function top: integer;
		procedure pop(n: integer);
		function getat(n: integer): integer;
		function empty: boolean;
		function count: integer;
		procedure clear;
	end;
]]>
<If EnableParser><![[
	sstack_item_t = record
		sid: integer;
		sv: xstype_t;
	end;
  
	psstack_item_t = ^sstack_item_t;
    
	sstack_t = class
	private
		el: psstack_item_t;
		tp: integer;
		sz: integer;
	public
		constructor create;
		destructor destroy; override;
		procedure push; overload;
		procedure push(sid: integer; sv: xstype_t); overload;

		function top: psstack_item_t;
		procedure pop(n: integer);
		function getat(n: integer): psstack_item_t;
		function empty: boolean;
		function count: integer;
	end;]]>
	<If EnableLocation><![[
	
	plstack_item_t = ^xltype_t;
	lstack_t = class
	private
		el: plstack_item_t;
		tp: integer;
		sz: integer;
	public
		constructor create;
		destructor destroy; override;
		procedure push; overload;
		procedure push(e: xltype_t); overload;
		function top: plstack_item_t;
		procedure pop(n: integer);
		function getat(n: integer): plstack_item_t;
		function empty: boolean;
		function count: integer;
	end;
]]>
	</If>
</If>
<![[	]]><$YY "parser_t"/><![[ = class
	private
	 	yyecode__: integer;
	 	yyerror: ]]><$YY "error_t"/><![[;]]>
<If EnableScanner><![[
		yybufmgr__: bufmgr_t;
		yyscstk__: istack_t;
		yysize__: integer;
		yystart__: integer;
		yymore_flag__: boolean;
		yyat_bol__: boolean;
		
		yytext: pchar;
		yyleng: integer;
		yylaleng: integer;
	private
		function renew_text__: boolean;
		function yylex_is_running__: boolean;
		function yyget_lexrule__(s: integer): integer;
		function yynext_lexstate__(s, c: integer): integer;
]]>
</If>
<If EnableParser><![[
	private
		yyerr_flag__: boolean;
		yyltok: integer;
		yylexer: ]]><$YY "lex_t"/><![[;
		
		procedure YYACCEPT;
		procedure YYABORT;
		procedure yyerrok;
		function yyparse_is_running__(s: integer): boolean;
		function yyget_defrule(s: integer): integer;
		function is_valid_pstate__(s: integer): boolean;
		function is_valid_prule__(r: integer): boolean;
		function yyget_prule__(s: integer): integer;
		procedure yydiscard__(var yydval: xstype_t; var yydloc: xltype_t; yydsymb: integer]]>
		<If Has?"FormalParams"><![[;]]><Action "FormalParams"/></If><![[);
		function yynext_pstate__(s, t: integer): integer;
		function yynext_goto__(s, t: integer): integer;
		function yyparse__]]>
		<If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: integer;
]]>
</If><![[
	public
		constructor create]]>
<If EnableParser>
		<![[(]]><![[plex: ]]><$YY "lex_t"/><![[ = nil)]]>
</If><![[;
		destructor destroy; override;
		procedure yyclearall__;
]]>
<If EnableScanner><![[
		function yylexinit__(pchFile: string; bi: boolean): boolean; overload;
		function yylexinit__(strbuf: pchar; size: integer; bcopied: boolean): boolean; overload;
		function yylex__]]>
		<If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: integer;
	private
		// user interfaces
		// easy way to print matched string
		procedure YYECHO;
		procedure ECHO;
		// switch start-condition
		procedure YYBEGIN(sc: integer);
		// return current start-condition
		function YYSTART: integer;
		// save current start-condition and switch to new start-condition
		procedure yy_push_state(nsc: integer);
		// switch to last saved start-condition
		function yy_pop_state: boolean;
		// return last saved start-condition
		function yy_top_state: integer;
		// get/set flag of beginning-of-line
		function yy_get_bol: boolean;
		procedure yy_set_bol(b: boolean);
		
		// buffer operations
		function yy_current_buffer: YYPBUFFER;
		function yy_has_buffer: boolean;
		procedure yy_push_buffer(pbuffer: YYPBUFFER);
		function yy_pop_buffer: YYPBUFFER;
		function yy_new_filebuf(strfile: string; bi: boolean = false): YYPBUFFER;
		function yy_new_cstrbuf(cstrbuf: pchar; size: integer): YYPBUFFER;
		function yy_new_strbuf(strbuf: pchar; size: integer): YYPBUFFER;
		procedure yy_delete_buffer;
		procedure yy_switch_buffer(buf: YYPBUFFER);
		procedure yyrestart;
		procedure yymore;
		function yyless(n: integer): integer;
		function yyinput: integer;
		function yyunput(c: char): boolean;
		function yyunget: boolean;
		procedure yyterminate;
		procedure yyadd_lineno(nline: integer);
		procedure yyadd_colno(ncol: integer);
		function yyget_lineno: integer;
		procedure yyset_lineno(nline: integer);
		function yyget_colno: integer;
		procedure yyset_colno(ncol: integer);
		function yyget_tabsize: integer;
		procedure yyset_tabsize(ntab: integer);
		function yywrap__]]><If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: boolean;
]]></If><![[
	end;
]]>
<If EnableScanner>
	<If EnableLocation>
		<If EnableColumn><![[
	//////////////////////////////////////////////////////////////
	// class cycstack_t
	constructor cycstack_t.create;
	begin
		inherited;
		bs := 0;
		tp := 0;
	end;

	procedure cycstack_t.push(n: integer);
	begin
		tp := (tp + 1) mod CYCSTACK_SIZE;
		el[tp] := smallint(n);
		if tp = bs then bs := (tp + 1) mod CYCSTACK_SIZE;
	end;

	function cycstack_t.pop: integer;
	begin

		if tp = bs then pop := 0   
		else
		begin
			pop := integer(el[tp]);
			tp := (tp + CYCSTACK_SIZE - 1) mod CYCSTACK_SIZE;
		end;
	end;

	procedure cycstack_t.clear;
	begin
	tp := bs;
	end;
	// class cycstack_t
	///////////////////////////////////////////////////////////////
]]>
		</If>
	</If><![[
	///////////////////////////////////////////////////////////////
	// class bufbase_t
	constructor bufbase_t.create;
	begin
		inherited;
]]>
	<If EnableLocation>
		<If EnableColumn><![[
		stlsz := cycstack_t.create;
		sttsz := cycstack_t.create;
]]>
		</If>
	</If><![[
		line := 1;
		col := 1;
		tab := 4;
		pvoid := nil;
		imod := false;
	end;
  
	procedure bufbase_t.reset;
	begin]]>
	<If EnableLocation>
		<If EnableColumn><![[
		stlsz.clear;
		sttsz.clear;
]]>
		</If>
    </If><![[    
	end;
  
	function bufbase_t.iseof: boolean;
	begin
		iseof := (gptr = gend);
	end;
  
	function bufbase_t.iseos: boolean;
	begin
		iseos := eos;
	end;
  
	function bufbase_t.isimod: boolean;
	begin
		isimod := imod;
	end;
  
	procedure bufbase_t.setimod(bi: boolean);
	begin
		imod := bi;
	end;
  
	function bufbase_t.getlineno: integer;
	begin
		getlineno := line;
	end;
  
	procedure bufbase_t.setlineno(nline: integer);
	begin
		line := nline;
	end;
  
	function bufbase_t.getcolno: integer;
	begin
		getcolno := col;
	end;
  
	procedure bufbase_t.setcolno(ncol: integer);
	begin
		col := ncol;
	end;
  
	function bufbase_t.gettabsize: integer;
	begin
		gettabsize := tab;
	end;

	procedure bufbase_t.settabsize(ntab: integer);
	begin
		tab := ntab;
	end;

	function bufbase_t.getdata: pointer;
	begin
		getdata := pvoid;
	end;

	procedure bufbase_t.setdata(pv: pointer);
	begin
		pvoid := pv;
	end;

]]>
	<If EnableLocation>
		<If EnableColumn><![[  
	procedure bufbase_t.pushlsz(nlsize: integer);
	begin
		stlsz.push(nlsize);
	end;

	function bufbase_t.poplsz: integer;
	begin
		poplsz := stlsz.pop;
	end;

	procedure bufbase_t.pushtsz(ntsize: integer);
	begin
		sttsz.push(ntsize);
	end;

	function bufbase_t.poptsz: integer;
	begin
		poptsz := sttsz.pop;
	end;
]]>
		</If>
	</If><![[
	// class bufbase_t
	///////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////
	// class filebuf_t
	procedure filebuf_t.init;
	begin
		gend := buf;
		gptr := gend + BUF_FULL_SIZE - 1;
		pbase := gptr;
		gptr^ := #10;
		eos := false;
		bpeeked := false;

		if pfile <> @input then
			system.reset(pfile^, 1);
	end;

	function filebuf_t.fill(p: pchar): integer;
	var
		ncnt, vacents: integer;
		c: char;
	begin
		ncnt := 0;
		vacents := ((pbase + BUF_FULL_SIZE) - gend) mod BUF_FULL_SIZE;

		if pfile <> @input then
		begin
			{$I-}
			blockread(pfile^, p^, BUF_HALF_SIZE, ncnt);
			{$I+}
		
			if ncnt > 0 then
				gend := buf + ((p - buf) + ncnt) mod BUF_FULL_SIZE;
		end
		else
		begin
			c := #0;
		  while (c <> #10) and (ncnt < BUF_HALF_SIZE) do
		  begin
			{$I-}
			read(input, c);
			{$I+}
			gend^ := c;
	
			if c = PAS_EOF__ then break;
		
			gend := buf + ((gend - buf) + 1) mod BUF_FULL_SIZE;
			ncnt := ncnt + 1;
			end; 
		end;

		if ncnt > vacents then
			pbase := buf + ((gend - buf) + 1) mod BUF_FULL_SIZE;
		  
		fill := ncnt;
	end;
	
	constructor filebuf_t.create(pf: pfile_t; bm: boolean);
	begin
		inherited create;

		if pf = nil then pfile := @input
		else pfile := pf;

		buf := @_buf;
		imod := bm;
		init;
	end;

	destructor filebuf_t.destroy;
	begin
		if pfile <> @input then
		begin
			closefile(pfile^);
			dispose(pfile);
		end;    	
	end;

	procedure filebuf_t.reset;
	begin
		if pfile <> @input then seek(pfile^, 0);

		init;
		inherited reset;
	end;

	function filebuf_t.get: integer;
	begin
		if gptr = gend then
		begin
			eos := true;
			get := END_OF_ALLFILE;
		end
		else
		begin
			gptr := buf + ((gptr - buf) + 1) mod BUF_FULL_SIZE;

			if (gptr = gend) and (not bpeeked) then
			begin
				fill(gptr);
				bpeeked := false;
			end;

			if iseof then get := END_OF_FILE
			else get := integer(gptr^);
		end;
	end;

	function filebuf_t.peek: integer;
	var
		p: pchar;
	begin
		if gptr = gend then peek := END_OF_ALLFILE
		else begin
			p := buf + ((gptr - buf) + 1) mod BUF_FULL_SIZE;
			if p = gend then fill(p);
			bpeeked := true;

			if p = gend then peek := END_OF_FILE
			else peek := integer(p^);
		end;
	end;

	function filebuf_t.unget: integer;
	begin
		if eos or (gptr = pbase) then unget := END_OF_FILE
		else begin
			unget := integer(gptr^);
			gptr := buf + ((gptr - buf) + BUF_FULL_SIZE - 1) mod BUF_FULL_SIZE;
		end;
	end;

	function filebuf_t.unget(num: integer): integer;
	var
		n: integer;
	begin
		if eos or (gptr = pbase) then unget := 0
		else
		begin
			n := ((gptr - pbase) + BUF_FULL_SIZE) mod BUF_FULL_SIZE;
			if n > num then n := num;

			gptr := buf + ((gptr - buf) + BUF_FULL_SIZE - n) mod BUF_FULL_SIZE;
			unget := n;
		end;
	end;

	function filebuf_t.put(c: char): integer;
	begin
		if eos or (gptr = pbase) then put := END_OF_FILE
		else begin
			put := integer(gptr^);
			gptr^ := c;
			gptr := buf + ((gptr - buf) + BUF_FULL_SIZE - 1) mod BUF_FULL_SIZE;
		end;
	end;
	// filebuf_t
	///////////////////////////////////////////////////////////////
  
	///////////////////////////////////////////////////////////////
	// strbuf_t
	constructor strbuf_t.create(pchbuf: pchar; nsize: integer; bown: boolean);
	var
		i: integer;
	begin
		inherited create;
		bowner := bown;
		if bowner then begin
			getmem(pbase, nsize);
			if pbase = nil then
			begin
				halt(1); { unrecoverable error }
			end;
			for i := 0 to nsize - 1 do
				pbase[i] := pchbuf[i];
			gend := pbase + nsize - 1;
			gend^ := #0;
		end
		else begin
			pbase := pchbuf;
			gend := pbase + nsize - 1;
		end;

		reset;
	end;

	destructor strbuf_t.destroy;
	begin
		if bowner then freemem(pbase);
	end;

	procedure strbuf_t.reset;
	begin
		gptr := pbase - 1;
		eos := false;
		inherited reset;
	end;

	function strbuf_t.get: integer;
	begin
		if gptr = gend then begin
			eos := true;
			get := END_OF_ALLFILE;
		end
		else begin
			gptr := gptr + 1;
			if gptr = gend then get := END_OF_FILE
			else get := integer(gptr^);
		end;
	end;

	function strbuf_t.peek: integer;
	begin
		if gptr = gend then begin
			if eos then peek := END_OF_ALLFILE
			else peek := END_OF_FILE;
		end
		else peek := integer((gptr + 1)^);
	end;

	function strbuf_t.unget: integer;
	begin
		if eos or (pbase - 1 = gptr) then unget := END_OF_FILE
		else begin
			unget := integer(gptr^);
			gptr := gptr - 1;
		end;
	end;

	function strbuf_t.unget(num: integer): integer;
	var
		n: integer;
	begin
		if eos or (pbase - 1 = gptr) then unget := 0
		else
		begin
			n := gptr - pbase + 1;
			if n > num then n := num;
			gptr := gptr - n;
			unget := n;
		end;
	end;

	function strbuf_t.put(c: char): integer;
	begin
		if eos or (pbase - 1 = gptr) then put := END_OF_FILE
		else begin
			put := integer(gptr^);
			gptr^ := c;
			gptr := gptr - 1;
		end;
	end;
	// class strbuf_t
	///////////////////////////////////////////////////////////////
  
	///////////////////////////////////////////////////////////////
	// class bufmgr_t
	constructor bufmgr_t.create;
	begin
		xstdin := filebuf_t.create(nil, true);
		new(pavail);
		pavail^.pxbuf := xstdin;
		pavail^.plink := nil;

		oldfmode := FileMode;
		FileMode := 0;
	end;

	destructor bufmgr_t.destroy;
	var
		p: plink_t;
	begin
		while pavail <> nil do begin
			p := pavail^.plink;
			pavail^.pxbuf.destroy;
			dispose(pavail);

			pavail := p;
		end;

		FileMode := oldfmode;
	end;

	function bufmgr_t.get: integer;
	begin
		if phead <> nil then get := phead^.pxbuf.get
		else get:= END_OF_ALLFILE;
	end;

	function bufmgr_t.peek: integer;
	begin
		if phead <> nil then peek := phead^.pxbuf.peek
		else peek := END_OF_ALLFILE;
	end;

	function bufmgr_t.unget: integer;
	begin
		if phead <> nil then unget := phead^.pxbuf.unget
		else unget := END_OF_FILE;
	end;

	function bufmgr_t.unget(num: integer): integer;
	begin
		if phead <> nil then unget := phead^.pxbuf.unget(num)
		else unget := 0;
	end;

	function bufmgr_t.put(c: char): integer;
	begin
		if phead <> nil then put := phead^.pxbuf.put(c)
		else put := END_OF_FILE;
	end;

	function bufmgr_t.iseof: boolean;
	begin
		if phead <> nil then iseof := phead^.pxbuf.iseof
		else iseof := true;
	end;

	function bufmgr_t.iseos: boolean;
	begin
		if phead <> nil then iseos := phead^.pxbuf.iseos
		else iseos := true;
	end;

	function bufmgr_t.isimod: boolean;
	begin
		if phead <> nil then isimod := phead^.pxbuf.isimod
		else isimod := false;
	end;

	function bufmgr_t.getlineno: integer;
	begin
		if phead <> nil then getlineno := phead^.pxbuf.getlineno
		else getlineno := 0;
	end;

	procedure bufmgr_t.setlineno(nline: integer);
	begin
		if phead <> nil then phead^.pxbuf.setlineno(nline);
	end;

	function bufmgr_t.getcolno: integer;
	begin
		if phead <> nil then getcolno := phead^.pxbuf.getcolno
		else getcolno := 0;
	end;

	procedure bufmgr_t.setcolno(ncol: integer);
	begin
		if phead <> nil then phead^.pxbuf.setcolno(ncol);
	end;

	function bufmgr_t.gettabsize: integer;
	begin
		if phead <> nil then gettabsize := phead^.pxbuf.gettabsize
		else gettabsize := 0;
	end;

	procedure bufmgr_t.settabsize(ntab: integer);
	begin
		if phead <> nil then phead^.pxbuf.settabsize(ntab);
	end;

	procedure bufmgr_t.reset;
	begin
		if phead <> nil then phead^.pxbuf.reset;
	end;
]]>
	<If EnableLocation>
		<If EnableColumn><![[
	procedure bufmgr_t.pushlsz(nlsize: integer);
	begin
		if phead <> nil then phead^.pxbuf.pushlsz(nlsize); 
	end;

	function bufmgr_t.poplsz: integer;
	begin
		if phead <> nil then poplsz := phead^.pxbuf.poplsz
		else poplsz := 0;
	end;

	procedure bufmgr_t.pushtsz(ntsize: integer);
	begin
		if phead <> nil then phead^.pxbuf.pushtsz(ntsize);
	end;

	function bufmgr_t.poptsz: integer;
	begin
	if phead <> nil then poptsz := phead^.pxbuf.poptsz
	else poptsz := 0;
	end;
]]>
		</If>
	</If><![[

	function bufmgr_t.current: YYPBUFFER;
	begin
		if phead <> nil then current := phead^.pxbuf
		else current := nil;
	end;

	function bufmgr_t.empty: boolean;
	begin
		empty := (phead = nil);
	end;

	function bufmgr_t.newbuf(pf: pfile_t; im: boolean): YYPBUFFER;
	var
		p: plink_t;
	begin
		if pf = @input then begin
			xstdin.reset;
			xstdin.setimod(im);
			newbuf := xstdin;
		end
		else begin
			new(p);
			p^.plink := pavail^.plink;
			p^.pxbuf := filebuf_t.create(pf, im);
			pavail^.plink := p;
			newbuf := p^.pxbuf;
		end;
	end;

	function bufmgr_t.newbuf(pcbuf: pchar; nsize: integer;
		bown: boolean): YYPBUFFER;
	var
		p: plink_t;
	begin

		new(p);
		p^.plink := pavail^.plink;
		p^.pxbuf := strbuf_t.create(pcbuf, nsize, bown);
		pavail^.plink := p;

		newbuf := p^.pxbuf;
	end;

	function bufmgr_t.switchto(pbuf: YYPBUFFER): YYPBUFFER;
	var
		p: plink_t;
	begin
		if phead = nil then switchto := nil
		else switchto := phead^.pxbuf;

		p := rmwork(pbuf);
		if p = nil then begin
			new(p);
			p^.pxbuf := pbuf;
		end;

		p^.plink := phead;
		phead := p;
	end;

	function bufmgr_t.pop: YYPBUFFER;
	var
		p: plink_t;
	begin
		if phead = nil then begin
			pop := nil;
			exit;
		end;

		p := phead;
		pop := p^.pxbuf;
		phead := phead^.plink;
		dispose(p);
	end;

	procedure bufmgr_t.destroytop;
	var
		p, q: plink_t;
		pxb: YYPBUFFER;
	begin
		pxb := pop;
		if (pxb <> nil) and (pxb <> xstdin) then begin
			p := pavail;
			while (p^.plink <> nil) and (p^.plink^.pxbuf <> pxb) do
			p := p^.plink;
			if p^.plink <> nil then begin
				q := p^.plink;
				p^.plink := q^.plink;

				pxb.destroy;
				dispose(q);
			end;
		end;
	end;

	procedure bufmgr_t.destroyall;
	var
		p: plink_t;
	begin
		while pavail^.plink <> nil do begin
			p := pavail^.plink;
			pavail^.plink := p^.plink;
			if p^.pxbuf <> nil then p^.pxbuf.destroy;
			dispose(p);
		end;

		phead := nil;
	end;

	function bufmgr_t.rmwork(pxb: YYPBUFFER): plink_t;
	var
		p, q: plink_t;
	begin
		p := phead;
		if p <> nil then begin
			if pxb = p^.pxbuf then begin
				phead := phead^.plink;
				rmwork := p;
				exit;
			end
			else begin
				while (p^.plink <> nil) and (p^.plink^.pxbuf <> pxb) do
					p := p^.plink;
				if p^.plink <> nil then
				begin
					q := p^.plink;
					p^.plink := q^.plink;
					rmwork := q;
					exit;
				end;
			end;
		end; 

	rmwork := nil;     
	end;
  // class bufmgr_t
  ///////////////////////////////////////////////////////////////
]]>
</If>
<![[
const  
	SIZEOF_CHAR = sizeof(char);
	CHARS_PER_INT = (sizeof(integer) + SIZEOF_CHAR - 1) div SIZEOF_CHAR;
  
	function deref_int(base: pistack_item_t; off: integer): pistack_item_t;
	begin
  		deref_int := pistack_item_t((pchar(base) + off * CHARS_PER_INT));
	end;

	function int_to_str__(num: integer): string;
	var
		s: string[12];
	begin
		str(num, s);
		int_to_str__ := s;
	end;
	
    procedure yyemit_error__(s: string]]>
	<If Has?"FormalParams"><![[; ]]><Action "FormalParams"/></If><![[);
	begin
		writeln(output, s);
	end;
	
	  	constructor istack_t.create;
  	begin
  		inherited;
  		getmem(el, sizeof(integer) * SSTACK_INIT_SIZE);
  		sz := SSTACK_INIT_SIZE;
  		tp := -1;
  	end;
  	
	destructor istack_t.destroy;
	begin
		freemem(el);
	end;
	
	procedure istack_t.push;
	begin
		if tp = sz - 1 then
		begin
			sz := sz + SSTACK_INC_SIZE;
			reallocmem(el, sz * sizeof(integer));
		end;
		tp := tp + 1;
	end;
				
	procedure istack_t.push(ss: integer);
	var
		p: pistack_item_t;
	begin
		if tp = sz - 1 then
		begin
			sz := sz + SSTACK_INC_SIZE;
			reallocmem(el, sz * sizeof(integer));
		end;
		tp := tp + 1;
		p := deref_int(el, tp);
		p^ := ss;
	end;
	
	function istack_t.top: integer;
	begin
		top := deref_int(el, tp)^;
	end;

	procedure istack_t.pop(n: integer);
	begin
		tp := tp - n;
	end;
	
	function istack_t.getat(n: integer): integer;
	begin
		getat := deref_int(el, tp - n)^;
	end;
	
	function istack_t.empty: boolean;
	begin
		empty := (tp < 0);
	end;
	
	function istack_t.count: integer;
	begin
		count := tp + 1;
	end;
	
	procedure istack_t.clear;
	begin
		tp := -1;
	end;
]]>
<If EnableParser>
	<If EnableLocation><![[
const
	CHARS_PER_LOC = (sizeof(xltype_t) + SIZEOF_CHAR - 1) div SIZEOF_CHAR;
  
	function deref_loc(base: plstack_item_t; off: integer): plstack_item_t;
	begin
		deref_loc := plstack_item_t((pchar(base) + off * CHARS_PER_LOC));
	end;
   
   	constructor lstack_t.create;
	begin
		inherited;
		getmem(el, sizeof(xltype_t) * SSTACK_INIT_SIZE);
		sz := SSTACK_INIT_SIZE;
		tp := -1;
	end;
	
	destructor lstack_t.destroy;
	begin
		freemem(el);
	end;
	
	procedure lstack_t.push;
	begin
		if tp = sz - 1 then
		begin
			sz := sz + SSTACK_INC_SIZE;
			reallocmem(el, sz * sizeof(xltype_t));
		end;
		tp := tp + 1;
	end;
	
	procedure lstack_t.push(e: xltype_t);
	var
		p: plstack_item_t;
	begin
		if tp = sz - 1 then
		begin
			sz := sz + SSTACK_INC_SIZE;
			reallocmem(el, sz * sizeof(xltype_t));
		end;
		tp := tp + 1;
		p := deref_loc(el, tp);
		p^ := e;
	end;
	
	function lstack_t.top: plstack_item_t;
	begin
		top := deref_loc(el, tp);
	end;
	
	procedure lstack_t.pop(n: integer);
	begin
		tp := tp - n;
	end;
	
	function lstack_t.getat(n: integer): plstack_item_t;
	begin
		getat := deref_loc(el, tp - n);
	end;
	
	function lstack_t.empty: boolean;
	begin
		empty := (tp < 0);
	end;
	
	function lstack_t.count: integer;
	begin
		count := tp + 1;
	end;
]]>
	</If>
	<If ParseDebugMode><![[

	function sym_text__(s: pchar): string;
	var
		t: string[24];
	begin
		t := 'unprintable-char{';
		if (length(s) = 1) and ((ord(s[0]) < 32) or (ord(s[0]) >= 127)) then
		begin
			t := t + int_to_str__(ord(s[0]));
			t := t + '}';
			sym_text__ := t;
		end
		else if (length(s) = 2) and (s[0] = '\') then
		begin
			case s[1] of
			'a': sym_text__ := t + '7}';
			'b': sym_text__ := t + '8}';
			'f': sym_text__ := t + '12}';
			't': sym_text__ := t + '9}';
			'n': sym_text__ := t + '10}';
			'r': sym_text__ := t + '13}';
			'v': sym_text__ := t + '11}';
			else sym_text__ := s[1];
			end;
		end
		else
			sym_text__ := string(s);
	end;
]]>
	</If><![[
const 
	CHARS_PER_SYM = (sizeof(sstack_item_t) + SIZEOF_CHAR - 1) div SIZEOF_CHAR;  
	  
	function deref_sym(base: psstack_item_t; off: integer): psstack_item_t;
	begin
		deref_sym := psstack_item_t((pchar(base) + off * CHARS_PER_SYM));
	end;
  
	constructor sstack_t.create;
	begin
		inherited;
		getmem(el, sizeof(sstack_item_t) * SSTACK_INIT_SIZE);
		sz := SSTACK_INIT_SIZE;
		tp := -1;    
	end;

	destructor sstack_t.destroy;
	begin
		freemem(el);
	end;
  
	procedure sstack_t.push;
	begin
		if tp = sz - 1 then begin
			sz := sz + SSTACK_INC_SIZE;
			reallocmem(el, sz * sizeof(sstack_item_t));
		end;
		tp := tp + 1;
	end;
  
	procedure sstack_t.push(sid: integer; sv: xstype_t);
	var
		p: psstack_item_t;
	begin
	if tp = sz - 1 then begin
		sz := sz + SSTACK_INC_SIZE;
		reallocmem(el, sz * sizeof(sstack_item_t));
	end;
		tp := tp + 1;
		p := deref_sym(el, tp);
		p^.sid := sid;
		p^.sv := sv;
	end;

	function sstack_t.top: psstack_item_t;
	begin
		top := deref_sym(el, tp);
	end;

	procedure sstack_t.pop(n: integer);
	begin
		tp := tp - n;
	end;

	function sstack_t.getat(n: integer): psstack_item_t;
	begin
		getat := deref_sym(el, tp - n);
	end;
  
	function sstack_t.empty: boolean;
	begin
		empty := (tp < 0);
	end;

	function sstack_t.count: integer;
	begin
		count := tp + 1;
	end;
  ]]>
</If>
<If EnableScanner><![[
	function ]]><$YY "parser_t"/><![[.renew_text__: boolean;
	begin
	  reallocmem(yytext, INC_YYTEXT_SIZE + yysize__);
	  yysize__ := yysize__ + INC_YYTEXT_SIZE;
	  yytext[yysize__ - 1] := #0;
	  renew_text__ := true;
	end;
	
	function ]]><$YY "parser_t"/><![[.yylex_is_running__: boolean;
	begin
		yylex_is_running__ := (yyecode__ = YYE_ALIVE);
	end;
	
	function ]]><$YY "parser_t"/><![[.yyget_lexrule__(s: integer): integer;
	begin
		yyget_lexrule__ := yydaccpt[s];
	end;
	function ]]><$YY "parser_t"/><![[.yynext_lexstate__(s, c: integer): integer;
	var
		d: integer;
	begin
		d := yydcmap[c];
		while (s < LEX_STATE_COUNT) and (yydchk[yydbase[s] + d] <> s) do
			s := yyddef[s];
		if s > LEX_STATE_COUNT then
		begin
			if yydchk[yydbase[s] + yydmeta[d]] = s then
				yynext_lexstate__ := yydnxt[yydbase[s] + yydmeta[d]]
			else
				yynext_lexstate__ := LEX_ERROR_STATE;
		end
		else
			yynext_lexstate__ := yydnxt[ yydbase[s] + d];
	end;
	
]]>
</If>
<If EnableParser><![[
	procedure ]]><$YY "parser_t"/><![[.YYACCEPT;
	begin
		yyecode__ := YYE_ACCEPT;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.YYABORT;
	begin
		yyecode__ := YYE_ABORT;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyerrok;
	begin
		yyerr_flag__ := false;
		yyltok := PARSE_UNDEFSYMB_ID;
	end;
	
	function ]]><$YY "parser_t"/><![[.yyparse_is_running__(s: integer): boolean;
	begin
		yyparse_is_running__ := ((yyecode__ > YYE_ACCEPT) and (s <> PARSE_ACCEPT_STATE));
	end;
	 
	function ]]><$YY "parser_t"/><![[.yyget_defrule(s: integer): integer;
	var
		r: integer;
	begin
		r := yyget_prule__(yyparv[s]);
		if (yyparn[s] = 0) and is_valid_prule__(r) then
			yyget_defrule := r
		else
			yyget_defrule := PERROR_RULE;
	end;
	
	function ]]><$YY "parser_t"/><![[.is_valid_pstate__(s: integer): boolean;
	begin
		is_valid_pstate__ := (s < PARSE_ERROR_STATE);
	end;
	
	function ]]><$YY "parser_t"/><![[.is_valid_prule__(r: integer): boolean;
	begin
		is_valid_prule__ := ((r >= 0) and (r < PERROR_RULE));
	end;
	
	function ]]><$YY "parser_t"/><![[.yyget_prule__(s: integer): integer;
	begin
		yyget_prule__ := s - (PARSE_ERROR_STATE + 1);
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yydiscard__(var yydval: xstype_t; var yydloc: xltype_t;
		yydsymb: integer]]><If Has?"FormalParams"><![[;]]><Action "FormalParams"/></If><![[);
	begin
	]]>
	<If Has?"DestructorActions"><![[
		case yydsymb of
		]]><$UserDiscardActions "DestructorSymbols" "DestructorActions"/><![[
		end;]]>
	</If><![[	
	end;
	
	function ]]><$YY "parser_t"/><![[.yynext_pstate__(s, t: integer): integer;
	begin
		if (yyvbmap[s * PARSE_BMAP_ROWSIZE + t div 8] and (1 shl (t mod 8))) <> 0 then
		begin
			if yyparn[s] < yypcn[t] then
				yynext_pstate__ := yyparv[s]
			else if yyparn[s] > yypcn[t] then
				yynext_pstate__ := yypcv[t]
			else
				yynext_pstate__ := yypact[yypabase[s] + t];
		end
		else
			yynext_pstate__ := PARSE_ERROR_STATE;
	end;
	
	function ]]><$YY "parser_t"/><![[.yynext_goto__(s, t: integer): integer;
	begin
		if yypgrn[s] < yypcn[PARSE_TYPE_BASE + t] then
			yynext_goto__ := yypgrv[s]
		else if yypgrn[s] > yypcn[PARSE_TYPE_BASE + t] then
			yynext_goto__ := yypcv[PARSE_TYPE_BASE + t]
		else
			yynext_goto__ := yypgoto[yypgbase[s] + t];
	end;
	
]]>
</If><![[

	constructor ]]><$YY "parser_t"/><![[.create]]>
<If EnableParser>
	<![[(]]><![[plex: ]]><$YY "lex_t"/><![[)]]>
</If><![[;
	begin
		inherited create;
		yyecode__ := YYE_ALIVE;]]>
<If EnableScanner><![[
		yyscstk__ := istack_t.create;
		yybufmgr__ := bufmgr_t.create;
		yysize__ := 0;
		yystart__ := INITIAL;
		yymore_flag__ := false;
		yyat_bol__ := true;
		yytext := nil;
		yyleng := 0;
		yylaleng := 0;]]>
</If>
<If EnableParser><![[
		yyerr_flag__ := false;
		yyltok := PARSE_UNDEFSYMB_ID;
		yylexer := plex;]]>
</If><![[
		yyerror := @yyemit_error__;		
	end;
	
	destructor ]]><$YY "parser_t"/><![[.destroy;
	begin
]]><If EnableScanner><![[
		if yytext <> nil then
			freemem(yytext);
		yyscstk__.destroy;
		yybufmgr__.destroy;
]]></If><![[
	end;
	
]]>
<If EnableScanner><![[
	function ]]><$YY "parser_t"/><![[.yylexinit__(pchFile: string; bi: boolean): boolean;
	var
		pbuf: YYPBUFFER;
	begin
		pbuf := yy_new_filebuf(pchFile, bi);
		if pbuf = nil then
		begin
			yylexinit__ := false;
			exit;
		end;
		
		yy_switch_buffer(pbuf);
		
		if yytext = nil then renew_text__;
		
		yylexinit__ := yy_has_buffer;
	end;
	
	function ]]><$YY "parser_t"/><![[.yylexinit__(strbuf: pchar; size: integer; bcopied: boolean): boolean;
	var
		pbuf: YYPBUFFER;
	begin
		pbuf := yybufmgr__.newbuf(strbuf, size, bcopied);
		if pbuf = nil then
		begin
			yylexinit__ := false;
			exit;
		end;
		yy_switch_buffer(pbuf);
		
		if yytext = nil then renew_text__;
		
		yylexinit__ := yy_has_buffer;
	end;
	
	function ]]><$YY "parser_t"/><![[.yylex__]]>
	<If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: integer;
	var
		yylstate__: integer;
		yylrule__: integer;
		yyaccleng__: integer;
		yycchar__:integer;
		bwrap__: boolean;]]>
	<If EnableLocation>
		<If EnableColumn><![[
		nline, ncol, nt, ts, yyt1__: integer;
]]>
		</If>
		<Else><![[
		nline, yyt1__: integer;
]]>
		</Else>
	</If>
	<$SingleAction "LexVarDecl"/><![[
	begin
		if not yy_has_buffer then begin
			yyecode__ := YYE_EOS;
			yylex__ := 0;
			exit;
		end;
		
		yylrule__ := LEX_ERROR_RULE;
		yyaccleng__ := 0;
		
		yymore_flag__ := false;
		yyecode__ := YYE_ALIVE;
		bwrap__ := false;
		yyleng := 0;
		yylaleng := 0;
		yytext[0] := #0;
		]]><$SingleAction "LexVarInit"/><![[
		]]><$CodeBlock "LexInitAction"/><![[
		
		if yyat_bol__ then
			yylstate__ := yydsc[yystart__]
		else
			yylstate__ := yydsc[yystart__ + 1];
			
		while yylex_is_running__ do
		begin
			yycchar__ := yybufmgr__.get;
			yylstate__ := yynext_lexstate__(yylstate__, yycchar__);
			
			if LEX_ERROR_STATE <> yylstate__ then
			begin

				if yylaleng >= yysize__ - 1 then
					renew_text__;
				yytext[yylaleng] := chr(yycchar__);

				yylaleng := yylaleng + 1;

				if yyget_lexrule__(yylstate__) <> LEX_ERROR_RULE then
				begin
					yylrule__ := yyget_lexrule__(yylstate__);
					yyaccleng__ := yylaleng;
				end;
			end;
			
			
			if (LEX_ERROR_STATE = yylstate__) or (yybufmgr__.isimod
				and ((10 = yycchar__) or (END_OF_FILE = yycchar__))) then
			begin
				if LEX_ERROR_RULE = yylrule__ then
				begin
					if yylaleng = yyleng then
					begin
						if yycchar__ = END_OF_FILE then
							yylrule__ := LEX_EOFRULE_BASE + yystart__ div 2
						else if yycchar__ = END_OF_ALLFILE then
							yylrule__ := LEX_EOAF_RULE;
					end;
				end
				else
				begin
					if LEX_ERROR_STATE = yylstate__ then
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);
					yylaleng := yyaccleng__;
					yytext[yylaleng] := #0;
				]]>
	<If Has?"LexDFALookaheads"><![[
					yyleng := yylaleng - yylad[yylrule__];
					if yylaleng > yyleng then
					begin
						yybufmgr__.unget(yylaleng - yyleng);
					end;
]]>
	</If>
				<Else><![[ yyleng := yylaleng;]]></Else>
					<![[
				end;

				if LEX_ERROR_RULE <> yylrule__ then begin
					if yyleng > 0 then
						yyat_bol__ := (yytext[yyleng - 1] = #10);
]]>
	<If LexDebugMode><![[
					if yylrule__ >= LEX_EOFRULE_BASE then
					begin
						if yylrule__ < LEX_EOAF_RULE then
						begin
							if yydline[yylrule__] > 0 then
								writeln(output, '.................... accept {EOF}, rule at line: ',
									yydline[yylrule__])
							else
								writeln(output, '.................... EOF reached');
						end
						else
							writeln(output, '.................... EOS reached');
					end
					else begin
						if (yyleng = 1) and ((ord(yytext[0]) < 32) or (ord(yytext[0]) >= 127)) then
							writeln(output, '.................... accept unprintable-char{',
								ord(yytext[0]), '}, rule at line: ', yydline[yylrule__])
						else
							writeln(output, '.................... accept {`', yytext,
								'''}, rule at line: ', yydline[yylrule__]);
					end;
]]>
	</If>
<$CodeBlock "PremacthAction"/>
	<If EnableLocation>
		<If EnableColumn><![[
					nline := yyget_lineno();
					ncol := yyget_colno() - 1;
					nt := yyget_tabsize();
					for yyt1__ := 0 to yyleng - 1 do
					begin
						if yytext[yyt1__] = #9 then
						begin

							ts := nt - ncol mod nt;
							yybufmgr__.pushtsz(ts);
							ncol := ncol + ts;
						end
						else if yytext[yyt1__] = #10 then
						begin
							yybufmgr__.pushlsz(ncol + 1);
							ncol := 0;
							nline := nline + 1;
						end
						else ncol := ncol + 1;
						
					end;]]>
			<If EnableParser><![[
					]]><$YY "lloc"/><![[.firstLine := yyget_lineno();
					]]><$YY "lloc"/><![[.firstColumn := yyget_colno();
					]]><$YY "lloc"/><![[.lastLine  := nline;
					if ncol < 0 then
						]]><$YY "lloc"/><![[.lastColumn := 0
					else ]]><$YY "lloc"/><![[.lastColumn := ncol;
]]>
			</If><![[yyset_lineno(nline);
					yyset_colno(ncol + 1);
]]>
		</If>
		<Else><![[
					nline := yyget_lineno();
					for yyt1__ := 0 to yyleng - 1 do
					begin
						if yytext[yyt1__] = #10 then
						begin
							nline := nline + 1;
						end						
					end;]]>
			<If EnableParser><![[
					]]><$YY "lloc"/><![[.firstLine := yyget_lineno();
					]]><$YY "lloc"/><![[.firstColumn := 0;
					]]><$YY "lloc"/><![[.lastLine  := nline;
					]]><$YY "lloc"/><![[.lastColumn := 0;
]]>
			</If><![[yyset_lineno(nline);
					yyset_colno(0);
]]>
		</Else>
	</If><![[
				end;

			if (yylrule__ >= LEX_EOFRULE_BASE) and (yylrule__ < LEX_EOAF_RULE) then
				bwrap__ := yywrap__]]><If Has?"ActualParams"><![[(]]><Action "ActualParams"/><![[)]]></If><![[
			else
				bwrap__ := false;

			if not bwrap__ then begin
				case yylrule__ of
				]]><$UserLexActions "LexRule2Actions" "LexActions"
						"LexRule2Lines" "ScriptFileName"/><![[

				LEX_EOAF_RULE: begin
						yy_delete_buffer;
						yyecode__ := YYE_EOS;
					end;
				else begin
					if yyleng > 0 then
						yyat_bol__ := (yytext[yyleng - 1] = #10);

]]>
	<If EnableDefaultAction><![[
]]>
	</If>
	<Else><![[
		YYMSG_UNMATCHED[28] := chr(yycchar__);
		yyecode__ := YYE_UNMATCHED;
		if assigned(yyerror) then
			yyerror(YYMSG_UNMATCHED]]><If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]>
	</Else><![[		end;
				end;
			end;
				if yylex_is_running__ then
				begin
					if yyat_bol__ then
						yylstate__ := yydsc[yystart__]
					else
						yylstate__ := yydsc[yystart__ + 1];

					yylrule__ := LEX_ERROR_RULE;

					if not yymore_flag__ then
					begin
						yyaccleng__ := 0;
						yylaleng := 0;
						yyleng := 0;
						yytext[yylaleng] := #0;
					end
					else
					begin
						yymore_flag__ := false;
					end;
				end;
			end;
		end;
		
		if yyecode__ = YYE_EOS then
			yylex__ := 0
		else
			yylex__ := yyecode__;
			
		///////////////////////////////////////////////////////////////////////////
	end;
]]>
</If>
<If EnableParser><![[	
	function ]]><$YY "parser_t"/><![[.yyparse__]]>
	<If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: integer;
	var
		yys_stt__: istack_t;
		yys_sv__: sstack_t;
		yyval: xstype_t;
]]>
	<If EnableLocation><![[
		yys_loc__: lstack_t;
		yycc: string[128];
]]>
	</If><![[
		yyloc: xltype_t;
		yyrplen__: integer;
		yyreducing__: boolean;
		yypstate__: integer;
		yyprule__: integer;
		yysidx__: integer;
		yytok__: integer;
		]]>
	<If ParseDebugMode><![[
		yyt1__, yyt2__: integer;
		]]>
	</If><$SingleAction "ParseVarDecl"/><![[
	begin

		if not assigned(yylexer) then
		begin
			yyparse__ := YYE_ABORT;
			exit;
		end;
		yypstate__ := PARSE_START_STATE;
		yyprule__ := PERROR_RULE;
		yysidx__ := PARSE_UNDEFSYMB_INDEX;
		yytok__ := PARSE_UNDEFSYMB_ID;
		yyreducing__ := false;
		
		yyecode__ := YYE_ALIVE;
		yyltok := PARSE_UNDEFSYMB_ID;
		yyerr_flag__ := false;
		
		yys_stt__ := istack_t.create;
		yys_sv__ := sstack_t.create;

]]>
	<If EnableLocation><![[
		yys_loc__ := lstack_t.create;

]]>
	</If>
	<$SingleAction "ParseVarInit"/><![[
]]><$CodeBlock "ParseInitAction"/><![[
		yys_stt__.push(yypstate__);

		while (not yys_stt__.empty) and yyparse_is_running__(yypstate__) do
		begin
		
			yyprule__ := yyget_defrule(yypstate__);
			if is_valid_prule__(yyprule__) then
				yyreducing__ := true			
			else
			begin
				if PARSE_UNDEFSYMB_ID = yytok__ then
				begin
					if PARSE_UNDEFSYMB_ID = yyltok then
						yytok__ := yylexer(]]><If Has?"ActualParams"><Action "ActualParams"/></If><![[)
					else begin
						yytok__ := yyltok;
						yyltok := PARSE_UNDEFSYMB_ID;
					end;
					
					if (yytok__ < 0) or (yytok__ >= PARSE_TOKENMAP_SIZE) then
						yysidx__ := PARSE_UNDEFSYMB_INDEX
					else
						yysidx__ := yyptmap[yytok__];
				end;

				]]>
	<If ParseDebugMode><![[
				writeln(output, 'Next symbol is ', sym_text__(yypsnam[yysidx__]));
				]]>
	</If><![[
				yypstate__ := yynext_pstate__(yys_stt__.top(), yysidx__);

				if is_valid_pstate__(yypstate__) then
				begin
					]]>
	<If ParseDebugMode><![[
					writeln(output, 'Shift ', sym_text__(yypsnam[yysidx__]), ', go to state ', yypstate__);
					]]>
	</If><![[

					yys_stt__.push(yypstate__);
					yys_sv__.push(yysidx__, ]]><$YY "lval"/><![[);
]]>
	<If EnableLocation><![[
					yys_loc__.push(]]><$YY "lloc"/><![[);
]]>
	</If><![[
					yytok__ := PARSE_UNDEFSYMB_ID;
					yyreducing__ := false;
				end
				else begin
					yyprule__ := yyget_prule__(yypstate__);
					yyreducing__ := true;
				end;
			end;

			if yyreducing__ then
			begin
				case yyprule__ of
				]]><$UserParseActions "PraseRule2Actions" "ParseActions"
						"ParseRule2Lines" "ScriptFileName"/><![[
				else begin

					if (not yyerr_flag__) or (PARSE_ENDSYMB_ID = yytok__) then
					begin
						if not yyerr_flag__ then begin
							if assigned(yyerror) then
							begin
]]>
	<If EnableLocation><![[
yycc := 'Error: syntax error at ';
yycc := yycc + int_to_str__(]]><$YY "lloc"/><![[.firstLine);
yycc := yycc + ':';
yycc := yycc + int_to_str__(]]>	<$YY "lloc"/><![[.firstColumn);
yycc := yycc + '.';
yyerror(yycc]]><If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]>
	</If>
	<Else><![[
yyerror('Error: syntax error.']]><If Has?"ActualParams"><![[, ]]><Action "ActualParams"/></If><![[);
]]>
	</Else><![[
							end;
							yyecode__ := YYE_PERROR;
						end
						else yyecode__ := YYE_NOINPUT;

						yyerr_flag__ := true;
						yyltok := yytok__;
					end
					else begin]]>
	<If ParseDebugMode><![[
				writeln(output, 'Error recovery : discard current token ', sym_text__(yypsnam[yysidx__]));
				]]>
</If><![[
						yydiscard__(]]><$YY "lval"/><![[, ]]><$YY "lloc"/><![[, yysidx__]]>
	<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);

						yyltok := PARSE_UNDEFSYMB_ID;
					end;
					yytok__ := PARSE_ERRORSYMB_ID;
					yysidx__ := PARSE_ERRORSYMB_INDEX;

					while not yys_sv__.empty do begin
						yypstate__ := yynext_pstate__(yys_stt__.top, yysidx__);
						if is_valid_pstate__(yypstate__) then break;
						]]>
	<If ParseDebugMode><![[begin
			yyt1__ := (yys_sv__.top)^.sid;
			
			writeln(output, 'Error recovery : Pop up ', sym_text__(yypsnam[yyt1__]));

			write(output, 'Now state stack:');
			if yyerr_flag__ then yyt1__ := 1
			else yyt1__ := 0;
			while yyt1__ < yys_stt__.count do begin
				write(output, ' ', yys_stt__.getat(yyt1__));
				yyt1__ := yyt1__ + 1;
			end;
			writeln(output);
		end;]]>
	</If><![[
]]>
	<If EnableLocation><![[
						yydiscard__((yys_sv__.top)^.sv, yys_loc__.top^, (yys_sv__.top)^.sid]]>
							<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);
						yys_loc__.pop(1);
]]>
</If><Else><![[
						yydiscard__((yys_sv__.top)^.sv, ]]><$YY "lloc"/><![[, (yys_sv__.top)^.sid]]>
							<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);
]]></Else><![[

						yys_sv__.pop(1);
						yys_stt__.pop(1);
					end;

						if yys_sv__.empty then yys_stt__.pop(1);
					end;
				end;

				if is_valid_prule__(yyprule__) or (YYE_ACCEPT = yyecode__) then
				begin
					yyrplen__ := yyprnum[yyprule__];
					yypstate__ := yynext_goto__(yys_stt__.getat(yyrplen__), yyplid[yyprule__]);
					]]>
	<If ParseDebugMode><![[begin
		write(output, 'Reduce action: ');
		for yyt2__ := yyrplen__ - 1 downto 0 do begin
			yyt1__ := (yys_sv__.getat(yyt2__))^.sid;
			write(output, sym_text__(yypsnam[yyt1__]), ' ');
		end;
		write(output, '=> ', yypsnam[yyplid[yyprule__] + PARSE_TYPE_BASE]);
		writeln(output, ', go to state ', yypstate__, ' by rule at ', yypline[yyprule__], '.');

					end;]]>
	</If><![[

					if YYE_ACCEPT <> yyecode__ then begin
						yys_stt__.pop(yyrplen__);
						yys_sv__.pop(yyrplen__);
]]>
`	<If EnableLocation><![[
						if yyrplen__ = 0 then begin
							yyloc.firstLine := yys_loc__.top^.lastLine;
							yyloc.lastLine := yys_loc__.top^.lastLine;
							yyloc.firstColumn := yys_loc__.top^.lastColumn;
							yyloc.lastColumn := yys_loc__.top^.lastColumn;
						end
						else begin
							yyloc.firstLine := yys_loc__.getat(yyrplen__ - 1)^.firstLine;
							yyloc.lastLine := yys_loc__.top^.lastLine;
							yyloc.firstColumn := yys_loc__.getat(yyrplen__ - 1)^.firstColumn;
							yyloc.lastColumn := yys_loc__.top^.lastColumn;
						end;
						yys_loc__.pop(yyrplen__);
						yys_loc__.push(yyloc);
]]>
	</If><![[
						yys_stt__.push(yypstate__);
						yys_sv__.push(yyplid[yyprule__] + PARSE_TYPE_BASE, yyval);
					end;
				end;
			end;
		end;

		while not yys_sv__.empty do begin
		]]>
	<If ParseDebugMode><![[			
			writeln(output, 'Clearup : Pop up ', sym_text__(yypsnam[(yys_sv__.top)^.sid]));
]]>
	</If>
	<If EnableLocation><![[
			yydiscard__(yys_sv__.top^.sv, yys_loc__.top^, yys_sv__.top^.sid]]>
				<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);
]]>
	</If>
	<Else><![[
			yydiscard__(yys_sv__.top^.sv, ]]><$YY "lloc"/><![[, yys_sv__.top^.sid]]>
				<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);
]]>
	</Else><![[
			yys_sv__.pop(1);
		end;

		if YYE_ACCEPT = yyecode__ then begin

]]>
	<If EnableLocation><![[
			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE]]>
				<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);
]]></If>
	<Else><![[
			yydiscard__(yyval, ]]><$YY "lloc"/><![[, yyplid[yyprule__] + PARSE_TYPE_BASE]]>
				<If Has?"ActualParams"><![[,]]><Action "ActualParams"/></If><![[);
]]>
	</Else><![[
		end;
]]><$CodeBlock "ParseExitAction"/><![[
		yys_stt__.destroy;
		yys_sv__.destroy;
]]>
	<If EnableLocation><![[
		yys_loc__.destroy;
]]>
	</If><![[
		if (yyecode__ = YYE_EOS) or (yyecode__ = YYE_ACCEPT) then yyparse__ := 0
		else yyparse__ := yyecode__;

	end;]]>
</If><![[
	
	procedure ]]><$YY "parser_t"/><![[.yyclearall__;
	begin
		yyecode__ := YYE_ALIVE;]]>
<If EnableScanner><![[
		yystart__ := INITIAL;		
		yymore_flag__ := false;
		yyat_bol__ := true;
		
		yyleng := 0;
		yylaleng := 0;
		if yytext <> nil then yytext[0] := #0;
		yybufmgr__.destroyall;
]]>
</If>
<If EnableParser><![[
		yyerr_flag__ := false;
		yyltok := PARSE_UNDEFSYMB_ID;
]]></If><![[
		end;
]]>
<If EnableScanner><![[
	// user interfaces
	// easy way to print matched string
	procedure ]]><$YY "parser_t"/><![[.YYECHO;
	begin
		ECHO;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.ECHO;
	begin
		write(output, yytext);
	end;
	
	// switch start-condition
	procedure ]]><$YY "parser_t"/><![[.YYBEGIN(sc :integer);
	begin
		yystart__ := sc;
	end;
	
	// return current start-condition
	function ]]><$YY "parser_t"/><![[.YYSTART: integer;
	begin
		YYSTART := yystart__;
	end;
	
	// save current start-condition and switch to new start-condition
	procedure ]]><$YY "parser_t"/><![[.yy_push_state(nsc: integer);
	begin
		yyscstk__.push(yystart__);
		yystart__ := nsc;
	end;
	
	// switch to last saved start-condition
	function ]]><$YY "parser_t"/><![[.yy_pop_state: boolean;
	begin
		if yyscstk__.empty then
			yy_pop_state := false
		else
		begin
			yystart__ := yyscstk__.top;
			yyscstk__.pop(1);
			yy_pop_state := true;
		end;
	end;
	
	// return last saved start-condition
	function ]]><$YY "parser_t"/><![[.yy_top_state: integer;
	begin
		if yyscstk__.empty then
			yy_top_state := INITIAL
		else
			yy_top_state := yyscstk__.top;
	end;
	
	// get/set flag of beginning-of-line
	function ]]><$YY "parser_t"/><![[.yy_get_bol: boolean;
	begin
		yy_get_bol := yyat_bol__;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yy_set_bol(b: boolean);
	begin
		yyat_bol__ := b;
	end;
		
	// buffer operations
	function ]]><$YY "parser_t"/><![[.yy_current_buffer: YYPBUFFER;
	begin
		yy_current_buffer := yybufmgr__.current;
	end;
	
	function ]]><$YY "parser_t"/><![[.yy_has_buffer: boolean;
	begin
		yy_has_buffer := not yybufmgr__.empty;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yy_push_buffer(pbuffer: YYPBUFFER);
	begin
		yybufmgr__.switchto(pbuffer);
	end;
	
	function ]]><$YY "parser_t"/><![[.yy_pop_buffer: YYPBUFFER;
	begin
		yy_pop_buffer := yybufmgr__.pop;
	end;
	
	function ]]><$YY "parser_t"/><![[.yy_new_filebuf(strfile: string; bi: boolean): YYPBUFFER;
	var
		pfile: pfile_t;
	begin
		if strfile = '' then
		begin
			yy_new_filebuf := yybufmgr__.newbuf(@input, bi);
			exit;
		end;
		
		new(pfile);
		assignfile(pfile^, strfile);
		{$I-}
		reset(pfile^, 1);
		{$I+}
		if IOResult <> 0 then
			yy_new_filebuf := nil
		else
			yy_new_filebuf := yybufmgr__.newbuf(pfile, bi);
	end;
	function ]]><$YY "parser_t"/><![[.yy_new_cstrbuf(cstrbuf: pchar; size: integer): YYPBUFFER;
	begin
		if (cstrbuf = nil) or (size < 1) then
		begin
			yy_new_cstrbuf := nil;
			exit;
		end;
		
		yy_new_cstrbuf := yybufmgr__.newbuf(cstrbuf, size, true);
	end;
	function ]]><$YY "parser_t"/><![[.yy_new_strbuf(strbuf: pchar; size: integer): YYPBUFFER;
	begin
		if (strbuf = nil) or (size < 1) then
		begin
			yy_new_strbuf := nil;
			exit;
		end;
		
		yy_new_strbuf := yybufmgr__.newbuf(strbuf, size, false);
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yy_delete_buffer;
	begin
		yybufmgr__.destroytop;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yy_switch_buffer(buf: YYPBUFFER);
	begin
		yybufmgr__.switchto(buf);
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyrestart;
	begin
		yystart__ := INITIAL;
		yyecode__ := YYE_ALIVE;
		yymore_flag__ := false;
		
		yyleng := 0;
		yylaleng := 0;
		if yytext = nil then yytext[0] := #0;
		
		yyscstk__.clear;
		yybufmgr__.reset;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yymore;
	begin
		yymore_flag__ := true;
		yylaleng := yyleng;
	end;
	
	function ]]><$YY "parser_t"/><![[.yyless(n: integer): integer;
	begin
		if (n > 0) and (n < yyleng) then
		begin
			yytext[n] := #0;
			n := yyleng - n;
			yyleng := yyleng - n;
			yylaleng := yyleng;
			
			yyless := yybufmgr__.unget(n);
		end
		else
		begin
			yylaleng := yyleng;
			yytext[yylaleng] := #0;
			yyless := 0;
		end;
	end;
	
	function ]]><$YY "parser_t"/><![[.yyinput: integer;
	var
		c: integer;]]>
	<If EnableLocation>
		<If EnableColumn><![[
		nt: integer;
]]>
		</If>
	</If><![[
	begin
		c := yybufmgr__.get;]]>
	<If EnableLocation>
		<If EnableColumn><![[
		if c < END_OF_FILE then
		begin
			if c = 9 then
			begin
				nt := yyget_tabsize;
				nt := nt - (yyget_colno() + nt - 1) mod nt;
				yybufmgr__.pushtsz(nt);
				yyadd_colno(nt);
			end
			else if c = 10 then
			begin
				yybufmgr__.pushlsz(yyget_colno());
				yyset_colno(1);
				yyadd_lineno(1);
			end
			else begin
				yyadd_colno(1);
			end;
		end;]]>
		</If>
	</If><![[	
		yyinput := c;
	end;
	
	function ]]><$YY "parser_t"/><![[.yyunput(c: char): boolean;
	var
		oldc: integer;]]>
	<If EnableLocation>
		<If EnableColumn><![[
		s: integer;
]]>
		</If>
	</If><![[
	begin
		oldc := yybufmgr__.put(c);]]>
	<If EnableLocation>
		<If EnableColumn><![[
		if oldc < END_OF_FILE then
		begin
			if oldc = 9 then
			begin
				s := yybufmgr__.poptsz;
				if s = 0 then
					yyadd_colno(-1)
				else
					yyadd_colno(-s);
			end
			else if oldc = 10 then
			begin
				s := yybufmgr__.poplsz;
				yyset_colno(s);
				yyadd_lineno(-1);
			end
			else begin
				yyadd_colno(-1);
			end;
		end;]]>
		</If>
	</If><![[
		yyunput := (oldc < END_OF_FILE);
	end;
	
	function ]]><$YY "parser_t"/><![[.yyunget: boolean;
	var
		oldc: integer;]]>
	<If EnableLocation>
		<If EnableColumn><![[
		s: integer;
]]>
		</If>
	</If><![[
	begin
		oldc := yybufmgr__.unget;]]>
	<If EnableLocation>
		<If EnableColumn><![[
		if oldc < END_OF_FILE then
		begin
			if oldc = 9 then
			begin
				s := yybufmgr__.poptsz;
				if s = 0 then
					yyadd_colno(-1)
				else
					yyadd_colno(-s);
			end
			else if oldc = 10 then
			begin
				s := yybufmgr__.poplsz;
				yyset_colno(s);
				yyadd_lineno(-1);
			end
			else begin
				yyadd_colno(-1);
			end;
		end;]]>
		</If>
	</If><![[
		yyunget := (oldc < END_OF_FILE);
	end;	

	procedure ]]><$YY "parser_t"/><![[.yyterminate;
	begin
		yyecode__ := YYE_TERM;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyadd_lineno(nline: integer);
	begin
		yybufmgr__.setlineno(yybufmgr__.getlineno + nline);
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyadd_colno(ncol: integer);
	begin
		yybufmgr__.setcolno(yybufmgr__.getcolno + ncol);
	end;
	
	function ]]><$YY "parser_t"/><![[.yyget_lineno: integer;
	begin
		yyget_lineno := yybufmgr__.getlineno;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyset_lineno(nline: integer);
	begin
		yybufmgr__.setlineno(nline);
	end;
	
	function ]]><$YY "parser_t"/><![[.yyget_colno: integer;
	begin
		yyget_colno := yybufmgr__.getcolno;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyset_colno(ncol: integer);
	begin
		yybufmgr__.setcolno(ncol);
	end;
	
	function ]]><$YY "parser_t"/><![[.yyget_tabsize: integer;
	begin
		yyget_tabsize := yybufmgr__.gettabsize;
	end;
	
	procedure ]]><$YY "parser_t"/><![[.yyset_tabsize(ntab: integer);
	begin
		yybufmgr__.settabsize(ntab);
	end;
	
	function ]]><$YY "parser_t"/><![[.yywrap__]]>
	<If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: boolean;
	begin
		result := false;
		]]>
	<If Has?"EOAFAction"><![[
		// line: ]]><ActLine "EOAFAction"/><![[
		]]><Action "EOAFAction"/>
	</If><![[
	end;
]]>
</If><![[
var
	theYYParser: ]]><$YY "parser_t"/><![[;

// assign new error-reporter and return the old one
function ]]><$YY "seterror"/><![[(perror: ]]><$YY "error_t"/><![[): ]]><$YY "error_t"/><![[;
begin

	]]><$YY "seterror"/><![[ := theYYParser.yyerror;
	theYYParser.yyerror := perror;
end;

// reset all (both scanner and parser, if they are available)
procedure ]]><$YY "clearall"/><![[;
begin
	theYYParser.yyclearall__;
end;
]]>
<If EnableScanner><![[

// initializing file buffer before parsing or patter-matching
function ]]><$YY "lexfile"/><![[(pchFile: string; iMod: boolean): integer;
begin
	if theYYParser.yylexinit__(pchFile, iMod) then
		]]><$YY "lexfile"/><![[ := 0
	else
		]]><$YY "lexfile"/><![[ := 1;
end;

// initializing string buffer before parsing or patter-matching
function ]]><$YY "lexstr"/><![[(strbuf: pchar; size: integer): integer;
begin
	if theYYParser.yylexinit__(strbuf, size, false) then
		]]><$YY "lexstr"/><![[ := 0
	else
		]]><$YY "lexstr"/><![[ := 1;
end;

// initializing const string buffer before parsing or patter-matching
function ]]><$YY "lexcstr"/><![[(strbuf: pchar; size: integer): integer;
begin
	if theYYParser.yylexinit__(strbuf, size, true) then
		]]><$YY "lexcstr"/><![[ := 0
	else
		]]><$YY "lexcstr"/><![[ := 1;
end;

// generated scanner, can be replaced
function ]]><$YY "lex"/><If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]></If><![[: integer;
begin
	]]><$YY "lex"/><![[ := theYYParser.yylex__(]]>
	<If Has?"ActualParams"><Action "ActualParams"/>
	</If><![[);
end;

]]>
</If>

<If EnableParser><![[
// assign new scanner and return the old one 
function ]]><$YY "setlex"/><![[(plex: ]]><$YY "lex_t"/><![[): ]]><$YY "lex_t"/><![[;
begin

	]]><$YY "setlex"/><![[ := theYYParser.yylexer;
	theYYParser.yylexer := plex;
end;

// generated parser, it should not be replaced
function ]]><$YY "parse"/>
	<If Has?"FormalParams"><![[(]]><Action "FormalParams"/><![[)]]>
	</If><![[: integer;
begin
	]]><$YY "parse"/><![[ := theYYParser.yyparse__]]>
	<If Has?"ActualParams"><![[(]]><Action "ActualParams"/><![[)]]>
	</If><![[;
end;
]]>
</If>
<$SingleAction "UserCode"/><![[

	
initialization

	theYYParser := ]]><$YY "parser_t"/><![[.create]]>
	<If EnableParser>
		<If EnableScanner><![[(@]]><$YY "lex"/><![[)]]>
		</If>
	</If><![[;

finalization
	theYYParser.destroy;
	
end.
]]>
</Program>
