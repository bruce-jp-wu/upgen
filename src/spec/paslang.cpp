/*
    Upgen -- a scanner and parser generator.
    CCopyright (C) 2009-2018 Bruce Wu
    
    This file is a part of Upgen program

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "./spec.h"

namespace spec_ns {

char sn_pasSpec[PAS_SPEC_SIZE] = "<\?Setup DefinitionExtName=\".pas\"/><Macros>\n\
	<Macro \"$FreeToUse\">\n\
<![[{\n\
A parser program in Object Pascal, generated by ]]>\n\
<String #0/><![[ ]]><String #1/><![[.\n\
}\n\
]]></Macro>\n\
\n\
	<Macro \"$YY\">\n\
	<Scalar \"Prefix\"/><Text #0/>\n\
	</Macro>\n\
\n\
	<Macro \"$ActionLine\">\n\
	<Case EnableLineNo><![[\n\
//]]><ActLine #0/><![[ \"]]><Scalar \"ScriptFileName\"/><![[\"\n\
]]></Case>\n\
	</Macro>\n\
	\n\
	<Macro \"$HeaderLine\">\n\
	<Case EnableLineNo><![[\n\
//]]><SrcLine/><![[ \"]]><Scalar \"DeclareFileName\"/><![[\"\n\
]]></Case>\n\
	</Macro>\n\
	\n\
	<Macro \"$DeclareAction\">\n\
	<Case Has><$ActionLine #0/><Action #0/><$HeaderLine/></Case>\n\
	</Macro>\n\
	\n\
	<Macro \"$SourceLine\">\n\
	<Case EnableLineNo><![[\n\
//]]><SrcLine/><![[ \"]]><Scalar \"DefineFileName\"/><![[\"\n\
]]></Case>\n\
	</Macro>\n\
\n\
	<Macro \"$SingleAction\">\n\
	<Case Has><$ActionLine #0/><Action #0/><$SourceLine/></Case>\n\
	</Macro>\n\
\n\
	<Macro \"$CodeBlock\">\n\
	<Case Has><![[begin\n\
	]]><$ActionLine #0/><Action #0/><$SourceLine/>\n\
	<![[\n\
	end;\n\
]]></Case>\n\
	</Macro>\n\
\n\
	<Macro \"$UserLexActions\">\n\
<Case End><GoFirst/></Case>\n\
<Case GroupFlag><![[: begin\n\
	]]><$SingleAction #1/><Skip #0/><![[\n\
	end;\n\
	]]><$UserLexActions/></Case>\n\
<Case GroupFirst><Integer #0/><$UserLexActions/></Case>\n\
<Default><![[, ]]><Integer #0/><$UserLexActions/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$UserParseActions\">\n\
<Case End><GoFirst/></Case>\n\
<Case GroupFlag><![[: begin ]]><$SingleAction #1/><Skip #0/><![[\n\
	end;\n\
	]]><$UserParseActions/></Case>\n\
<Case GroupFirst><Integer #0/><$UserParseActions/></Case>\n\
<Default><![[, ]]><Integer #0/><$UserParseActions/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$UserDiscardActions\">\n\
<Case End><GoFirst/></Case>\n\
<Case GroupFlag><![[: begin ]]><$SingleAction #1/><Skip #0/><![[ end;\n\
	]]><$UserDiscardActions/></Case>\n\
<Case GroupFirst><Integer #0/><$UserDiscardActions/></Case>\n\
<Default><![[, ]]><Integer #0/><$UserDiscardActions/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$IntArray\">\n\
<Case Last><Integer #0/><GoFirst/></Case>\n\
<Case Mod\?8><Integer #0/><![[,\n\
	]]><$IntArray/></Case>\n\
<Default><Integer #0/><![[,	]]><$IntArray/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$QStrArray\">\n\
<Case Last><![[\']]><String #0/><![[\']]><GoFirst/></Case>\n\
<Case Mod\?8><![[\']]><String #0/><![[\',\n\
	]]><$QStrArray/></Case>\n\
<Default><![[\']]><String #0/><![[\',	]]><$QStrArray/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$ConstsDefine\">\n\
<Case End><GoFirst/></Case>\n\
<Default><String #0/><![[ = ]]><Integer #1/><![[;\n\
]]><$ConstsDefine/></Default>\n\
	</Macro>\n\
\n\
	<Macro \"$SVNAME_LEFT\"><![[yyval.]]><Text #0/></Macro>\n\
	<Macro \"$SVNAME_RIGHT\"><![[yys_sv__.getat(]]><Text #0/><![[)^.sv.]]><Text #1/></Macro>\n\
	<Macro \"$SVLOC_LEFT\"><![[yyloc]]></Macro>\n\
	<Macro \"$SVLOC_RIGHT\"><![[yys_loc__.getat(]]><Text #0/><![[)^]]></Macro>\n\
	<Macro \"$SVNAME_DSTRCT\"><![[yydval.]]><Text #0/></Macro>\n\
	<Macro \"$SVLOC_DSTRCT\"><![[yydloc]]></Macro>\n\
\n\
	<Macro \"$TypeName\">\n\
		<Case Has><Action #0/></Case>\n\
		<Default><Scalar \"Prefix\"/><Text #1/></Default>\n\
	</Macro>\n\
</Macros>\n\
\n\
<Program>\n\
<Define/>\n\
<$FreeToUse \"SoftwareName\" \"SoftwareVersion\"/>\n\
<![[\n\
unit ]]><String \"FileBaseName\"/><![[;\n\
interface\n\
]]><$DeclareAction \"DeclareHeader\"/><![[\n\
const\n\
	PAS_EOF = #26; {ctrl+z}\n\
]]>\n\
<If EnableParser><![[\n\
//token ID definition\n\
]]><$ConstsDefine \"ParseTokenNames\" \"ParseTokenValues\"/>\n\
</If>\n\
<If EnableScanner><![[\n\
	END_OF_FILE = 256;\n\
	END_OF_ALLFILE = 257;\n\
\n\
// start-condition names\n\
]]><$ConstsDefine \"LexStartLabels\" \"LexStartIndexes\"/><![[\n\
// number of DFA states of scanner\n\
	LEX_STATE_COUNT = ]]><Integer \"LexDefaultState\"/><![[;\n\
\n\
// DFA trap-state of scanner\n\
	LEX_ERROR_STATE = ]]><Integer \"LexErrorState\"/><![[;\n\
\n\
// ID of invalid rule for scanner,\n\
// indicating current string can not be matched by any pattern\n\
	LEX_ERROR_RULE = ]]><Integer \"LexErrorRule\"/><![[;\n\
\n\
// this constant used by computing index of a rule that matches EOF\n\
// for example, in start-condition INITIAL, index of the rule that\n\
// matches EOF is \n\
//	LEX_EOFRULE_BASE + INITIAL\n\
	LEX_EOFRULE_BASE = ]]><Integer \"LexEOFRuleBase\"/><![[;\n\
\n\
// index of the rule that matches EOAF (end of all files, or end of input)\n\
	LEX_EOAF_RULE = ]]><Integer \"LexEOFARuleIndex\"/><![[;\n\
]]>\n\
</If><![[\n\
// index of symbol `$end\' in symbol table\n\
	PARSE_ENDSYMB_INDEX = ]]><Integer \"ParseEndSymbIdx\"/><![[;\n\
// index of symbol `error\' in symbol table\n\
	PARSE_ERRORSYMB_INDEX = ]]><Integer \"ParseErrorSymbIdx\"/><![[;\n\
// index of symbol `$undef\' in symbol table\n\
	PARSE_UNDEFSYMB_INDEX = ]]><Integer \"ParseUndefSymbIdx\"/><![[;\n\
\n\
// ID of symbol `$end\'\n\
	PARSE_ENDSYMB_ID = ]]><Integer \"ParseEndSymbID\"/><![[;\n\
// ID of symbol `error\'\n\
	PARSE_ERRORSYMB_ID = ]]><Integer \"ParseErrorSymbID\"/><![[;\n\
// ID of symbol \'$undef\'\n\
	PARSE_UNDEFSYMB_ID = ]]><Integer \"ParseUndefSymbID\"/><![[;\n\
]]>\n\
<If EnableParser><![[\n\
// row size(in byte) of non-error bitmap of parse table\n\
	PARSE_BMAP_ROWSIZE = ]]><Integer \"ParseBMapRowSize\"/><![[;\n\
// base address of indexes of types (aka non-terminals or variables)\n\
	PARSE_TYPE_BASE = ]]><Integer \"ParseTypeBase\"/><![[;\n\
// number of symbols in parser\n\
	PARSE_SYMBOL_COUNT = ]]><Integer \"ParseSymbolNum\"/><![[;\n\
\n\
// number of symbols in parser\n\
	PARSE_TOKENMAP_SIZE = ]]><Size \"ParseTokenMap\"/><![[;\n\
\n\
// start state of parser\n\
	PARSE_START_STATE = ]]><Integer \"ParseStartState\"/><![[;\n\
\n\
// accept state of parser\n\
	PARSE_ACCEPT_STATE = ]]><Integer \"ParseAcceptState\"/><![[;\n\
\n\
// illegal state for parser\n\
	PARSE_ERROR_STATE = ]]><Integer \"ParseErrorState\"/><![[;\n\
\n\
// special ID of invalid rule for parser, indicating current lookahead\n\
// symbol can not be shifted\n\
	PERROR_RULE = ]]><Integer \"ParseErrorRule\"/><![[;\n\
]]>\n\
</If><![[	\n\
type\n\
// function type for error-reporting\n\
	ptext_t = ^text;\n\
	]]><$YY \"error_t\"/><![[ = procedure (msg: string]]><If Has\?\"FormalParams\"><![[; ]]><Action \"FormalParams\"/></If><![[);\n\
]]>\n\
<If EnableParser><![[// function type for scanning\n\
	]]><$YY \"lex_t\"/><![[ = function (]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[): integer;\n\
]]>\n\
	<If Has\?\"LTypeName\"><![[\n\
// location type is defined by user as ]]><Action \"LTypeName\"/>\n\
	</If>\n\
	<Else><![[\n\
// location defines here\n\
	]]><$YY \"ltype_t\"/><![[ = record\n\
	]]><If Has\?\"LTypeDeclare\"><Action \"LTypeDeclare\"/></If>\n\
		<Else><![[firstLine: integer;\n\
	firstColumn: integer;\n\
	lastLine: integer;\n\
	lastColumn: integer;\n\
	]]>\n\
		</Else><![[\n\
	end;\n\
]]>\n\
	</Else>\n\
	<If Has\?\"STypeName\"><![[\n\
// semantic value type defined by user as ]]><Action \"STypeName\"/>\n\
	</If>\n\
	<Else><![[\n\
// semantic value type define here\n\
	]]><$YY \"stype_t\"/><![[ = record\n\
	]]>\n\
		<If Has\?\"STypeDeclare\"><Action \"STypeDeclare\"/>\n\
		</If>\n\
		<Else><![[nVal: integer;]]>\n\
		</Else><![[\n\
	end;\n\
\n\
]]>\n\
	</Else><![[\n\
	xstype_t = ]]><$TypeName \"STypeName\" \"stype_t\"/><![[;\n\
	xltype_t = ]]><$TypeName \"LTypeName\" \"ltype_t\"/><![[;\n\
]]>\n\
</If>\n\
\n\
<If EnableScanner><![[\n\
// initializing file buffer before parsing or patter-matching\n\
	function ]]><$YY \"lexfile\"/><![[(pchFile: string; iMod: boolean = false): integer;\n\
// initializing string buffer before parsing or patter-matching\n\
	function ]]><$YY \"lexstr\"/><![[(strbuf: pchar; size: integer): integer;\n\
// initializing const string buffer before parsing or patter-matching\n\
	function ]]><$YY \"lexcstr\"/><![[(strbuf: pchar; size: integer): integer;\n\
\n\
// generated scanner, can be replaced\n\
	function ]]><$YY \"lex\"/><If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: integer;\n\
\n\
]]>\n\
</If>\n\
<If EnableParser><![[\n\
// generated parser, it should not be replaced\n\
	function ]]><$YY \"parse\"/><![[(]]><If Has\?\"FormalParams\"><Action \"FormalParams\"/></If><![[): integer;\n\
// assign new scanner and return the old one\n\
	function ]]><$YY \"setlex\"/><![[(plex: ]]><$YY \"lex_t\"/><![[):]]><$YY \"lex_t\"/><![[;\n\
]]>\n\
</If><![[\n\
// assign new log stream\n\
	procedure ]]><$YY \"setstream\"/><![[(poutput, plogger: ptext_t);\n\
// assign new error-reporter and return the old one\n\
	function ]]><$YY \"seterror\"/><![[(perror: ]]><$YY \"error_t\"/><![[): ]]><$YY \"error_t\"/><![[;\n\
// reset all (both scanner and parser, if they are available)\n\
	procedure ]]><$YY \"clearall\"/><![[;\n\
]]>\n\
<If EnableParser><![[\n\
var\n\
	]]><$YY \"lval\"/><![[: xstype_t;\n\
	]]><$YY \"lloc\"/><![[: xltype_t;\n\
]]>\n\
</If>\n\
<If EnableScanner><![[\n\
const\n\
	CYCSTACK_SIZE = 64;\n\
	\n\
type\n\
	pfile_t = ^file;\n\
	bufbase_t = class;\n\
	YYPBUFFER = bufbase_t;\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
	cycstack_t = class\n\
	private\n\
		el: array [0..CYCSTACK_SIZE - 1] of smallint;\n\
		bs: smallint;\n\
		tp: smallint;\n\
	public\n\
		constructor create;\n\
		procedure push(n: integer);\n\
		function pop: integer;\n\
		procedure clear;\n\
	end;]]>\n\
		</If>\n\
	</If><![[\n\
	bufbase_t = class\n\
	protected\n\
		pbase, gptr, gend: pchar;\n\
		eos, imod: boolean;\n\
		line, col, tab: integer;\n\
		pvoid: pointer;\n\
\n\
	public\n\
		constructor create;\n\
		procedure reset; virtual;\n\
		function get: integer; virtual; abstract;\n\
		function peek: integer; virtual; abstract;\n\
		function unget: integer; overload; virtual; abstract;\n\
		function unget(num: integer): integer; overload; virtual; abstract;\n\
		function put(c: char): integer; virtual; abstract;\n\
\n\
		function iseof: boolean;\n\
		function iseos: boolean;\n\
		function isimod: boolean;\n\
		procedure setimod(bi: boolean);\n\
		function getlineno: integer;\n\
		procedure setlineno(nline: integer);\n\
		function getcolno: integer;\n\
		procedure setcolno(ncol: integer);\n\
		function gettabsize: integer;\n\
		procedure settabsize(ntab: integer);\n\
		function getdata: pointer;\n\
		procedure setdata(pv: pointer);\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
	private\n\
		stlsz: cycstack_t;\n\
		sttsz: cycstack_t;\n\
	public\n\
		procedure pushlsz(nlsize: integer);\n\
		function poplsz: integer;\n\
		procedure pushtsz(ntsize: integer);\n\
		function poptsz: integer;]]>\n\
		</If>\n\
	</If><![[\n\
	end;\n\
]]></If>\n\
<![[\n\
implementation\n\
]]>\n\
<$SingleAction \"DefineHeader\"/>\n\
<![[\n\
const\n\
	PAS_EOF__ = #26; {ctrl+z}\n\
	MAX_MSG_LENG = 64;\n\
	INIT_YYTEXT_SIZE = 4096;\n\
	INC_YYTEXT_SIZE = 2048;\n\
	SSTACK_INIT_SIZE = 1024;\n\
	SSTACK_INC_SIZE = 1024;\n\
	BUF_HALF_SIZE = 8192;\n\
	BUF_FULL_SIZE = BUF_HALF_SIZE * 2;\n\
\n\
	// grammar is accepted by automation\n\
	YYE_ACCEPT = 1;\n\
	// indicate automation is alive\n\
	YYE_ALIVE = 2;\n\
	// run out of all buffers,\n\
	// and token `$end\' will be sent to parser\n\
	YYE_EOS = 3;\n\
	// lexical analysis terminated manually,\n\
	// and token `$end\' will be sent to parser\n\
	YYE_TERM = 3;\n\
	// syntactic error occurs, and try to error-recover\n\
	YYE_PERROR = 4;\n\
\n\
	// can not match any pattern, token `$undef\' will\n\
	// be sent to parser\n\
	YYE_UNMATCHED =	PARSE_UNDEFSYMB_ID;\n\
\n\
	// out of memory\n\
	YYE_OOM = -1;\n\
	// out of range\n\
	YYE_OOR = -2;\n\
	// I/O error\n\
	YYE_IO = -3;\n\
	// parsing aborted\n\
	YYE_ABORT = -4;\n\
	YYE_NOINPUT = -5;\n\
	\n\
]]>\n\
<If EnableScanner><![[\n\
///////////////////////////////////////////////////////////////////////////\n\
	// lexical tables\n\
	// start states of DFAs\n\
	yydsc: array[0..]]><Size \"LexStartStates\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexStartStates\"/>\n\
	<![[	\n\
	);\n\
\n\
	// @yydcmap is a char map: char -> transition-label,\n\
	// that is, chars are grouped, transition label is\n\
	// representation of equivalent class of chars\n\
	yydcmap: array[0..]]><Size \"LexCharMap\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexCharMap\"/>\n\
	<![[\n\
	);\n\
\n\
	// @yydmeta is transition-label map: transition-label -> grouped-transition-label,\n\
	// that is, transition-label in @yydcmap are further grouped in order to save space\n\
	yydmeta: array[0..]]><Size \"LexMetaChars\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexMetaChars\"/>\n\
	<![[	\n\
	);\n\
\n\
	// use next-check-base-default scheme to store DFAs\n\
	// \n\
	yydbase: array[0..]]><Size \"LexDFABases\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexDFABases\"/>\n\
	<![[	\n\
	);\n\
	yyddef: array[0..]]><Size \"LexDFADefaults\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexDFADefaults\"/>\n\
	<![[	\n\
	);\n\
	// next table is an indeed transition table\n\
	yydnxt: array[0..]]><Size \"LexDFANexts\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexDFANexts\"/>\n\
	<![[	\n\
	);\n\
	yydchk: array[0..]]><Size \"LexDFAChecks\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexDFAChecks\"/>\n\
	<![[	\n\
	);\n\
	yydaccpt: array[0..]]><Size \"LexDFAAccepts\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexDFAAccepts\"/>\n\
	<![[	\n\
	);\n\
	YYMSG_UNMATCHED: pchar = \'Error: unmatched character ` \'\'.\';\n\
]]>\n\
	<If Has\?\"LexDFALookaheads\"><![[\n\
	yylad: array[0..]]><Size \"LexDFALookaheads\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexDFALookaheads\"/><![[\n\
	);]]>\n\
	</If>\n\
\n\
	<If LexDebugMode><![[\n\
	yydscnam: array[0..]]><Size \"LexStartLabels\"/><![[ - 1] of pchar = (\n\
	]]><$QStrArray \"LexStartLabels\"/><![[\n\
	);\n\
\n\
	yydline: array[0..]]><Size \"LexRule2Lines\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"LexRule2Lines\"/><![[\n\
	);]]>\n\
	</If>\n\
</If>\n\
<If EnableParser><![[\n\
	// token map: token ID --> token index in token ID table\n\
	// in fact, it acts like inverse table of token ID table\n\
	yyptmap: array[0..]]><Size \"ParseTokenMap\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseTokenMap\"/>\n\
<![[\n\
	);\n\
{\n\
	// token ID table, containing token IDs\n\
	yyptid: array[0..]]><Size \"ParseTokenID\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseTokenID\"/>\n\
<![[\n\
	);\n\
}\n\
	// prnum table, its element is number of symbols in right part of corresponding grammar rule\n\
	yyprnum: array[0..]]><Size \"ParseRPNum\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseRPNum\"/>\n\
<![[\n\
	);\n\
\n\
	// plid table, its element is the index of left part of corresponding grammar rule in token ID table\n\
	yyplid: array[0..]]><Size \"ParseLPID\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseLPID\"/>\n\
<![[\n\
	);\n\
\n\
	// parse action table\n\
	yypact: array[0..]]><Size \"ParseActEntries\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseActEntries\"/>\n\
<![[\n\
	);\n\
\n\
	// base array for parse action table\n\
	// which is used to determine the base location of the entries\n\
	// for each state stored in the yypack table\n\
	yypabase: array[0..]]><Size \"PActionBases\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"PActionBases\"/>\n\
<![[\n\
	);\n\
\n\
	yypgoto: array[0..]]><Size \"ParseGotos\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseGotos\"/>\n\
<![[\n\
	);\n\
\n\
	yypgbase: array[0..]]><Size \"PGotoBases\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"PGotoBases\"/>\n\
<![[\n\
	);\n\
\n\
	yyvbmap: array[0..]]><Size \"ParseValidBMap\"/><![[ - 1] of byte = (\n\
	]]><$IntArray \"ParseValidBMap\"/>\n\
<![[\n\
	);\n\
\n\
	yyparv: array[0..]]><Size \"ParseActRowVal\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseActRowVal\"/>\n\
<![[\n\
	);\n\
\n\
\n\
	yyparn: array[0..]]><Size \"ParseActRowNice\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseActRowNice\"/>\n\
<![[\n\
	);\n\
\n\
	yypcv: array[0..]]><Size \"ParseColVal\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseColVal\"/>\n\
<![[\n\
	);\n\
\n\
	yypcn: array[0..]]><Size \"ParseColNice\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseColNice\"/>\n\
<![[\n\
	);\n\
\n\
\n\
	yypgrv: array[0..]]><Size \"ParseGotoRowVal\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseGotoRowVal\"/>\n\
<![[\n\
	);\n\
\n\
	yypgrn: array[0..]]><Size \"ParseGotoRowNice\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseGotoRowNice\"/>\n\
<![[\n\
	);\n\
]]>\n\
	<If ParseDebugMode><![[\n\
	yypsnam: array[0..]]><Size \"ParseSymName\"/><![[ - 1] of pchar = (\n\
	]]><$QStrArray \"ParseSymName\"/><![[\n\
	);\n\
\n\
	yyprpbase: array[0..]]><Size \"ParseRPBases\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseRPBases\"/><![[\n\
	);\n\
\n\
	yyprpidx: array[0..]]><Size \"ParseRPIndexes\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseRPIndexes\"/><![[\n\
	);\n\
\n\
	yypline: array[0..]]><Size \"ParseRule2Lines\"/><![[ - 1] of integer = (\n\
	]]><$IntArray \"ParseRule2Lines\"/><![[\n\
	);]]>\n\
	</If>\n\
</If><![[\n\
type\n\
]]>\n\
<If EnableScanner><![[\n\
	\n\
	filebuf_t = class(bufbase_t)\n\
	private\n\
		bpeeked: boolean;\n\
		pfile: pfile_t;\n\
		_buf: array[0..BUF_FULL_SIZE - 1] of char;\n\
		buf: pchar;\n\
	private\n\
		procedure init;\n\
		function fill(p: pchar): integer;\n\
	public\n\
		constructor create(pf: pfile_t = nil; bm: boolean = false);\n\
		destructor destroy; override;\n\
	public\n\
		procedure reset; override;\n\
		function get: integer; override;\n\
		function peek: integer; override;\n\
		function unget: integer; override;\n\
		function unget(num: integer): integer; override;\n\
		function put(c: char): integer; override;\n\
	end;\n\
  \n\
	strbuf_t = class(bufbase_t)\n\
	private\n\
		bowner: boolean;\n\
	public\n\
		constructor create(pchbuf: pchar; nsize: integer;\n\
		  bown: boolean = false);\n\
		destructor destroy; override;\n\
	public\n\
		procedure reset; override;\n\
		function get: integer; override;\n\
		function peek: integer; override;\n\
		function unget: integer; override;\n\
		function unget(num: integer): integer; override;\n\
		function put(c: char): integer; override;\n\
	end;\n\
\n\
	plink_t = ^link_t;\n\
	link_t = record\n\
		pxbuf: YYPBUFFER;\n\
		plink: plink_t;\n\
	end;\n\
  \n\
	bufmgr_t = class\n\
	private\n\
		phead, pavail: plink_t;\n\
		xstdin: bufbase_t;\n\
		oldfmode: byte;\n\
	public\n\
		constructor create;\n\
		destructor destroy; override;\n\
		function get: integer;\n\
		function peek: integer;\n\
		function unget: integer; overload;\n\
		function unget(num: integer): integer; overload;\n\
		function put(c: char): integer;\n\
		function iseof: boolean;\n\
		function iseos: boolean;\n\
		function isimod: boolean;\n\
		function getlineno: integer;\n\
		procedure setlineno(nline: integer);\n\
		function getcolno: integer;\n\
		procedure setcolno(ncol: integer);\n\
		function gettabsize: integer;\n\
		procedure settabsize(ntab: integer);\n\
		procedure reset;\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		procedure pushlsz(nlsize: integer);\n\
		function poplsz: integer;\n\
		procedure pushtsz(ntsize: integer);\n\
		function poptsz: integer;]]>\n\
		</If>\n\
	</If><![[	\n\
		function current: YYPBUFFER;\n\
		function empty: boolean;\n\
		function newbuf(pf: pfile_t; im: boolean = false): YYPBUFFER; overload;\n\
		function newbuf(pcbuf: pchar; nsize: integer;\n\
		  bown: boolean = false): YYPBUFFER; overload;\n\
		function switchto(pbuf: YYPBUFFER): YYPBUFFER;\n\
		function pop: YYPBUFFER;\n\
		procedure destroytop;\n\
		procedure destroyall;\n\
	private\n\
		function rmwork(pxb: YYPBUFFER): plink_t;\n\
  end;\n\
]]>\n\
</If>\n\
<![[\n\
	istack_item_t = integer;\n\
	pistack_item_t = ^istack_item_t;\n\
	\n\
	istack_t = class\n\
	private\n\
		el: pistack_item_t;\n\
		tp: integer;\n\
		sz: integer;\n\
	public\n\
		constructor create;\n\
		destructor destroy; override;\n\
		procedure push; overload;\n\
		procedure push(ss: integer); overload;\n\
		function top: integer;\n\
		procedure pop(n: integer);\n\
		function getat(n: integer): integer;\n\
		function empty: boolean;\n\
		function count: integer;\n\
		procedure clear;\n\
	end;\n\
]]>\n\
<If EnableParser><![[\n\
	sstack_item_t = record\n\
		sid: integer;\n\
		sv: xstype_t;\n\
	end;\n\
  \n\
	psstack_item_t = ^sstack_item_t;\n\
    \n\
	sstack_t = class\n\
	private\n\
		el: psstack_item_t;\n\
		tp: integer;\n\
		sz: integer;\n\
	public\n\
		constructor create;\n\
		destructor destroy; override;\n\
		procedure push; overload;\n\
		procedure push(sid: integer; sv: xstype_t); overload;\n\
\n\
		function top: psstack_item_t;\n\
		procedure pop(n: integer);\n\
		function getat(n: integer): psstack_item_t;\n\
		function empty: boolean;\n\
		function count: integer;\n\
	end;]]>\n\
	<If EnableLocation><![[\n\
	\n\
	plstack_item_t = ^xltype_t;\n\
	lstack_t = class\n\
	private\n\
		el: plstack_item_t;\n\
		tp: integer;\n\
		sz: integer;\n\
	public\n\
		constructor create;\n\
		destructor destroy; override;\n\
		procedure push; overload;\n\
		procedure push(e: xltype_t); overload;\n\
		function top: plstack_item_t;\n\
		procedure pop(n: integer);\n\
		function getat(n: integer): plstack_item_t;\n\
		function empty: boolean;\n\
		function count: integer;\n\
	end;\n\
]]>\n\
	</If>\n\
</If>\n\
<![[	]]><$YY \"parser_t\"/><![[ = class\n\
	private\n\
	 	yyecode__: integer;\n\
	 	yyoutput: ptext_t;\n\
	 	yylogger: ptext_t;\n\
	 	yyerror: ]]><$YY \"error_t\"/><![[;]]>\n\
<If EnableScanner><![[\n\
		yybufmgr__: bufmgr_t;\n\
		yyscstk__: istack_t;\n\
		yysize__: integer;\n\
		yystart__: integer;\n\
		yymore_flag__: boolean;\n\
		yyat_bol__: boolean;\n\
		\n\
		yytext: pchar;\n\
		yyleng: integer;\n\
		yylaleng: integer;\n\
	private\n\
		function renew_text__: boolean;\n\
		function yylex_is_running__: boolean;\n\
		function yyget_lexrule__(s: integer): integer;\n\
		function yynext_lexstate__(s, c: integer): integer;\n\
]]>\n\
</If>\n\
<If EnableParser><![[\n\
	private\n\
		yyerr_flag__: boolean;\n\
		yyltok: integer;\n\
		yylexer: ]]><$YY \"lex_t\"/><![[;\n\
		\n\
		procedure YYACCEPT;\n\
		procedure YYABORT;\n\
		procedure yyerrok;\n\
		function yyparse_is_running__(s: integer): boolean;\n\
		function yyget_defrule(s: integer): integer;\n\
		function is_valid_pstate__(s: integer): boolean;\n\
		function is_valid_prule__(r: integer): boolean;\n\
		function yyget_prule__(s: integer): integer;\n\
		procedure yydiscard__(var yydval: xstype_t; var yydloc: xltype_t; yydsymb: integer]]>\n\
		<If Has\?\"FormalParams\"><![[;]]><Action \"FormalParams\"/></If><![[);\n\
		function yynext_pstate__(s, t: integer): integer;\n\
		function yynext_goto__(s, t: integer): integer;\n\
		function yyparse__]]>\n\
		<If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: integer;\n\
]]>\n\
</If><![[\n\
	public\n\
		constructor create]]>\n\
<If EnableParser>\n\
		<![[(]]><![[plex: ]]><$YY \"lex_t\"/><![[ = nil)]]>\n\
</If><![[;\n\
		destructor destroy; override;\n\
		procedure yyclearall__;\n\
]]>\n\
<If EnableScanner><![[\n\
		function yylexinit__(pchFile: string; bi: boolean): boolean; overload;\n\
		function yylexinit__(strbuf: pchar; size: integer; bcopied: boolean): boolean; overload;\n\
		function yylex__]]>\n\
		<If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: integer;\n\
	private\n\
		// user interfaces\n\
		// easy way to print matched string\n\
		procedure YYECHO;\n\
		procedure ECHO;\n\
		// switch start-condition\n\
		procedure YYBEGIN(sc: integer);\n\
		// return current start-condition\n\
		function YYSTART: integer;\n\
		// save current start-condition and switch to new start-condition\n\
		procedure yy_push_state(nsc: integer);\n\
		// switch to last saved start-condition\n\
		function yy_pop_state: boolean;\n\
		// return last saved start-condition\n\
		function yy_top_state: integer;\n\
		// get/set flag of beginning-of-line\n\
		function yy_get_bol: boolean;\n\
		procedure yy_set_bol(b: boolean);\n\
		\n\
		// buffer operations\n\
		function yy_current_buffer: YYPBUFFER;\n\
		function yy_has_buffer: boolean;\n\
		procedure yy_push_buffer(pbuffer: YYPBUFFER);\n\
		function yy_pop_buffer: YYPBUFFER;\n\
		function yy_new_filebuf(strfile: string; bi: boolean = false): YYPBUFFER;\n\
		function yy_new_cstrbuf(cstrbuf: pchar; size: integer): YYPBUFFER;\n\
		function yy_new_strbuf(strbuf: pchar; size: integer): YYPBUFFER;\n\
		procedure yy_delete_buffer;\n\
		procedure yy_switch_buffer(buf: YYPBUFFER);\n\
		procedure yyrestart;\n\
		procedure yymore;\n\
		function yyless(n: integer): integer;\n\
		function yyinput: integer;\n\
		function yyunput(c: char): boolean;\n\
		function yyunget: boolean;\n\
		procedure yyterminate;\n\
		procedure yyadd_lineno(nline: integer);\n\
		procedure yyadd_colno(ncol: integer);\n\
		function yyget_lineno: integer;\n\
		procedure yyset_lineno(nline: integer);\n\
		function yyget_colno: integer;\n\
		procedure yyset_colno(ncol: integer);\n\
		function yyget_tabsize: integer;\n\
		procedure yyset_tabsize(ntab: integer);\n\
		function yywrap__]]><If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: boolean;\n\
]]></If><![[\n\
	end;\n\
]]>\n\
<If EnableScanner>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
	//////////////////////////////////////////////////////////////\n\
	// class cycstack_t\n\
	constructor cycstack_t.create;\n\
	begin\n\
		inherited;\n\
		bs := 0;\n\
		tp := 0;\n\
	end;\n\
\n\
	procedure cycstack_t.push(n: integer);\n\
	begin\n\
		tp := (tp + 1) mod CYCSTACK_SIZE;\n\
		el[tp] := smallint(n);\n\
		if tp = bs then bs := (tp + 1) mod CYCSTACK_SIZE;\n\
	end;\n\
\n\
	function cycstack_t.pop: integer;\n\
	begin\n\
\n\
		if tp = bs then pop := 0   \n\
		else\n\
		begin\n\
			pop := integer(el[tp]);\n\
			tp := (tp + CYCSTACK_SIZE - 1) mod CYCSTACK_SIZE;\n\
		end;\n\
	end;\n\
\n\
	procedure cycstack_t.clear;\n\
	begin\n\
	tp := bs;\n\
	end;\n\
	// class cycstack_t\n\
	///////////////////////////////////////////////////////////////\n\
]]>\n\
		</If>\n\
	</If><![[\n\
	///////////////////////////////////////////////////////////////\n\
	// class bufbase_t\n\
	constructor bufbase_t.create;\n\
	begin\n\
		inherited;\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		stlsz := cycstack_t.create;\n\
		sttsz := cycstack_t.create;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
		line := 1;\n\
		col := 1;\n\
		tab := 4;\n\
		pvoid := nil;\n\
		imod := false;\n\
	end;\n\
  \n\
	procedure bufbase_t.reset;\n\
	begin]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		stlsz.clear;\n\
		sttsz.clear;\n\
]]>\n\
		</If>\n\
    </If><![[    \n\
	end;\n\
  \n\
	function bufbase_t.iseof: boolean;\n\
	begin\n\
		iseof := (gptr = gend);\n\
	end;\n\
  \n\
	function bufbase_t.iseos: boolean;\n\
	begin\n\
		iseos := eos;\n\
	end;\n\
  \n\
	function bufbase_t.isimod: boolean;\n\
	begin\n\
		isimod := imod;\n\
	end;\n\
  \n\
	procedure bufbase_t.setimod(bi: boolean);\n\
	begin\n\
		imod := bi;\n\
	end;\n\
  \n\
	function bufbase_t.getlineno: integer;\n\
	begin\n\
		getlineno := line;\n\
	end;\n\
  \n\
	procedure bufbase_t.setlineno(nline: integer);\n\
	begin\n\
		line := nline;\n\
	end;\n\
  \n\
	function bufbase_t.getcolno: integer;\n\
	begin\n\
		getcolno := col;\n\
	end;\n\
  \n\
	procedure bufbase_t.setcolno(ncol: integer);\n\
	begin\n\
		col := ncol;\n\
	end;\n\
  \n\
	function bufbase_t.gettabsize: integer;\n\
	begin\n\
		gettabsize := tab;\n\
	end;\n\
\n\
	procedure bufbase_t.settabsize(ntab: integer);\n\
	begin\n\
		tab := ntab;\n\
	end;\n\
\n\
	function bufbase_t.getdata: pointer;\n\
	begin\n\
		getdata := pvoid;\n\
	end;\n\
\n\
	procedure bufbase_t.setdata(pv: pointer);\n\
	begin\n\
		pvoid := pv;\n\
	end;\n\
\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[  \n\
	procedure bufbase_t.pushlsz(nlsize: integer);\n\
	begin\n\
		stlsz.push(nlsize);\n\
	end;\n\
\n\
	function bufbase_t.poplsz: integer;\n\
	begin\n\
		poplsz := stlsz.pop;\n\
	end;\n\
\n\
	procedure bufbase_t.pushtsz(ntsize: integer);\n\
	begin\n\
		sttsz.push(ntsize);\n\
	end;\n\
\n\
	function bufbase_t.poptsz: integer;\n\
	begin\n\
		poptsz := sttsz.pop;\n\
	end;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
	// class bufbase_t\n\
	///////////////////////////////////////////////////////////////\n\
\n\
	///////////////////////////////////////////////////////////////\n\
	// class filebuf_t\n\
	procedure filebuf_t.init;\n\
	begin\n\
		gend := buf;\n\
		gptr := gend + BUF_FULL_SIZE - 1;\n\
		pbase := gptr;\n\
		gptr^ := #10;\n\
		eos := false;\n\
		bpeeked := false;\n\
\n\
		if pfile <> @input then\n\
			system.reset(pfile^, 1);\n\
	end;\n\
\n\
	function filebuf_t.fill(p: pchar): integer;\n\
	var\n\
		ncnt, vacents: integer;\n\
		c: char;\n\
	begin\n\
		ncnt := 0;\n\
		vacents := ((pbase + BUF_FULL_SIZE) - gend) mod BUF_FULL_SIZE;\n\
\n\
		if pfile <> @input then\n\
		begin\n\
			{$I-}\n\
			blockread(pfile^, p^, BUF_HALF_SIZE, ncnt);\n\
			{$I+}\n\
		\n\
			if ncnt > 0 then\n\
				gend := buf + ((p - buf) + ncnt) mod BUF_FULL_SIZE;\n\
		end\n\
		else\n\
		begin\n\
			c := #0;\n\
		  while (c <> #10) and (ncnt < BUF_HALF_SIZE) do\n\
		  begin\n\
			{$I-}\n\
			read(input, c);\n\
			{$I+}\n\
			gend^ := c;\n\
	\n\
			if c = PAS_EOF__ then break;\n\
		\n\
			gend := buf + ((gend - buf) + 1) mod BUF_FULL_SIZE;\n\
			ncnt := ncnt + 1;\n\
			end; \n\
		end;\n\
\n\
		if ncnt > vacents then\n\
			pbase := buf + ((gend - buf) + 1) mod BUF_FULL_SIZE;\n\
		  \n\
		fill := ncnt;\n\
	end;\n\
	\n\
	constructor filebuf_t.create(pf: pfile_t; bm: boolean);\n\
	begin\n\
		inherited create;\n\
\n\
		if pf = nil then pfile := @input\n\
		else pfile := pf;\n\
\n\
		buf := @_buf;\n\
		imod := bm;\n\
		init;\n\
	end;\n\
\n\
	destructor filebuf_t.destroy;\n\
	begin\n\
		if pfile <> @input then\n\
		begin\n\
			closefile(pfile^);\n\
			dispose(pfile);\n\
		end;    	\n\
	end;\n\
\n\
	procedure filebuf_t.reset;\n\
	begin\n\
		if pfile <> @input then seek(pfile^, 0);\n\
\n\
		init;\n\
		inherited reset;\n\
	end;\n\
\n\
	function filebuf_t.get: integer;\n\
	begin\n\
		if gptr = gend then\n\
		begin\n\
			eos := true;\n\
			get := END_OF_ALLFILE;\n\
		end\n\
		else\n\
		begin\n\
			gptr := buf + ((gptr - buf) + 1) mod BUF_FULL_SIZE;\n\
\n\
			if (gptr = gend) and (not bpeeked) then\n\
			begin\n\
				fill(gptr);\n\
				bpeeked := false;\n\
			end;\n\
\n\
			if iseof then get := END_OF_FILE\n\
			else get := integer(gptr^);\n\
		end;\n\
	end;\n\
\n\
	function filebuf_t.peek: integer;\n\
	var\n\
		p: pchar;\n\
	begin\n\
		if gptr = gend then peek := END_OF_ALLFILE\n\
		else begin\n\
			p := buf + ((gptr - buf) + 1) mod BUF_FULL_SIZE;\n\
			if p = gend then fill(p);\n\
			bpeeked := true;\n\
\n\
			if p = gend then peek := END_OF_FILE\n\
			else peek := integer(p^);\n\
		end;\n\
	end;\n\
\n\
	function filebuf_t.unget: integer;\n\
	begin\n\
		if eos or (gptr = pbase) then unget := END_OF_FILE\n\
		else begin\n\
			unget := integer(gptr^);\n\
			gptr := buf + ((gptr - buf) + BUF_FULL_SIZE - 1) mod BUF_FULL_SIZE;\n\
		end;\n\
	end;\n\
\n\
	function filebuf_t.unget(num: integer): integer;\n\
	var\n\
		n: integer;\n\
	begin\n\
		if eos or (gptr = pbase) then unget := 0\n\
		else\n\
		begin\n\
			n := ((gptr - pbase) + BUF_FULL_SIZE) mod BUF_FULL_SIZE;\n\
			if n > num then n := num;\n\
\n\
			gptr := buf + ((gptr - buf) + BUF_FULL_SIZE - n) mod BUF_FULL_SIZE;\n\
			unget := n;\n\
		end;\n\
	end;\n\
\n\
	function filebuf_t.put(c: char): integer;\n\
	begin\n\
		if eos or (gptr = pbase) then put := END_OF_FILE\n\
		else begin\n\
			put := integer(gptr^);\n\
			gptr^ := c;\n\
			gptr := buf + ((gptr - buf) + BUF_FULL_SIZE - 1) mod BUF_FULL_SIZE;\n\
		end;\n\
	end;\n\
	// filebuf_t\n\
	///////////////////////////////////////////////////////////////\n\
  \n\
	///////////////////////////////////////////////////////////////\n\
	// strbuf_t\n\
	constructor strbuf_t.create(pchbuf: pchar; nsize: integer; bown: boolean);\n\
	var\n\
		i: integer;\n\
	begin\n\
		inherited create;\n\
		bowner := bown;\n\
		if bowner then begin\n\
			getmem(pbase, nsize);\n\
			if pbase = nil then\n\
			begin\n\
				halt(1); { unrecoverable error }\n\
			end;\n\
			for i := 0 to nsize - 1 do\n\
				pbase[i] := pchbuf[i];\n\
			gend := pbase + nsize - 1;\n\
			gend^ := #0;\n\
		end\n\
		else begin\n\
			pbase := pchbuf;\n\
			gend := pbase + nsize - 1;\n\
		end;\n\
\n\
		reset;\n\
	end;\n\
\n\
	destructor strbuf_t.destroy;\n\
	begin\n\
		if bowner then freemem(pbase);\n\
	end;\n\
\n\
	procedure strbuf_t.reset;\n\
	begin\n\
		gptr := pbase - 1;\n\
		eos := false;\n\
		inherited reset;\n\
	end;\n\
\n\
	function strbuf_t.get: integer;\n\
	begin\n\
		if gptr = gend then begin\n\
			eos := true;\n\
			get := END_OF_ALLFILE;\n\
		end\n\
		else begin\n\
			gptr := gptr + 1;\n\
			if gptr = gend then get := END_OF_FILE\n\
			else get := integer(gptr^);\n\
		end;\n\
	end;\n\
\n\
	function strbuf_t.peek: integer;\n\
	begin\n\
		if gptr = gend then begin\n\
			if eos then peek := END_OF_ALLFILE\n\
			else peek := END_OF_FILE;\n\
		end\n\
		else peek := integer((gptr + 1)^);\n\
	end;\n\
\n\
	function strbuf_t.unget: integer;\n\
	begin\n\
		if eos or (pbase - 1 = gptr) then unget := END_OF_FILE\n\
		else begin\n\
			unget := integer(gptr^);\n\
			gptr := gptr - 1;\n\
		end;\n\
	end;\n\
\n\
	function strbuf_t.unget(num: integer): integer;\n\
	var\n\
		n: integer;\n\
	begin\n\
		if eos or (pbase - 1 = gptr) then unget := 0\n\
		else\n\
		begin\n\
			n := gptr - pbase + 1;\n\
			if n > num then n := num;\n\
			gptr := gptr - n;\n\
			unget := n;\n\
		end;\n\
	end;\n\
\n\
	function strbuf_t.put(c: char): integer;\n\
	begin\n\
		if eos or (pbase - 1 = gptr) then put := END_OF_FILE\n\
		else begin\n\
			put := integer(gptr^);\n\
			gptr^ := c;\n\
			gptr := gptr - 1;\n\
		end;\n\
	end;\n\
	// class strbuf_t\n\
	///////////////////////////////////////////////////////////////\n\
  \n\
	///////////////////////////////////////////////////////////////\n\
	// class bufmgr_t\n\
	constructor bufmgr_t.create;\n\
	begin\n\
		xstdin := filebuf_t.create(nil, true);\n\
		new(pavail);\n\
		pavail^.pxbuf := xstdin;\n\
		pavail^.plink := nil;\n\
\n\
		oldfmode := FileMode;\n\
		FileMode := 0;\n\
	end;\n\
\n\
	destructor bufmgr_t.destroy;\n\
	var\n\
		p: plink_t;\n\
	begin\n\
		while pavail <> nil do begin\n\
			p := pavail^.plink;\n\
			pavail^.pxbuf.destroy;\n\
			dispose(pavail);\n\
\n\
			pavail := p;\n\
		end;\n\
\n\
		FileMode := oldfmode;\n\
	end;\n\
\n\
	function bufmgr_t.get: integer;\n\
	begin\n\
		if phead <> nil then get := phead^.pxbuf.get\n\
		else get:= END_OF_ALLFILE;\n\
	end;\n\
\n\
	function bufmgr_t.peek: integer;\n\
	begin\n\
		if phead <> nil then peek := phead^.pxbuf.peek\n\
		else peek := END_OF_ALLFILE;\n\
	end;\n\
\n\
	function bufmgr_t.unget: integer;\n\
	begin\n\
		if phead <> nil then unget := phead^.pxbuf.unget\n\
		else unget := END_OF_FILE;\n\
	end;\n\
\n\
	function bufmgr_t.unget(num: integer): integer;\n\
	begin\n\
		if phead <> nil then unget := phead^.pxbuf.unget(num)\n\
		else unget := 0;\n\
	end;\n\
\n\
	function bufmgr_t.put(c: char): integer;\n\
	begin\n\
		if phead <> nil then put := phead^.pxbuf.put(c)\n\
		else put := END_OF_FILE;\n\
	end;\n\
\n\
	function bufmgr_t.iseof: boolean;\n\
	begin\n\
		if phead <> nil then iseof := phead^.pxbuf.iseof\n\
		else iseof := true;\n\
	end;\n\
\n\
	function bufmgr_t.iseos: boolean;\n\
	begin\n\
		if phead <> nil then iseos := phead^.pxbuf.iseos\n\
		else iseos := true;\n\
	end;\n\
\n\
	function bufmgr_t.isimod: boolean;\n\
	begin\n\
		if phead <> nil then isimod := phead^.pxbuf.isimod\n\
		else isimod := false;\n\
	end;\n\
\n\
	function bufmgr_t.getlineno: integer;\n\
	begin\n\
		if phead <> nil then getlineno := phead^.pxbuf.getlineno\n\
		else getlineno := 0;\n\
	end;\n\
\n\
	procedure bufmgr_t.setlineno(nline: integer);\n\
	begin\n\
		if phead <> nil then phead^.pxbuf.setlineno(nline);\n\
	end;\n\
\n\
	function bufmgr_t.getcolno: integer;\n\
	begin\n\
		if phead <> nil then getcolno := phead^.pxbuf.getcolno\n\
		else getcolno := 0;\n\
	end;\n\
\n\
	procedure bufmgr_t.setcolno(ncol: integer);\n\
	begin\n\
		if phead <> nil then phead^.pxbuf.setcolno(ncol);\n\
	end;\n\
\n\
	function bufmgr_t.gettabsize: integer;\n\
	begin\n\
		if phead <> nil then gettabsize := phead^.pxbuf.gettabsize\n\
		else gettabsize := 0;\n\
	end;\n\
\n\
	procedure bufmgr_t.settabsize(ntab: integer);\n\
	begin\n\
		if phead <> nil then phead^.pxbuf.settabsize(ntab);\n\
	end;\n\
\n\
	procedure bufmgr_t.reset;\n\
	begin\n\
		if phead <> nil then phead^.pxbuf.reset;\n\
	end;\n\
]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
	procedure bufmgr_t.pushlsz(nlsize: integer);\n\
	begin\n\
		if phead <> nil then phead^.pxbuf.pushlsz(nlsize); \n\
	end;\n\
\n\
	function bufmgr_t.poplsz: integer;\n\
	begin\n\
		if phead <> nil then poplsz := phead^.pxbuf.poplsz\n\
		else poplsz := 0;\n\
	end;\n\
\n\
	procedure bufmgr_t.pushtsz(ntsize: integer);\n\
	begin\n\
		if phead <> nil then phead^.pxbuf.pushtsz(ntsize);\n\
	end;\n\
\n\
	function bufmgr_t.poptsz: integer;\n\
	begin\n\
	if phead <> nil then poptsz := phead^.pxbuf.poptsz\n\
	else poptsz := 0;\n\
	end;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
\n\
	function bufmgr_t.current: YYPBUFFER;\n\
	begin\n\
		if phead <> nil then current := phead^.pxbuf\n\
		else current := nil;\n\
	end;\n\
\n\
	function bufmgr_t.empty: boolean;\n\
	begin\n\
		empty := (phead = nil);\n\
	end;\n\
\n\
	function bufmgr_t.newbuf(pf: pfile_t; im: boolean): YYPBUFFER;\n\
	var\n\
		p: plink_t;\n\
	begin\n\
		if pf = @input then begin\n\
			xstdin.reset;\n\
			xstdin.setimod(im);\n\
			newbuf := xstdin;\n\
		end\n\
		else begin\n\
			new(p);\n\
			p^.plink := pavail^.plink;\n\
			p^.pxbuf := filebuf_t.create(pf, im);\n\
			pavail^.plink := p;\n\
			newbuf := p^.pxbuf;\n\
		end;\n\
	end;\n\
\n\
	function bufmgr_t.newbuf(pcbuf: pchar; nsize: integer;\n\
		bown: boolean): YYPBUFFER;\n\
	var\n\
		p: plink_t;\n\
	begin\n\
\n\
		new(p);\n\
		p^.plink := pavail^.plink;\n\
		p^.pxbuf := strbuf_t.create(pcbuf, nsize, bown);\n\
		pavail^.plink := p;\n\
\n\
		newbuf := p^.pxbuf;\n\
	end;\n\
\n\
	function bufmgr_t.switchto(pbuf: YYPBUFFER): YYPBUFFER;\n\
	var\n\
		p: plink_t;\n\
	begin\n\
		if phead = nil then switchto := nil\n\
		else switchto := phead^.pxbuf;\n\
\n\
		p := rmwork(pbuf);\n\
		if p = nil then begin\n\
			new(p);\n\
			p^.pxbuf := pbuf;\n\
		end;\n\
\n\
		p^.plink := phead;\n\
		phead := p;\n\
	end;\n\
\n\
	function bufmgr_t.pop: YYPBUFFER;\n\
	var\n\
		p: plink_t;\n\
	begin\n\
		if phead = nil then begin\n\
			pop := nil;\n\
			exit;\n\
		end;\n\
\n\
		p := phead;\n\
		pop := p^.pxbuf;\n\
		phead := phead^.plink;\n\
		dispose(p);\n\
	end;\n\
\n\
	procedure bufmgr_t.destroytop;\n\
	var\n\
		p, q: plink_t;\n\
		pxb: YYPBUFFER;\n\
	begin\n\
		pxb := pop;\n\
		if (pxb <> nil) and (pxb <> xstdin) then begin\n\
			p := pavail;\n\
			while (p^.plink <> nil) and (p^.plink^.pxbuf <> pxb) do\n\
			p := p^.plink;\n\
			if p^.plink <> nil then begin\n\
				q := p^.plink;\n\
				p^.plink := q^.plink;\n\
\n\
				pxb.destroy;\n\
				dispose(q);\n\
			end;\n\
		end;\n\
	end;\n\
\n\
	procedure bufmgr_t.destroyall;\n\
	var\n\
		p: plink_t;\n\
	begin\n\
		while pavail^.plink <> nil do begin\n\
			p := pavail^.plink;\n\
			pavail^.plink := p^.plink;\n\
			if p^.pxbuf <> nil then p^.pxbuf.destroy;\n\
			dispose(p);\n\
		end;\n\
\n\
		phead := nil;\n\
	end;\n\
\n\
	function bufmgr_t.rmwork(pxb: YYPBUFFER): plink_t;\n\
	var\n\
		p, q: plink_t;\n\
	begin\n\
		p := phead;\n\
		if p <> nil then begin\n\
			if pxb = p^.pxbuf then begin\n\
				phead := phead^.plink;\n\
				rmwork := p;\n\
				exit;\n\
			end\n\
			else begin\n\
				while (p^.plink <> nil) and (p^.plink^.pxbuf <> pxb) do\n\
					p := p^.plink;\n\
				if p^.plink <> nil then\n\
				begin\n\
					q := p^.plink;\n\
					p^.plink := q^.plink;\n\
					rmwork := q;\n\
					exit;\n\
				end;\n\
			end;\n\
		end; \n\
\n\
	rmwork := nil;     \n\
	end;\n\
  // class bufmgr_t\n\
  ///////////////////////////////////////////////////////////////\n\
]]>\n\
</If>\n\
<![[\n\
const  \n\
	SIZEOF_CHAR = sizeof(char);\n\
	CHARS_PER_INT = (sizeof(integer) + SIZEOF_CHAR - 1) div SIZEOF_CHAR;\n\
  \n\
	function deref_int(base: pistack_item_t; off: integer): pistack_item_t;\n\
	begin\n\
  		deref_int := pistack_item_t((pchar(base) + off * CHARS_PER_INT));\n\
	end;\n\
\n\
	function int_to_str__(num: integer): string;\n\
	var\n\
		s: string[12];\n\
	begin\n\
		str(num, s);\n\
		int_to_str__ := s;\n\
	end;\n\
	\n\
    procedure yyemit_error__(s: string]]>\n\
	<If Has\?\"FormalParams\"><![[; ]]><Action \"FormalParams\"/></If><![[); forward;\n\
	\n\
	constructor istack_t.create;\n\
  	begin\n\
  		inherited;\n\
  		getmem(el, sizeof(integer) * SSTACK_INIT_SIZE);\n\
  		sz := SSTACK_INIT_SIZE;\n\
  		tp := -1;\n\
  	end;\n\
  	\n\
	destructor istack_t.destroy;\n\
	begin\n\
		freemem(el);\n\
	end;\n\
	\n\
	procedure istack_t.push;\n\
	begin\n\
		if tp = sz - 1 then\n\
		begin\n\
			sz := sz + SSTACK_INC_SIZE;\n\
			reallocmem(el, sz * sizeof(integer));\n\
		end;\n\
		tp := tp + 1;\n\
	end;\n\
				\n\
	procedure istack_t.push(ss: integer);\n\
	var\n\
		p: pistack_item_t;\n\
	begin\n\
		if tp = sz - 1 then\n\
		begin\n\
			sz := sz + SSTACK_INC_SIZE;\n\
			reallocmem(el, sz * sizeof(integer));\n\
		end;\n\
		tp := tp + 1;\n\
		p := deref_int(el, tp);\n\
		p^ := ss;\n\
	end;\n\
	\n\
	function istack_t.top: integer;\n\
	begin\n\
		top := deref_int(el, tp)^;\n\
	end;\n\
\n\
	procedure istack_t.pop(n: integer);\n\
	begin\n\
		tp := tp - n;\n\
	end;\n\
	\n\
	function istack_t.getat(n: integer): integer;\n\
	begin\n\
		getat := deref_int(el, tp - n)^;\n\
	end;\n\
	\n\
	function istack_t.empty: boolean;\n\
	begin\n\
		empty := (tp < 0);\n\
	end;\n\
	\n\
	function istack_t.count: integer;\n\
	begin\n\
		count := tp + 1;\n\
	end;\n\
	\n\
	procedure istack_t.clear;\n\
	begin\n\
		tp := -1;\n\
	end;\n\
]]>\n\
<If EnableParser>\n\
	<If EnableLocation><![[\n\
const\n\
	CHARS_PER_LOC = (sizeof(xltype_t) + SIZEOF_CHAR - 1) div SIZEOF_CHAR;\n\
  \n\
	function deref_loc(base: plstack_item_t; off: integer): plstack_item_t;\n\
	begin\n\
		deref_loc := plstack_item_t((pchar(base) + off * CHARS_PER_LOC));\n\
	end;\n\
   \n\
   	constructor lstack_t.create;\n\
	begin\n\
		inherited;\n\
		getmem(el, sizeof(xltype_t) * SSTACK_INIT_SIZE);\n\
		sz := SSTACK_INIT_SIZE;\n\
		tp := -1;\n\
	end;\n\
	\n\
	destructor lstack_t.destroy;\n\
	begin\n\
		freemem(el);\n\
	end;\n\
	\n\
	procedure lstack_t.push;\n\
	begin\n\
		if tp = sz - 1 then\n\
		begin\n\
			sz := sz + SSTACK_INC_SIZE;\n\
			reallocmem(el, sz * sizeof(xltype_t));\n\
		end;\n\
		tp := tp + 1;\n\
	end;\n\
	\n\
	procedure lstack_t.push(e: xltype_t);\n\
	var\n\
		p: plstack_item_t;\n\
	begin\n\
		if tp = sz - 1 then\n\
		begin\n\
			sz := sz + SSTACK_INC_SIZE;\n\
			reallocmem(el, sz * sizeof(xltype_t));\n\
		end;\n\
		tp := tp + 1;\n\
		p := deref_loc(el, tp);\n\
		p^ := e;\n\
	end;\n\
	\n\
	function lstack_t.top: plstack_item_t;\n\
	begin\n\
		top := deref_loc(el, tp);\n\
	end;\n\
	\n\
	procedure lstack_t.pop(n: integer);\n\
	begin\n\
		tp := tp - n;\n\
	end;\n\
	\n\
	function lstack_t.getat(n: integer): plstack_item_t;\n\
	begin\n\
		getat := deref_loc(el, tp - n);\n\
	end;\n\
	\n\
	function lstack_t.empty: boolean;\n\
	begin\n\
		empty := (tp < 0);\n\
	end;\n\
	\n\
	function lstack_t.count: integer;\n\
	begin\n\
		count := tp + 1;\n\
	end;\n\
]]>\n\
	</If>\n\
	<If ParseDebugMode><![[\n\
\n\
	function sym_text__(s: pchar): string;\n\
	var\n\
		t: string[24];\n\
	begin\n\
		t := \'unprintable-char{\';\n\
		if (length(s) = 1) and ((ord(s[0]) < 32) or (ord(s[0]) >= 127)) then\n\
		begin\n\
			t := t + int_to_str__(ord(s[0]));\n\
			t := t + \'}\';\n\
			sym_text__ := t;\n\
		end\n\
		else if (length(s) = 2) and (s[0] = \'\\\') then\n\
		begin\n\
			case s[1] of\n\
			\'a\': sym_text__ := t + \'7}\';\n\
			\'b\': sym_text__ := t + \'8}\';\n\
			\'f\': sym_text__ := t + \'12}\';\n\
			\'t\': sym_text__ := t + \'9}\';\n\
			\'n\': sym_text__ := t + \'10}\';\n\
			\'r\': sym_text__ := t + \'13}\';\n\
			\'v\': sym_text__ := t + \'11}\';\n\
			else sym_text__ := s[1];\n\
			end;\n\
		end\n\
		else\n\
			sym_text__ := string(s);\n\
	end;\n\
]]>\n\
	</If><![[\n\
const \n\
	CHARS_PER_SYM = (sizeof(sstack_item_t) + SIZEOF_CHAR - 1) div SIZEOF_CHAR;  \n\
	  \n\
	function deref_sym(base: psstack_item_t; off: integer): psstack_item_t;\n\
	begin\n\
		deref_sym := psstack_item_t((pchar(base) + off * CHARS_PER_SYM));\n\
	end;\n\
  \n\
	constructor sstack_t.create;\n\
	begin\n\
		inherited;\n\
		getmem(el, sizeof(sstack_item_t) * SSTACK_INIT_SIZE);\n\
		sz := SSTACK_INIT_SIZE;\n\
		tp := -1;    \n\
	end;\n\
\n\
	destructor sstack_t.destroy;\n\
	begin\n\
		freemem(el);\n\
	end;\n\
  \n\
	procedure sstack_t.push;\n\
	begin\n\
		if tp = sz - 1 then begin\n\
			sz := sz + SSTACK_INC_SIZE;\n\
			reallocmem(el, sz * sizeof(sstack_item_t));\n\
		end;\n\
		tp := tp + 1;\n\
	end;\n\
  \n\
	procedure sstack_t.push(sid: integer; sv: xstype_t);\n\
	var\n\
		p: psstack_item_t;\n\
	begin\n\
	if tp = sz - 1 then begin\n\
		sz := sz + SSTACK_INC_SIZE;\n\
		reallocmem(el, sz * sizeof(sstack_item_t));\n\
	end;\n\
		tp := tp + 1;\n\
		p := deref_sym(el, tp);\n\
		p^.sid := sid;\n\
		p^.sv := sv;\n\
	end;\n\
\n\
	function sstack_t.top: psstack_item_t;\n\
	begin\n\
		top := deref_sym(el, tp);\n\
	end;\n\
\n\
	procedure sstack_t.pop(n: integer);\n\
	begin\n\
		tp := tp - n;\n\
	end;\n\
\n\
	function sstack_t.getat(n: integer): psstack_item_t;\n\
	begin\n\
		getat := deref_sym(el, tp - n);\n\
	end;\n\
  \n\
	function sstack_t.empty: boolean;\n\
	begin\n\
		empty := (tp < 0);\n\
	end;\n\
\n\
	function sstack_t.count: integer;\n\
	begin\n\
		count := tp + 1;\n\
	end;\n\
  ]]>\n\
</If>\n\
<If EnableScanner><![[\n\
	function ]]><$YY \"parser_t\"/><![[.renew_text__: boolean;\n\
	begin\n\
	  reallocmem(yytext, INC_YYTEXT_SIZE + yysize__);\n\
	  yysize__ := yysize__ + INC_YYTEXT_SIZE;\n\
	  yytext[yysize__ - 1] := #0;\n\
	  renew_text__ := true;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yylex_is_running__: boolean;\n\
	begin\n\
		yylex_is_running__ := (yyecode__ = YYE_ALIVE);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyget_lexrule__(s: integer): integer;\n\
	begin\n\
		yyget_lexrule__ := yydaccpt[s];\n\
	end;\n\
	function ]]><$YY \"parser_t\"/><![[.yynext_lexstate__(s, c: integer): integer;\n\
	var\n\
		d: integer;\n\
	begin\n\
		d := yydcmap[c];\n\
		while (s < LEX_STATE_COUNT) and (yydchk[yydbase[s] + d] <> s) do\n\
			s := yyddef[s];\n\
		if s > LEX_STATE_COUNT then\n\
		begin\n\
			if yydchk[yydbase[s] + yydmeta[d]] = s then\n\
				yynext_lexstate__ := yydnxt[yydbase[s] + yydmeta[d]]\n\
			else\n\
				yynext_lexstate__ := LEX_ERROR_STATE;\n\
		end\n\
		else\n\
			yynext_lexstate__ := yydnxt[ yydbase[s] + d];\n\
	end;\n\
	\n\
]]>\n\
</If>\n\
<If EnableParser><![[\n\
	procedure ]]><$YY \"parser_t\"/><![[.YYACCEPT;\n\
	begin\n\
		yyecode__ := YYE_ACCEPT;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.YYABORT;\n\
	begin\n\
		yyecode__ := YYE_ABORT;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyerrok;\n\
	begin\n\
		yyerr_flag__ := false;\n\
		yyltok := PARSE_UNDEFSYMB_ID;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyparse_is_running__(s: integer): boolean;\n\
	begin\n\
		yyparse_is_running__ := ((yyecode__ > YYE_ACCEPT) and (s <> PARSE_ACCEPT_STATE));\n\
	end;\n\
	 \n\
	function ]]><$YY \"parser_t\"/><![[.yyget_defrule(s: integer): integer;\n\
	var\n\
		r: integer;\n\
	begin\n\
		r := yyget_prule__(yyparv[s]);\n\
		if (yyparn[s] = 0) and is_valid_prule__(r) then\n\
			yyget_defrule := r\n\
		else\n\
			yyget_defrule := PERROR_RULE;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.is_valid_pstate__(s: integer): boolean;\n\
	begin\n\
		is_valid_pstate__ := (s < PARSE_ERROR_STATE);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.is_valid_prule__(r: integer): boolean;\n\
	begin\n\
		is_valid_prule__ := ((r >= 0) and (r < PERROR_RULE));\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyget_prule__(s: integer): integer;\n\
	begin\n\
		yyget_prule__ := s - (PARSE_ERROR_STATE + 1);\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yydiscard__(var yydval: xstype_t; var yydloc: xltype_t;\n\
		yydsymb: integer]]><If Has\?\"FormalParams\"><![[;]]><Action \"FormalParams\"/></If><![[);\n\
	begin\n\
	]]>\n\
	<If Has\?\"DestructorActions\"><![[\n\
		case yydsymb of\n\
		]]><$UserDiscardActions \"DestructorSymbols\" \"DestructorActions\"/><![[\n\
		end;]]>\n\
	</If><![[	\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yynext_pstate__(s, t: integer): integer;\n\
	begin\n\
		if (yyvbmap[s * PARSE_BMAP_ROWSIZE + t div 8] and (1 shl (t mod 8))) <> 0 then\n\
		begin\n\
			if yyparn[s] < yypcn[t] then\n\
				yynext_pstate__ := yyparv[s]\n\
			else if yyparn[s] > yypcn[t] then\n\
				yynext_pstate__ := yypcv[t]\n\
			else\n\
				yynext_pstate__ := yypact[yypabase[s] + t];\n\
		end\n\
		else\n\
			yynext_pstate__ := PARSE_ERROR_STATE;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yynext_goto__(s, t: integer): integer;\n\
	begin\n\
		if yypgrn[s] < yypcn[PARSE_TYPE_BASE + t] then\n\
			yynext_goto__ := yypgrv[s]\n\
		else if yypgrn[s] > yypcn[PARSE_TYPE_BASE + t] then\n\
			yynext_goto__ := yypcv[PARSE_TYPE_BASE + t]\n\
		else\n\
			yynext_goto__ := yypgoto[yypgbase[s] + t];\n\
	end;\n\
	\n\
]]>\n\
</If><![[\n\
\n\
	constructor ]]><$YY \"parser_t\"/><![[.create]]>\n\
<If EnableParser>\n\
	<![[(]]><![[plex: ]]><$YY \"lex_t\"/><![[)]]>\n\
</If><![[;\n\
	begin\n\
		inherited create;\n\
		yyecode__ := YYE_ALIVE;\n\
		yyoutput := @output;\n\
		yylogger := @output;]]>\n\
<If EnableScanner><![[\n\
		yyscstk__ := istack_t.create;\n\
		yybufmgr__ := bufmgr_t.create;\n\
		yysize__ := 0;\n\
		yystart__ := INITIAL;\n\
		yymore_flag__ := false;\n\
		yyat_bol__ := true;\n\
		yytext := nil;\n\
		yyleng := 0;\n\
		yylaleng := 0;]]>\n\
</If>\n\
<If EnableParser><![[\n\
		yyerr_flag__ := false;\n\
		yyltok := PARSE_UNDEFSYMB_ID;\n\
		yylexer := plex;]]>\n\
</If><![[\n\
		yyerror := @yyemit_error__;		\n\
	end;\n\
	\n\
	destructor ]]><$YY \"parser_t\"/><![[.destroy;\n\
	begin\n\
]]><If EnableScanner><![[\n\
		if yytext <> nil then\n\
			freemem(yytext);\n\
		yyscstk__.destroy;\n\
		yybufmgr__.destroy;\n\
]]></If><![[\n\
	end;\n\
	\n\
]]>\n\
<If EnableScanner><![[\n\
	function ]]><$YY \"parser_t\"/><![[.yylexinit__(pchFile: string; bi: boolean): boolean;\n\
	var\n\
		pbuf: YYPBUFFER;\n\
	begin\n\
		pbuf := yy_new_filebuf(pchFile, bi);\n\
		if pbuf = nil then\n\
		begin\n\
			yylexinit__ := false;\n\
			exit;\n\
		end;\n\
		\n\
		yy_switch_buffer(pbuf);\n\
		\n\
		if yytext = nil then renew_text__;\n\
		\n\
		yylexinit__ := yy_has_buffer;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yylexinit__(strbuf: pchar; size: integer; bcopied: boolean): boolean;\n\
	var\n\
		pbuf: YYPBUFFER;\n\
	begin\n\
		pbuf := yybufmgr__.newbuf(strbuf, size, bcopied);\n\
		if pbuf = nil then\n\
		begin\n\
			yylexinit__ := false;\n\
			exit;\n\
		end;\n\
		yy_switch_buffer(pbuf);\n\
		\n\
		if yytext = nil then renew_text__;\n\
		\n\
		yylexinit__ := yy_has_buffer;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yylex__]]>\n\
	<If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: integer;\n\
	var\n\
		yylstate__: integer;\n\
		yylrule__: integer;\n\
		yyaccleng__: integer;\n\
		yycchar__:integer;\n\
		bwrap__: boolean;]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		nline, ncol, nt, ts, yyt1__: integer;\n\
]]>\n\
		</If>\n\
		<Else><![[\n\
		nline, yyt1__: integer;\n\
]]>\n\
		</Else>\n\
	</If>\n\
	<$SingleAction \"LexVarDecl\"/><![[\n\
	begin\n\
		if not yy_has_buffer then begin\n\
			yyecode__ := YYE_EOS;\n\
			yylex__ := 0;\n\
			exit;\n\
		end;\n\
		\n\
		yylrule__ := LEX_ERROR_RULE;\n\
		yyaccleng__ := 0;\n\
		\n\
		yymore_flag__ := false;\n\
		yyecode__ := YYE_ALIVE;\n\
		bwrap__ := false;\n\
		yyleng := 0;\n\
		yylaleng := 0;\n\
		yytext[0] := #0;\n\
		]]><$SingleAction \"LexVarInit\"/><![[\n\
		]]><$CodeBlock \"LexInitAction\"/><![[\n\
		\n\
		if yyat_bol__ then\n\
			yylstate__ := yydsc[yystart__]\n\
		else\n\
			yylstate__ := yydsc[yystart__ + 1];\n\
			\n\
		while yylex_is_running__ do\n\
		begin\n\
			yycchar__ := yybufmgr__.get;\n\
			yylstate__ := yynext_lexstate__(yylstate__, yycchar__);\n\
			\n\
			if LEX_ERROR_STATE <> yylstate__ then\n\
			begin\n\
\n\
				if yylaleng >= yysize__ - 1 then\n\
					renew_text__;\n\
				yytext[yylaleng] := chr(yycchar__);\n\
\n\
				yylaleng := yylaleng + 1;\n\
\n\
				if yyget_lexrule__(yylstate__) <> LEX_ERROR_RULE then\n\
				begin\n\
					yylrule__ := yyget_lexrule__(yylstate__);\n\
					yyaccleng__ := yylaleng;\n\
				end;\n\
			end;\n\
			\n\
			\n\
			if (LEX_ERROR_STATE = yylstate__) or (yybufmgr__.isimod\n\
				and ((10 = yycchar__) or (END_OF_FILE = yycchar__))) then\n\
			begin\n\
				if LEX_ERROR_RULE = yylrule__ then\n\
				begin\n\
					if yylaleng = yyleng then\n\
					begin\n\
						if yycchar__ = END_OF_FILE then\n\
							yylrule__ := LEX_EOFRULE_BASE + yystart__ div 2\n\
						else if yycchar__ = END_OF_ALLFILE then\n\
							yylrule__ := LEX_EOAF_RULE;\n\
					end;\n\
				end\n\
				else\n\
				begin\n\
					if LEX_ERROR_STATE = yylstate__ then\n\
						yybufmgr__.unget(yylaleng + 1 - yyaccleng__);\n\
					yylaleng := yyaccleng__;\n\
					yytext[yylaleng] := #0;\n\
				]]>\n\
	<If Has\?\"LexDFALookaheads\"><![[\n\
					yyleng := yylaleng - yylad[yylrule__];\n\
					if yylaleng > yyleng then\n\
					begin\n\
						yybufmgr__.unget(yylaleng - yyleng);\n\
					end;\n\
]]>\n\
	</If>\n\
				<Else><![[ yyleng := yylaleng;]]></Else>\n\
					<![[\n\
				end;\n\
\n\
				if LEX_ERROR_RULE <> yylrule__ then begin\n\
					if yyleng > 0 then\n\
						yyat_bol__ := (yytext[yyleng - 1] = #10);\n\
]]>\n\
	<If LexDebugMode><![[\n\
				if yylogger <> nil then begin\n\
					if yylrule__ >= LEX_EOFRULE_BASE then\n\
					begin\n\
						if yylrule__ < LEX_EOAF_RULE then\n\
						begin\n\
							if yydline[yylrule__] > 0 then\n\
								writeln(yylogger^, \'.................... accept {EOF}, rule at line: \',\n\
									yydline[yylrule__])\n\
							else\n\
								writeln(yylogger^, \'.................... EOF reached\');\n\
						end\n\
						else\n\
							writeln(yylogger^, \'.................... EOS reached\');\n\
					end\n\
					else begin\n\
						if (yyleng = 1) and ((ord(yytext[0]) < 32) or (ord(yytext[0]) >= 127)) then\n\
							writeln(yylogger^, \'.................... accept unprintable-char{\',\n\
								ord(yytext[0]), \'}, rule at line: \', yydline[yylrule__])\n\
						else\n\
							writeln(yylogger^, \'.................... accept {`\', yytext,\n\
								\'\'\'}, rule at line: \', yydline[yylrule__]);\n\
					end;\n\
				end;\n\
]]>\n\
	</If>\n\
<$CodeBlock \"PremacthAction\"/>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
					nline := yyget_lineno();\n\
					ncol := yyget_colno() - 1;\n\
					nt := yyget_tabsize();\n\
					for yyt1__ := 0 to yyleng - 1 do\n\
					begin\n\
						if yytext[yyt1__] = #9 then\n\
						begin\n\
\n\
							ts := nt - ncol mod nt;\n\
							yybufmgr__.pushtsz(ts);\n\
							ncol := ncol + ts;\n\
						end\n\
						else if yytext[yyt1__] = #10 then\n\
						begin\n\
							yybufmgr__.pushlsz(ncol + 1);\n\
							ncol := 0;\n\
							nline := nline + 1;\n\
						end\n\
						else ncol := ncol + 1;\n\
						\n\
					end;]]>\n\
			<If EnableParser><![[\n\
					]]><$YY \"lloc\"/><![[.firstLine := yyget_lineno();\n\
					]]><$YY \"lloc\"/><![[.firstColumn := yyget_colno();\n\
					]]><$YY \"lloc\"/><![[.lastLine  := nline;\n\
					if ncol < 0 then\n\
						]]><$YY \"lloc\"/><![[.lastColumn := 0\n\
					else ]]><$YY \"lloc\"/><![[.lastColumn := ncol;\n\
]]>\n\
			</If><![[yyset_lineno(nline);\n\
					yyset_colno(ncol + 1);\n\
]]>\n\
		</If>\n\
		<Else><![[\n\
					nline := yyget_lineno();\n\
					for yyt1__ := 0 to yyleng - 1 do\n\
					begin\n\
						if yytext[yyt1__] = #10 then\n\
						begin\n\
							nline := nline + 1;\n\
						end						\n\
					end;]]>\n\
			<If EnableParser><![[\n\
					]]><$YY \"lloc\"/><![[.firstLine := yyget_lineno();\n\
					]]><$YY \"lloc\"/><![[.firstColumn := 0;\n\
					]]><$YY \"lloc\"/><![[.lastLine  := nline;\n\
					]]><$YY \"lloc\"/><![[.lastColumn := 0;\n\
]]>\n\
			</If><![[yyset_lineno(nline);\n\
					yyset_colno(0);\n\
]]>\n\
		</Else>\n\
	</If><![[\n\
				end;\n\
\n\
			if (yylrule__ >= LEX_EOFRULE_BASE) and (yylrule__ < LEX_EOAF_RULE) then\n\
				bwrap__ := yywrap__]]><If Has\?\"ActualParams\"><![[(]]><Action \"ActualParams\"/><![[)]]></If><![[\n\
			else\n\
				bwrap__ := false;\n\
\n\
			if not bwrap__ then begin\n\
				case yylrule__ of\n\
				]]><$UserLexActions \"LexRule2Actions\" \"LexActions\"\n\
						\"LexRule2Lines\" \"ScriptFileName\"/><![[\n\
\n\
				LEX_EOAF_RULE: begin\n\
						yy_delete_buffer;\n\
						yyecode__ := YYE_EOS;\n\
					end;\n\
				else begin\n\
					if yyleng > 0 then\n\
						yyat_bol__ := (yytext[yyleng - 1] = #10);\n\
\n\
]]>\n\
	<If EnableDefaultAction><![[\n\
]]>\n\
	</If>\n\
	<Else><![[\n\
		YYMSG_UNMATCHED[28] := chr(yycchar__);\n\
		yyecode__ := YYE_UNMATCHED;\n\
		if assigned(yyerror) then\n\
			yyerror(YYMSG_UNMATCHED]]><If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]>\n\
	</Else><![[		end;\n\
				end;\n\
			end;\n\
				if yylex_is_running__ then\n\
				begin\n\
					if yyat_bol__ then\n\
						yylstate__ := yydsc[yystart__]\n\
					else\n\
						yylstate__ := yydsc[yystart__ + 1];\n\
\n\
					yylrule__ := LEX_ERROR_RULE;\n\
\n\
					if not yymore_flag__ then\n\
					begin\n\
						yyaccleng__ := 0;\n\
						yylaleng := 0;\n\
						yyleng := 0;\n\
						yytext[yylaleng] := #0;\n\
					end\n\
					else\n\
					begin\n\
						yymore_flag__ := false;\n\
					end;\n\
				end;\n\
			end;\n\
		end;\n\
		\n\
		if yyecode__ = YYE_EOS then\n\
			yylex__ := 0\n\
		else\n\
			yylex__ := yyecode__;\n\
			\n\
		///////////////////////////////////////////////////////////////////////////\n\
	end;\n\
]]>\n\
</If>\n\
<If EnableParser><![[	\n\
	function ]]><$YY \"parser_t\"/><![[.yyparse__]]>\n\
	<If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: integer;\n\
	var\n\
		yys_stt__: istack_t;\n\
		yys_sv__: sstack_t;\n\
		yyval: xstype_t;\n\
]]>\n\
	<If EnableLocation><![[\n\
		yys_loc__: lstack_t;\n\
		yycc: string[128];\n\
]]>\n\
	</If><![[\n\
		yyloc: xltype_t;\n\
		yyrplen__: integer;\n\
		yyreducing__: boolean;\n\
		yypstate__: integer;\n\
		yyprule__: integer;\n\
		yysidx__: integer;\n\
		yytok__: integer;\n\
		]]>\n\
	<If ParseDebugMode><![[\n\
		yyt1__, yyt2__: integer;\n\
		]]>\n\
	</If><$SingleAction \"ParseVarDecl\"/><![[\n\
	begin\n\
\n\
		if not assigned(yylexer) then\n\
		begin\n\
			yyparse__ := YYE_ABORT;\n\
			exit;\n\
		end;\n\
		yypstate__ := PARSE_START_STATE;\n\
		yyprule__ := PERROR_RULE;\n\
		yysidx__ := PARSE_UNDEFSYMB_INDEX;\n\
		yytok__ := PARSE_UNDEFSYMB_ID;\n\
		yyreducing__ := false;\n\
		\n\
		yyecode__ := YYE_ALIVE;\n\
		yyltok := PARSE_UNDEFSYMB_ID;\n\
		yyerr_flag__ := false;\n\
		\n\
		yys_stt__ := istack_t.create;\n\
		yys_sv__ := sstack_t.create;\n\
\n\
]]>\n\
	<If EnableLocation><![[\n\
		yys_loc__ := lstack_t.create;\n\
\n\
]]>\n\
	</If>\n\
	<$SingleAction \"ParseVarInit\"/><![[\n\
]]><$CodeBlock \"ParseInitAction\"/><![[\n\
		yys_stt__.push(yypstate__);\n\
\n\
		while (not yys_stt__.empty) and yyparse_is_running__(yypstate__) do\n\
		begin\n\
		\n\
			yyprule__ := yyget_defrule(yypstate__);\n\
			if is_valid_prule__(yyprule__) then\n\
				yyreducing__ := true			\n\
			else\n\
			begin\n\
				if PARSE_UNDEFSYMB_ID = yytok__ then\n\
				begin\n\
					if PARSE_UNDEFSYMB_ID = yyltok then\n\
						yytok__ := yylexer(]]><If Has\?\"ActualParams\"><Action \"ActualParams\"/></If><![[)\n\
					else begin\n\
						yytok__ := yyltok;\n\
						yyltok := PARSE_UNDEFSYMB_ID;\n\
					end;\n\
					\n\
					if (yytok__ < 0) or (yytok__ >= PARSE_TOKENMAP_SIZE) then\n\
						yysidx__ := PARSE_UNDEFSYMB_INDEX\n\
					else\n\
						yysidx__ := yyptmap[yytok__];\n\
				end;\n\
\n\
				]]>\n\
	<If ParseDebugMode><![[\n\
			if yylogger <> nil then\n\
				writeln(yylogger^, \'Next symbol is \', sym_text__(yypsnam[yysidx__]));\n\
				]]>\n\
	</If><![[\n\
				yypstate__ := yynext_pstate__(yys_stt__.top(), yysidx__);\n\
\n\
				if is_valid_pstate__(yypstate__) then\n\
				begin\n\
					]]>\n\
	<If ParseDebugMode><![[\n\
					if yylogger <> nil then\n\
						writeln(yylogger^, \'Shift \', sym_text__(yypsnam[yysidx__]), \', go to state \', yypstate__);\n\
					]]>\n\
	</If><![[\n\
\n\
					yys_stt__.push(yypstate__);\n\
					yys_sv__.push(yysidx__, ]]><$YY \"lval\"/><![[);\n\
]]>\n\
	<If EnableLocation><![[\n\
					yys_loc__.push(]]><$YY \"lloc\"/><![[);\n\
]]>\n\
	</If><![[\n\
					yytok__ := PARSE_UNDEFSYMB_ID;\n\
					yyreducing__ := false;\n\
				end\n\
				else begin\n\
					yyprule__ := yyget_prule__(yypstate__);\n\
					yyreducing__ := true;\n\
				end;\n\
			end;\n\
\n\
			if yyreducing__ then\n\
			begin\n\
				case yyprule__ of\n\
				]]><$UserParseActions \"PraseRule2Actions\" \"ParseActions\"\n\
						\"ParseRule2Lines\" \"ScriptFileName\"/><![[\n\
				else begin\n\
\n\
					if (not yyerr_flag__) or (PARSE_ENDSYMB_ID = yytok__) then\n\
					begin\n\
						if not yyerr_flag__ then begin\n\
							if assigned(yyerror) then\n\
							begin\n\
]]>\n\
	<If EnableLocation><![[\n\
yycc := \'Error: syntax error at \';\n\
yycc := yycc + int_to_str__(]]><$YY \"lloc\"/><![[.firstLine);\n\
yycc := yycc + \':\';\n\
yycc := yycc + int_to_str__(]]>	<$YY \"lloc\"/><![[.firstColumn);\n\
yycc := yycc + \'.\';\n\
yyerror(yycc]]><If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]>\n\
	</If>\n\
	<Else><![[\n\
yyerror(\'Error: syntax error.\']]><If Has\?\"ActualParams\"><![[, ]]><Action \"ActualParams\"/></If><![[);\n\
]]>\n\
	</Else><![[\n\
							end;\n\
							yyecode__ := YYE_PERROR;\n\
						end\n\
						else yyecode__ := YYE_NOINPUT;\n\
\n\
						yyerr_flag__ := true;\n\
						yyltok := yytok__;\n\
					end\n\
					else begin]]>\n\
	<If ParseDebugMode><![[\n\
				if yylogger <> nil then\n\
					writeln(yylogger^, \'Error recovery : discard current token \', sym_text__(yypsnam[yysidx__]));\n\
				]]>\n\
</If><![[\n\
						yydiscard__(]]><$YY \"lval\"/><![[, ]]><$YY \"lloc\"/><![[, yysidx__]]>\n\
	<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
\n\
						yyltok := PARSE_UNDEFSYMB_ID;\n\
					end;\n\
					yytok__ := PARSE_ERRORSYMB_ID;\n\
					yysidx__ := PARSE_ERRORSYMB_INDEX;\n\
\n\
					while not yys_sv__.empty do begin\n\
						yypstate__ := yynext_pstate__(yys_stt__.top, yysidx__);\n\
						if is_valid_pstate__(yypstate__) then break;\n\
						]]>\n\
	<If ParseDebugMode><![[begin\n\
			if yylogger <> nil then begin\n\
				yyt1__ := (yys_sv__.top)^.sid;\n\
				writeln(yylogger^, \'Error recovery : Pop up \', sym_text__(yypsnam[yyt1__]));\n\
\n\
				write(yylogger^, \'Now state stack:\');\n\
				if yyerr_flag__ then yyt1__ := 1\n\
				else yyt1__ := 0;\n\
				while yyt1__ < yys_stt__.count do begin\n\
					write(yylogger^, \' \', yys_stt__.getat(yyt1__));\n\
					yyt1__ := yyt1__ + 1;\n\
				end;\n\
				writeln(yylogger^);\n\
			end;\n\
		end;]]>\n\
	</If><![[\n\
]]>\n\
	<If EnableLocation><![[\n\
						yydiscard__((yys_sv__.top)^.sv, yys_loc__.top^, (yys_sv__.top)^.sid]]>\n\
							<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
						yys_loc__.pop(1);\n\
]]>\n\
</If><Else><![[\n\
						yydiscard__((yys_sv__.top)^.sv, ]]><$YY \"lloc\"/><![[, (yys_sv__.top)^.sid]]>\n\
							<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
]]></Else><![[\n\
\n\
						yys_sv__.pop(1);\n\
						yys_stt__.pop(1);\n\
					end;\n\
\n\
						if yys_sv__.empty then yys_stt__.pop(1);\n\
					end;\n\
				end;\n\
\n\
				if is_valid_prule__(yyprule__) or (YYE_ACCEPT = yyecode__) then\n\
				begin\n\
					yyrplen__ := yyprnum[yyprule__];\n\
					yypstate__ := yynext_goto__(yys_stt__.getat(yyrplen__), yyplid[yyprule__]);\n\
					]]>\n\
	<If ParseDebugMode><![[\n\
		if yylogger <> nil then\n\
		begin\n\
			write(yylogger^, \'Reduce action: \');\n\
			for yyt2__ := yyrplen__ - 1 downto 0 do begin\n\
				yyt1__ := (yys_sv__.getat(yyt2__))^.sid;\n\
				write(yylogger^, sym_text__(yypsnam[yyt1__]), \' \');\n\
			end;\n\
			write(yylogger^, \'=> \', yypsnam[yyplid[yyprule__] + PARSE_TYPE_BASE]);\n\
			writeln(yylogger^, \', go to state \', yypstate__, \' by rule at \', yypline[yyprule__], \'.\');\n\
		end;]]>\n\
	</If><![[\n\
\n\
					if YYE_ACCEPT <> yyecode__ then begin\n\
						yys_stt__.pop(yyrplen__);\n\
						yys_sv__.pop(yyrplen__);\n\
]]>\n\
`	<If EnableLocation><![[\n\
						if yyrplen__ = 0 then begin\n\
							yyloc.firstLine := yys_loc__.top^.lastLine;\n\
							yyloc.lastLine := yys_loc__.top^.lastLine;\n\
							yyloc.firstColumn := yys_loc__.top^.lastColumn;\n\
							yyloc.lastColumn := yys_loc__.top^.lastColumn;\n\
						end\n\
						else begin\n\
							yyloc.firstLine := yys_loc__.getat(yyrplen__ - 1)^.firstLine;\n\
							yyloc.lastLine := yys_loc__.top^.lastLine;\n\
							yyloc.firstColumn := yys_loc__.getat(yyrplen__ - 1)^.firstColumn;\n\
							yyloc.lastColumn := yys_loc__.top^.lastColumn;\n\
						end;\n\
						yys_loc__.pop(yyrplen__);\n\
						yys_loc__.push(yyloc);\n\
]]>\n\
	</If><![[\n\
						yys_stt__.push(yypstate__);\n\
						yys_sv__.push(yyplid[yyprule__] + PARSE_TYPE_BASE, yyval);\n\
					end;\n\
				end;\n\
			end;\n\
		end;\n\
\n\
		while not yys_sv__.empty do begin\n\
		]]>\n\
	<If ParseDebugMode><![[\n\
		if yylogger <> nil then			\n\
			writeln(yylogger^, \'Clearup : Pop up \', sym_text__(yypsnam[(yys_sv__.top)^.sid]));\n\
]]>\n\
	</If>\n\
	<If EnableLocation><![[\n\
			yydiscard__(yys_sv__.top^.sv, yys_loc__.top^, yys_sv__.top^.sid]]>\n\
				<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
]]>\n\
	</If>\n\
	<Else><![[\n\
			yydiscard__(yys_sv__.top^.sv, ]]><$YY \"lloc\"/><![[, yys_sv__.top^.sid]]>\n\
				<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
]]>\n\
	</Else><![[\n\
			yys_sv__.pop(1);\n\
		end;\n\
\n\
		if YYE_ACCEPT = yyecode__ then begin\n\
\n\
]]>\n\
	<If EnableLocation><![[\n\
			yydiscard__(yyval, yyloc, yyplid[yyprule__] + PARSE_TYPE_BASE]]>\n\
				<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
]]></If>\n\
	<Else><![[\n\
			yydiscard__(yyval, ]]><$YY \"lloc\"/><![[, yyplid[yyprule__] + PARSE_TYPE_BASE]]>\n\
				<If Has\?\"ActualParams\"><![[,]]><Action \"ActualParams\"/></If><![[);\n\
]]>\n\
	</Else><![[\n\
		end;\n\
]]><$CodeBlock \"ParseExitAction\"/><![[\n\
		yys_stt__.destroy;\n\
		yys_sv__.destroy;\n\
]]>\n\
	<If EnableLocation><![[\n\
		yys_loc__.destroy;\n\
]]>\n\
	</If><![[\n\
		if (yyecode__ = YYE_EOS) or (yyecode__ = YYE_ACCEPT) then yyparse__ := 0\n\
		else yyparse__ := yyecode__;\n\
\n\
	end;]]>\n\
</If><![[\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyclearall__;\n\
	begin\n\
		yyecode__ := YYE_ALIVE;]]>\n\
<If EnableScanner><![[\n\
		yystart__ := INITIAL;		\n\
		yymore_flag__ := false;\n\
		yyat_bol__ := true;\n\
		\n\
		yyleng := 0;\n\
		yylaleng := 0;\n\
		if yytext <> nil then yytext[0] := #0;\n\
		yybufmgr__.destroyall;\n\
]]>\n\
</If>\n\
<If EnableParser><![[\n\
		yyerr_flag__ := false;\n\
		yyltok := PARSE_UNDEFSYMB_ID;\n\
]]></If><![[\n\
		end;\n\
]]>\n\
<If EnableScanner><![[\n\
	// user interfaces\n\
	// easy way to print matched string\n\
	procedure ]]><$YY \"parser_t\"/><![[.YYECHO;\n\
	begin\n\
		ECHO;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.ECHO;\n\
	begin\n\
		if yyoutput <> nil then\n\
			write(yyoutput^, yytext);\n\
	end;\n\
	\n\
	// switch start-condition\n\
	procedure ]]><$YY \"parser_t\"/><![[.YYBEGIN(sc :integer);\n\
	begin\n\
		yystart__ := sc;\n\
	end;\n\
	\n\
	// return current start-condition\n\
	function ]]><$YY \"parser_t\"/><![[.YYSTART: integer;\n\
	begin\n\
		YYSTART := yystart__;\n\
	end;\n\
	\n\
	// save current start-condition and switch to new start-condition\n\
	procedure ]]><$YY \"parser_t\"/><![[.yy_push_state(nsc: integer);\n\
	begin\n\
		yyscstk__.push(yystart__);\n\
		yystart__ := nsc;\n\
	end;\n\
	\n\
	// switch to last saved start-condition\n\
	function ]]><$YY \"parser_t\"/><![[.yy_pop_state: boolean;\n\
	begin\n\
		if yyscstk__.empty then\n\
			yy_pop_state := false\n\
		else\n\
		begin\n\
			yystart__ := yyscstk__.top;\n\
			yyscstk__.pop(1);\n\
			yy_pop_state := true;\n\
		end;\n\
	end;\n\
	\n\
	// return last saved start-condition\n\
	function ]]><$YY \"parser_t\"/><![[.yy_top_state: integer;\n\
	begin\n\
		if yyscstk__.empty then\n\
			yy_top_state := INITIAL\n\
		else\n\
			yy_top_state := yyscstk__.top;\n\
	end;\n\
	\n\
	// get/set flag of beginning-of-line\n\
	function ]]><$YY \"parser_t\"/><![[.yy_get_bol: boolean;\n\
	begin\n\
		yy_get_bol := yyat_bol__;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yy_set_bol(b: boolean);\n\
	begin\n\
		yyat_bol__ := b;\n\
	end;\n\
		\n\
	// buffer operations\n\
	function ]]><$YY \"parser_t\"/><![[.yy_current_buffer: YYPBUFFER;\n\
	begin\n\
		yy_current_buffer := yybufmgr__.current;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yy_has_buffer: boolean;\n\
	begin\n\
		yy_has_buffer := not yybufmgr__.empty;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yy_push_buffer(pbuffer: YYPBUFFER);\n\
	begin\n\
		yybufmgr__.switchto(pbuffer);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yy_pop_buffer: YYPBUFFER;\n\
	begin\n\
		yy_pop_buffer := yybufmgr__.pop;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yy_new_filebuf(strfile: string; bi: boolean): YYPBUFFER;\n\
	var\n\
		pfile: pfile_t;\n\
	begin\n\
		if strfile = \'\' then\n\
		begin\n\
			yy_new_filebuf := yybufmgr__.newbuf(@input, bi);\n\
			exit;\n\
		end;\n\
		\n\
		new(pfile);\n\
		assignfile(pfile^, strfile);\n\
		{$I-}\n\
		reset(pfile^, 1);\n\
		{$I+}\n\
		if IOResult <> 0 then\n\
			yy_new_filebuf := nil\n\
		else\n\
			yy_new_filebuf := yybufmgr__.newbuf(pfile, bi);\n\
	end;\n\
	function ]]><$YY \"parser_t\"/><![[.yy_new_cstrbuf(cstrbuf: pchar; size: integer): YYPBUFFER;\n\
	begin\n\
		if (cstrbuf = nil) or (size < 1) then\n\
		begin\n\
			yy_new_cstrbuf := nil;\n\
			exit;\n\
		end;\n\
		\n\
		yy_new_cstrbuf := yybufmgr__.newbuf(cstrbuf, size, true);\n\
	end;\n\
	function ]]><$YY \"parser_t\"/><![[.yy_new_strbuf(strbuf: pchar; size: integer): YYPBUFFER;\n\
	begin\n\
		if (strbuf = nil) or (size < 1) then\n\
		begin\n\
			yy_new_strbuf := nil;\n\
			exit;\n\
		end;\n\
		\n\
		yy_new_strbuf := yybufmgr__.newbuf(strbuf, size, false);\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yy_delete_buffer;\n\
	begin\n\
		yybufmgr__.destroytop;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yy_switch_buffer(buf: YYPBUFFER);\n\
	begin\n\
		yybufmgr__.switchto(buf);\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyrestart;\n\
	begin\n\
		yystart__ := INITIAL;\n\
		yyecode__ := YYE_ALIVE;\n\
		yymore_flag__ := false;\n\
		\n\
		yyleng := 0;\n\
		yylaleng := 0;\n\
		if yytext = nil then yytext[0] := #0;\n\
		\n\
		yyscstk__.clear;\n\
		yybufmgr__.reset;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yymore;\n\
	begin\n\
		yymore_flag__ := true;\n\
		yylaleng := yyleng;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyless(n: integer): integer;\n\
	begin\n\
		if (n > 0) and (n < yyleng) then\n\
		begin\n\
			yytext[n] := #0;\n\
			n := yyleng - n;\n\
			yyleng := yyleng - n;\n\
			yylaleng := yyleng;\n\
			\n\
			yyless := yybufmgr__.unget(n);\n\
		end\n\
		else\n\
		begin\n\
			yylaleng := yyleng;\n\
			yytext[yylaleng] := #0;\n\
			yyless := 0;\n\
		end;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyinput: integer;\n\
	var\n\
		c: integer;]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		nt: integer;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
	begin\n\
		c := yybufmgr__.get;]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		if c < END_OF_FILE then\n\
		begin\n\
			if c = 9 then\n\
			begin\n\
				nt := yyget_tabsize;\n\
				nt := nt - (yyget_colno() + nt - 1) mod nt;\n\
				yybufmgr__.pushtsz(nt);\n\
				yyadd_colno(nt);\n\
			end\n\
			else if c = 10 then\n\
			begin\n\
				yybufmgr__.pushlsz(yyget_colno());\n\
				yyset_colno(1);\n\
				yyadd_lineno(1);\n\
			end\n\
			else begin\n\
				yyadd_colno(1);\n\
			end;\n\
		end;]]>\n\
		</If>\n\
	</If><![[	\n\
		yyinput := c;\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyunput(c: char): boolean;\n\
	var\n\
		oldc: integer;]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		s: integer;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
	begin\n\
		oldc := yybufmgr__.put(c);]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		if oldc < END_OF_FILE then\n\
		begin\n\
			if oldc = 9 then\n\
			begin\n\
				s := yybufmgr__.poptsz;\n\
				if s = 0 then\n\
					yyadd_colno(-1)\n\
				else\n\
					yyadd_colno(-s);\n\
			end\n\
			else if oldc = 10 then\n\
			begin\n\
				s := yybufmgr__.poplsz;\n\
				yyset_colno(s);\n\
				yyadd_lineno(-1);\n\
			end\n\
			else begin\n\
				yyadd_colno(-1);\n\
			end;\n\
		end;]]>\n\
		</If>\n\
	</If><![[\n\
		yyunput := (oldc < END_OF_FILE);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyunget: boolean;\n\
	var\n\
		oldc: integer;]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		s: integer;\n\
]]>\n\
		</If>\n\
	</If><![[\n\
	begin\n\
		oldc := yybufmgr__.unget;]]>\n\
	<If EnableLocation>\n\
		<If EnableColumn><![[\n\
		if oldc < END_OF_FILE then\n\
		begin\n\
			if oldc = 9 then\n\
			begin\n\
				s := yybufmgr__.poptsz;\n\
				if s = 0 then\n\
					yyadd_colno(-1)\n\
				else\n\
					yyadd_colno(-s);\n\
			end\n\
			else if oldc = 10 then\n\
			begin\n\
				s := yybufmgr__.poplsz;\n\
				yyset_colno(s);\n\
				yyadd_lineno(-1);\n\
			end\n\
			else begin\n\
				yyadd_colno(-1);\n\
			end;\n\
		end;]]>\n\
		</If>\n\
	</If><![[\n\
		yyunget := (oldc < END_OF_FILE);\n\
	end;	\n\
\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyterminate;\n\
	begin\n\
		yyecode__ := YYE_TERM;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyadd_lineno(nline: integer);\n\
	begin\n\
		yybufmgr__.setlineno(yybufmgr__.getlineno + nline);\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyadd_colno(ncol: integer);\n\
	begin\n\
		yybufmgr__.setcolno(yybufmgr__.getcolno + ncol);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyget_lineno: integer;\n\
	begin\n\
		yyget_lineno := yybufmgr__.getlineno;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyset_lineno(nline: integer);\n\
	begin\n\
		yybufmgr__.setlineno(nline);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyget_colno: integer;\n\
	begin\n\
		yyget_colno := yybufmgr__.getcolno;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyset_colno(ncol: integer);\n\
	begin\n\
		yybufmgr__.setcolno(ncol);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yyget_tabsize: integer;\n\
	begin\n\
		yyget_tabsize := yybufmgr__.gettabsize;\n\
	end;\n\
	\n\
	procedure ]]><$YY \"parser_t\"/><![[.yyset_tabsize(ntab: integer);\n\
	begin\n\
		yybufmgr__.settabsize(ntab);\n\
	end;\n\
	\n\
	function ]]><$YY \"parser_t\"/><![[.yywrap__]]>\n\
	<If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: boolean;\n\
	begin\n\
		result := false;\n\
		]]>\n\
	<If Has\?\"EOAFAction\"><![[\n\
		// line: ]]><ActLine \"EOAFAction\"/><![[\n\
		]]><Action \"EOAFAction\"/>\n\
	</If><![[\n\
	end;\n\
]]>\n\
</If><![[\n\
var\n\
	theYYParser: ]]><$YY \"parser_t\"/><![[;\n\
// assign new log stream\n\
procedure ]]><$YY \"setstream\"/><![[(poutput, plogger: ptext_t);\n\
begin\n\
	theYYParser.yyoutput := poutput;\n\
	theYYParser.yylogger := plogger;\n\
end;\n\
\n\
procedure yyemit_error__(s: string]]>\n\
<If Has\?\"FormalParams\"><![[; ]]><Action \"FormalParams\"/></If><![[);\n\
begin\n\
	if theYYParser.yylogger <> nil then\n\
		writeln(theYYParser.yylogger^, s);\n\
end;\n\
	\n\
// assign new error-reporter and return the old one\n\
function ]]><$YY \"seterror\"/><![[(perror: ]]><$YY \"error_t\"/><![[): ]]><$YY \"error_t\"/><![[;\n\
begin\n\
\n\
	]]><$YY \"seterror\"/><![[ := theYYParser.yyerror;\n\
	theYYParser.yyerror := perror;\n\
end;\n\
\n\
// reset all (both scanner and parser, if they are available)\n\
procedure ]]><$YY \"clearall\"/><![[;\n\
begin\n\
	theYYParser.yyclearall__;\n\
end;\n\
]]>\n\
<If EnableScanner><![[\n\
\n\
// initializing file buffer before parsing or patter-matching\n\
function ]]><$YY \"lexfile\"/><![[(pchFile: string; iMod: boolean): integer;\n\
begin\n\
	if theYYParser.yylexinit__(pchFile, iMod) then\n\
		]]><$YY \"lexfile\"/><![[ := 0\n\
	else\n\
		]]><$YY \"lexfile\"/><![[ := 1;\n\
end;\n\
\n\
// initializing string buffer before parsing or patter-matching\n\
function ]]><$YY \"lexstr\"/><![[(strbuf: pchar; size: integer): integer;\n\
begin\n\
	if theYYParser.yylexinit__(strbuf, size, false) then\n\
		]]><$YY \"lexstr\"/><![[ := 0\n\
	else\n\
		]]><$YY \"lexstr\"/><![[ := 1;\n\
end;\n\
\n\
// initializing const string buffer before parsing or patter-matching\n\
function ]]><$YY \"lexcstr\"/><![[(strbuf: pchar; size: integer): integer;\n\
begin\n\
	if theYYParser.yylexinit__(strbuf, size, true) then\n\
		]]><$YY \"lexcstr\"/><![[ := 0\n\
	else\n\
		]]><$YY \"lexcstr\"/><![[ := 1;\n\
end;\n\
\n\
// generated scanner, can be replaced\n\
function ]]><$YY \"lex\"/><If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]></If><![[: integer;\n\
begin\n\
	]]><$YY \"lex\"/><![[ := theYYParser.yylex__(]]>\n\
	<If Has\?\"ActualParams\"><Action \"ActualParams\"/>\n\
	</If><![[);\n\
end;\n\
\n\
]]>\n\
</If>\n\
\n\
<If EnableParser><![[\n\
// assign new scanner and return the old one \n\
function ]]><$YY \"setlex\"/><![[(plex: ]]><$YY \"lex_t\"/><![[): ]]><$YY \"lex_t\"/><![[;\n\
begin\n\
\n\
	]]><$YY \"setlex\"/><![[ := theYYParser.yylexer;\n\
	theYYParser.yylexer := plex;\n\
end;\n\
\n\
// generated parser, it should not be replaced\n\
function ]]><$YY \"parse\"/>\n\
	<If Has\?\"FormalParams\"><![[(]]><Action \"FormalParams\"/><![[)]]>\n\
	</If><![[: integer;\n\
begin\n\
	]]><$YY \"parse\"/><![[ := theYYParser.yyparse__]]>\n\
	<If Has\?\"ActualParams\"><![[(]]><Action \"ActualParams\"/><![[)]]>\n\
	</If><![[;\n\
end;\n\
]]>\n\
</If>\n\
<$SingleAction \"UserCode\"/><![[\n\
\n\
	\n\
initialization\n\
\n\
	theYYParser := ]]><$YY \"parser_t\"/><![[.create]]>\n\
	<If EnableParser>\n\
		<If EnableScanner><![[(@]]><$YY \"lex\"/><![[)]]>\n\
		</If>\n\
	</If><![[;\n\
\n\
finalization\n\
	theYYParser.destroy;\n\
	\n\
end.\n\
]]>\n\
</Program>\n\
\0\0";

};
