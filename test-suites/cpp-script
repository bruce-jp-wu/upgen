<<<< ------------------------------ global setting
<<settings>>

	<<group>>
<<<<<<<------------------ input from file
<<buffer_init>>yylexfile(argv[1], false)<</buffer_init>>
<<buffer_init2>>lexfile(argv[1], false)<</buffer_init2>>
<<buffer_init3>>yylexfile(argv[1], false)<</buffer_init3>>
<<filebuf_decl2>>lexfile(const char *, bool);<</filebuf_decl2>>
<<filebuf_decl>>int yylexfile(const char*, bool);<</filebuf_decl>>
<<inputed_file>> $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = fopen(argv[1], "r");<</before_myinput>>
<<stream_type>>c++-file.log<</stream_type>>
>>>>>>>------------------ input from file
	<</group>>


	<<group>>
<<<<<<------------------ input from stdin
<<buffer_init>>yylexfile(NULL, true)<</buffer_init>>
<<buffer_init2>>lexfile(NULL, true)<</buffer_init2>>
<<buffer_init3>>yylexfile(NULL, false)<</buffer_init3>>
<<filebuf_decl>>int yylexfile(const char*, bool);<</filebuf_decl>>
<<filebuf_decl2>>lexfile(const char *, bool);<</filebuf_decl2>>
<<inputed_file>> < $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = stdin;<</before_myinput>>
<<stream_type>>c++-stdin.log<</stream_type>>
>>>>>>------------------- input from stdin
	<</group>>


	<<group>>
<<<<<<<------------------ input from buffer
<<before_buffer_init>>
	if(argc < 2) {
		fprintf(stderr, "Error: file name expected\n");
		return 0;
	}
	struct stat st;
	if(stat(argv[1], &st)) {
		fprintf(stderr, "Error: failed to access file `%s\'.\n", argv[1]);
		return 0;
	}

	char *buffer_content = NULL;
	size_t tt2 = 0;

	if(st.st_size > 0) {

		FILE *infile = fopen(argv[1], "r");
		if( ! infile) {
			fprintf(stderr, "Error: failed to open file `%s\'.\n", argv[1]);
			return 0;
		}

		size_t tt1 = (size_t)st.st_size;
		
		size_t ngot;

		buffer_content = new char[tt1 + 1];
		if( ! buffer_content) {
			fprintf(stderr, "Error: failed to allocate buffer.\n");
			return 0;
		}
		buffer_content[tt1] = '\0';
	
		while(tt1 > 0) {
			if((ngot = fread(&buffer_content[tt2], sizeof(char), tt1, infile)) == 0 
				&& ferror(infile)) {
				if(errno != EINTR) {
					break;
				}
				clearerr(infile);
				errno = 0;
			}
			tt1 -= ngot;
			tt2 += ngot;		
		}
		buffer_content[tt2] = '\0';
		++tt2;

		fclose(infile);
	}
	else {
		buffer_content = new char[2];
		buffer_content[0] = buffer_content[1] = '\0';
		tt2 = 1;
	}

<</before_buffer_init>>

<<after_buffer_usage>>
	if(buffer_content) {
		delete[] buffer_content;
	}
<</after_buffer_usage>>

<<buffer_init>>yylexstr(buffer_content, (int)tt2)<</buffer_init>>
<<buffer_init2>>lexstr(buffer_content, (int)tt2)<</buffer_init2>>
<<buffer_init3>>yylexstr(buffer_content, (int)tt2)<</buffer_init3>>
<<filebuf_decl2>>lexstr(char *, int);<</filebuf_decl2>>
<<filebuf_decl>>int yylexstr(char*, int);<</filebuf_decl>>
<<inputed_file>> $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = fopen(argv[1], "r");<</before_myinput>>
<<stream_type>>c++-buffer.log<</stream_type>>
>>>>>>>------------------ input from buffer
	<</group>>

	<<group>>
<<<<<<<------------------ input from copied buffer
<<before_buffer_init>>
	if(argc < 2) {
		fprintf(stderr, "Error: file name expected.\n");
		return 0;
	}
	struct stat st;
	if(stat(argv[1], &st)) {
		fprintf(stderr, "Error: failed to access file `%s\'.\n", argv[1]);
		return 0;
	}

	char *buffer_content = NULL;
	size_t tt2 = 0;

	if(st.st_size > 0) {

		FILE *infile = fopen(argv[1], "r");
		if( ! infile) {
			fprintf(stderr, "Error: failed to open file `%s\'.\n", argv[1]);
			return 0;
		}

		size_t tt1 = (size_t)st.st_size;
		
		size_t ngot;

		buffer_content = new char[tt1 + 1];
		if( ! buffer_content) {
			fprintf(stderr, "Error: failed to allocate buffer.\n");
			return 0;
		}
		buffer_content[tt1] = '\0';
	
		while(tt1 > 0) {
			if((ngot = fread(&buffer_content[tt2], sizeof(char), tt1, infile)) == 0 
				&& ferror(infile)) {
				if(errno != EINTR) {
					break;
				}
				clearerr(infile);
				errno = 0;
			}
			tt1 -= ngot;
			tt2 += ngot;		
		}
		buffer_content[tt2] = '\0';
		++tt2;

		fclose(infile);
	}
	else {
		buffer_content = new char[2];
		buffer_content[0] = buffer_content[1] = '\0';
		tt2 = 1;
	}

<</before_buffer_init>>

<<after_buffer_usage>>
	if(buffer_content) {
		delete[] buffer_content;
	}
<</after_buffer_usage>>

<<buffer_init>>yylexcstr(buffer_content, (int)tt2)<</buffer_init>>
<<buffer_init2>>lexcstr(buffer_content, (int)tt2)<</buffer_init2>>
<<buffer_init3>>yylexcstr(buffer_content, (int)tt2)<</buffer_init3>>
<<filebuf_decl2>>lexcstr(const char *, int);<</filebuf_decl2>>
<<filebuf_decl>>int yylexcstr(const char*, int);<</filebuf_decl>>
<<inputed_file>> $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = fopen(argv[1], "r");<</before_myinput>>
<<stream_type>>c++-cbuffer.log<</stream_type>>
>>>>>>>------------------ input from copied buffer
	<</group>>


<</settings>>
>>>> ------------------------------------ global setting
<<templs>>

<<<----------template for configure.ac-------------->>>
<<templ "config-template">>AC_INIT([the pattern-matching and parsing program generator], [<<version/>>], [<<email/>>], [upgen])
AM_INIT_AUTOMAKE([])
AC_PROG_CC
AC_PROG_CXX
AC_CHECK_HEADERS([stdio.h])
AC_CHECK_HEADERS([sys/stat.h])
AC_CHECK_HEADERS([string.h])

AC_HEADER_STDC
AC_HEADER_STDBOOL
AC_CHECK_FUNCS([isdigit isalpha memset])
AC_CONFIG_HEADERS([config.h])

UDIFF=<<diff/>>
LOGFILE=../../upgen_test_log/<<stream_type/>>
AC_SUBST([UPGEN_BINDIR])
AC_SUBST([UDIFF])
AC_SUBST([LOGFILE])

AC_CONFIG_FILES(<<makefiles/>>
)
AC_OUTPUT

<</templ>>

<<<----------template for Makefile.am of directories---------->>>
<<templ "subdir-makefile-template">>## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE
SUBDIRS = <<subdirs/>>
DIST_SUBDIRS = <<subdirs/>>

test-suites: clean
	NOK=;\
	NFAIL=;\
	for subdir in $(SUBDIRS) ; do \
		echo Enter "$$subdir" "..." >> $(top_srcdir)/$(LOGFILE) ; \
		( cd "$$subdir" && $(MAKE) test-suites --quiet) ; \
		case $$? in \
			0 ) NOK=0$$NOK;\
				;; \
			* ) NFAIL=0$$NFAIL; \
				;; \
		esac; \
	done ; \
	echo Results: >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NOK@ECHO_C@"|wc -c` succeeded >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NFAIL@ECHO_C@"|wc -c` FAILED >> $(top_srcdir)/$(LOGFILE) ; \
	test "$$NFAIL" = ""

<</templ>>

<<<----------template for Makefile.am of cases---------->>>
<<templ "lex-only-makefile-template">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) <<upgen_options/>> -clLp -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "make-no-exec">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

UPGEN = $(UPGEN_BINDIR)/upgen

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

EXTRA_DIST = script.upg test.input result.out result.err
CLEANFILES = test.out test.err

test-suites: $(srcdir)/script.upg
	$(UPGEN) <<upgen_options/>> -o script.cpp $< >$(srcdir)/test.out 2>$(srcdir)/test.err; \
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<<----------template for script.upg of cases---------->>>
<<templ "lex-only-script-template">><<desc/>>
%{
#include <iostream>
using std::cout;
using std::endl;

<<init_code/>>
%}
<<declare_section/>>
%%
<<lex_section/>>
%%
<<parse_section/>>
%%
<<code_section/>>

using namespace yynsx;

int main(int argc, char **argv) {

<<before_buffer_init/>>
<<before_init/>>
	if(<<buffer_init/>>) {
		return -1;
	}
<<after_init/>>
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "invoke-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -cL <<upgen_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "invoke-make-stdout-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -cL <<upgen_options/>> -t $< >$@ 2>> $(top_srcdir)/$(LOGFILE) ;
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "invoke-make-lex-parse-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp scanner.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg scanner.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = script.cpp scanner.cpp test.out test.err $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -clL <<parser_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
scanner.cpp: $(srcdir)/scanner.upg
	@rm -f scanner.cpp
	$(UPGEN) <<scanner_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "basic-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -clL <<upgen_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "invoke-full-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%{

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>


typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

// to avoid copy yytext
static string	s_strVarName; 
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

[0-9]+				<<prefix/>>lval.nVal = atoi(yytext);
				return NUM;
"quit"				return QUIT;
"clear"				return CLEAR;
"list"				return LIST;
{var}				s_strVarName = yytext;
				return VARI;
[\+\-\*\/\%\^\=\(\)\?\n]	return yytext[0];

<<default_action/>>

%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
			cerr << "; description: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: at " << @1.firstLine << ": " << @1.firstColumn;
		cerr << "; description: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
				cerr << "; description: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;

%%

using namespace <<prefix/>>nsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<prefix/>><<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	<<prefix/>>parse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "invoke-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>


typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

// to avoid copy yytext
static string	s_strVarName; 
			
%}


/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

			
%%

[0-9]+				<<prefix/>>lval.nVal = atoi(yytext);
				return NUM;
"quit"				return QUIT;
"clear"				return CLEAR;
"list"				return LIST;
{var}				s_strVarName = yytext;
				return VARI;
[\+\-\*\/\%\^\=\(\)\?\n]	return yytext[0];
<<default_action/>>
			
%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;

			
%%

using namespace <<prefix/>>nsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(<<prefix/>><<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	<<prefix/>>parse();
<<after_buffer_usage/>>
	return 0;
}


<</templ>>

<<templ "invoke-myscanner-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>
#include <ctype.h>


typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

static string	yytext;

static string	s_strVarName;
			
%}

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

			
%%

			
%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
			cerr << "; description: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: at " << @1.firstLine << ": " << @1.firstColumn;
		cerr << "; description: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
				cerr << "; description: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;
			
%%

using namespace <<prefix/>>nsx;

static FILE *s_pfile = NULL;

int myscanner(void) {

	int c;
	bool to_be_var;

	if( ! s_pfile) {
		return 0;
	}

	do {
		to_be_var = false;
		yytext.clear();

		c = fgetc(s_pfile);
		if(EOF == c && feof(s_pfile)) {
			return 0;
		}
		if(isdigit(c)) {
			do {
				yytext += c;
				c = fgetc(s_pfile);
			}while(isdigit(c));

			ungetc(c, s_pfile );
			<<prefix/>>lval.nVal = atoi(yytext.c_str());

			return NUM;
		}

		switch(c) {

		case '+':
		case '-':
		case '*':
		case '/':
		case '%':
		case '^':
		case '=':
		case '(':
		case ')':
		case '\?':
		case '\n':
			yytext += c;
			return c;
		case 'q':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'u') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'i') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {

						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return QUIT;
						}
					}
				}
			}
			break;

		case 'c':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'l') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'e') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 'a') {
						yytext += c;
						c = fgetc(s_pfile);
						if(c == 'r') {
							yytext += c;
							c = fgetc(s_pfile);
							if( ! isalnum(c) && c != '_') {
								ungetc(c, s_pfile);
								return CLEAR;
							}
						}
					}
				}
			}
			break;

		case 'l':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'i') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 's') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {
						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return LIST;
						}
					}
				}
			}
			break;

		default:
			
			if(isalpha(c) || c == '_') {
				to_be_var = true;
			}
			else if(c != EOF) {
				if(c != ' ' && c != '\t' && c != '\v') {
					cerr << "undefined symbol `" << (char)c << '\'' << endl;
				}
			}
			break;
		}

		if(to_be_var) {
			while(isalnum(c) || c == '_') {
				yytext += c;
				c = fgetc(s_pfile);
			}
			ungetc(c, s_pfile);

			s_strVarName = yytext;
			return VARI;
		}

	}while( ! feof(s_pfile));

	return 0;
}

int main(int argc, char **argv) {
	
	<<before_myinput/>>
	<<prefix/>>setlex(myscanner);

	<<prefix/>>parse();
	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}

<</templ>>

<<templ "invoke-myscanner-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>
#include <ctype.h>



typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

static string	yytext;

static string	s_strVarName;
			
%}

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

			
%%

			
%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;
			
%%

using namespace yynsx;

static FILE *s_pfile = NULL;

int myscanner(void) {

	int c;
	bool to_be_var;

	if( ! s_pfile) {
		return 0;
	}

	do {
		to_be_var = false;
		yytext.clear();

		c = fgetc(s_pfile);
		if(EOF == c && feof(s_pfile)) {
			return 0;
		}
		if(isdigit(c)) {
			do {
				yytext += c;
				c = fgetc(s_pfile);
			}while(isdigit(c));

			ungetc(c, s_pfile );
			<<prefix/>>lval.nVal = atoi(yytext.c_str());

			return NUM;
		}

		switch(c) {

		case '+':
		case '-':
		case '*':
		case '/':
		case '%':
		case '^':
		case '=':
		case '(':
		case ')':
		case '\?':
		case '\n':
			yytext += c;
			return c;
		case 'q':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'u') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'i') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {

						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return QUIT;
						}
					}
				}
			}
			break;

		case 'c':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'l') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'e') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 'a') {
						yytext += c;
						c = fgetc(s_pfile);
						if(c == 'r') {
							yytext += c;
							c = fgetc(s_pfile);
							if( ! isalnum(c) && c != '_') {
								ungetc(c, s_pfile);
								return CLEAR;
							}
						}
					}
				}
			}
			break;

		case 'l':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'i') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 's') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {
						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return LIST;
						}
					}
				}
			}
			break;

		default:
			
			if(isalpha(c) || c == '_') {
				to_be_var = true;
			}
			else if(c != EOF) {
				if(c != ' ' && c != '\t' && c != '\v') {
					cerr << "undefined symbol `" << (char)c << '\'' << endl;
				}
			}
			break;
		}

		if(to_be_var) {
			while(isalnum(c) || c == '_') {
				yytext += c;
				c = fgetc(s_pfile);
			}
			ungetc(c, s_pfile);

			s_strVarName = yytext;
			return VARI;
		}

	}while( ! feof(s_pfile));

	return 0;
}

int main(int argc, char **argv) {
	
	<<before_myinput/>>
	<<prefix/>>setlex(myscanner);

	<<prefix/>>parse();
	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}

<</templ>>


<<templ "invoke-parser-only-template">>

/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only parsing program.
************************************************************************/

%{

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>



typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

// to avoid copy yytext
extern string	s_strVarName;

namespace zznsx {

extern bool zz<<filebuf_decl2/>>
extern int zzlex(void);
}

%}


/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in yyparse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
			cerr << "; description: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: at " << @1.firstLine << ": " << @1.firstColumn;
		cerr << "; description: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
				cerr << "; description: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;

%%

using namespace yynsx;
using namespace zznsx;

string	s_strVarName;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(zz<<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	yysetlex(zzlex);

	yyparse();
<<after_buffer_usage/>>
	return 0;
}


<</templ>>

<<templ "invoke-noparser-template">>
<<desc/>>
/***********************************************************************
	program sample : extract keywords, identifiers, and numbers
************************************************************************/
<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
		
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*
			
%%

[0-9]+				cout << "number: " << yytext << endl;
"quit"				cout << "keyword: " << yytext << endl;
"clear"				cout << "keyword: " << yytext << endl;
"list"				cout << "keyword: " << yytext << endl;
{var}				cout << "identifier: " << yytext << endl;
[\+\-\*\/\%\^\=\(\)\?]		cout << "operator: " << yytext[0] << endl;
\n				cout << "new line encountered." << endl;
<<default_action/>>
<<EOF>>				cout << "Good-bye!" << endl;
			
%%

			
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(<<prefix/>><<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	<<prefix/>>lex();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "basic-parentheses-template">>
<<desc/>>
/**********************************************************************
	program sample: extract parentheses from expression,
			and convert them to brackets
***********************************************************************/

<<declare_section/>>
%%

[\(\)]		<<parent_lex_action/>>
		return yytext[0];
\n		printf("\n");
.

%%

Program: PExpr %{
<<accept_action/>>
		YYACCEPT();
	%}
	;

PExpr: PExpr PItem	%{

	%}
	|
	;
PItem: '('		%{
		printf("[");
	%}
	PExpr ')'	%{
		printf("]");
	%}
	;
%%
<<code_section/>>

<</templ>>

<<templ "basic-sentinfo-template">>
<<desc/>>
/****************************************************************
	program sample: count information of sentences in text
*****************************************************************/

%{
<<union_code/>>
<<location_code/>>
static int sentenceCounter = 1;
%}

<<union_decl/>>
<<location_decl/>>

%parsevar-decl%{
int lineCounter = 0;
int wordCounter = 0;
int charCounter = 0;
%}

ws	[ \t]
nows	[^ \t\n\.\?\!]

%token<nVal> TK_WORD TK_WS
%token	TK_ES

%type<nPair> Block Blocks

%%

[\.\?\!]		{
		yylloc.sentenceNo = sentenceCounter;
		++sentenceCounter;
		return TK_ES;
	}

{nows}+	{
		yylloc.sentenceNo = sentenceCounter;
		yylval.nVal = yyleng;
		return TK_WORD;
	}

{ws}+		{
		yylloc.sentenceNo = sentenceCounter;
		yylval.nVal = yyleng;
		return TK_WS;
	}
\n		{
		yylloc.sentenceNo = sentenceCounter;
		return '\n';
	}

%%


SText: Blocks	%{
		fprintf(stdout, "Words: %d\n", wordCounter);
		fprintf(stdout, "Chars: %d\n", charCounter);
		fprintf(stdout, "Sents: %d\n", @1.sentenceNo);
		fprintf(stdout, "Lines: %d\n", lineCounter);
		YYACCEPT();
	%}
	;

Blocks:	Blocks Block	%{
		@$.sentenceNo = @2.sentenceNo;
		if($2.charCounter == -1) {
			++$1.charCounter;
			fprintf(stdout, "S%d\t%d words;\t%d characters.\n",
				@1.sentenceNo,
				$1.wordCounter,
				$1.charCounter);

			++charCounter;

			$$.wordCounter = 0;
			$$.charCounter = 0;
		}
		else {
			$$.wordCounter = $1.wordCounter + $2.wordCounter;
			$$.charCounter = $1.charCounter + $2.charCounter;

			wordCounter += $2.wordCounter;
			charCounter += $2.charCounter;
		}
	%}
	| Block		%{
		@$.sentenceNo = @1.sentenceNo;
		if($1.charCounter == -1) {
			fprintf(stdout, "S%d\t%d words;\t1 characters.\n",
				@1.sentenceNo,
				$1.wordCounter);

			++charCounter;

			$$.wordCounter = 0;
			$$.charCounter = 0;
		}
		else {
			$$.wordCounter = $1.wordCounter;
			$$.charCounter = $1.charCounter;

			wordCounter += $1.wordCounter;
			charCounter += $1.charCounter;
		}
	%}
	;

Block: TK_WORD	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 1;
		$$.charCounter = $1;
	%}
	| TK_WS	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 0;
		$$.charCounter = $1;
	%}
	| '\n'	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 0;
		$$.charCounter = 1;
		++lineCounter;
	%}
	| TK_ES	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 0;
		$$.charCounter = -1;
	%}
	;

%%

using namespace yynsx;
int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "basic-tagchecker-template">>
<<desc/>>
/**************************************************************
	sample program: tag checker, which determines if
			tag head has corresponding tag tail
***************************************************************/

%{

#include <string.h>

struct triple_t{
	/* max of depth */
	int maxdep;
	/* current depth */
	int curdep;
	/* number of parentheses */
	int pairnum;
};

struct _tag_node_t {

	char *plabel;
	_tag_node_t *pnext;
};

typedef struct _tag_node_t tag_node_t;
typedef tag_node_t *tag_link_t;

/* push tag into stack */
static void stack_push(char *);
/* pop tag from stack */
static char* stack_pop();
/* get most recently pushed tag */
static char* stack_top();
/* free all nodes(not incuding their contents) in stack */
static void stack_clear();
/* allocate a string */
static char* alloc_string(int);
/* free all allocated string */
static void free_string();

/* top of tag stack */
static tag_link_t sttop = NULL;
/* top of allocation stack */
static tag_link_t stravail = NULL;

/* temporary variable */
/* @tempi used as counter in loops */
static int tempi;

<<init_code/>>
%}

/* legal name of tag excludes and string containing
	 ( ) [ ] { } < > , / " ' ; :
*/
tag	[A-Za-z0-9\!\@\#\$\%\^\&\*\+\-\_\~\`\?\.]+

/* semantic value type definition */
%union%{
	char* pchval;
	int level;
%}

%token<pchval> '(' ')'
%type<pchval> TagHead
%type<level> TagItem TagExpr
<<parse_param/>>
<<parsevar_decl/>>
<<parsevar_init/>>
<<destructor/>>
<<start_symbol/>>

%%

"<"{tag}">"	{
		yylval.pchval = alloc_string(yyleng - 1);
		strncpy(yylval.pchval, &yytext[1], yyleng - 2);
		yylval.pchval[yyleng - 2] = '\0';

		return '(';
	}

"</"{tag}">"	{
		yylval.pchval = stack_top();
		yytext[yyleng - 1] = '\0';
		if(!yylval.pchval || strcmp(yylval.pchval, &yytext[2])) {
			return ']';
		}
		return ')';
	}

.|\n		<<deflex_action/>>

%%

Exprs: TagExpr %{
		fprintf(stdout, "Tag checking passed.\n");
		<<exprs_action/>>
	%}
	;

SText: Exprs %{
		fprintf(stdout, "Input text is accepted by tag-check grammar.\n");
		YYACCEPT();
	%}
	;

TagExpr: TagExpr TagItem %{
		$$ = $2;
	%}
	|		%{
		$$ = tpl.curdep;
	%}
	;
TagItem: TagHead TagExpr ')'	%{
		--tpl.curdep;
		++tpl.pairnum;
		stack_pop();

		for(tempi = 0; tempi < tpl.curdep; ++tempi) {
			fprintf(stdout, "\t");
		}
		fprintf(stdout, "</%s>\n", $3);

		$$ = tpl.curdep;
	%}
	| TagHead error ')'	%{
		--tpl.curdep;
		++tpl.pairnum;
		stack_pop();

		for(tempi = 0; tempi < tpl.curdep; ++tempi) {
			fprintf(stdout, "\t");
		}
		fprintf(stdout, "</%s>\n", $3);

		$$ = tpl.curdep;

		yyerrok();
	%}
	;
TagHead: '('	%{

		for(tempi = 0; tempi < tpl.curdep; ++tempi) {
			fprintf(stdout, "\t");
		}
		fprintf(stdout, "<%s>\n", $1);

		++tpl.curdep;
		if(tpl.curdep > tpl.maxdep) {
			tpl.maxdep = tpl.curdep;
		}
		stack_push($1);
		$$ = $1;
	%}
	;
%%

/* push tag into stack */
void stack_push(char *plbl) {
	tag_link_t p;

	p = (tag_link_t)malloc(sizeof(tag_node_t));
	p->plabel = plbl;
	p->pnext = sttop;
	sttop = p;
}

/* pop tag from stack */
char* stack_pop() {
	char *pch;
	tag_link_t p;

	p = sttop;
	if(p) {
		pch = p->plabel;
		sttop = sttop->pnext;
		free(p);
	}
	else {
		pch = NULL;
	}
	return pch;
}

/* get most recently pushed tag */
char* stack_top() {
	return sttop? sttop->plabel: NULL;
}

/* free all nodes(not incuding their contents) in stack */
void stack_clear() {

	tag_link_t p;

	while(sttop) {
		p = sttop->pnext;
		free(sttop);
		sttop = p;	
	}
	sttop = NULL;
}

/* allocate a string */
char* alloc_string(int nlen) {

	tag_link_t p;

	if(nlen <= 0) {
		return NULL;
	}

	p = (tag_link_t)malloc(sizeof(tag_node_t));
	p->plabel = (char*)malloc(sizeof(char)*nlen);
	p->pnext = stravail;
	stravail = p;

	return p->plabel;
}

/* free all allocated string */
void free_string() {
	
	tag_link_t p;

	while(stravail) {
		p = stravail->pnext;
		free(stravail->plabel);
		free(stravail);
		stravail = p;	
	}
	stravail = NULL;
}

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	sttop = NULL;
	stravail = NULL;

	<<before_yyparse/>>
	
	yyparse(<<yyparse_param/>>);

	<<after_yyparse/>>

	stack_clear();
	free_string();
<<after_buffer_usage/>>

	return 0;
}


<</templ>>

<<templ "basic-extr-numopr-template">>
<<desc/>>
/****************************************************************************
*	sample program: number(including integer and float),
*			arithmetic operator(+ - * / % ^ =)
*			extracter
*****************************************************************************/

%{

<<init_code/>>
%}

udec	[0-9]+
sdec	[\-\+]?{udec}
frct	\.{udec}
num	{sdec}{frct}?
opr	[\+\-\*\/\%\^\=]

<<lvar_decl/>>
<<lvar_init/>>
<<lex_init/>>
<<pre_match/>>
<<yywrap/>>

%token FEOF

%%

"#open"[ \t]*\"[^\"\'\n]+\"	{
		++dc;
		yytext[yyleng - 1] = '\0';

		int i = 5;
		while(yytext[i++] != '\"');

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stderr, "Error: failed to open file `%s\'\n", &yytext[i]);
		}
		else {
			yy_switch_buffer(pbuf);
		}
	}
{sdec}		++ic;
{num}		++rc;
{opr}		++oc;
<<EOF>>	yy_delete_buffer();			
		fprintf(stdout, "number of integers: %d\n", ic);
		fprintf(stdout, "number of reals: %d\n", rc);
		fprintf(stdout, "number of operators: %d\n", oc);
		fprintf(stdout, "number of discarded symbols: %d\n", dc);
		fprintf(stdout, "number of matched patterns: %d\n", mc);
		return FEOF;

.|\n		++dc;
%%

Start: Start FEOF 
	| FEOF
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "basic-fdc-template">>
<<desc/>>
/****************************************************************************
*	sample program: calculator for integers and reals
*	the purpose of this is to show how to use following features of upgen
*			%left %right %nonassoc %type
*			%prec %parse-init %parse-exit
*****************************************************************************/
%{
#include <limits.h>
#include <math.h>

enum {
	NT_INT,
	NT_REAL
};
%}

%union%{
	long nVal;
	double dVal;
	struct {
		int nType;
		union {
			long nVal;
			double dVal;
		};
	}xNum;
%}
%yywrap%{
	yy_delete_buffer();
	return 0;
%}

%lvar-decl%{
	char *endptr = NULL;
%}
%pvar-decl%{
	bool berror = false;
	int errors = 0;
%}


udec	[0-9]+
frct	\.{udec}
ureal	{udec}{frct}
opr	[\+\-\*\/\^\(\)]

%token<nVal> TK_INT
%token<dVal> TK_REAL

<<token_decl/>>
<<parse_init/>>
<<parse_exit/>>

%type<xNum> Expr

<<type_decl/>>

<<other_decl/>>

%%

"#open"[ \t]*\"[^\"\'\n]+\"	{

		int i;
		while((i = yyinput()) != '\n' && i != END_OF_FILE);
		yy_set_bol(true);

		yytext[yyleng - 1] = '\0';

		i = 5;
		while(yytext[i++] != '\"');

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stdout, "Error: failed to open file `%s\'\n", &yytext[i]);
		}
		else {
			yy_switch_buffer(pbuf);
		}
	}
{udec}		errno = 0;
		yylval.nVal = strtol(yytext, &endptr, 10);
		if(errno == ERANGE) {
			fprintf(stdout, "Error: integer is out of range.\n");
		}
		else {
			fprintf(stdout, "%s", yytext);
			return TK_INT;
		}

{ureal}		errno = 0;
		yylval.dVal = strtod(yytext, &endptr);
		if(errno == ERANGE) {
			fprintf(stdout, "Error: float number is out of range.\n");
		}
		else {
			fprintf(stdout, "%s", yytext);
			return TK_REAL;
		}
		
{opr}		fprintf(stdout, "%c", yytext[0]);
		return yytext[0];

\n		fprintf(stdout, "\n");		
		return '\n';
[ \t]		fprintf(stdout, "%c", yytext[0]);

.

%%

Task: Lines		%{
<<type_action_0/>>
	%}
	;

Lines: Lines Line	%{
<<type_action_1/>>
	%}
	|		%{
<<type_action_2/>>
	%}
	;
Line: Expr '\n'		%{
		if(!berror) {
			if($1.nType == NT_INT) {
				fprintf(stdout, "\t\t%ld[INT]\n", $1.nVal);
			}
			else {
				fprintf(stdout, "\t\t%g[REAL]\n", $1.dVal);
			}
		}

		errors += berror? 1: 0;

		berror = false;
	%}
	| error '\n'	%{

		errors += berror? 1: 0;

		berror = false;
		yyerrok();
	%}
	| '\n'		%{
		berror = false;
	%}
	;

Expr: Expr '+' Expr	%{
		if(!berror) {

			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				$$.nVal = $1.nVal + $3.nVal;
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal + $3.dVal;
				}
				else if($3.nType == NT_INT) {
					$$.dVal = $1.dVal + (double)$3.nVal;
				}
				else {
					$$.dVal = $1.dVal + $3.dVal;
				}
			}
		}
	%}
	| Expr '-' Expr	%{
		if(!berror) {
			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				$$.nVal = $1.nVal - $3.nVal;
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal - $3.dVal;
				}
				else if($3.nType == NT_INT) {
					$$.dVal = $1.dVal - (double)$3.nVal;
				}
				else {
					$$.dVal = $1.dVal - $3.dVal;
				}
			}
		}
	%}
	| Expr '*' Expr	%{

		if(!berror) {
			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				$$.nVal = $1.nVal * $3.nVal;
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal * $3.dVal;
				}
				else if($3.nType == NT_INT) {
					$$.dVal = $1.dVal * (double)$3.nVal;
				}
				else {
					$$.dVal = $1.dVal * $3.dVal;
				}
			}
		}
	%}
	| Expr '/' Expr	%{

		if(!berror) {
			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				if($3.nVal == 0) {
					fprintf(stdout, "Error: divided by zero!\n");
					berror = true;
				}
				else {
					$$.nVal = $1.nVal / $3.nVal;
				}
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal / $3.dVal;
				}
				else if($3.nType == NT_INT) {
					if($3.nVal == 0) {
						fprintf(stdout, "Error: divided by zero!\n");
						berror = true;
					}
					else {
						$$.dVal = $1.dVal / (double)$3.nVal;
					}
				}
				else {
					$$.dVal = $1.dVal / $3.dVal;
				}
			}
		}
	%}
	| Expr '^' Expr %{

		if(!berror) {
			errno = 0;
			$$.nType = NT_REAL;
			if($1.nType == NT_INT) {
				if($3.nType == NT_INT) {
					$$.dVal = pow($1.nVal, $3.nVal);
				}
				else {
					$$.dVal = pow($1.nVal, $3.dVal);
				}
			}
			else {
				if($3.nType == NT_INT) {
					$$.dVal = pow($1.dVal, $3.nVal);
				}
				else {
					$$.dVal = pow($1.dVal, $3.dVal);
				}
			}
			if(errno) {
				switch(errno) {
				case EDOM:
					fprintf(stdout, "Error: domain error, x is negative while y is non-integer.\n");
					break;
				default:
					fprintf(stdout, "Error: number is out of range.\n");
					break;
				}
				berror = true;
			}
		}
	%}
	| '(' Expr ')'	%{

		if(!berror) {
			$$.nType = $2.nType;
			if($2.nType == NT_INT) {
				$$.nVal = $2.nVal;
			}
			else {
				$$.dVal = $2.dVal;
			}
		}
	%}
	| '+' <<prec_refer/>> Expr	%{

		if(!berror) {
			$$.nType = $2.nType;
			if($2.nType == NT_INT) {
				$$.nVal = $2.nVal;
			}
			else {
				$$.dVal = $2.dVal;
			}
		}
	%}
	| '-' <<prec_refer/>> Expr	%{

		if(!berror) {
			$$.nType = $2.nType;
			if($2.nType == NT_INT) {
				$$.nVal = - $2.nVal;
			}
			else {
				$$.dVal = - $2.dVal;
			}
		}
	%}
	| TK_INT		%{
		$$.nType = NT_INT;
		$$.nVal = $1;
	%}
	| TK_REAL		%{
		$$.nType = NT_REAL;
		$$.dVal = $1;
	%}
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stdout, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "interface-scanner-template">><<desc/>>
%{
#include <iostream>
using std::cout;
using std::endl;

<<init_code/>>
%}
<<declare_section/>>
%%
<<lex_section/>>
%%

Start: /* empty */

%%
<<code_section/>>

using namespace yynsx;

int main(int argc, char **argv) {

<<before_buffer_init/>>
<<before_init/>>
	if(<<buffer_init/>>) {
		return -1;
	}
<<after_init/>>
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-bstack-template">>
/*
	sample program: test buffer operations
	feature to test:
		yy_current_buffer, yy_has_buffer, yy_push_buffer, yy_pop_buffer,
		yy_new_filebuf, yy_new_cstrbuf, yy_new_strbuf, yy_switch_buffer,
		yy_delete_buffer
*/

%{
#include <vector>
using std::vector;
#include <string>
using std::string;

typedef void* pvoid_t;


typedef vector<char*> vpchar_t;
typedef vpchar_t::size_type vpc_size_t;

//namespace yynsx {
//class bufbase_t;
//typedef bufbase_t * YYPBUFFER;
//}

using namespace yynsx;


static void regbuffer(YYPBUFFER, const char *, unsigned int);
static const char* buffername(YYPBUFFER);

static vpchar_t vbufname;
static char *temp_buffer = NULL;

%}

%lvar-decl%{
	int i, j, d;
%}

%yywrap%{
	const char* pbn = buffername(yy_current_buffer());
	if(pbn) {
		fprintf(stderr, "buffer `%s\' is coming.\n", pbn);
	}
	return false;
%}

%x	RSTRT

fname	\`[^\"\'\`\n\r]+\`
str	\"[^\"\'\`]+\"
cstr	\'[^\"\'\`]+\'
bname	[[:cidf:]][[:cids:]]*


%parse-init%{

	regbuffer(yy_current_buffer(), "test", 4);
%}
%token FEOF

%%

{bname}">"[ \t]*"open"[ \t]+{fname}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '`');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for file `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"push"[ \t]+{fname}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '`');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for file `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		}
	}
		
{bname}">"[ \t]*"open"[ \t]+{str}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\"');
		++i;

		d = yyleng - i;
		if(temp_buffer) {
			delete[] temp_buffer;
		}

		temp_buffer = new char[d];
		strncpy(temp_buffer, &yytext[i], d - 1);
		temp_buffer[d - 1] = '\0';
		

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_strbuf(temp_buffer, d);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"push"[ \t]+{str}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\"');
		++i;

		d = yyleng - i;
		if(temp_buffer) {
			delete[] temp_buffer;
		}

		temp_buffer = new char[d];
		strncpy(temp_buffer, &yytext[i], d - 1);
		temp_buffer[d - 1] = '\0';

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_strbuf(temp_buffer, d);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"open"[ \t]+{cstr}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\'');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_cstrbuf(&yytext[i], yyleng - i);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for constant string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"push"[ \t]+{cstr}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\'');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_cstrbuf(&yytext[i], yyleng - i);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for constant string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);

			yy_push_buffer(pbuf);
		}
	}

"has?"		{
		if(yy_has_buffer()) {
			fprintf(stderr, "Yes, there are buffers!\n");
		}
		else {
			fprintf(stderr, "Oh, no! It\'s impossible!!!\n");
			YYABORT();
		}
	}

"cur?"		{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "current buffer: %s\n", pbn);
		}
		else {
			fprintf(stderr, "Oh, no name for current buffer! It\'s impossible!!!\n");
			YYABORT();
		}
	}

"close"		{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "closing buffer %s ...\n", pbn);
			yy_delete_buffer();
			if(yy_has_buffer()) {
				pbn = buffername(yy_current_buffer());
				if(pbn) {
					fprintf(stderr, "switching to buffer %s ...\n", pbn);
				}
				else {
					fprintf(stderr, "Oh, no name for to-be-switched buffer! It\'s impossible!!!\n");
					YYABORT();
				}
			}
		}
		else {
			fprintf(stderr, "Oh, no name for to-be-deleted buffer! It\'s impossible!!!\n");
			YYABORT();
		}
	}
"abort"		{
		fprintf(stderr, "program exit abnormal ...\n");
		YYABORT();
	}
"pop"		{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "popping buffer %s ...\n", pbn);
			yy_pop_buffer();
			if(yy_has_buffer()) {
				pbn = buffername(yy_current_buffer());
				if(pbn) {
					fprintf(stderr, "switching to buffer %s ...\n", pbn);
				}
				else {
					fprintf(stderr, "Oh, no name for to-be-switched buffer! It\'s impossible!!!\n");
					YYABORT();
				}
			}
		}
		else {
			fprintf(stderr, "Oh, no name for to-be-popped buffer! It\'s impossible!!!\n");
			YYABORT();
		}
	}

"restart"	{

		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "restarting buffer %s ...\n", pbn);
			
			yyrestart();
			BEGIN(RSTRT);
		}
		else {
			fprintf(stderr, "Oh, no name for to-be-restarted buffer! It\'s impossible!!!\n");
			YYABORT();
		}

	}

<*>.|\n		fprintf(stderr, "%s", yytext);

<RSTRT><<EOF>>	{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "buffer `%s\' is abort to leave.\n", pbn);
		}
		BEGIN(INITIAL);
		yy_delete_buffer();
		return FEOF;
	}

<*><<EOF>>	{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "buffer `%s\' is abort to leave.\n", pbn);
		}
		yy_delete_buffer();
		return FEOF;
	}

%%

Start: Texts %{
		if(yy_has_buffer()) {
			fprintf(stderr, "There are still buffers!\n");
			YYABORT();
		}
		else {
			fprintf(stderr, "All buffers closed.\n");
		}
	%}
	;

Texts: Texts FEOF
	|
	;

%%

using namespace yynsx;

void regbuffer(YYPBUFFER pbuf, const char *pbname, unsigned int sz){

	if(pbuf) {
		char *pc = new char[sz + 1];
		strncpy(pc, pbname, sz);
		pc[sz] = '\0';

		vpc_size_t n = vbufname.size();
		vbufname.push_back(pc);
		pbuf->setdata((void*)n);
	}
}

const char* buffername(YYPBUFFER pbuf) {
	
	if(pbuf) {
		vpc_size_t n = (vpc_size_t)pbuf->getdata();
		if(n < vbufname.size()) {
			return vbufname[n];
		}
	}
	return NULL;
}

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init3/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}

	yyparse();

	if(temp_buffer) {
		delete[] temp_buffer;
	}
	for(int i = 0; i < (int)vbufname.size(); ++i) {
		if(vbufname[i]) {
			delete[] vbufname[i];
		}
	}
<<after_buffer_usage/>>
	return 0;
}


<</templ>>

<<templ "interface-echo-template">>
/*
 *	sample program: test ECHO
 */

num	[0-9]+
xnum	0x[0-9]{2}

%%

^{num}	ECHO();

{xnum}	ECHO();
\n	ECHO();
.	ECHO();

%%

Start:
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>


<<templ "interface-getbol-template">>
/*
 *	sample program: test yy_get_bol
 */

num	[0-9]+
xnum	0x[0-9]{2}

%%

^{num}	int n = atoi(yytext);
	if(n != yylloc.firstLine) {
		fprintf(stderr, "Error: at %d:%d failed to verify line number.\n",
			yylloc.firstLine, yylloc.firstColumn);
	}

{xnum}	int n = atoi(&yytext[2]);
	if(n != yylloc.firstLine) {
		fprintf(stderr, "Error: at %d:%d failed to verify line number.\n",
			yylloc.firstLine, yylloc.firstColumn);
	}
\n	if( ! yy_get_bol()) {
		fprintf(stderr, "Error: at %d:%d failed to verify value of bol.\n",
			yylloc.firstLine, yylloc.firstColumn);
	}
.

%%

Start:
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>


<<templ "interface-line-editor-template">>
/*
	sample program: special line editor
	feature to test: yymore yyless  yyinput yyterminate /
*/

%%

"&"		{
		--yyleng;
		if(yyleng > 0) {
			yytext[yyleng] = '\0';
			fprintf(stdout, "%s", yytext);
		}
	}
"&&"		{
		--yyleng;
		yytext[yyleng] = '\0';
		yymore();
	}
"&!"		{
		--yyleng;
		yytext[yyleng - 1] = '!';
		yytext[yyleng] = '\0';
		yymore();
	}
"&@"		{
		--yyleng;
		yytext[yyleng - 1] = '@';
		yytext[yyleng] = '\0';
		yymore();
	}
"!!"		{
		yyleng -= 2;
		yytext[yyleng] = '\0';
		if(yyleng > 0) {
			fprintf(stdout, "%s", yytext);
		}

		int c;
		while((c = yyinput()) != '\n' && c != END_OF_FILE);
		if(c == '\n') {
			fprintf(stdout, "\n");
			yy_set_bol(true);
		}
	}
"!!!"		{
		yyleng -= 3;
		yytext[yyleng] = '\0';
		if(yyleng > 0) {
			fprintf(stdout, "%s", yytext);
		}
		yyterminate();
	}

[^\@\&\!\n]+/"@"[0-9][0-9]	{

		yytext[yyleng] = '\0';
		fprintf(stdout, "%s", yytext);
		
		char *endptr;
		int n = (int)strtol(&yytext[yyleng + 1], &endptr, 10);

		if(n > 0) {
			if(n > yyleng) {
				n = yyleng;
			}
			yytext[n] = '\0';
			fprintf(stdout, "%s", yytext);
		}
		// throw away 3 chars followed: @##
		yyinput();
		yyinput();
		yyinput();
	}
[^\@\&\!\n]+/"@-"[0-9][0-9]	{

		yytext[yyleng] = '\0';
		yylaleng = yyleng;
		
		char *endptr;
		int n = (int)strtol(&yytext[yyleng + 2], &endptr, 10);

		fprintf(stdout, "%s", yytext);

		n = yyleng - n;
		if(n > 0 && n < yyleng) {
			yyless(n);
		}
	}
[^\@\&\!\n]+/"!"[0-9][0-9]	{

		char *endptr;
		int n = (int)strtol(&yytext[yyleng + 1], &endptr, 10);

		if(n > yyleng) {
			n = yyleng;
		}
		yyleng -= n;
		yytext[yyleng] = '\0';

		if(yyleng > 0) {

			fprintf(stdout, "%s", yytext);
		}
		// throw away 3 chars followed: @##
		yyinput();
		yyinput();
		yyinput();
	}

"@-"[0-9][0-9]	{
		yyleng -= 4;
		yytext[yyleng] = '\0';
		yymore();			
	}

.		yymore();

\n		fprintf(stdout, "%s", yytext);
		

<<EOF>>		{
		if(yyleng > 0) {
			fprintf(stdout, "%s", yytext);
		}
		fflush(stdout);
	}
%%

Start: /* empty */
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-loc2-template">>
/*
	sample program: location counter 2
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
		yyinput yyunput yyunget
*/

%{
#include <vector>
using std::vector;

#include <string>
using std::string;

#include <ctype.h>

struct loc_pair_t {
	int line;
	int col;

	loc_pair_t(void)
	: line(0)
	, col(0) {
	}

	loc_pair_t(int ln, int cl)
	: line(ln)
	, col(cl) {
	}

	loc_pair_t(const loc_pair_t &src)
	: line(src.line)
	, col(src.col){
	}
	
	loc_pair_t& operator=(const loc_pair_t &src) {
		if(&src == this) {
			return *this;
		}
		line = src.line;
		col = src.col;
		return *this;
	}

	bool operator==(const loc_pair_t &src) const {
		return line == src.line && col == src.col;
	}

	bool operator!=(const loc_pair_t &src) const {
		return line != src.line || col != src.col;
	}
};

typedef vector<loc_pair_t> vlpair_t;

typedef vector< vlpair_t* > vpvlp_t;

%}

%union%{
	loc_pair_t locVal;
	int nVal;
	vlpair_t * pvpVal;
%}
%formal-param%{ vpvlp_t &vvprLocs, string &strBuf, int &nLastLoc %}
%actual-param%{ vvprLocs, strBuf, nLastLoc %}

locn	[[:alnum:]]{2}[[:digit:]]
num	[[:digit:]]+

%x	LOC_SC
%x	TOL_SC
%x	PUT_SC

%token LOC_HEAD LOC_TAIL PUT_TAIL
%token TR_TAIL LR_TAIL OR_TAIL
%token<nVal> TR_HEAD LR_HEAD OR_HEAD
%token<locVal> LOCN

%type<pvpVal> TabLine
%%

"#location_head"[ \t]*\r?\n		{

		BEGIN(LOC_SC);
		return LOC_HEAD;
	}

<LOC_SC>"#location_tail"[ \t]*\r?\n	{

		BEGIN(INITIAL);
		return LOC_TAIL;
	}

"#line_replace"[ \t]+{num}[ \t]*\r?\n	|
"#orignal"[ \t]+{num}[ \t]*\r?\n	|
"#tab_replace"[ \t]+{num}[ \t]*\r?\n	{

		yyset_lineno(1);
		yyset_colno(1);
		fprintf(stdout, "after reseting, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());

		int i = yyleng - 1;
		while( ! isdigit(yytext[--i]));
		yytext[i + 1] = '\0';
		while( isdigit(yytext[--i]));
		++i;

		char *endptr;
		errno = 0;
		yylval.nVal = (int)strtol(&yytext[i], &endptr, 10);
		if(errno) {
			perror("strtol");
		}
		
		strBuf.clear();

		BEGIN(TOL_SC);

		switch(yytext[1]) {
		case 'l':
			return LR_HEAD;
			break;
		case 'o':
			return OR_HEAD;
			break;
		default:
			return TR_HEAD;
			break;
		}
	}

<TOL_SC>"#line_replace"[ \t]*\r?\n	|
<TOL_SC>"#orignal"[ \t]*\r?\n		|
<TOL_SC>"#tab_replace"[ \t]*\r?\n	{

		strBuf += yytext;

		BEGIN(INITIAL);

		switch(yytext[1]) {
		case 'l':
			return LR_TAIL;
			break;
		case 'o':
			return OR_TAIL;
			break;
		default:
			return TR_TAIL;
			break;
		};
	}

<PUT_SC>"#line_replace"			|
<PUT_SC>"#orignal"			|
<PUT_SC>"#tab_replace"			{

		BEGIN(INITIAL);
		return PUT_TAIL;
	}

"tab?"				{
		fprintf(stdout, "tabsize = %d\n", yyget_tabsize());
	}

"tab="[[:digit:]]		{

		int n = (int)(yytext[4] - '0');
		yyset_tabsize(n);
		fprintf(stdout, "tabsize is %d now\n", yyget_tabsize());
	}

<*>{locn}		{
		if(isdigit(yytext[0])) {
			yylval.locVal.line = (int)(yytext[0] - '0');
		}
		else  if(islower(yytext[0])) {
			yylval.locVal.line = (int)(yytext[0] - 'a') + 10;
		}
		else {
			yylval.locVal.line = (int)(yytext[0] - 'A') + 36;
		}


		if(isdigit(yytext[1])) {
			yylval.locVal.col = (int)(yytext[1] - '0') * 10 + (int)(yytext[2] - '0');
		}
		else if(islower(yytext[1])) {
			yylval.locVal.col = (int)(yytext[1] - 'a') * 10 + 100 + (int)(yytext[2] - '0');
		}
		else {
			yylval.locVal.col = (int)(yytext[1] - 'A') * 10 + 360 + (int)(yytext[2] - '0');
		}

		if(YYSTART() == TOL_SC) {
			strBuf += yytext;
		}

		return LOCN;
	}

<*>.|\n		{
		if(YYSTART() == TOL_SC) {
			strBuf += yytext;
		}
	}

%%

File:	File Section
	| Section
	;

Section: LocSect
	| RLSect
	| RTSect
	| OrgSect
	| TabLine PUT_TAIL	%{
		if(nLastLoc < 0) {
			fprintf(stdout, "Error: OOPS!!!\n");
		}
		else {
			vlpair_t *pLoc = vvprLocs[nLastLoc];
			fprintf(stdout, "begin comparing location(size %d) %d and its referrence(size %d)\n",
				 (int)pLoc->size(), nLastLoc, (int)$1->size());
			for(vlpair_t::size_type i = 0; i < $1->size() && i < pLoc->size(); ++i) {
				if((*pLoc)[i] != (*$1)[i]) {
					fprintf(stdout, "refer.line = %d\trefer.col = %d"
						"\tLoc.line = %d\tLoc.col = %d\n",
						(*$1)[i].line, (*$1)[i].col, (*pLoc)[i].line, (*pLoc)[i].col);
				}
			}
		}
		delete $1;
	%}
	;

LocSect: LOC_HEAD
	 %{ nLastLoc = -1; %}
	 TabLine LOC_TAIL	%{
		vvprLocs.push_back($3);
	%}
	;
RLSect: LR_HEAD
	 %{
		nLastLoc = -2;
		fprintf(stdout, "begin scanning line_replace section by referrence %d\n", $1);
	 %}
	 TabLine LR_TAIL		%{
		nLastLoc = $1;
		fprintf(stdout, "before putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		if(strBuf.size() > 0) {
			for(string::size_type i = strBuf.size(); i > 0; --i) {
				if(strBuf[i - 1] != '\n') {
					yyunget();
				}
				else {
					yyunput('*');
				}
			}
		}
		strBuf.clear();
		fprintf(stdout, "after putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		fprintf(stdout, "scanning line_replace section is over\n");
		BEGIN(PUT_SC);
	%}
	;
RTSect: TR_HEAD
	 %{
		nLastLoc = -3;
		fprintf(stdout, "begin scanning tab_replace section by referrence %d\n", $1);
	 %}
	 TabLine TR_TAIL		%{
		nLastLoc = $1;
		fprintf(stdout, "before putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());

		if(strBuf.size() > 0) {
			for(string::size_type i = strBuf.size(); i > 0; --i) {
				if(strBuf[i- 1] != '\t') {
					yyunget();
				}
				else {
					yyunput('*');
				}
			}
		}
		strBuf.clear();

		fprintf(stdout, "after putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		fprintf(stdout, "scanning tab_replace section is over\n");

		BEGIN(PUT_SC);
	%}
	;
OrgSect: OR_HEAD
	 %{
		nLastLoc = -4;
		fprintf(stdout, "begin scanning orignal section by referrence %d\n", $1);
	 %}
	 TabLine OR_TAIL 	%{
		nLastLoc = $1;
		fprintf(stdout, "before putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		if(strBuf.size() > 0) {
			for(string::size_type i = strBuf.size(); i > 0; --i) {
				yyunget();
			}
		}
		strBuf.clear();
		fprintf(stdout, "after putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		fprintf(stdout, "scanning orignal section is over\n");

		BEGIN(PUT_SC);
	%}
	;

TabLine: TabLine LOCN	%{
		if(nLastLoc >= -1) {
			$$ = $1;
			if( nLastLoc > -1) {
				$$->push_back(loc_pair_t(@2.firstLine, @2.firstColumn));
			}
			else {
				$$->push_back($2);
			}
		}
		else {
			if(@2.firstLine != $2.line || @2.firstColumn != $2.col) {
				fprintf(stdout, "`@2.firstLine = %d\t`@2.firstColumn = %d"
						"\tLoc.line = %d\tLoc.col = %d\n",
						@2.firstLine, @2.firstColumn, $2.line, $2.col);
			}
		}
	%}
	| LOCN		%{
		if(nLastLoc >= -1) {
			$$ = new vlpair_t;
			if(nLastLoc > -1) {
				$$->push_back(loc_pair_t(@1.firstLine, @1.firstColumn));
			}
			else {
				$$->push_back($1);
			}
		}
		else {
			if(@1.firstLine != $1.line || @1.firstColumn != $1.col) {
				fprintf(stdout, "`@1.firstLine = %d\t`@1.firstColumn = %d"
						"\tLoc.line = %d\tLoc.col = %d\n",
						@1.firstLine, @1.firstColumn, $1.line, $1.col);
			}
		}
	%}
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}

	vpvlp_t vvLocs;
	int nLoc = -1;
	string strBuf;
	yyparse(vvLocs, strBuf, nLoc);

	for(vpvlp_t::size_type i = 0; i < vvLocs.size(); ++i) {
		if(vvLocs[i]) {
			delete vvLocs[i];
		}
	}
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-location-template">>
/*
	sample program: location counter
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
*/
fname	"<"[^\<\>\n\*\/\\\?]+">"
locn	[[:digit:]]{3}

%yywrap%{ return false; %}

%union%{
	struct {
		int line;
		int col;
	} locVal;
	int nVal;
%}

%token TABGET TABSET FOPENED FCLOSED
%token<locVal> LOCN

%%

"tab?"			fprintf(stdout, "tabsize = %d\n", yyget_tabsize());
			return TABGET;

"tab="[[:digit:]]	int n = (int)(yytext[4] - '0');
			yyset_tabsize(n);
			fprintf(stdout, "tabsize is %d now\n", yyget_tabsize());
			return TABSET;

{fname}			yytext[yyleng - 1] = '\0';
			YYPBUFFER pbuf = yy_new_filebuf(&yytext[1]);
			if(! pbuf) {
				fprintf(stderr, "Error: failed to open file `%s`\n", &yytext[1]);
				return -1;
			}
			else {
				fprintf(stdout, "file `%s` is open.\n", &yytext[1]);
			}
			yy_switch_buffer(pbuf);
			return FOPENED;

{locn}			yylval.locVal.line = (int)(yytext[0] - '0');
			yylval.locVal.col = (int)(yytext[1] - '0') * 10 + (int)(yytext[2] - '0');
			return LOCN;

\n			return '\n';

.

<<EOF>>		yy_delete_buffer();
			fprintf(stdout, "file closed.\n");
			return FCLOSED;

%%

Files:	Files File FCLOSED
	| File FCLOSED
	;

File:	File Line
	| Line
	;

Line:	FOPENED
	| TabLine '\n'
	;
TabLine: TabLine TLItem
	| TLItem
	;

TLItem: TABGET
	| TABSET
	| LOCN	%{
		if(@1.firstLine != $1.line || @1.firstColumn != $1.col) {
			fprintf(stderr, "Error: failed to verify location information. `@1.firstLine = %d\t`@1.firstColumn = %d"
					"\tLoc.line = %d\tLoc.col = %d\n",
					@1.firstLine, @1.firstColumn, $1.line, $1.col);
		}
	%}
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-tinyfp-template">>
/*
	sample program: analyse tiny functional programming language
	feature to test:	YYSTART, yy_push_state, yy_pop_state, yy_top_state
		yy_set_bol
		yy_current_buffer, yy_has_buffer, yy_push_buffer, yy_pop_buffer,
		yy_new_filebuf, yy_new_cstrbuf, yy_new_strbuf,
		yy_delete_buffer, yy_switch_buffer, yyrestart,
		yyinput, yyunput,

*/

%{

#include <string>
using std::string;
#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <vector>
using std::vector;
#include <stack>
using std::stack;

#include <cassert>

//// to create name of constant
//#define CNBASE	"(C"
// to create name of unnamed function
#define FNBASE	"(F"

enum datatype_t {

	DT_UNK,
	DT_VOID,
	DT_BOOL,
	DT_INT,
	DT_REAL,
	DT_CHAR,
	DT_STR,
	DT_LIST,
	DT_FUNC,
	
};

class environ_t;
struct glist_t;

struct symbol_t {

	// constant, built-in operator: read-only
	// others: read/write
	bool writable;

	// symbol value type
	datatype_t vtype;

	// symbol name
	// constant has no name, so @strname is NULL
	string *strname;
	
	// value
	union {
		// vtype = DT_BOOL
		bool bval;
		// vtype = DT_CHAR
		char cval;
		// vtype = DT_INT
		int nval;
		// vtype = DT_REAL
		double dval;
		// vtype = DT_STR
		string *strval;
		// vtype = DT_LIST
		glist_t *lstval;

		// vtype = DT_FUNC
		struct {
			// number of formal-params
			int fpcnt: 16;
			// indicate if there are optional params
			int more: 16;
			// return-value type
			datatype_t rtype;
			// symbol's environment
			environ_t *table;
		};
	};
};

enum gltype_t {
	GLT_SYMB,
	GLT_LIST
};

struct glist_t {
	gltype_t vtype;
	union {
		struct {
			glist_t *head;
			glist_t *tail;
		};
		symbol_t *symb;
	};
};

typedef pair<string, symbol_t*> s2sym_pair_t;
typedef map<string, symbol_t*> s2sym_map_t;
typedef s2sym_map_t::iterator s2sym_it_t;
typedef s2sym_map_t::const_iterator s2sym_cit_t;

// return-value's type for insertion of s2sym_map_t's object
typedef pair<s2sym_it_t, bool> s2sym_insert_t;

typedef vector<symbol_t*> vsymbol_t;

static string* alloc_string(void);
static glist_t* alloc_list(void);
static symbol_t* alloc_symbol(void);
static string* get_ufname(void);

class environ_t {
public:
	environ_t(environ_t *prnt)
	: parent(prnt) {
	}

	inline symbol_t* snew(string *pstrname, symbol_t *symb = NULL) {

		assert(pstrname);
		s2sym_insert_t sit = symmap.insert(s2sym_pair_t(*pstrname, symb));
		if(sit.second) {

			if( ! symb) {
				sit.first->second = alloc_symbol();
				sit.first->second->strname = pstrname;
			}
		}
		else {
			if(symb) {
				sit.first->second = symb;
			}
		}
		return sit.first->second;
	}
	inline symbol_t* snew(const string &strname, symbol_t *symb = NULL) {

		s2sym_insert_t sit = symmap.insert(s2sym_pair_t(strname, symb));
		if(sit.second) {
			if( ! symb) {
				sit.first->second = alloc_symbol();
			}
		}
		else {
			if(symb) {
				sit.first->second = symb;
			}
		}
		return sit.first->second;
	}

	symbol_t* sfind(string *pstrname) {

		environ_t *penv = this;
		while(penv) {
			s2sym_cit_t cit = penv->symmap.find(*pstrname);
			if(cit != penv->symmap.end()) {
				return cit->second;
			}
			penv = penv->parent;
		}
		return NULL;
	}
	symbol_t* sfind(const string &strname) {

		environ_t *penv = this;
		while(penv) {
			s2sym_cit_t cit = penv->symmap.find(strname);
			if(cit != penv->symmap.end()) {
				return cit->second;
			}
			penv = penv->parent;
		}
		return NULL;
	}

	inline void update(string *pstrname, symbol_t *nsymb) {
		assert(pstrname);
		symmap.erase(*pstrname);
		s2sym_insert_t sit = symmap.insert(s2sym_pair_t(*pstrname, nsymb));
	}

private:
	s2sym_map_t symmap;
	environ_t* parent;
};

typedef stack<environ_t*> env_stack_t;

static symbol_t * snew_unk(void);
static symbol_t * snew_const (void);
static symbol_t * snew_const(bool b, bool rw = false);
static symbol_t * snew_const(char c, bool rw = false);
static symbol_t * snew_const(int n, bool rw = false);
static symbol_t * snew_const(double d, bool rw = false);
static symbol_t * snew_const(string *str, bool rw = false);
static symbol_t * snew_const(glist_t *glst, bool rw = false);
static symbol_t * snew_func(string *sname, int fps, int mr, datatype_t rt, bool rw = false);

static char *s_temp_buffer = NULL;

%}

%lexvar-decl%{
	int c, d;
	char *endptr;
	string *quotedstr;
%}

%yywrap%{
	return false;
%}

%x	QT_SC
%x	STR1_SC
%x	STR2_SC

oct	\\[0-3][0-7][0-7]
hex	\\x[[:xdigit:]]
esc	\\[0abfnrtv\?\"\'\`]
dqcc	({oct}|{hex}|{esc}|(\r?\n)|[^\"])
rqcc	({oct}|{hex}|{esc}|(\r?\n)|[^\`])
idc	[^ \t\0\r\n\(\)\;\"\'\`\|\[\]\{\}]
sid	{idc}+


%formal-param%{environ_t &topenv, env_stack_t &stenv%}
%actual-param%{topenv, stenv%}

%union%{
	bool bVal;
	char cVal;
	int nVal;
	double dVal;
	string *strVal;
	symbol_t *symbVal;
	glist_t *listVal;
	vsymbol_t *vsymVal;
%}

%parsevar-decl%{
	int i;
%}

%token LIF LELSE LCASE LCOND LDEFINE LLET LLAMBDA
%token LQUOTE LSET

%token<strVal> SID LSTR
%token<cVal> LCHAR
%token<bVal> LBOOL
%token<nVal> LINT
%token<dVal> LREAL
%token<symbVal> LOPTR

%type<symbVal> Const
%type<listVal> List ListItems ListItem
%type<symbVal> FName BForm DForm ExeExpr Expr
%type<symbVal> NForm SForm QuoteExpr SetExpr UNDefExpr
%type<symbVal> IfExpr CaseExpr CaseItems ElseExpr CondExpr CondItems
%type<symbVal> DefineExpr DefinSign LetExpr LambdaExpr

%type<vsymVal> Exprs0 Exprs1
%type<vsymVal> LetParams SIDList
%%

<INITIAL,QT_SC>";"		{
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);
	}
<INITIAL,QT_SC>"#|"		{
		c = yyinput();
		while(c != END_OF_FILE) {
			if(c == '|') {
				c = yyinput();
				if(c == '#') {
					break;
				}
			}
			if(c != '|') {
				c = yyinput();
			}
		}	
	}

<INITIAL,QT_SC>[\(\)]		return yytext[0];

[\+\-\*\/]		{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* arithmetic operators */
		return LOPTR;
	}

[\>\<\=]	|
">="		|
"<="		|
"<>"			{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* relational operators */
		return LOPTR;
	}

"and"		|
"or"		|
"not"			{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* logical operators */
		return LOPTR;
	}

"car"		|
"cdr"		|
"head"		|
"tail"		|
"cons"		|
"list"		|
"null?"		|
"length"	|
"number?"	|
"integer?"	|
"real?"		|
"make-string"	|
"string?"		{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* top-level built-in function object */
		return LOPTR;
	}

"if"		return LIF;
"cond"		return LCOND;
"case"		return LCASE;
"else"		return LELSE;
"let"		return LLET;
"lambda"	return LLAMBDA;
"define"	return LDEFINE;
"quote"			{
		yy_push_state(QT_SC);
		return LQUOTE;
	}
"set!"		return LSET;
"eval"[ \t]+{sid}	{

		c = 4;
		while(yytext[++c] == ' ' || yytext[c] == '\t');
		symbol_t *symb = stenv.top()->sfind(&yytext[c]);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else if(symb->vtype != DT_STR) {
			fprintf(stderr, "Error: at %d:%d, `%s` is not a macro\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else {
			if(s_temp_buffer) {
				delete[] s_temp_buffer;
			}
			d = symb->strval->size();
			s_temp_buffer = new char[d + 2];
			strncpy(s_temp_buffer, symb->strval->c_str(), d);
			s_temp_buffer[d] = '\0';
			s_temp_buffer[d + 1] = '\0';
			fprintf(stderr, "expand macro `%s\', its content is `%s\'\n", &yytext[c], s_temp_buffer);
			YYPBUFFER pbuf = yy_new_cstrbuf(s_temp_buffer, d + 1);
			if( ! pbuf) {
				fprintf(stderr, "Error: at %d:%d, failed to create constant string buffer for macro `%s`\n",
					yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
				YYABORT();
			}
			else {
				yy_switch_buffer(pbuf);
			}
		}
	}

"(load"[ \t]+{sid}")"	{

		yytext[yyleng - 1] = '\0';
		c = 5;
		while(yytext[++c] == ' ' || yytext[c] == '\t');
		symbol_t *symb = stenv.top()->sfind(&yytext[c]);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else if(symb->vtype != DT_STR) {
			fprintf(stderr, "Error: at %d:%d, `%s` is not a macro\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else {
			fprintf(stderr, "open file `%s\', its content is `%s\'\n", &yytext[c], symb->strval->c_str());
			YYPBUFFER pbuf = yy_new_filebuf(symb->strval->c_str());
			if( ! pbuf) {
				fprintf(stderr, "Error: at %d:%d, failed to create buffer for file `%s`\n",
					yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
				YYABORT();
			}
			else {
				yy_switch_buffer(pbuf);
			}
		}
	}

"ceval"[ \t]+{sid}	{

		c = 4;
		while(yytext[++c] == ' ' || yytext[c] == '\t');
		symbol_t *symb = stenv.top()->sfind(&yytext[c]);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else if(symb->vtype != DT_STR) {
			fprintf(stderr, "Error: at %d:%d, `%s` is not a macro\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else {
			if(s_temp_buffer) {
				delete[] s_temp_buffer;
			}
			d = symb->strval->size();
			s_temp_buffer = new char[d + 2];
			strncpy(s_temp_buffer, symb->strval->c_str(), d);
			s_temp_buffer[d] = '\0';
			s_temp_buffer[d + 1] = '\0';
			fprintf(stderr, "expand macro `%s\', its content is `%s\'\n", &yytext[c], s_temp_buffer);
			YYPBUFFER pbuf = yy_new_strbuf(s_temp_buffer, d + 1);
			if( ! pbuf) {
				fprintf(stderr, "Error: at %d:%d, failed to create string buffer for macro `%s`\n",
					yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
				YYABORT();
			}
			else {
				yy_switch_buffer(pbuf);
			}
		}
	}

"#t"	{
		yylval.bVal = true;
		return LBOOL;
	}
"#f"	{
		yylval.bVal = false;
		return LBOOL;
	}


"#b"[01]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal <<= 1;
			yylval.nVal += (int)(yytext[c] - '0');
		}
		return LINT;
	}
"#o"[0-7]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal <<= 3;
			yylval.nVal += (int)(yytext[c] - '0');
		}
		return LINT;
	}
"#d"?[0-9]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal = (yylval.nVal << 1) + (yylval.nVal << 3);
			yylval.nVal += (int)(yytext[c] - '0');
		}
		return LINT;
	}
			
"#x"[0-9a-f]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal <<= 4;
			d = (int)(yytext[c] - '0');
			if(d < 10) {
				yylval.nVal += d;
			}
			else if(d < 23) {
				yylval.nVal += d - 7;
			}
			else {
				yylval.nVal += d - 39;
			}
		}
		return LINT;		
	}
[0-9]+\.[0-9]+[sfdl]?	{

		yytext[yyleng - 1] = '\0';
		yylval.dVal = strtod(yytext, &endptr);

		return LREAL;
	}

"#\\"[[:graph:]]	{
		yylval.cVal = yytext[2];
		return LCHAR;
	}

"#\\U\+"[0-9a-f]{2}	{
		yylval.cVal = 0;
		for(c = 4; c < yyleng; ++c) {
			yylval.cVal <<= 4;
			d = (int)(yytext[c] - '0');
			if(d < 10) {
				yylval.cVal += (char)d;
			}
			else if(d < 23) {
				yylval.cVal += (char)(d - 7);
			}
			else {
				yylval.cVal += (char)(d - 39);
			}
		}
		return LCHAR;
	}

<INITIAL,QT_SC>{sid}		{
		yylval.strVal = alloc_string();
		*yylval.strVal += yytext;
		if(YYSTART() == INITIAL) {
			return SID;
		}
		else {
			return LSTR;
		}
	}

<INITIAL,QT_SC>\"		{
		quotedstr = alloc_string();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yy_push_state(STR1_SC);
	}
<STR1_SC>{dqcc}	{

		if(yytext[0] == '\\') {
			if(yyleng == 4) {
				switch(yytext[1]) {
				case 'x':
				case 'X':
				{
					d = (int)(yytext[2] - '0');
					if(d < 10) {
						c = d;
					}
					else if(d < 23) {
						c = d - 7;
					}
					else {
						c = d - 39;
					}

					d = (int)(yytext[3] - '0');
					c <<= 4;

					if(d < 10) {
						c += d;
					}
					else if(d < 23) {
						c += d - 7;
					}
					else {
						c += d - 39;
					}
								
				}
					break;
				default:
				{
					c = (int)(yytext[1] - '0');
					c <<= 3;
					c += (int)(yytext[2] - '0');
					c <<= 3;
					c += (int)(yytext[3] - '0');
				}
					break;
				}
				*quotedstr += (char)c;
			}
			else { // yyleng == 2
				*quotedstr += yytext[1];
			}
		}
		else {
			*quotedstr += yytext[0];
		}
	}
<STR1_SC>\r?\n	{
		*quotedstr += yytext;
	}
<STR1_SC>\"	{
		yy_pop_state();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yylval.strVal = quotedstr;

		return LSTR;
	}
<INITIAL,QT_SC>\`		{
		quotedstr = alloc_string();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yy_push_state(STR2_SC);
	}
<STR2_SC>{rqcc}	{

		if(yytext[0] == '\\') {
			if(yyleng == 4) {
				switch(yytext[1]) {
				case 'x':
				case 'X':
				{
					d = (int)(yytext[2] - '0');
					if(d < 10) {
						c = d;
					}
					else if(d < 23) {
						c = d - 7;
					}
					else {
						c = d - 39;
					}

					d = (int)(yytext[3] - '0');
					c <<= 4;

					if(d < 10) {
						c += d;
					}
					else if(d < 23) {
						c += d - 7;
					}
					else {
						c += d - 39;
					}
								
				}
					break;
				default:
				{
					c = (int)(yytext[1] - '0');
					c <<= 3;
					c += (int)(yytext[2] - '0');
					c <<= 3;
					c += (int)(yytext[3] - '0');
				}
					break;
				}
				*quotedstr += (char)c;
			}
			else { // yyleng == 2
				*quotedstr += yytext[1];
			}
		}
		else {
			*quotedstr += yytext[0];
		}
	}
<STR2_SC>\r?\n	{
		*quotedstr += yytext;
	}
<STR2_SC>\`	{
		yy_pop_state();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yylval.strVal = quotedstr;
		return LSTR;
	}
<*><<EOF>>	yy_delete_buffer();
\'			{
		yy_push_state(QT_SC);
		return yytext[0];
	}
<*><<EOF>>	yy_delete_buffer();

<*>[ \t\n\r]+
<*>.

%%

Program: Exprs0		%{
		fprintf(stderr, "parsing scheme program succeeded\n");
		YYACCEPT();
	%}
	;
Exprs0: Exprs0 Expr	%{
		$$ = $1;
		$$->push_back($2);
	%}
	|	%{
		$$ = new vsymbol_t;
	%}
	;
Exprs1:	Exprs1 Expr	%{
		$$ = $1;
		$$->push_back($2);
	%}
	| Expr		%{
		$$ = new vsymbol_t;
		$$->push_back($1);
	%}
	;
Expr:	NForm		%{
		$$ = $1;
	%}
	| SForm		%{
		$$ = $1;
	%}
	;
NForm:	Const		%{
		$$ = $1;
	%}
	| SID		%{
		$$ = stenv.top()->sfind(*$1);
		if( !$$) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				@1.firstLine, @1.firstColumn, $1->c_str());
			YYABORT();
		}
	%}
	| LOPTR		%{
		$$ = $1;
	%}
	| List		%{
		$$ = snew_const($1);
	%}
	| QuoteExpr	%{
		$$ = $1;
	%}
	| ExeExpr	%{
		$$ = $1;
	%}
	;
ExeExpr: '(' FName Exprs0 ')'	%{

		if($2->vtype == DT_UNK) {
			if($3->size() > 0) {
				$$ = (*$3)[$3->size() - 1];
			}
			else {
				$$ = snew_const();
			}
		}
		else if($2->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@2.firstLine, @2.firstColumn);
			YYABORT();
		}
		else {
			if($2->more) {
				if($2->fpcnt > (int)$3->size()) {
					fprintf(stderr, "Error: at %d:%d, function signature unmatched,\n"
						"expected number of parameters: %d, given: %d\n",
						@2.firstLine, @2.firstColumn, $2->fpcnt, (int)$3->size());
					YYABORT();
				}
			}
			else if($2->fpcnt != (int)$3->size()) {
				fprintf(stderr, "Error: at %d:%d, function signature unmatched,\n"
					"expected number of parameters: %d, given: %d\n",
					@2.firstLine, @2.firstColumn, $2->fpcnt, (int)$3->size());
				YYABORT();
			}
			else {
				//for(i = 0; i < $2->fpcnt; ++i) {
				//	
				//}

				if($3->size() > 0) {
					$$ = (*$3)[$3->size() - 1];
				}
				else {
					$$ = snew_const();
				}
			}
		}
		delete $3;
	%}
	;

SForm: BForm		%{
		$$ = $1;
	%}
	| DForm		%{
		$$ = $1;
	%}
	| SetExpr	%{
		$$ = $1;
	%}
	;
BForm: IfExpr		%{
		$$ = $1;
	%}
	| CaseExpr	%{
		$$ = $1;
	%}
	| CondExpr	%{
		$$ = $1;
	%}
	;
DForm: DefineExpr	%{
		$$ = $1;
	%}
	| UNDefExpr	%{
		$$ = $1;
	%}
	;
UNDefExpr: LetExpr	%{
		$$ = $1;
	%}
	| LambdaExpr	%{
		$$ = $1;
	%}
	;

IfExpr: '(' LIF ExeExpr Expr ')'	%{
		$$ = $4;
	%}
	| '(' LIF ExeExpr Expr Expr ')'	%{
		$$ = $5;
	%}
	;
CaseExpr: '(' LCASE ExeExpr CaseItems ')'	%{
		$$ = $4;
	%}
	| '(' LCASE ExeExpr CaseItems ElseExpr ')'	%{
		$$ = $5;
	%}
	;
CaseItems: CaseItems '(' List Exprs1 ')'	%{
		$$ = (*$4)[$4->size() - 1];
		delete $4;
	%}
	| '(' List Exprs1 ')'	%{
		$$ = (*$3)[$3->size() - 1];
		delete $3;
	%}
	;
ElseExpr: '(' LELSE Exprs1 ')'	%{
		$$ = (*$3)[$3->size() - 1];
		delete $3;
	%}
	;
CondExpr: '(' LCOND ExeExpr CondItems ')'	%{
		$$ = $4;
	%}
	| '(' LCOND ExeExpr CondItems ElseExpr ')'	%{
		$$ = $5;
	%}
	;
CondItems: CondItems '(' ExeExpr Exprs1 ')'	%{
		$$ = (*$4)[$4->size() - 1];
		delete $4;
	%}
	| '(' ExeExpr Exprs1 ')'	%{
		$$ = (*$3)[$3->size() - 1];
		delete $3;
	%}
	;

DefineExpr: '(' LDEFINE SID NForm ')'	%{
		$$ = $4;
		stenv.top()->snew($3, $4);
	%}
	| '(' LDEFINE SID UNDefExpr ')'	%{
		$$ = $4;
		stenv.top()->snew($3, $4);
	%}
	| '(' LDEFINE DefinSign Exprs1 ')'	%{

		$$ = $3;
		$$->rtype = (*$4)[$4->size() - 1]->vtype;
		stenv.pop();
	%}
	;

DefinSign: '(' SID %{

		symbol_t *symb = stenv.top()->snew($2);
		symb->writable = false;
		symb->vtype = DT_FUNC;
		symb->table = new environ_t(stenv.top());
		stenv.push(symb->table);
		$<symbVal>$ = symb;
	%}
	SIDList ')' %{
		$<symbVal>3->fpcnt = (int)$4->size();
		$$ = $<symbVal>3;
	%}
	;

LetExpr: '(' LLET %{
		string *str = get_ufname();
		symbol_t *symb = stenv.top()->snew(str);
		symb->writable = false;
		symb->vtype = DT_FUNC;
		symb->table = new environ_t(stenv.top());
		stenv.push(symb->table);
		$<symbVal>$ = symb;
	%}
	'(' LetParams %{
		$<symbVal>3->fpcnt = (int)$5->size();
	%}
	')' Exprs1 ')' %{
		$<symbVal>3->rtype = (*$8)[$8->size() - 1]->vtype;
		$$ = (*$8)[$8->size() - 1];
		delete $8;
		stenv.pop();
	%}
	;
LetParams: LetParams '(' SID Expr ')'	%{

		$4->writable = true;
		symbol_t *symb = stenv.top()->snew($3, $4);
		$$->push_back(symb);
	%}
	|		%{
		$$ = new vsymbol_t;
	%}
	;
LambdaExpr: '(' LLAMBDA %{

		string *str = get_ufname();
		symbol_t *symb = stenv.top()->snew(str);
		symb->writable = false;
		symb->vtype = DT_FUNC;
		symb->table = new environ_t(stenv.top());
		stenv.push(symb->table);
		$<symbVal>$ = symb;

	%} '(' SIDList %{
		$<symbVal>3->fpcnt = (int)$5->size();
		$<symbVal>3->more = 0;
	%}
	')' Exprs1 ')' %{
		$<symbVal>3->rtype = (*$8)[$8->size() - 1]->vtype;
		$$ = $<symbVal>3;
		delete $8;

		stenv.pop();
	%}
	;
SIDList: SIDList SID	%{

		symbol_t *symb = stenv.top()->snew($2);
		symb->vtype = DT_UNK;
		symb->writable = true;
		$$ = $1;
		$$->push_back(symb);
	%}
	|		%{
		$$ = new vsymbol_t;
	%}
	;

SetExpr: '(' LSET SID Expr ')'		%{
		symbol_t* symb = stenv.top()->sfind($3);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				@3.firstLine, @3.firstColumn, $3->c_str());
			YYABORT();
		}
		else {
			stenv.top()->update($3, $4);
			$$ = snew_const();
		}
	%}
	;

QuoteExpr: '(' LQUOTE LSTR	%{
		yy_pop_state();
	%}
	')'	%{
		$$ = snew_const($3);
	%}
	| '(' LQUOTE List	%{
		yy_pop_state();
	%}
	')'	%{
		$$ = snew_const($3);
	%}
	| '\'' LSTR		%{
		yy_pop_state();
		$$ = snew_const($2);
	%}
	| '\'' List		%{
		yy_pop_state();
		$$ = snew_const($2);
	%}
	;

List: '(' ListItems ')'	%{
		$$ = $2;
	%}
	| '(' ')'	%{

		$$ = alloc_list();
		$$->vtype = GLT_LIST;
		$$->head = NULL;
		$$->tail = NULL;
	%}
	;
ListItems: ListItem ListItems	%{

		$$ = alloc_list();
		$$->vtype = GLT_LIST;
		$$->head = $1;
		$$->tail = $2;
	%}
	| ListItem	%{

		$$ = alloc_list();
		$$->head = $1;
		$$->tail = NULL;
	%}
	;

ListItem: LSTR		%{

		$$ = alloc_list();
		$$->vtype = GLT_SYMB;
		$$->symb = snew_const($1);
	%}
	| List		%{
		$$ = $1;
	%}
	;

Const: LINT	%{
		$$ = snew_const($1);
	%}
	| LREAL	%{
		$$ = snew_const($1);
	%}
	| LCHAR	%{
		$$ = snew_const($1);
	%}
	| LSTR	%{
		$$ = snew_const($1);
	%}
	| LBOOL	%{
		$$ = snew_const($1);
	%}
	;

FName: SID	%{
		$$ = stenv.top()->sfind(*$1);
		if( !$$) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				@1.firstLine, @1.firstColumn, $1->c_str());
			YYABORT();
		}
	%}
	| LOPTR	%{
		$$ = $1;
	%}
	| BForm	%{
		if($1->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@1.firstLine, @1.firstColumn);
			YYABORT();
		}
		$$ = $1;
	%}
	| DForm %{
		if($1->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@1.firstLine, @1.firstColumn);
			YYABORT();
		}
		$$ = $1;		
	%}
	| ExeExpr	%{
		if($1->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@1.firstLine, @1.firstColumn);
			YYABORT();
		}
		$$ = $1;
	%}
	;
%%

using namespace yynsx;

#define INIT_POOL_SIZE	128
#define INCR_POOL_SIZE	64
#define REALLOC(VARI, TYPE, SIZE, NEWSIZE) {\
	TYPE* p = new TYPE[(NEWSIZE)];\
	if( !p ) {\
		exit(-1);\
	}\
	memcpy(p, VARI, sizeof(TYPE) * SIZE);\
	delete[] VARI;\
	VARI = p;\
	SIZE = NEWSIZE;\
}


template<class T, int init_size = INIT_POOL_SIZE,
	int incr_size = INCR_POOL_SIZE>
class allocator_t {
public:
	allocator_t(void)
	: base(NULL)
	, size(init_size)
	, top(0) {

		base = new T*[size];
	}
	~allocator_t(void) {
		for(int i = 0; i < top; ++i) {
			delete base[i];
		}
		delete[] base;
	}

	T* alloc(void) {
		if(size == top) {
			REALLOC(base, T*, size, size + incr_size);
		}
		base[top] = new T;
		return base[top++];
	}
private:
	T** base;
	int size, top;
};

string* alloc_string(void) {
	static allocator_t<string> stralloc;
	return stralloc.alloc();
}

glist_t* alloc_list(void) {
	static allocator_t<glist_t> glalloc;
	return glalloc.alloc();
}
symbol_t* alloc_symbol(void) {
	static allocator_t<symbol_t> symalloc;
	return symalloc.alloc();
}
string* get_ufname(void) {

	static int lamidx = 0;
	++lamidx;

	string* pstr = alloc_string();
	*pstr = string(FNBASE);

	// this name is illegal for any named symbols,
	// therefore, name conflict is not a problem
	char rem;

	int qot = lamidx;
	do {
		rem = (char)(qot % 10) + '0';
		*pstr += rem;

		qot = qot / 10;		
	}while(qot > 0);

	return pstr;
}

symbol_t * snew_unk(void) {
	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_UNK;
	symb->strname = NULL;
	return symb;
}

symbol_t * snew_const (void) {
	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_VOID;
	symb->writable = false;
	return symb;
}

symbol_t * snew_const(bool b, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_BOOL;
	symb->strname = NULL;
	symb->writable = rw;
	symb->bval = b;
	return symb;
}
symbol_t * snew_const(char c, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_CHAR;
	symb->strname = NULL;
	symb->cval = c;
	symb->writable = rw;
	return symb;
}
symbol_t * snew_const(int n, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_INT;
	symb->strname = NULL;
	symb->nval = n;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_const(double d, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_REAL;
	symb->strname = NULL;
	symb->dval = d;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_const(string *str, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_STR;
	symb->strname = NULL;
	symb->strval = str;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_const(glist_t *glst, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_LIST;
	symb->strname = NULL;
	symb->lstval = glst;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_func(string *sname, int fps, int mr, datatype_t rt, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_FUNC;
	symb->strname = sname;
	symb->fpcnt = fps;
	symb->more = mr;
	symb->rtype = rt;
	symb->writable = rw;

	return symb;
}


void init_top_env(environ_t &env) {
	
	symbol_t *symb;
	
	symb = env.snew("+");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("-");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;
	
	symb = env.snew("*");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("/");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew(">");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("<");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew(">=");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("<=");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("<>");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("=");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;


	symb = env.snew("and");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("or");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("not");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;


	symb = env.snew("car");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_UNK;

	symb = env.snew("cdr");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_LIST;

	symb = env.snew("head");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_UNK;

	symb = env.snew("tail");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_UNK;

	symb = env.snew("cons");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_LIST;

	symb = env.snew("list");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_LIST;

	symb = env.snew("null?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("null?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_INT;

	symb = env.snew("number?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("number?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("integer?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("real?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("string?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("make-string");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_STR;
}

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}

	environ_t topenv(NULL);
	env_stack_t stenv;

	init_top_env(topenv);
	stenv.push(&topenv);

	int nret = yyparse(topenv, stenv);
	if(nret != 0) {
		fprintf(stderr, "Error: parsing program failed\n");
	}
	if(s_temp_buffer) {
		delete[] s_temp_buffer;
	}
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-yyerror-template">>
/*
 *	sample program: test yyerror
 */

num	[[:digit:]]+
cid	[A-Za-z_][A-Za-z_0-9]*

%token NUM CID

%%

{num}	return NUM;
{cid}	return CID;

[ \t]
\r?\n	return '\n';
.

%%

Lines: Lines Line
	|
	;
Line: Numbers '\n'
	;
Numbers: Numbers Unit
	|
	;
Unit: NUM
	| error '\n' %{
		yyerrok();
	%}
	;
%%
using namespace yynsx;

void myerror(const char* msg) {
	
	fprintf(stderr, "Redirect to my error-handler ---- %s\n", msg);
}

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyseterror(myerror);

	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "esc-char-inaction-template">>
/*
	feature to test: using escape char, transform meta-symbols such as
		 $$, $n, @$, @n, %}, $<..>$, $<...>n
		to literal text in %{ %} embraced actions
*/

%header%{
#include <iostream>
using std::cerr;
using std::endl;
/*in declaration header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
%}

%{

/*in definition header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
%}

%lex-init%{
	cerr << "in lex-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%pre-match%{
	cerr <<  "in pre-match: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%lvar-decl%{
	cerr << "in lexvar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}
%lvar-init%{
	cerr << "in lexvar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%yywrap%{
	cerr << "in yywrap: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%destructor%{
	cerr << "in destruct<>: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%} <>

%parse-init%{
	cerr << "in parse-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%parse-exit%{
	cerr << "in parse-exit: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%union%{
	/*in SVT defintion: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
	int nVal;
	char *pchVal;
%}

%location%{
	/*in location type definiton: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
%}

%pvar-decl%{
	cerr << "in parsevar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}
%pvar-init%{
	cerr << "in parsevar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%formal-param%{int &n/*in formal-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/%}
%actual-param%{n/*in actual-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/%}

%token<pchVal> NUM
%token<pchVal> CID

%type<nVal> Symbols

%%

[[:digit:]]+	{
		yylval.pchVal = new char[yyleng + 1];
		strncpy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] = '\0';

		return NUM;
	}
[[:cidf:]][[:cids:]]*	{
		yylval.pchVal = new char[yyleng + 1];
		strncpy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] = '\0';

		return CID;
	}
.|\n

%%

Start: Symbols
	;
Symbols: Symbols CID	%{
		++n;
		cerr << "`$2 is a C-style ID, its value is " << $2  << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	| Symbols NUM	%{
		++$$;
		cerr << "`$2 is a number, its value is " << $2 << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	| CID		%{
		n = 1;
		cerr << "`$1 is a C-style ID, its value is " << $1 << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	| NUM		%{
		$$ = 1;
		cerr << "`$1 is a number, its value is " << $1 << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {

<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	int ncnt = 0;
	yyparse(ncnt);
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "script-empty-sect-2">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/
%{
#include <iostream>
using std::cout;
using std::endl;

%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ cout << "\t\t" << $1 << endl; %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ = $1; %}
	| Number Digit	%{ $$ = $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ = 0; %}
	| '1'		%{ $$ = 1; %}
	| '2'		%{ $$ = 2; %}
	| '3'		%{ $$ = 3; %}
	| '4'		%{ $$ = 4; %}
	| '5'		%{ $$ = 5; %}
	| '6'		%{ $$ = 6; %}
	| '7'		%{ $$ = 7; %}
	| '8'		%{ $$ = 8; %}
	| '9'		%{ $$ = 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
%%

using namespace yynsx;

static FILE *s_pfile = NULL;
int myinput(void) {

	if( ! s_pfile) {
		return 0;
	}

	int c = fgetc(s_pfile);
	if(c == EOF && feof(s_pfile)) {
		return 0;
	}
	return c;
}

int main(int argc, char **argv) {

	<<before_myinput/>>

	yysetlex(myinput);
	yyparse();

	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}
<</templ>>

<<templ "script-only-3-sections">>

/*************************************************************************
feature to test: scannerless parser (section 2 of script is empty)
	 	 without user-code section
**************************************************************************/
%{
#include <iostream>
using std::cout;
using std::endl;

namespace yynsx {

typedef int(*yylex_t)(void);

yylex_t yysetlex(yylex_t);
int yyparse(void);

}

using namespace yynsx;

static FILE *s_pfile = NULL;

int myinput(void) {

	if( ! s_pfile) {
		return 0;
	}

	int c = fgetc(s_pfile);
	if(c == EOF && feof(s_pfile)) {
		return 0;
	}
	return c;
}

int main(int argc, char **argv) {

	<<before_myinput/>>

	yysetlex(myinput);
	yyparse();

	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}

%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ cout << "\t\t" << $1 << endl; %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ = $1; %}
	| Number Digit	%{ $$ = $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ = 0; %}
	| '1'		%{ $$ = 1; %}
	| '2'		%{ $$ = 2; %}
	| '3'		%{ $$ = 3; %}
	| '4'		%{ $$ = 4; %}
	| '5'		%{ $$ = 5; %}
	| '6'		%{ $$ = 6; %}
	| '7'		%{ $$ = 7; %}
	| '8'		%{ $$ = 8; %}
	| '9'		%{ $$ = 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
<</templ>>

<<templ "script-empty-sect-3">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

namespace yynsx {
<<filebuf_decl/>>
int yylex(void);

}

using namespace yynsx;
int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner." << endl;
		return -1;
	}
	
	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	cout << yytext;
%%

<</templ>>

<<templ "script-dprec-rrc">>
/*
testing program: extract parentheses from expression, and convert them to brackets
	the purpose of this program is to show how to resolve reduce-reduce conflicts
	by %dprec
*/

%left '(' ')'
%%

[\(\)]		return yytext[0];
\n		printf("\n");
.		printf("%c", yytext[0]);
%%

Program: PExpr %dprec 2 %{
		printf("Done!\n");
		YYACCEPT();
	%}
	;
PExpr: PExpr PExpr %dprec 3
	| '(' 
	%{ printf("["); %}
	PExpr ')' %{ printf("]"); %}
	| %dprec 1
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");	
		return -1;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<</templs>>

<<<----------top-level suite: / ---------->>>
<<suites make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone ---------->>>
<<suite "lex-alone" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/begin---------->>>
	<<suite "begin" make="subdir-makefile-template">>

<<<----case: /lex-alone/begin/case-insensitive---->>>
		<<case "case-insensitive" make="lex-only-makefile-template">>
			<<upgen_options>>-i<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: case-insensitive
*/
				<</desc>>
				<<init_code>>
	int abcs = 0;
	int XYZs = 0;
				<</init_code>>
				<<lex_section>>
abc	cout << yytext << " ---> `abc\'" << endl; ++abcs;
XYZ	cout << yytext << " ---> `XYZ\'" << endl; ++XYZs;
.|\n	/* do nothing*/
				<</lex_section>>
				<<after_init>>
	yylex();
	cout << "abc's = " << abcs << endl;
	cout << "XYZ's = " << XYZs << endl;
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
ABCD
xyz1232
abcd
XYZJFSLK
			<</textfile>>
			<<textfile "result.out">>
ABC ---> `abc'
xyz ---> `XYZ'
abc ---> `abc'
XYZ ---> `XYZ'
abc's = 2
XYZ's = 2
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/case-insensitive---->>>


<<<----case: /lex-alone/begin/debug-option---->>>
		<<case "debug-option" make="lex-only-makefile-template">>
			<<upgen_options>>-d<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%x	SC1
				<</declare_section>>
				<<lex_section>>
\{	BEGIN(SC1);
<SC1>\}	BEGIN(INITIAL);

<*>abc	++abcs;
<*>.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
acde
ABCabc
{
aabc
cccabc

			<</textfile>>
			<<textfile "result.out">>
			<</textfile>>
			<<textfile "result.err">>
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`a'}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`d'}, rule at line: 23 
.................... accept {`e'}, rule at line: 23 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`A'}, rule at line: 23 
.................... accept {`B'}, rule at line: 23 
.................... accept {`C'}, rule at line: 23 
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`{'}, rule at line: 19 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`a'}, rule at line: 23 
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept unprintable-char{10}, rule at line: 23 
.................... EOF reached
.................... EOS reached
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/debug-option---->>>


<<<----case: /lex-alone/begin/entry-param---->>>
		<<case "entry-param" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%formal-param%{int abc, char def %}
%actual-param%{abc, def %}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	int nret = yylex(0, 0);
	if(nret) {
		return nret;
	}
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/entry-param---->>>

<<<----case: /lex-alone/begin/eol-lookahead---->>>
		<<case "eol-lookahead" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/* test operator '$' */
				<</desc>>

				<<lex_section>>
.+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
		yytext[yyleng] = '\0';
		fprintf(stdout, "matched-text = \"%s\".\n", yytext);

\n		fprintf(stdout, "a newline is matched.\n");
				<</lex_section>>
				<<after_init>>
	int nret = yylex();
	if(nret) {
		return nret;
	}
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
/* test operator '$' */

%%

.+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
		yytext[yyleng] = '\0';
		fprintf(stdout, "matched-text = \"%s\".\n", yytext);

\n		fprintf(stdout, "a newline is matched.\n");

%%

/* empty */

%%

using namespace yynsx;

int main(int argc, char **argv) {

	if(argc < 2) {
		yylexfile(NULL, true);
	}
	else {
		if(yylexfile(argv[1], false)) {
			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
			return -1;
		}
	}

	return yylex();
}
			<</textfile>>
			<<textfile "result.out">>
whole-text = "/* test operator '$' */
".
lookahead-text = "
".
matched-text = "/* test operator '$' */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);".
a newline is matched.
whole-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);".
a newline is matched.
whole-text = "		yytext[yyleng] = '\0';
".
lookahead-text = "
".
matched-text = "		yytext[yyleng] = '\0';".
a newline is matched.
whole-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);".
a newline is matched.
a newline is matched.
whole-text = "\n		fprintf(stdout, "a newline is matched.\n");
".
lookahead-text = "
".
matched-text = "\n		fprintf(stdout, "a newline is matched.\n");".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "/* empty */
".
lookahead-text = "
".
matched-text = "/* empty */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "using namespace yynsx;
".
lookahead-text = "
".
matched-text = "using namespace yynsx;".
a newline is matched.
a newline is matched.
whole-text = "int main(int argc, char **argv) {
".
lookahead-text = "
".
matched-text = "int main(int argc, char **argv) {".
a newline is matched.
a newline is matched.
whole-text = "	if(argc < 2) {
".
lookahead-text = "
".
matched-text = "	if(argc < 2) {".
a newline is matched.
whole-text = "		yylexfile(NULL, true);
".
lookahead-text = "
".
matched-text = "		yylexfile(NULL, true);".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
whole-text = "	else {
".
lookahead-text = "
".
matched-text = "	else {".
a newline is matched.
whole-text = "		if(yylexfile(argv[1], false)) {
".
lookahead-text = "
".
matched-text = "		if(yylexfile(argv[1], false)) {".
a newline is matched.
whole-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
".
lookahead-text = "
".
matched-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);".
a newline is matched.
whole-text = "			return -1;
".
lookahead-text = "
".
matched-text = "			return -1;".
a newline is matched.
whole-text = "		}
".
lookahead-text = "
".
matched-text = "		}".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
a newline is matched.
whole-text = "	return yylex();
".
lookahead-text = "
".
matched-text = "	return yylex();".
a newline is matched.
whole-text = "}
".
lookahead-text = "
".
matched-text = "}".
a newline is matched.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eol-lookahead---->>>

<<<----case: /lex-alone/begin/eos-action---->>>
		<<case "eos-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined END-OF-FILE action
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%yywrap%{
	cout << "YYSTART = " << YYSTART() << endl;
	return false;
%}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
YYSTART = 0
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eos-action---->>>


<<<----case: /lex-alone/begin/lex-init-action---->>>
		<<case "lex-init-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined lex-init action, which is executed
	before pattern-matching
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%lex-init{

	cout << "Let\'s get started" << endl;
%}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
Let's get started
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/lex-init-action---->>>


<<<----case: /lex-alone/begin/prematch-action---->>>
		<<case "prematch-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined prematch action, which is executed just before
	action corresponding matched pattern
*/
				<</desc>>
				<<init_code>>
#include <cstring>

int abcs = 0;
int matches = 0;
				<</init_code>>
				<<declare_section>>
%pre-match{

	if(strcmp(yytext, "abc") == 0) {
		++matches;
	}
%}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	
	cout << "number of \"abc\" is " << abcs << endl;
	cout << "number of matches is " << matches << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
	if(abcs == matches) {
		cout << "abcs equals matches" << endl;
	}
	else {
		cout << "abcs is different from matches" << endl;
	}
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
number of matches is 4
abcs equals matches
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/prematch-action---->>>


<<<----case: /lex-alone/begin/simplest---->>>
		<<case "simplest" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test simplest case to check basic features
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/simplest---->>>


<<<----case: /lex-alone/begin/yyterminate---->>>
		<<case "yyterminate" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-interface: yyterminate
*/
				<</desc>>
				<<lex_section>>
q|Q	cout << endl << "It is time to say goodbye." << endl;	
	yyterminate();

.|\n	cout << yytext;

<<EOF>>	cout << "Something wrong happened." << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
hello, yyterminate
no more to say
q
			<</textfile>>
			<<textfile "result.out">>
hello, yyterminate
no more to say

It is time to say goodbye.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/yyterminate---->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/begin---------->>>


<<<----------sub-suite: /lex-alone/basic---------->>>
	<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/basic/action---->>>
		<<suite "action" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/action/ECHO---->>>
			<<case "ECHO" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: ECHO
*/
					<</desc>>
					<<declare_section>>
cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	cout << "Start scanning upgen script ..." << endl;
%}
					<</declare_section>>
					<<lex_section>>
int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); cout << "... keyword." << endl;

{cid}		ECHO(); cout << "... identifier." << endl;
{digit}		ECHO(); cout << "... number" << endl;
{punct}
.|\n
					<</lex_section>>
					<<after_init>>
		yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test built-in routines: ECHO
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	cout << "Start scanning upgen script ..." << endl;
%}

%%

int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); cout << "... keyword." << endl;

{cid}		ECHO(); cout << "... identifier." << endl;
{digit}		ECHO(); cout << "... number" << endl;
{punct}
.|\n

%%
				<</textfile>>
				<<textfile "result.out">>
Start scanning upgen script ...
test... identifier.
built... identifier.
in... identifier.
routines... identifier.
ECHO... identifier.
#include... keyword.
iostream... identifier.
using... keyword.
std... identifier.
cout... identifier.
using... keyword.
std... identifier.
endl... identifier.
cid... identifier.
cidf... identifier.
cids... identifier.
digit... identifier.
digit... identifier.
punct... identifier.
punct... identifier.
lex... identifier.
init... identifier.
cout... identifier.
Start... identifier.
scanning... identifier.
upgen... identifier.
script... identifier.
endl... identifier.
int... keyword.
void... keyword.
if... keyword.
return... keyword.
NULL... keyword.
using... keyword.
#include... keyword.
ECHO... identifier.
cout... identifier.
keyword... identifier.
endl... identifier.
cid... identifier.
ECHO... identifier.
cout... identifier.
identifier... identifier.
endl... identifier.
digit... identifier.
ECHO... identifier.
cout... identifier.
number... identifier.
endl... identifier.
punct... identifier.
n... identifier.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/ECHO---->>>


<<<----------case: /lex-alone/basic/action/yy_buffer---->>>
			<<case "yy_buffer" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yy_new_filebuf(file-name): buffer-object
	yy_push_buffer(buffer-object)
	yy_pop_buffer(): buffer-object
	yy_delete_buffer()
	yy_switch_buffer(buffer-object)
	yy_has_buffer(): false/true
	yy_current_buffer(): buffer-object
	yy_set_bol(false/true)
	yyinput(): char
*/
					<</desc>>
					<<init_code>>
#include <cstring>

#define MAX_BUF_NUM	10
char *fnlist[MAX_BUF_NUM];
int cur_size = 0;
					<</init_code>>
					<<declare_section>>
fn	[^\\\/\*\r\n\t ]+
					<</declare_section>>
					<<lex_section>>
#include[ \t]*\<{fn}\>	{

		int c = END_OF_FILE;
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);

		if(cur_size <  MAX_BUF_NUM) {

			int beg = 8;
			while(yytext[beg] != '<') ++beg;
			++beg;
			char *pch = new char[yyleng - beg];
			strncpy(pch, &yytext[beg], yyleng - beg - 1);
			beg = yyleng - beg - 1;
			pch[beg] = '\0';

			YYPBUFFER pnewbuf = yy_new_filebuf(pch);
			if(pnewbuf) {
				YYPBUFFER poldbuf = yy_current_buffer();
				yy_push_buffer(pnewbuf);
				yy_push_buffer(poldbuf);
				fnlist[cur_size++] = pch;
			}
			else {
				cout << "Warning: failed to open file `" << pch << "\'" << endl;
				delete[] pch;
			}		
		}
	}

#open[ \t]*\<{fn}\>	{

		int c = END_OF_FILE;
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		if(cur_size <  MAX_BUF_NUM) {

			int beg = 5;
			while(yytext[beg] != '<') ++beg;
			++beg;
			char *pch = new char[yyleng - beg];
			strncpy(pch, &yytext[beg], yyleng - beg - 1);
			beg = yyleng - beg - 1;
			pch[beg] = '\0';
	
			YYPBUFFER pnewbuf = yy_new_filebuf(pch);
			if(pnewbuf) {
				yy_push_buffer(pnewbuf);
				fnlist[cur_size++] = pch;
				yy_set_bol(true);
			}
			else {
				cout << "Warning: failed to open file `" << pch << "\'" << endl;
				delete[] pch;
			}
				
		}
    }

#overwrite[ \t]*\<{fn}\>	{

		int c = END_OF_FILE;
		while((c = yyinput()) != END_OF_FILE && c != '\n');

		if(cur_size <  MAX_BUF_NUM) {

			int beg = 5;
			while(yytext[beg] != '<') ++beg;
			++beg;
			char *pch = new char[yyleng - beg];
			strncpy(pch, &yytext[beg], yyleng - beg - 1);
			beg = yyleng - beg - 1;
			pch[beg] = '\0';
	
			yy_delete_buffer();

			YYPBUFFER pnewbuf = yy_new_filebuf(pch);
			if(pnewbuf) {

				yy_push_buffer(pnewbuf);
				fnlist[cur_size++] = pch;
				yy_set_bol(true);
			}
			else {
				cout << "Warning: failed to open file `" << pch << "\'" << endl;
				delete[] pch;
			}		
		}
    }

<<EOF>>		{

	cout << endl;
	if(yy_has_buffer()) {

		yy_pop_buffer();
		yy_set_bol(true);
	}
    }
.|\n		cout << yytext;
					<</lex_section>>
					<<after_init>>
	yylex();
	for(int i = 0; i < cur_size; ++i) {

		delete[] fnlist[i];
	}

					<</after_init>>
				<</script>>
				<<textfile "test.input">>
******** test.input begin **********
#include<test1.input>
aaa
aaa
#open <test2.input>
aaa
******** test.input over ***********
				<</textfile>>
				<<textfile "test1.input">>
******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********
				<</textfile>>
				<<textfile "test2.input">>
******** test2.input begin **********
ccc
ccc
#overwrite<test3.input>
ccc
******** test2.input over ***********
				<</textfile>>
				<<textfile "test3.input">>
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********
				<</textfile>>
				<<textfile "result.out">>
******** test.input begin **********
aaa
aaa
******** test2.input begin **********
ccc
ccc
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********

aaa
******** test.input over ***********

******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yy_buffer---->>>


<<<----------case: /lex-alone/basic/action/yyinput---->>>
			<<case "yyinput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyinput(): char
	yyunput(char)
	yy_set_bol(false/true)
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

					<</declare_section>>
					<<lex_section>>
"/*"	int c = END_OF_FILE;
	while((c = yyinput()) != END_OF_FILE) {

		if(c == '*') {

			if((c = yyinput()) == (int)((unsigned char)'/')
			    || c == END_OF_FILE) {

				break;
			}
			yyunput(c);
		}	
	}

"//"	int c = END_OF_FILE;
	while((c = yyinput()) != END_OF_FILE) {

		if(c == (int)((unsigned char)'\n')) {

			break;
		}
	}
	yy_set_bol(true);

^[ \t]+.*\n	cout << yytext;
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
 just test for yyinput & yyunput
*/show me
 you can see me
 if there is not `beautiful life', then life is awful
//something wrong must be happened
/*
 
*************
/
Oops!
************/
 beautiful life
//***********************/
I am Prince of Darkness, so you can't see me
//************/**************/**********/
 and God will always be with you.
				<</textfile>>
				<<textfile "result.out">>
 you can see me
 if there is not `beautiful life', then life is awful
 beautiful life
 and God will always be with you.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyinput---->>>


<<<----------case: /lex-alone/basic/action/yyless---->>>
			<<case "yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyless(number-of-chars)
*/
					<</desc>>
					<<lex_section>>
"hello, world"	cout << yytext; yyless(7);
"world"		cout << yytext;
"Hi, guys"	cout << yytext; yyless(4);
"guys"		cout << yytext;
\n		cout << endl;
.

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
104 101 108 108 111 44 32 119 111 114 108 100 10 72 105 44 
32 103 117 121 115 10 10 -43 -116 58 -98 -119 88 -127 -96 15 
-47 82 -73 -50 -100 -62 -49 -8 79 -68 108 90 -112 -90 -3 124 
-80 37 32 -48 -52 -84 -93 64 -107 10 -110 66 -82 85 51 -42 
74 -72 36 38 -67 -123 92 119 -94 80 -40 -36 16 101 97 103 
47 12 -115 -113 105 114 -75 22 -57 -2 30 -12 3 -65 102 -121 
44 -22 -60 -44 -64 33 99 107 120 115 -104 55 28 77 -109 57 
83 69 98 42 -91 96 87 -106 65 11 41 94 126 8 29 -66 
-111 7 0 -39 95 113 48 61 -46 40 -18 100 123 -53 -99 -74 
49 1 -30 86 -5 45 -37 -85 89 34 -114 -10 24 116 -79 -89 
54 -23 60 62 76 -9 59 -117 -76 -95 31 127 -35 -17 68 -15 
84 -38 26 53 -54 -16 56 -105 78 110 -124 81 17 -19 -6 93 
-4 -78 -13 67 109 -83 117 122 91 -41 52 2 125 -97 -126 -25 
6 -24 70 -77 13 104 20 72 -1 -70 43 -103 46 -7 -108 -21 
-45 121 35 -31 39 -20 -26 25 -125 106 27 -81 -55 -92 19 -88 
-102 -61 -128 -120 -101 71 14 -51 -11 -59 -29 -28 -122 5 -71 -34 
73 4 -14 -69 -32 75 -87 18 -27 63 112 -58 23 -63 -56 111 
21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
hello, worldworld
Hi, guysguys


				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyless---->>>


<<<----------case: /lex-alone/basic/action/yymore--->>>
			<<case "yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>
/*
test built-in routines:
	yymore()
*/
					<</desc>>
					<<lex_section>>
"It\'s"		cout << yytext << endl; yymore();
"nice to"	cout << yytext << endl; yymore();
"see you!"	cout << yytext << endl; yymore();
" "		cout << "*" << endl; yymore();
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
It's nice to see you!
None of these are available.
				<</textfile>>
				<<textfile "result.out">>
It's
*
It's nice to
*
It's nice to see you!
*
*
*
*
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yymore---->>>


<<<----------case: /lex-alone/basic/action/yyrestart--->>>
			<<case "yyrestart" make="lex-only-makefile-template">>
				<<EXTRA_DIST>>test1.input<</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyrestart()
*/
					<</desc>>
					<<init_code>>
#define MAX_OPEN_TIMES	8

bool useFile = false;
int reopen_times = 0;
					<</init_code>>
					<<declare_section>>
%yywrap%{

	if(!useFile) {
		YYPBUFFER pbuf = yy_new_filebuf("test1.input");
		if( !pbuf) {
			cout << "failed to open `test1.input\'" << endl;
			yyterminate();
		}
		else {
			yy_switch_buffer(pbuf);
		}
	}
	useFile = true;

	return 0;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
	
a	cout << yytext; ++ncnt;

<<EOF>>	{
		cout << endl;
		if(useFile && reopen_times < MAX_OPEN_TIMES) {

			++reopen_times;
			yyrestart();
			yy_set_bol(true);
		}
	}

.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << endl << "a\'s occurrences: " << ncnt << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
aa
				<</textfile>>
				<<textfile "test1.input">>
aa
				<</textfile>>
				<<textfile "result.out">>
aa
aa
aa
aa
aa
aa
aa
aa
aa

a's occurrences: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyrestart---->>>



<<<----------case: /lex-alone/basic/action/yysc_state--->>>
			<<case "yysc_state" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	YYSTART()
	yy_push_state(DFA-begin-state)
 	yy_pop_state()
*/
					<</desc>>
					<<init_code>>
#include <iomanip>
using std::setw;
					<</init_code>>
					<<declare_section>>
%x	sc1
%x	sc2
%x	sc3
%x	sc4
					<</declare_section>>
					<<lex_section>>
<INITIAL,sc1,sc2,sc3>"("	{
		
		switch(YYSTART()) {
		case INITIAL:
			yy_push_state(sc1);
			break;
		case sc1:
			yy_push_state(sc2);
			break;
		case sc2:
			yy_push_state(sc3);
			break;
		case sc3:
			yy_push_state(sc4);
			break;
		}
	}

<sc1,sc2,sc3,sc4>")"	yy_pop_state();

<*>[[:space:]]+

<sc1>[^\(\)\r\n \t]+	{
		cout << "\t" << yytext << endl;
	}
<sc2>[^\(\)\r\n \t]+	{
		cout << "\t\t" << yytext << endl;
	}
<sc3>[^\(\)\r\n \t]+	{
		cout << "\t\t\t" << yytext << endl;
	}
<sc4>[^\(\)\r\n \t]+	{
		cout << "\t\t\t\t" << yytext << endl;
	}
[^\(\)\n\r \t]+	{
		cout << yytext << endl;
	}

<*>.|\r?\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
	(define
		(right-branch
		tree)
		(cadr
		tree))
	(define
		(symbols
		tree)
		(if
			(leaf?
			tree)
			(list
				(symbol-leaf
				tree))
			(caddr tree)))
	(define
		(weight
		tree)
		(if
			(leaf?
			tree)
			(weight-leaf
			tree)
			(cadddr tree)))
				<</textfile>>
				<<textfile "result.out">>
	define
		right-branch
		tree
		cadr
		tree
	define
		symbols
		tree
		if
			leaf?
			tree
			list
				symbol-leaf
				tree
			caddr
			tree
	define
		weight
		tree
		if
			leaf?
			tree
			weight-leaf
			tree
			cadddr
			tree
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yysc_state---->>>


<<<----------case: /lex-alone/basic/action/yyunput--->>>
			<<case "yyunput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyunput(char-to-put)
*/
					<</desc>>
					<<declare_section>>
%lex-init%{
	cout << "Play game of `Change Word\'" << endl;
%}
					<</declare_section>>
					<<lex_section>>
bad	yyunput('d');
	yyunput('o');
	yyunput('o');
	yyunput('g');

ugly	yyunput('e');
	yyunput('t');
	yyunput('u');
	yyunput('c');

cruel	yyunput('d');
	yyunput('n');
	yyunput('i');
	yyunput('k');

lie	yyunput('h');
	yyunput('t');
	yyunput('u');
	yyunput('r');
	yyunput('t');

proud	yyunput('e');
	yyunput('l');
	yyunput('b');
	yyunput('m');
	yyunput('u');
	yyunput('h');

.|\n	cout << yytext;

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
Once upon a time, there is very bad, ugly guy. He is alway very cruel to people around him, and force himself to tell at leat a lie everyday. What's more, he is a very proud man.
				<</textfile>>
				<<textfile "result.out">>
Play game of `Change Word'
Once upon a time, there is very good, cute guy. He is alway very kind to people around him, and force himself to tell at leat a truth everyday. What's more, he is a very humble man.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyunput---->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/action---->>>



<<<----------sub-suite: /lex-alone/basic/charset---->>>
		<<suite "charset" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/charset/charset-blank--->>>
			<<case "charset-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
[ \t]		++ncnt;
[ \t]{5}	ncnt += 10;
[ \t]+		ncnt += yyleng * 3;

.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
 a a a a
					b
          c
				<</textfile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>	
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>
			<<case "charset-cesc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
	escape char in C language
*/
					<</desc>>
					<<init_code>>
int ncnt = 0;
					<</init_code>>
					<<declare_section>>
cesc1	[\0\?\\\"\'\a\b\f\n\r\t\v]
cesc2	\0|\?|\\|\"|\'|\a|\b|\f|\n|\r|\t|\v
cesc3	"\0"|"\?"|"\\"|"\""|"\'"|"\a"|"\b"|"\f"|"\n"|"\r"|"\t"|"\v"

					<</declare_section>>
					<<lex_section>>
{cesc1}		++ncnt;
{cesc2}{5}	ncnt += 10;
{cesc3}+	ncnt += yyleng * 3;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	cout << ncnt << endl;
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
7 65 0 65 9 65 10 65 63 34 39 63 39 65 11 13 
11 13 92 92 92 92 13 34
				<</bytefile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>


<<<----------case: /lex-alone/basic/charset/charset-concat--->>>
			<<case "charset-concat" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation:
	concat
*/
					<</desc>>
					<<declare_section>>
int	[\+\-]?([1-9][0-9]*|0)
hex	\\[Xx][0-9A-Fa-f][0-9A-Fa-f]
oct	\\[0-3][0-7][0-7]
real	{int}|{int}"\."[0-9]+
					<</declare_section>>
					<<lex_section>>
{int}	|
{hex}	|
{oct}	|
{real}	cout << yytext << endl;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/+100 c-999 a7777
\xffe wiof\X33kis \\x4232 \XDCE
dd\001\777\888\999\aaa
43.90a 48.23b1233204.738429sfsj4332
				<</textfile>>
				<<textfile "result.out">>
+100
-999
7777
\xff
\X33
\x42
32
\XDC
\001
777
888
999
43.90
48.23
1233204.738429
4332
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-concat--->>>


<<<----------case: /lex-alone/basic/charset/charset-email--->>>
			<<case "charset-email" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze email address 
*/
					<</desc>>
					<<init_code>>
int ncnt = 0;
					<</init_code>>
					<<declare_section>>
/* name section */
nsect	[0-9A-Za-z\_\-]{1,}
/* name */
name	{nsect}("."{nsect})*
emaddr	{name}\@{name}
					<</declare_section>>
					<<lex_section>>
{emaddr}	cout << yytext << endl; ++ncnt;

.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	cout << ncnt << endl;
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
somebody.upgen@robot.com
somebody.upgen@r@obot.com
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
				<</textfile>>
				<<textfile "result.out">>
somebody.upgen@robot.com
somebody.upgen@r
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
3
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-email--->>>


<<<----------case: /lex-alone/basic/charset/charset-hex--->>>
			<<case "charset-hex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning hexadecimal numbers
*/
					<</desc>>
					<<init_code>>
int blanks = 0;
int spaces = 0;
int digits = 0;
int uppers = 0;
int lowers = 0;
int eofs = 0;
int nansis = 0;
					<</init_code>>
					<<declare_section>>
blank	[\x09\x20]
space	[\x09-\x0D]
digit	[\x30-\x39]
upper	[\X41-\X5a]
lower	[\x61-\X7A]
eof	[\XFf]
nansi	[\X80-\xff]
					<</declare_section>>
					<<lex_section>>
{blank}		++blanks;
{space}		++spaces;
{digit}		++digits;
{upper}		++uppers;
{lower}		++lowers;
{eof}		++eofs;
{nansi}		++nansis;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "blanks: " << blanks << endl
	     << "spaces: " << spaces << endl
	     << "digits: " << digits << endl
	     << "uppers: " << uppers << endl
	     << "lowers: " << lowers << endl
	     << "eofs: " << eofs << endl
	     << "nansis: " << nansis << endl;

					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-43 -116 58 -98 -119 88 -127 -96 15 -47 82 -73 -50 -100 -62 -49 
-8 79 -68 108 90 -112 -90 -3 124 -80 37 32 -48 -52 -84 -93 
64 -107 10 -110 66 -82 85 51 -42 74 -72 36 38 -67 -123 92 
119 -94 80 -40 -36 16 101 97 103 47 12 -115 -113 105 114 -75 
22 -57 -2 30 -12 3 -65 102 -121 44 -22 -60 -44 -64 33 99 
107 120 115 -104 55 28 77 -109 57 83 69 98 42 -91 96 87 
-106 65 11 41 94 126 8 29 -66 -111 7 0 -39 95 113 48 
61 -46 40 -18 100 123 -53 -99 -74 49 1 -30 86 -5 45 -37 
-85 89 34 -114 -10 24 116 -79 -89 54 -23 60 62 76 -9 59 
-117 -76 -95 31 127 -35 -17 68 -15 84 -38 27 53 -54 -16 56 
-105 78 110 -124 81 17 -19 -6 93 -4 -78 -13 67 109 -83 117 
122 91 -41 52 2 125 -97 -126 -25 6 -24 70 -77 13 104 20 
72 -1 -70 43 -103 46 -7 -108 -21 -45 121 35 -31 39 -20 -26 
25 -125 106 27 -81 -55 -92 19 -88 -102 -61 -128 -120 -101 71 14 
-51 -11 -59 -29 -28 -122 5 -71 -34 73 4 -14 -69 -32 75 -87 
18 -27 63 112 -58 23 -63 -56 111 21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
blanks: 2
spaces: 4
digits: 10
uppers: 26
lowers: 26
eofs: 1
nansis: 127
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-hex--->>>


<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>
			<<case "charset-ipaddress" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze ip address 
*/
					<</desc>>
					<<init_code>>
int selfs = 0;
int ipaddrs = 0;
					<</init_code>>
					<<declare_section>>
self	"127"\.0{1,3}\.0{1,3}\.(0?0)?1
ipsect	[01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5]
ipaddr	({ipsect})(\.({ipsect})){3}
					<</declare_section>>
					<<lex_section>>
{self}		++selfs; cout << "localhost " << selfs << ": " << yytext << endl;
{ipaddr}	++ipaddrs; cout << "ip " << ipaddrs << ": " << yytext << endl;
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "localhosts: " << selfs << endl
	     << "others: " << ipaddrs << endl;
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
localhost1: 127.0.0.1
localhost2: 127.000.000.001
localhost3: 127.0.00.001
ip1: 192.156.173.115
ip3: 0.0.0.1
ip4: 0.0.0.0
ip5: 255.255.255.255
ip6: 256.001.002.003
ip7: 128.a.9.3
ip8: 116.119.121.34
ip2: 99.77.88.10
				<</textfile>>
				<<textfile "result.out">>
localhost 1: 127.0.0.1
localhost 2: 127.000.000.001
localhost 3: 127.0.00.001
ip 1: 192.156.173.115
ip 2: 0.0.0.1
ip 3: 0.0.0.0
ip 4: 255.255.255.255
ip 5: 56.001.002.003
ip 6: 116.119.121.34
ip 7: 99.77.88.10
localhosts: 3
others: 7
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>


<<<----------case: /lex-alone/basic/charset/charset-meta--->>>
			<<case "charset-meta" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
meta-char as escape char
*/
					<</desc>>
					<<init_code>>
int meta1s = 0,
 meta2s = 0,
 meta3s = 0,
 meta4s = 0;
					<</init_code>>
					<<declare_section>>
meta1	[\%\(\)\[\]\{\}\<\>\|\<\>\:\$\^\/\*\+\,\;\.\?\-]
meta2	\%|\(|\)|\[|\]|\{|\}|\<|\>|\||\<|\>|\:|\$|\^|\/|\*|\+|\,|\;|\.|\?|\-
meta3	"\%"|"\("|"\)"|"\["|"\]"|"\{"|"\}"|"\<"|"\>"|"\|"|"\<"|"\>"|"\:"|"\$"|"\^"|"\/"|"\*"|"\+"|"\,"|"\;"|"\."|"\?"|"\-"
meta4	"%"|"("|")"|"["|"]"|"{"|"}"|"<"|">"|"|"|"<"|">"|":"|"$"|"^"|"/"|"*"|"+"|","|";"|"."|"?"|"-"

					<</declare_section>>
					<<lex_section>>
{meta1}		++meta1s; cout << yytext;
{meta2}		++meta2s; cout << yytext;
{meta3}		++meta3s; cout << yytext;
{meta4}		++meta4s; cout << yytext;
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "\nmeta1s = " << meta1s << endl
	     << "meta2s = " << meta2s << endl
	     << "meta3s = " << meta3s << endl
	     << "meta4s = " << meta4s << endl;
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
				<</textfile>>
				<<textfile "result.out">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
meta1s = 41
meta2s = 0
meta3s = 0
meta4s = 0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-meta--->>>


<<<----------case: /lex-alone/basic/charset/charset-negator--->>>
			<<case "charset-negator" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation:
	negator(^)
*/
					<</desc>>
					<<init_code>>
int blanks = 0,
 spaces = 0,
 ansis = 0,
 eofs = 0,
 others = 0,
 nospcs = 0,
 noblks = 0,
 neofs = 0;
					<</init_code>>
					<<declare_section>>
ansi	[\000-\177]
other	[^\000-\177]
blank	[ \t]
noblk	[^ \t]
space	[[:space:]]
nospc	[^[:space:]]
eof		[\xFF]
neof	[^\xff]

					<</declare_section>>
					<<lex_section>>
{blank}		++blanks;
{space}		++spaces;
{ansi}		++ansis;
{eof}		++eofs;
{other}		++others;

{nospc}		++nospcs;
{noblk}		++noblks;
{neof}		++neofs;

.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "blanks: " << blanks << endl
	     << "spaces: " << spaces << endl
	     << "ansis: " << ansis << endl
	     << "eofs: " << eofs << endl
	     << "others: " << others << endl
	     << "nospcs: " << nospcs << endl
	     << "noblks: " << noblks << endl
	     << "neofs: " << neofs << endl;
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 
48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 
80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 
96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 
112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 
-128 -127 -126 -125 -124 -123 -122 -121 -120 -119 -118 -117 -116 -115 -114 -113 
-112 -111 -110 -109 -108 -107 -106 -105 -104 -103 -102 -101 -100 -99 -98 -97 
-96 -95 -94 -93 -92 -91 -90 -89 -88 -87 -86 -85 -84 -83 -82 -81 
-80 -79 -78 -77 -76 -75 -74 -73 -72 -71 -70 -69 -68 -67 -66 -65 
-64 -63 -62 -61 -60 -59 -58 -57 -56 -55 -54 -53 -52 -51 -50 -49 
-48 -47 -46 -45 -44 -43 -42 -41 -40 -39 -38 -37 -36 -35 -34 -33 
-32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 
-16 -15 -14 -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1
				<</bytefile>>
				<<textfile "result.out">>
blanks: 2
spaces: 4
ansis: 122
eofs: 1
others: 127
nospcs: 0
noblks: 0
neofs: 0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-negator--->>>


<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>
			<<case "charset-normal-esc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
normal char as escape char
*/
					<</desc>>
					<<init_code>>
int norm2 = 0,
 norm3 = 0,
 norm4 = 0,
 norm5 = 0;	
					<</init_code>>
					<<declare_section>>

norm1	\\[A-Zc-eg-mo-qsuw-z_\#\&\=\@\`\~]
norm2	"\A"|"\B"|"\C"|"\D"|"\E"|"\F"|"\G"|"\H"|"\I"|"\J"|"\K"|"\L"|"\M"|"\N"|"\O"|"\P"|"\Q"|"\R"|"\S"|"\T"|"\U"|"\V"|"\W"|"\X"|"\Y"|"\Z"|"\c"|"\d"|"\e"|"\g"|"\h"|"\i"|"\j"|"\k"|"\l"|"\m"|"\o"|"\p"|"\q"|"\s"|"\u"|"\w"|"\x"|"\y"|"\z"|"\_"|"\#"|"\&"|"\="|"\@"|"\`"|"\~"
norm3	"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"|"c"|"d"|"e"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"o"|"p"|"q"|"s"|"u"|"w"|"x"|"y"|"z"|"_"|"#"|"&"|"="|"@"|"`"|"~"
norm4	\A|\B|\C|\D|\E|\F|\G|\H|\I|\J|\K|\L|\M|\N|\O|\P|\Q|\R|\S|\T|\U|\V|\W|\X|\Y|\Z|\c|\d|\e|\g|\h|\i|\j|\k|\l|\m|\o|\p|\q|\s|\u|\w|\x|\y|\z|\_|\#|\&|\=|\@|\`|\~
norm5	A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|c|d|e|g|h|i|j|k|l|m|o|p|q|s|u|w|x|y|z|_|#|&|=|@|`|~

					<</declare_section>>
					<<lex_section>>
{norm2}		++norm2; cout << yytext;
{norm3}		++norm3; cout << yytext;
{norm4}		++norm4; cout << yytext;
{norm5}		++norm5; cout << yytext;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	yylex();
	cout << "\nnorm2:" << norm2 << endl
	     << "norm3:" << norm3 << endl
	     << "norm4:" << norm4 << endl
	     << "norm5:" << norm5 << endl;

					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
8 -43 -30 120 -90 29 110 54 120 -14 -67 8 -80 -94 97 23 
105 -21 -111 8 65 -77 98 125 0 22 -102 27 71 -77 -10 80 
-120 -40 -56 46 -11 54 100 109 40 33 118 -40 -61 -41 -17 45 
-62 -128 53 3 51 -104 -127 52 -82 27 79 -11 -50 69 69 86 
29 13 -123 19 67 -23 -128 107 11 -10 67 -50 -50 50 -5 -112 
-78 49 -108 -26 -55 21 27 119 48 105 108 -2 -82 -78 84 -53 
-65 -39 -34 3 -61 95 110 -50 85 -78 -100 35 -28 -104 -76 -105 
-55 72 125 -110 93 -105 9 -115 0 117 -117 -82 39 -33 121 -25 
-71 88 -22 124 -73 88 74 12 10 -26 48 -17 126 -28 -122 71 
44 3 -39 -119 -102 -30 22 -102 88 -95 72 127 -128 -63 102 57 
25 80 -75 -48 -87
				<</bytefile>>
				<<textfile "result.out">>
xxiAGPdmOEEVCkCwilT_U#HuyXXJ~GXHP
norm2:33
norm3:0
norm4:0
norm5:0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>


<<<----------case: /lex-alone/basic/charset/charset-oct--->>>
			<<case "charset-oct" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning octal numbers
*/
					<</desc>>
					<<init_code>>
#include <string>
using std::string;
int digits = 0,
 uppers = 0,
 lowers = 0;
int eofs = 0,
 nansis = 0;
string strd,
 stru,
 strl;
					<</init_code>>
					<<declare_section>>
digit	[\060-\071]
upper	[\101-\132]
lower	[\141-\172]
eof		[\377]
nansi	[\200-\377]
					<</declare_section>>
					<<lex_section>>
{digit}		++digits; strd += yytext;
{upper}		++uppers; stru += yytext;
{lower}		++lowers; strl += yytext;
{eof}		++eofs;
{nansi}		++nansis;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	yylex();
	cout << "\ndigits: " << strd << " " << digits << " in total." << endl
	     << "uppers: " << stru << " " << uppers << " in total." << endl
	     << "lowers: " << strl << " " << lowers << " in total." << endl
	     << "eofs: " << eofs << endl
	     << "nansis: " << nansis << endl;

					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
127 120 -93 -30 32 116 -64 2 -87 120 62 116 95 68 68 83 
-51 88 9 -21 -77 25 65 0 -69 -42 -115 -29 -74 127 -34 53 
-9 -127 24 23 -10 -40 25 -97 81 87 19 -80 -100 87 4 105 
-81 13 84 98 39 -106 98 -30 108 -16 -59 34 111 -92 88 102 
37 112 125 27 72 -105 -69 -103 -18 -50 74 -118 38 78 -12 -43 
91 72 56 -126 -34 -102 100 74 -118 42 109 -7 -50 -59 95 -13 
53 -35 15 125 116 -54 23 98 -104 97 -19 -66 -81 -31 -108 10 
41 -52 -115 8 102 -15 82 -15 27 -65 -22 -23 -124 74 -35 -71 
39 -20 55 -101 -74 78 -3 78 -81 -22 13 94 -53 -95 104 -11 
109 -11 -3 -45 -25 79 -60 2 15 -81 -20 -109 -7 -55 77 32 
-75 -124 -69 107 -46 -72 -71 -127 -93 -58 -33 110 103 71 99 -44 
61 96 -88 36 -80 108 38 -65 27 18 82 20 -37 -97 52 -112 
35 -17 -5 -11 -88 -75 118 75 123 85 -71 -29 -99 29 -73 -38 
125 95 -2 45 -52 36 -20 -25 55 63 -4 18 -34 48 -93 2 
32 -98 -9 -56 83 110 19 -49 -61 -52 -78 96 -23 105 58 103 
-55 56 -108 -107 93 -127 124 -108 -64 120 -90 -98 -87 73 -96 -55 
-24 -104 -111 59 6 -92 10 -55 112 -68 42 90 38 100 -63 -17 
-99 85 -124 -6 -42 0 -114 -106 121 52 53 34 126 -43 -21 102 
109 124 -95 115 32 -84 61 -112 104 103 -22 -114 -53 -85 125 104 
1 1 98 -41 2 -16 110 123 37 -93 -99 -93 120 -120 9 -26 
4 -86 89 36 86 -106 -76 -65 -3 -97 77 -55 74 -53 49 75 
-52 -108 35 -50 -124 -111 73 -87 52 -26 76 -84 110 85 -110 114 
0 -20 -106 86 -126 75 21 -128 -22 99 73 52 46 122 -128 -6 
14 -93 -55 -109 52 18 60 104 -7 -119 20 103 -34 -89 -38 -34 
-109 112 53 21 -69 74 -107 -91 -83 -34 -38 -37 89 90 -42 103 
-3 -97 -6 49 -79 55 -103 -86 -64 -83 18 -98 84 -20 125 -25 
92 -78 -3 24 -4 -110 -67 -86 113 -105 -123 -54 -15 91 49 -18 
-6 44 31 -84 99 -72 86 35 102 104 -63 -70 84 62 -94 -79 
-16 -97 -55 -19 49 -122 -105 -94 30 28 108 15 120 -98 -2 114 
-54 29 30 45 -42 117 80 60 -35 17 -10 50 80 -104 -29 64 
55 -84 45 105 50 -60 11 80 -31 120 96 89 22 94 -53 -32 
123 -22 13 81 95 93 -115 60 110 -124 110 -66 28 81 
				<</bytefile>>
				<<textfile "result.out">>

digits: 5857470845144451711272 22 in total.
uppers: DDSXAQWWTXHJNHJRJNNOMGRKUSIZUYVMJKILUVKIJYZTVTPPPYQQ 52 in total.
lowers: xtxtibblofpdmtbafhmkngclvnigxpdyfmshghbnxnrczhgpgqcfhlxruixnn 61 in total.
eofs: 0
nansis: 257
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-oct--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>
			<<case "charset-posix-alnum" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alnum
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

alnum	[[:alnum:]]

					<</declare_section>>
					<<lex_section>>
{alnum}		++ncnt; cout << yytext << " +1" << endl;
{alnum}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{alnum}+	ncnt += yyleng * 3; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-37 -96 60 -108 -49 -92 47 -81 -7 75 -102 -11 50 -112 -35 6 
104 -75 -88 109 -98 34 -54 49 -114 102 97 -67 -20 -46 56 -100 
118 64 24 -13 -128 36 -79 120 -59 89 42 51 -66 18 -47 68 
-60 43 -70 127 57 -74 -34 53 -50 -68 22 115 29 76 17 -40 
15 112 -76 96 -87 0 122 -12 -9 -17 65 -124 -15 -110 8 41 
114 78 46 98 -39 -83 86 119 -14 -78 -5 101 -57 -71 38 -89 
-27 -52 -117 87 -120 63 117 13 25 100 -122 69 83 27 40 -44 
59 -62 -73 91 80 31 -106 -103 -21 -51 -82 -94 -36 99 -25 -1 
-104 58 -126 55 -4 -109 14 -63 33 -18 11 -118 -64 -41 -99 72 
-33 -16 27 -84 110 113 45 -90 10 48 -72 37 92 93 1 77 
-45 -121 62 -86 -95 -6 -42 -125 -69 -65 -113 52 -111 16 -31 -107 
-38 70 121 81 106 108 103 85 123 90 82 54 73 -3 -115 -26 
-55 105 -8 88 -85 107 94 -2 124 74 -127 -105 12 116 -80 44 
23 -43 -32 67 -28 19 -24 -97 95 -119 30 21 126 79 -48 -53 
39 71 125 2 -77 4 9 20 35 -10 -22 5 -23 32 7 -29 
-30 -61 -93 61 -56 111 -58 -91 3 -19 84 66 -116 -123 -101 28
				<</bytefile>>
				<<textfile "result.out">>
K +1
2 +1
h +1
m +1
1 +1
fa +4
8 +1
v +1
x +1
Y +1
3 +1
D +1
9 +1
5 +1
s +1
L +1
p +1
z +1
A +1
rN +4
b +1
Vw +4
e +1
W +1
u +1
d +1
ES +4
P +1
c +1
7 +1
H +1
nq +4
0 +1
M +1
4 +1
FyQjlgU +21
ZR6I +12
i +1
X +1
k +1
J +1
t +1
C +1
O +1
G +1
o +1
TB +4
96
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>
			<<case "charset-posix-alpha" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alpha
*/
					<</desc>>
					<<declare_section>>
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
{alpha}		++ncnt; cout << yytext << " +1" << endl;
{alpha}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{alpha}+	ncnt += yyleng * 3; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
96 -34 -73 -66 -14 56 39 -45 -43 111 120 -56 67 -86 6 89 
106 -94 13 87 -28 84 45 16 110 36 117 15 102 -122 -78 -109 
-20 22 -72 58 94 23 -59 12 126 66 -62 28 -19 -26 -91 -67 
107 -89 59 -44 -92 -93 52 103 -83 -33 -75 -104 -102 7 63 55 
74 79 -16 -63 -12 35 100 40 121 71 70 -127 -90 -55 61 -23 
3 0 -96 5 80 57 43 -70 -69 -9 -111 -52 34 77 24 69 
-11 90 14 91 33 -21 41 27 92 29 -82 47 -58 -35 73 86 
46 98 37 -107 95 -37 118 119 10 72 122 123 124 125 25 127 
-128 75 -126 -125 -124 -123 105 -121 -120 -119 -118 -117 -116 -115 -114 -113 
-112 97 -110 31 -108 115 -106 -105 50 -103 60 -101 -100 -99 -98 -97 
82 -95 17 53 54 112 76 49 -88 -87 18 -85 -84 83 114 -81 
-80 -79 30 -77 -76 116 -74 2 104 -71 19 88 -68 48 21 -65 
-64 113 42 -61 -60 38 108 -57 11 93 -54 -53 99 -51 -50 -49 
-48 -47 -46 78 51 8 -42 -41 -40 -39 -38 27 -36 109 1 85 
-32 -31 -30 -29 20 -27 64 -25 -24 65 -22 101 32 44 -18 -17 
9 -15 4 -13 68 81 -10 62 -8 -7 -6 -5 -4 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
ox +4
C +1
Yj +4
W +1
T +1
n +1
u +1
f +1
B +1
k +1
g +1
JO +4
d +1
yGF +9
P +1
M +1
E +1
Z +1
IV +4
b +1
vw +4
Hz +4
K +1
i +1
a +1
s +1
R +1
pL +4
Sr +4
t +1
h +1
X +1
q +1
l +1
c +1
N +1
m +1
U +1
A +1
e +1
DQ +4
76
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>
			<<case "charset-posix-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - blank
*/

					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
blank	[[:blank:]]
					<</declare_section>>
					<<lex_section>>
{blank}		++ncnt; cout << yytext << " +1" << endl;
{blank}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{blank}+	ncnt += yyleng * 3; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
80 -104 -125 -100 -42 84 120 -57 -58 40 -114 6 -1 115 10 -28 
16 -74 -62 -12 -7 -75 65 47 -90 -76 2 -67 54 -65 -69 88 
-96 -95 34 17 -101 68 15 -18 0 46 -91 -36 -107 96 -120 -92 
123 -97 -127 75 126 43 -117 116 111 71 -21 -20 94 41 -38 86 
95 30 44 124 11 39 114 -43 102 19 -13 -121 106 28 98 -32 
-17 105 69 63 1 13 -25 -31 -30 -82 77 -81 74 -24 90 85 
49 -109 -94 103 55 27 -79 -122 -16 83 -23 7 127 -88 -11 42 
-80 -68 76 -110 93 -2 -48 51 104 25 -106 -85 59 61 67 -59 
-70 8 -34 73 -124 60 -33 112 -78 -14 18 64 -123 -54 -93 35 
122 113 5 -66 -51 101 78 -9 107 -113 20 27 -84 57 92 -47 
-8 -116 -45 -98 50 22 33 -22 -72 -118 4 -126 -44 87 -87 -111 
56 -71 66 14 81 -37 125 -29 29 32 -52 -61 -99 23 9 89 
3 -40 -49 -119 -39 119 58 -102 31 121 100 -50 -63 52 72 62 
79 24 -77 -56 -103 -83 -108 108 37 53 -89 -64 97 91 -46 -26 
-19 -112 -86 99 -35 38 118 109 48 -27 -15 -128 36 70 -115 -105 
82 -55 -41 45 21 110 -10 -60 -53 -73 -6 -5 -4 -3 117 12 
				<</bytefile>>
				<<textfile "result.out">>
  +1
	 +1
2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>
			<<case "charset-posix-cid" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - cid
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{cidf}{cids}*		cout << yytext << endl; ++ncnt;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test posix charset - cid
*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]

%%

{cidf}{cids}*		cout << yytext << endl; ++ncnt;
.|\n

%%

using namespace yynsx;

int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
posix
charset
cid
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
cidf
cidf
cids
cids
cidf
cids
cout
yytext
endl
ncnt
n
using
namespace
yynsx
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
51
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-cntrl--->>>
			<<case "charset-posix-cntrl" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - cntrl
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

digit	[[:digit:]]
xdigt	[[:xdigit:]]
lower	[[:lower:]]
upper	[[:upper:]]
alnum	[[:alnum:]]
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{cntrl}			++ncnt;	cout << (int)yytext[0] << " +1" << endl;
{cntrl}{2}		ncnt += 4; cout << (int)yytext[0] << " " << (int)yytext[1] << " +4" << endl;
{cntrl}+		ncnt += 3 * yyleng;
			for(int i = 0; i < yyleng; ++i) {
				cout << (int)yytext[i] << " ";
			}
			cout << "+" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-100 -25 -72 103 -126 106 83 53 117 46 -81 42 126 -111 -23 -105 
14 -128 87 80 1 -95 98 5 74 -79 -115 27 -68 -119 -113 10 
-69 -97 26 -87 -53 -50 34 118 41 -8 105 119 -74 15 73 -1 
20 78 70 35 0 -75 121 47 -125 28 116 -2 66 110 92 -92 
-84 -55 52 38 -31 -61 -11 111 -20 -47 -109 -118 59 -96 94 43 
16 93 -80 -58 -14 102 12 9 -32 -46 -103 40 115 7 -54 123 
6 49 -90 -29 -42 -121 65 79 31 55 23 -43 97 -21 -3 -73 
69 122 -62 125 67 -123 124 62 -70 -36 60 3 120 -120 96 4 
-101 -94 -78 68 -57 -88 -18 11 39 54 -26 -56 -9 81 -108 -93 
44 -49 33 13 22 -122 -16 32 21 -40 104 25 63 8 127 -7 
88 -37 -10 -71 108 -15 100 -67 -24 61 50 57 29 -99 -44 -13 
-6 -91 -98 101 17 90 75 2 -63 -30 -38 -106 -82 -102 -27 -89 
-114 58 99 -4 -64 24 19 95 109 -41 -86 107 -34 112 48 -65 
-110 30 64 -48 51 -83 45 -22 -117 -35 89 114 -77 91 -66 76 
18 -124 82 -33 -107 56 37 -60 -45 84 -52 36 -85 72 85 -59 
-116 86 -12 77 -112 -5 71 -17 -76 -51 -127 -19 -39 -104 -28 113
				<</bytefile>>
				<<textfile "result.out">>
14 +1
1 +1
5 +1
27 +1
10 +1
26 +1
15 +1
20 +1
0 +1
28 +1
16 +1
12 9 +4
7 +1
6 +1
31 +1
23 +1
3 +1
4 +1
11 +1
13 22 +4
21 +1
25 +1
8 127 +4
29 +1
17 +1
2 +1
24 19 +4
30 +1
18 +1
41
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-cntrl--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>
			<<case "charset-posix-digit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - digit
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

digit	[[:digit:]]
xdigt	[[:xdigit:]]
lower	[[:lower:]]
upper	[[:upper:]]
alnum	[[:alnum:]]
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{digit}		++ncnt; cout << yytext << " +1" << endl;
{digit}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{digit}+	ncnt += 3 * yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
105 -64 -121 -114 -94 -25 -51 16 54 -50 33 28 -75 -58 84 -61 
-14 -91 123 -69 86 93 22 110 -74 65 14 85 -6 -78 9 55 
114 94 29 42 64 -92 -48 -49 90 60 -77 -100 -111 111 -102 8 
49 -2 126 -47 -79 122 -19 124 40 70 -43 -30 98 20 -93 -105 
-104 -83 3 27 -82 45 127 -10 51 -36 -117 27 -76 -26 7 79 
32 56 -95 -97 -120 102 74 -106 5 88 66 -20 -66 91 53 -41 
6 25 106 118 121 41 17 -88 -57 96 -23 43 -12 -67 -54 -60 
83 30 -112 -70 67 0 39 44 -42 -98 -17 68 -34 1 -128 -16 
-55 -52 97 -53 35 -56 -81 -5 -37 -115 -119 -90 107 -18 81 61 
47 -87 58 13 72 -35 -96 104 -109 -116 -38 34 117 31 108 69 
-80 2 -108 95 -32 115 36 -28 -84 -118 -8 -1 -24 -113 82 -124 
120 -11 52 -73 18 113 -39 87 -68 92 -123 80 -62 -107 -33 -9 
-71 -63 24 -21 77 -45 -13 100 -27 -7 -72 112 -29 89 76 59 
-122 99 -127 116 109 -89 -85 62 57 15 -110 63 10 38 -3 4 
119 -59 21 -40 73 125 78 -65 12 19 -4 -103 -125 37 -101 103 
-126 -86 11 23 75 101 46 -22 50 -44 -15 -31 48 -46 71 -99
				<</bytefile>>
				<<textfile "result.out">>
6 +1
7 +1
1 +1
3 +1
8 +1
5 +1
4 +1
9 +1
2 +1
0 +1
10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>
			<<case "charset-posix-graph" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - graph
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{graph}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{graph}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{graph}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-100 -54 -41 127 91 -15 40 -14 -78 -22 95 -102 -111 -52 -43 -88 
-89 -12 99 103 94 48 -44 74 -29 -113 -36 -94 -103 71 -55 -83 
72 77 114 -116 -26 3 -71 38 -39 -120 -118 98 52 23 -4 -73 
-80 -31 -87 56 2 106 109 -99 89 -112 -59 -70 -119 29 90 -1 
66 115 -33 19 79 104 -79 -86 9 82 69 -96 33 119 17 51 
-34 -121 -25 -35 101 -75 121 5 -108 -17 -24 108 -127 -47 -48 120 
-122 84 105 -93 -64 43 -37 -62 -60 -77 -13 -11 50 68 -38 86 
73 -72 122 -61 -65 -23 41 123 14 62 25 12 10 -95 -82 18 
57 -51 -30 111 53 -97 110 15 -49 83 -2 67 64 31 -3 45 
-85 -28 92 -42 -101 30 -27 55 42 -92 118 -128 -91 16 60 -90 
96 59 -66 39 -18 -21 28 7 4 -32 -63 80 -67 -123 37 -76 
-40 -74 21 27 -7 -6 -126 107 102 -117 -109 -115 81 76 27 113 
32 88 1 -53 -125 -58 -9 -110 0 -68 -19 6 -69 -57 54 124 
70 -114 -105 -10 44 -8 126 63 8 75 20 49 -124 11 22 125 
-5 61 -45 58 87 78 -50 -84 46 93 -16 85 -46 97 24 47 
117 116 65 -20 100 13 34 36 -98 -81 112 35 -107 -106 -104 -56 
				<</bytefile>>
				<<textfile "result.out">>
[ +1
( +1
_ +1
cg^0 +12
J +1
G +1
HMr +9
& +1
b4 +4
8 +1
jm +4
Y +1
Z +1
Bs +4
Oh +4
RE +4
!w +4
3 +1
e +1
y +1
l +1
x +1
Ti +4
+ +1
2D +4
VI +4
z +1
){ +4
> +1
9 +1
o5 +4
n +1
S +1
C@ +4
- +1
\ +1
7* +4
v +1
< +1
`; +4
' +1
P +1
% +1
kf +4
QL +4
q +1
X +1
6|F +9
, +1
~? +4
K +1
1 +1
} +1
= +1
:WN +9
.] +4
U +1
a +1
/utA +12
d +1
"$ +4
p# +4
168 94
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>
			<<case "charset-posix-lower" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - lower
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
lower	[[:lower:]]

%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}
					<</declare_section>>
					<<lex_section>>
{lower}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{lower}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{lower}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-81 -95 86 58 -122 -116 -14 -27 110 -63 0 -105 19 16 -69 -39 
49 -60 -79 14 -15 -33 8 43 112 -128 -88 -62 -89 -67 88 -20 
62 -46 -2 -23 74 -101 -10 10 -28 40 -55 18 -61 106 -85 126 
-92 101 -47 -26 -48 -34 -86 -87 -3 66 123 47 118 -64 117 56 
-16 57 3 73 79 99 -125 82 59 6 -51 17 55 -112 68 -19 
32 28 11 67 36 115 -83 69 13 127 -74 -107 -96 98 -66 -77 
24 2 90 -108 114 -102 -73 7 -98 9 64 -12 29 72 -41 -40 
52 -123 -113 -109 -49 21 89 38 -1 108 -118 92 33 95 -6 105 
-24 -5 -13 -103 12 65 -94 -22 -35 54 -4 103 100 -38 -59 -111 
25 -21 35 34 -84 -18 -93 27 63 -32 -68 -78 84 5 -100 -58 
30 -25 85 -117 27 75 87 22 20 31 122 125 -124 4 94 -8 
-57 -50 -110 -104 83 78 -99 1 -75 -17 -56 51 -71 91 53 -80 
-127 -42 -29 111 -106 -31 61 107 -11 71 46 23 77 15 -44 -7 
-114 42 -65 119 48 -90 -30 -126 80 81 41 -9 -43 93 97 104 
50 39 116 -120 102 -76 121 120 -52 -97 -119 44 -121 -70 -82 96 
70 -53 -91 -72 37 -36 45 113 -115 109 -37 60 -54 76 124 -45 
				<</bytefile>>
				<<textfile "result.out">>
n +1
p +1
j +1
e +1
v +1
u +1
c +1
s +1
b +1
r +1
l +1
i +1
gd +4
z +1
o +1
k +1
w +1
ah +4
t +1
f +1
yx +4
q +1
m +1
32 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>
			<<case "charset-posix-print" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - print
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

print	[[:print:]]
					<</declare_section>>
					<<lex_section>>

{print}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{print}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{print}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
45 -115 61 96 -10 -11 -86 -118 -92 -2 62 114 -70 52 53 58 
124 -28 27 -45 21 -105 95 -44 -25 123 46 79 54 -93 -124 -89 
31 51 -3 -22 -24 110 -94 -74 -12 36 19 -23 4 -59 -56 102 
10 -119 70 72 -96 -110 -5 68 -36 -127 0 -98 126 -112 -123 90 
108 35 -6 60 -34 -126 38 -68 -15 127 44 -82 -72 -9 94 -35 
105 -16 100 -113 -32 -27 103 48 -63 32 -4 -17 91 -47 -54 -128 
65 -95 -29 37 -40 -26 101 -99 13 97 -21 -43 116 -53 -57 49 
-90 1 14 88 -71 -33 16 -73 104 3 80 93 -108 -101 -78 84 
-8 89 111 20 122 98 29 28 -42 85 -61 117 -31 -116 18 22 
119 30 33 -103 -81 12 9 42 47 -121 27 -13 74 -100 -107 -97 
-49 78 -39 -18 -76 -104 67 120 77 109 -83 -120 17 -60 -41 15 
-65 -19 -102 107 -20 -7 -88 -1 81 63 -62 -77 -80 34 -106 -87 
83 -69 -111 -14 75 8 -64 71 64 -50 106 -55 -38 -91 -46 25 
-52 2 -85 121 -51 39 87 -79 57 125 24 -114 -58 -66 -30 41 
86 7 118 -125 -122 23 55 92 -75 40 43 113 -67 -109 -84 56 
11 59 99 76 112 73 -48 82 5 6 50 66 -117 69 -37 115 
				<</bytefile>>
				<<textfile "result.out">>
- +1
=` +4
>r +4
45:| +12
_ +1
{.O6 +12
3 +1
n +1
$ +1
f +1
FH +4
D +1
~ +1
Zl# +9
< +1
& +1
, +1
^ +1
i +1
d +1
g0 +4
  +1
[ +1
A +1
% +1
e +1
a +1
t +1
1 +1
X +1
h +1
P] +4
T +1
Yo +4
zb +4
U +1
u +1
w +1
! +1
*/ +4
J +1
N +1
CxMm +12
k +1
Q? +4
" +1
S +1
K +1
G@ +4
j +1
y +1
'W +4
9} +4
)V +4
v +1
7\ +4
(+q +9
8 +1
;cLpI +15
R +1
2B +4
E +1
s +1
171 95
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-punct--->>>
			<<case "charset-posix-punct" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - punct

*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

punct	[[:punct:]]

					<</declare_section>>
					<<lex_section>>

{punct}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{punct}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{punct}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-58 59 -89 -123 -35 94 -40 -10 6 37 -55 84 125 26 96 103 
-120 -127 -21 -99 -2 -78 95 117 -6 77 -25 -116 -12 -73 -106 107 
56 -128 -76 1 -100 -43 -109 93 90 14 -80 126 -50 50 122 -125 
-64 -30 31 62 -34 52 -54 -5 111 -62 87 65 -122 -98 64 106 
86 48 -105 33 60 2 -74 -70 21 16 -47 -61 -39 20 -16 -45 
127 108 40 81 -93 -88 -124 17 -85 80 -108 -86 -112 -95 -82 39 
43 -11 67 -38 -83 22 74 -63 85 69 -57 -46 41 7 -37 -117 
-107 99 98 -52 -90 -56 10 -97 -91 -65 104 36 101 -36 -66 71 
70 -51 123 46 4 35 -8 -110 -71 -3 27 91 78 -115 -126 112 
68 -94 -102 -44 15 -72 45 -32 -33 -31 -77 79 -81 -75 -69 -15 
100 121 -14 83 120 25 24 -121 29 76 -9 8 -1 -79 -28 53 
-20 105 -18 57 109 34 82 -23 -67 55 51 -119 -101 -4 11 116 
0 61 -22 38 13 -48 -42 -53 -49 42 102 28 119 54 -60 110 
3 44 -26 -111 -113 88 -7 -24 30 115 47 63 92 5 -59 -92 
-103 9 -68 89 72 58 -84 97 -29 66 124 -41 12 118 18 19 
-118 23 -27 32 49 113 73 -114 -13 114 -19 -17 -87 75 -96 -104 
				<</bytefile>>
				<<textfile "result.out">>
; +1
^ +1
% +1
} +1
` +1
_ +1
] +1
~ +1
> +1
@ +1
!< +4
( +1
'+ +4
) +1
$ +1
{. +4
# +1
[ +1
- +1
" +1
= +1
& +1
* +1
, +1
/?\ +9
: +1
| +1
44 32
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-punct--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>
			<<case "charset-posix-space" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - space
*/
					<</desc>>
					<<declare_section>>

%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

space	[[:space:]]
					<</declare_section>>
					<<lex_section>>
{space}			++ncnt; ++nchars; cout << yytext << " +1" << endl;
{space}{2}		ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{space}+		ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
111 -113 11 107 -106 2 -51 76 -112 -119 102 -121 -122 27 -47 77 
-109 32 3 -64 44 25 -9 -31 33 17 69 51 31 -99 67 1 
-1 97 -44 -85 -3 61 -62 78 -65 -111 -83 112 -38 -126 -21 43 
-84 84 56 48 -63 113 -79 68 16 6 -29 39 -59 123 71 41 
-37 4 42 -34 95 86 14 91 19 85 -8 45 -71 -90 -98 89 
10 -32 62 -58 -80 23 74 -43 118 98 -86 126 63 -35 -10 66 
109 -13 -127 72 46 -94 -19 58 -102 -81 122 -11 -55 121 83 117 
-72 116 -114 101 -16 9 53 -5 -69 -15 -95 -50 52 -117 -33 -66 
-49 -92 124 -115 99 28 -7 108 -110 0 -2 -107 -77 55 -18 94 
-78 88 12 7 -4 37 -74 -24 22 -46 -52 64 15 -89 8 103 
-30 -45 -97 114 -101 -96 -20 -26 -128 -36 -57 18 5 -48 -40 79 
-22 -91 13 29 -104 100 73 -108 -88 70 75 -6 -53 57 -73 93 
-76 92 -123 80 105 -75 21 81 -67 -103 -42 82 -125 -68 -17 -120 
115 59 87 -124 120 90 -28 -27 106 24 96 -14 119 30 26 60 
-118 47 -82 -25 110 104 -70 49 65 -56 20 34 -61 -105 50 -23 
-93 -60 40 35 54 38 125 127 -100 -41 -87 36 -39 -54 -12 -116 
				<</bytefile>>
				<<bytefile "result.out">>
11 32 43 49 10 32 32 43 49 10 10 32 43 49 10 9 
32 43 49 10 12 32 43 49 10 13 32 43 49 10 54 32 
54 10
				<</bytefile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>
			<<case "charset-posix-upper" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - upper
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

upper	[[:upper:]]
					<</declare_section>>
					<<lex_section>>
{upper}			++ncnt; ++nchars; cout << yytext << " +1" << endl;
{upper}{2}		ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{upper}+		ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-34 -84 -47 -124 91 80 -37 87 -104 48 74 -16 -126 -61 1 -62 
-67 58 102 34 32 -33 110 65 -102 85 75 124 -77 -125 122 -25 
7 -118 28 -13 70 -15 107 83 104 13 -65 27 49 42 46 10 
-23 69 90 101 -4 -80 5 -95 -49 120 119 62 15 23 66 67 
44 45 -53 20 -127 12 24 60 76 99 -20 57 59 -121 30 -123 
93 -103 29 -5 -31 -113 -41 118 72 21 0 -98 -22 54 73 -101 
-63 100 43 -6 -99 113 97 -10 38 -97 -40 17 11 -71 71 36 
-17 82 -26 -35 86 121 4 64 98 -114 -78 -46 -105 -30 94 -57 
117 63 25 22 -94 39 -119 -11 40 78 -106 -86 -54 111 95 18 
123 77 -39 89 52 -91 -115 -109 127 -48 50 33 -120 -100 79 68 
126 55 -9 2 -68 -107 -90 -89 -88 -87 -117 -85 14 -83 -82 -81 
53 -79 -122 19 -76 -75 -74 -73 -72 109 -70 -69 -92 16 -66 61 
-64 96 51 41 -60 -59 -58 8 -56 -55 -116 88 -52 -51 -50 56 
81 -93 -112 -45 -44 -43 -42 116 106 -110 -38 6 -36 115 -128 27 
-32 84 125 -29 -28 -27 114 31 -24 9 92 -21 47 -19 -18 112 
108 37 -14 35 -12 -111 103 3 -8 -7 -96 105 -108 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
P +1
W +1
J +1
A +1
UK +4
F +1
S +1
EZ +4
BC +4
L +1
H +1
I +1
G +1
R +1
V +1
N +1
M +1
Y +1
OD +4
X +1
Q +1
T +1
34 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>
			<<case "charset-posix-xdigit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - xdigit
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

xdigt	[[:xdigit:]]
					<</declare_section>>
					<<lex_section>>

{xdigt}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{xdigt}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{xdigt}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
121 -78 -90 74 45 -59 -107 80 -96 112 78 -54 -113 -84 56 -63 
-73 9 -79 10 8 -8 42 69 111 104 118 57 -88 117 95 -87 
-81 38 -40 70 85 54 -67 -121 -37 -45 32 44 127 -60 -19 22 
40 -46 109 -122 3 -68 29 43 99 90 -98 -76 -117 -125 -4 61 
-111 53 -62 31 123 2 -39 68 -126 103 86 -118 11 -24 114 -72 
50 115 27 -14 18 -53 94 -77 -103 126 13 -31 -23 72 -22 -42 
89 -16 -34 -94 63 -70 -66 75 -12 -51 -100 -85 -35 60 5 28 
-115 -120 65 -30 79 98 -128 -97 -92 -1 6 113 -36 -102 -29 15 
119 37 -6 105 27 -61 36 19 25 21 39 -91 -114 110 -21 91 
-112 30 24 67 34 35 -38 1 -9 58 -11 -93 -26 -17 -3 -20 
4 73 17 66 -104 -7 -47 -32 -127 0 -2 64 -65 -50 -74 -110 
-123 106 -105 -124 83 33 52 122 -15 -108 102 100 -75 88 125 107 
-95 -10 -5 51 -58 93 97 49 71 -116 108 -44 23 -71 124 -101 
82 62 46 -82 -86 14 55 -41 47 76 12 77 101 48 -64 59 
-55 116 87 -13 7 -119 -52 20 81 -28 92 -99 -33 -56 -49 -69 
-48 -109 -106 -89 41 -80 -27 120 -25 96 -57 -83 84 16 -43 -18 
				<</bytefile>>
				<<textfile "result.out">>
8 +1
E +1
9 +1
F +1
6 +1
c +1
5 +1
D +1
2 +1
A +1
b +1
C +1
B +1
4 +1
fd +4
3 +1
a1 +4
7 +1
e0 +4
28 22
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>


<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>
			<<case "charset-single-a" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
Test charset set has only a single char
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

aset	[a]
					<</declare_section>>
					<<lex_section>>
{aset}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{aset}{2,5}	ncnt += 2 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 2 << endl;
{aset}+		ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abbbbbbaaaaaaaaaabbaaaaaaaaabbbbbbaaaaaaaabaaaaaaaaaaaaaaabbbaaaaaaaabbaaaaabbbaaabaabbaaaabbbaaabbabbbaabbbbb
				<</textfile>>
				<<textfile "result.out">>
a +1
aaaaaaaaaa +30
aaaaaaaaa +27
aaaaaaaa +24
aaaaaaaaaaaaaaa +45
aaaaaaaa +24
aaaaa +10
aaa +6
aa +4
aaaa +8
aaa +6
a +1
aa +4
190 71
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/charset---------->>>



<<<----------sub-suite: /lex-alone/basic/lookahead---->>>
		<<suite "lookahead" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>
			<<case "lookahead-mixture" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore, yyless, yyunput
*/
					<</desc>>
					<<lex_section>>
"hell"			
"hello"(\,?" ")?	cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;
			yymore();

"seat"			cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;
			yyless(1);
			yyunput('b');

"beat"			cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;

"seat"/tle		cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;
			yyless(1);
			yyunput('b');

"beat"/tle		cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;

.|\n			cout << yytext;
					<</lex_section>>

					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
seat-eh, hello, seattle
				<</textfile>>
				<<textfile "result.out">>

whole-text = seat
lookahead-text = 
valid-text = seat

whole-text = beat
lookahead-text = 
valid-text = beat
-eh, 
whole-text = hello, 
lookahead-text = 
valid-text = hello, 

whole-text = hello, seattle
lookahead-text = tle
valid-text = hello, seattle
bello, 
whole-text = seattle
lookahead-text = tle
valid-text = seattle

whole-text = beattle
lookahead-text = tle
valid-text = beattle
tle
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>
			<<case "lookahead-multiple" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/
					<</desc>>
					<<init_code>>
int lineno = 1;
bool bla = false;
					<</init_code>>
					<<declare_section>>

cid	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	for(--yyleng; yytext[yyleng] == ' ' || yytext[yyleng] == '\t'; --yyleng) {
				
			}
			++yyleng;
			yytext[yyleng] = '\0';
			bla = true;
			cout << "k" << lineno << ":" << yytext << endl;	
if		|
else		|
return		|
#include		cout << "t" << lineno << ":" << yytext << endl; 
.			if(bla) {
				cout << yytext << endl;
			}
			bla = false;
\n			++lineno;
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/

%{

#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*

%%
	int lineno = 1;
	bool bla = false;

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	for(--yyleng; yytext[yyleng] == ' ' || yytext[yyleng] == '\t'; --yyleng) {
				
			}
			++yyleng;
			yytext[yyleng] = '\0';
			bla = true;
			cout << "k" << lineno << ":" << yytext << endl;	
if		|
else		|
return		|
#include		cout << "t" << lineno << ":" << yytext << endl; 
.			if(bla) {
				cout << yytext << endl;
			}
			bla = false;
\n			++lineno;
%%
/*do nothing */

using namespace yynsx;

int main(int argc, char **argv) {

	if(0 != yylex(NULL)) {
		
		return -1;
	}
	else {
		return 0;
	}
}
				<</textfile>>
				<<textfile "result.out">>
k7:#include
<
t18:if
t19:else
t20:return
t21:#include
t28:if
t29:else
k30:return
	
t31:#include
k32:if
(
k44:if
(
k46:return
 
k48:else
{
k49:return
 
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>
			<<case "lookahead-single" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test basic functionality of lookahead feature
*/
					<</desc>>
					<<init_code>>
int abcs = 0;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
abc/d	++abcs;
	cout << "whole-text = " << yytext << endl;	
	cout << "lookahead-text = " << &yytext[yyleng] << endl;
	yytext[yyleng] = '\0';
	cout << "valid-text = " << yytext << endl;

abc
.|\n	cout << yytext;

<<EOF>>	cout << "number of \"abc/d\" is " << abcs << endl;
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abcd
abc
babcd
babc
				<</textfile>>
				<<textfile "result.out">>
whole-text = abcd
lookahead-text = d
valid-text = abc
d

bwhole-text = abcd
lookahead-text = d
valid-text = abc
d
b
number of "abc/d" is 2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>
			<<case "lookahead-yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yyless
*/
					<</desc>>
					<<init_code>>
bool bla = false;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
gabcde/f	cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		yyless(1);
		bla = true;

abc/d		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		yyless(1);
		bla = true;

b/c		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;

abc		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = false;

.|\n		if(bla) {
			cout << yytext << endl;
		}
		bla = false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
gabcdefg
				<</textfile>>
				<<textfile "result.out">>
whole-text = gabcdef
lookahead-text = f
valid-text = gabcde
whole-text = abcd
lookahead-text = d
valid-text = abc
whole-text = bc
lookahead-text = c
valid-text = b
c
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>
			<<case "lookahead-yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore
*/
					<</desc>>
					<<init_code>>
bool bla = false;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
Hello\,\040/world\!	{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;
		yymore();
	}
world\!			{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = false;
	}
Michael/" "Jodan	{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;
		yymore();
	}
" "Jodan		{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = false;
	}

Jackson"--"/King" of "R"&"R	{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;
	}

.|\n		if(bla) {
			cout << yytext << endl;
		}
		bla = false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
Hello, world!
Michael Jodan
Jackson--King of R&R
abc
				<</textfile>>
				<<textfile "result.out">>
whole-text = Hello, world!
lookahead-text = world!
valid-text = Hello, 
whole-text = Hello, world!
lookahead-text = 
valid-text = Hello, world!
whole-text = Michael Jodan
lookahead-text =  Jodan
valid-text = Michael
whole-text = Michael Jodan
lookahead-text = 
valid-text = Michael Jodan
whole-text = Jackson--King of R&R
lookahead-text = King of R&R
valid-text = Jackson--
K
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/lookahead---->>>


<<<----------sub-suite: /lex-alone/basic/option---->>>
		<<suite "option" make="subdir-makefile-template">>


<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>
			<<case "lex-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: duplicated option

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%option debug=1
%option debug=yes
%option debug="yes"
					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>


<<<----------case: /lex-alone/basic/option/lex-option1--->>>
			<<case "lex-option1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test option setting
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	{
		cout << yytext << endl;
		++ncnt;
	}
.|\n

					<</lex_section>>
					<<before_init>>
int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test option setting
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*

%%
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	{
		cout << yytext << endl;
		++ncnt;
	}
.|\n

%%

using namespace yynsx;

int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
option
setting
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
option
debug
option
debug1
option
verbose
off
option
detail
on
option
just
test
yes
option
you
are
joking
true
option
file
path
upgen
option
file
name
no
title
c
cpp
id
cidf
cids
Aa
Dd
Ss
Uu
Bb
Mm
Uu
Ll
Dd
Ii
Vv
id
cout
yytext
endl
ncnt
n
using
namespace
yynsx
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
89
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-option1--->>>


<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>
			<<case "lex-unsupported" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: unsupported options
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%array
%pointer
%8bit
%case-insentitive

					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/option---->>>


<<<----------sub-suite: /lex-alone/basic/reop---->>>
		<<suite "reop" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>
			<<case "charset-plus" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexical analyse float number in C
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &ints, int &floats %}
%actual-param%{ ints, floats %}

int		[\+\-]?[0-9]+
basic		{int}(\.[0-9]+)?
float		{basic}([EFef]{int})?
					<</declare_section>>
					<<lex_section>>
{int}
		cout << yytext << endl;
		++ints;
{float}

		cout << yytext << endl;

		++floats;
.|\n

					<</lex_section>>
					<<before_init>>
	int ni = 0, nf = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ni, nf);
	cout << "number of integer: " << ni << endl
	     << "number of float: " << nf << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
123
39999999900000000000E
234.5Fa3423
23f4.5
566666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
39999999900000000000
234.5
3423
23f4
5
566666
3
45e0
3
4.5
6E8
4E34
5
6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9
7F3
4
number of integer: 10
number of float: 11
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>

<<<----------case: /lex-alone/basic/reop/charset-range--->>>
			<<case "charset-range" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: range

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &cnt1, int &cnt2, int &cnt3, int &cnt4 %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

eq4a	a{4}
lt3b	b{,3}
gt2c	c{2,}
d2t5	d{2,5}
					<</declare_section>>
					<<lex_section>>

{eq4a}		++cnt1; cout << yytext << " --> match {eq4a}" << endl;
{lt3b}		++cnt2; cout << yytext << " --> match {lt3b}" << endl;
{gt2c}		++cnt3; cout << yytext << " --> match {gt2c}" << endl;
{d2t5}		++cnt4; cout << yytext << " --> match {d2t5}" << endl;
.|\n
<<EOF>>		cout << "end of file reached." << endl;
					<</lex_section>>
					<<before_init>>
	int ncnt1 = 0, ncnt2 = 0, ncnt3 = 0, ncnt4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex( ncnt1, ncnt2, ncnt3, ncnt4);
	cout << "aaa: " << ncnt1 << endl
	     << "-bbb: " << ncnt2 << endl
	     << "cc-: " << ncnt3 << endl
	     << "dd-ddddd: " << ncnt4 << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
.aaaddd.........aaaadddddddd.......aaaaaabbabbbbbbbbbbbbbbbaaaaaaaaabdddddddddd.......................................ddd................ccccccccccddddddddddddddddddddddddddddddaaaaaaabbbbbbbbbbbbbbbbdddd..ddddddd...............ddddd...ccccdddddddddddddddddddddddcccccccdbbbbbbbbbbcccccccccccccccccccccccdddd...aaaaaaaaaacccccccccddddddddddddbbbbbbbbbcccccc........aaaaaaaaa.........aaaddd......ddd......bbbbbbbbbbcccccccccccddd......aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadddddddddd.ccccccdddddddddddddddddddddddcccccccccddddddddddddaabbbbbbbbbbbbbbbbbbbbbbdddddd........................ccccccddddd
				<</textfile>>
				<<textfile "result.out">>
ddd --> match {d2t5}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddd --> match {d2t5}
aaaa --> match {eq4a}
bb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
b --> match {lt3b}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
cccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
aaaa --> match {eq4a}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
dddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
ddddd --> match {d2t5}
cccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccc --> match {gt2c}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccccccccccccccc --> match {gt2c}
dddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
cccccc --> match {gt2c}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddd --> match {d2t5}
ddd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccc --> match {gt2c}
ddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
end of file reached.
aaa: 22
-bbb: 32
cc-: 10
dd-ddddd: 40
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-range--->>>

<<<----------case: /lex-alone/basic/reop/charset-star--->>>
			<<case "charset-star" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexically analyse real number in PASCAL
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

/* unsigned positve integer */
nonzero		[1-9][0-9]*
/* natural number */
natural		0|{nonzero}
/* mantissa */
mant		[0-9]*[1-9]
/* basic representation of real number*/
basic		[\+\-]?{natural}(\.{mant})?
/* scientific representatio of real number */
/*scient		{basic}[Ee][\+\-]{nonzero}*/
/* pascal real number */
preal		{basic}([Ee][\+\-]?{nonzero})?
					<</declare_section>>
					<<lex_section>>

{preal}		{
		cout << yytext << endl;
		++ncnt;
		}

.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
123
234.5ea3423
23e4.5
566a666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
234.5
3423
23e4
5
566
666
3
45
0.3
4.5
6E8
4E34
5
6E8
9.7
34
9
7
3
4
21
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-star--->>>

<<<----------case: /lex-alone/basic/reop/charset-union--->>>
			<<case "charset-union" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: union
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &cnt1, int &cnt2, int &cnt3, int &cnt4 %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

int	(\+|\-)?((0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*|0)
hex	\\(X|x)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)
oct	\\(0|1|2|3)(0|1|2|3|4|5|6|7)(0|1|2|3|4|5|6|7)
real	{int}(\.(0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*)?
					<</declare_section>>
					<<lex_section>>

{int}		++cnt1;
		cout << yytext << endl;
{hex}		++cnt2;
		cout << yytext << endl;
{oct}		++cnt3;
		cout << yytext << endl;
{real}		++cnt4;
		cout << yytext << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt1 = 0, ncnt2 = 0, ncnt3 = 0, ncnt4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt1, ncnt2, ncnt3, ncnt4);
	cout << "int: " << ncnt1 << endl
	     << "hex: " << ncnt2 << endl
	     << "oct: " << ncnt3 << endl
	     << "real: " << ncnt4 << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
\X3289f
434.3300.342.43423.9324.4320
\580523
\2347843
tfghui90ioik568io
00.00.00.00.00.00.090000
00x9000

				<</textfile>>
				<<textfile "result.out">>
\X32
89
434.33
0
0.342
43423.9324
432
0
58
0523
\234
7843
9
0
568
0
0.0
0.0
0.0
0.0
0.0
0.09
0
0
0
0
0
0
9
0
0
0
int: 21
hex: 1
oct: 1
real: 9
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-union--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/reop---->>>


<<<----------sub-suite: /lex-alone/basic/rule---->>>
		<<suite "rule" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>
			<<case "rule-bol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test bol(beginning of line) flag
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{int &bols, int &nbols%}
%actual-param%{bols, nbols%}
					<</declare_section>>
					<<lex_section>>
^"#include"	{
		cout << yytext << " => matched ^\"#include\"" << endl;
		++bols;
	}
"#include"	{
		cout << yytext << " => matched \"#include\"" << endl;
		++nbols;
	}
"#import"	{
		cout << yytext << " => matched \"#import\"" << endl;
		++nbols;
	}
^"#if"		{
		cout << yytext << " => matched ^\"#if\"" << endl;
		++bols;
	}
"#if"		{
		cout << yytext << " => matched \"#if\"" << endl;
		++nbols;
	}
"#cond"		{
		cout << yytext << " => matched \"#cond\"" << endl;
		++nbols;
	}
.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "at_bol: " << n1 << endl 
	     << "not_at_bol: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test regular expression: bol flag is set

Sample:
#include
 #include
#import
	#import
#if #if
#cond
#cond

*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{int &bols, int &nbols%}
%actual-param%{bols, nbols%}

%%
^"#include"	{
		cout << yytext << " => matched ^\"#include\"" << endl;
		++bols;
	}
"#include"	{
		cout << yytext << " => matched \"#include\"" << endl;
		++nbols;
	}
"#import"	{
		cout << yytext << " => matched \"#import\"" << endl;
		++nbols;
	}
^"#if"		{
		cout << yytext << " => matched ^\"#if\"" << endl;
		++bols;
	}
"#if"		{
		cout << yytext << " => matched \"#if\"" << endl;
		++nbols;
	}
"#cond"		{
		cout << yytext << " => matched \"#cond\"" << endl;
		++nbols;
	}
.|\n

%%

using namespace yynsx;

int main(int argc, char **argv) {

	int n1 = 0, n2 = 0;
	int nret = yylex(NULL, n1, n2);
	
	cout << "at_bol: " << n1 << endl 
	     << "not_at_bol: " << n2 << endl;
	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
#include => matched ^"#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched ^"#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
#include => matched ^"#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
at_bol: 3
not_at_bol: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>
			<<case "rule-bol-sc-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 1
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &as, int &bs%}
%actual-param%{ as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	as += 2; cout << yytext << " => matched `^a\'" << endl;
a	++as; cout << yytext << " => matched `a\'" << endl;
^b	bs += 2; cout << yytext << " => matched `^b\'" << endl;
b	++bs; cout << yytext << " => matched `b\'" << endl;

.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abc		2	1
actual bonus	5	2
beta		6	4
beattles	7	6
business man	8	8
blog address	9	10
as useful tool	11	10

				<</textfile>>
				<<textfile "result.out">>
a => matched `^a'
b => matched `b'
a => matched `^a'
a => matched `a'
b => matched `b'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
a => matched `^a'
a's: 11
b's: 10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>
			<<case "rule-bol-sc-2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 2
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &as, int &bs%}
%actual-param%{ as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	as += 2; cout << yytext << " => matched `^a\'" << endl;
a	++as; cout << yytext << " => matched `a\'" << endl;
b	++bs; cout << yytext << " => matched `b\'" << endl;
^bb	bs += 4; cout << yytext << " => matched `^bb\'" << endl;

.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
bbcc...aaa	3	4
aa		6	4
bbbbbb		6	12
cccaacccc	8	12
aaaaaaaa	17	12
...bbcbbb	17	17
ccaaa		20	17
aaax		24	17
xaaa		27	17
...aa		29	17
bbabjjabaa	33	23
bababa		36	26
a......aa	40	26
aa		43	26
aaabbb		47	29
				<</textfile>>
				<<textfile "result.out">>
bb => matched `^bb'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
bb => matched `^bb'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
bb => matched `^bb'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
a's: 47
b's: 29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>
			<<case "rule-bol-sc-3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &bs, int &cs, int &ds, int &es, int &fs, int &gs%}
%actual-param%{ as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>

a|b		if(yytext[0] == 'a') {

			++as;
			yy_push_state(asc);
		}
		else {
			++bs;
			yy_push_state(bsc);
		}
<*>[cd]		switch(yytext[0]) {
		case 'c': cs += 2; break;
		default:  ds += 2; break;
		}
<asc,bsc>[abce]	switch(yytext[0]) {
		case 'a': as += 3; break;
		case 'b': bs += 3; break;
		case 'c': cs += 3; break;
		default:  es += 3; break;
		}
<asc>f		fs += 4;
<bsc>[fg]	if(yytext[0] == 'f')
			fs += 5;
		else
			gs += 5;
<asc>aa		yy_pop_state(); as += 6;
<bsc>bb		yy_pop_state(); bs += 6;
<*>.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4, n5, n6, n7);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl
	     << "c's: " << n3 << endl
	     << "d's: " << n4 << endl
	     << "e's: " << n5 << endl
	     << "f's: " << n6 << endl
	     << "g's: " << n7 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			7	0	0	0	0	0	0
a			8	0	0	0	0	0	0
	ggggg		8	0	0	0	0	0	0
	cccc		8	0	8	0	0	0	0
	ddddd		8	0	8	10	0	0	0
	fffff		8	0	8	10	0	20	0
aa			14	0	8	10	0	20	0
a			15	0	8	10	0	20	0
aa			21	0	8	10	0	20	0
a			22	0	8	10	0	20	0
	bbbbbbb		22	21	8	10	0	20	0
	ddddddddd	22	21	8	28	0	20	0
	ee		22	21	8	28	6	20	0
aa			28	21	8	28	6	20	0
a			29	21	8	28	6	20	0
aa			35	21	8	28	6	20	0
a			36	21	8	28	6	20	0
aa			42	21	8	28	6	20	0
b			42	22	8	28	6	20	0
bb			42	28	8	28	6	20	0
b			42	29	8	28	6	20	0
bb			42	35	8	28	6	20	0
b			42	36	8	28	6	20	0
bb			42	42	8	28	6	20	0
b			42	43	8	28	6	20	0
bb			42	49	8	28	6	20	0
b			42	50	8	28	6	20	0
bb			42	56	8	28	6	20	0
b			42	57	8	28	6	20	0
	ggggg..........	42	57	8	28	6	20	25
	g		42	57	8	28	6	20	30
	a		45	57	8	28	6	20	30
	ddddddd		45	57	8	42	6	20	30
	eeeee		45	57	8	42	21	20	30
	f		45	57	8	42	21	25	30
	eeeeeeeee	45	57	8	42	48	25	30
	ffff		45	57	8	42	48	45	30
	aaaaaaa		66	57	8	42	48	45	30
bb			66	63	8	42	48	45	30
b			66	64	8	42	48	45	30
bb			66	70	8	42	48	45	30
b			66	71	8	42	48	45	30
	cccccccc	66	71	24	42	48	45	30
	ddddd....	66	71	24	52	48	45	30
bb			66	77	24	52	48	45	30
a			67	77	24	52	48	45	30
	a		70	77	24	52	48	45	30
	cccc		70	77	32	52	48	45	30
	ddddd		70	77	32	62	48	45	30
	ffffff		70	77	32	62	48	69	30
	gggggg		70	77	32	62	48	69	30
	ddddd		70	77	32	72	48	69	30
	e		70	77	32	72	51	69	30
	ffggggg		70	77	32	72	51	77	30
	ee		70	77	32	72	57	77	30
	b		70	80	32	72	57	77	30
	dddd		70	80	32	80	57	77	30
	eeee		70	80	32	80	69	77	30
				<</textfile>>
				<<textfile "result.out">>
a's: 70
b's: 80
c's: 32
d's: 80
e's: 69
f's: 77
g's: 30
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>
			<<case "rule-bol-sc-4" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 4
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &bs, int &cs, int &ds, int &es, int &fs, int &gs%}
%actual-param%{ as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc

					<</declare_section>>
					<<lex_section>>

\{|\[		switch(yytext[0]) {
		case '{': BEGIN(asc); break;
		default:  BEGIN(bsc); break;
		}
<asc>^[abcdefg]	switch(yytext[0]) {
		case 'a': --as; break;
		case 'b': --bs; break;
		case 'c': --cs; break;
		case 'd': --ds; break;
		case 'e': --es; break;
		case 'f': --fs; break;
		default:  --gs; break;
		}

<asc>[abcdefg]	switch(yytext[0]) {
		case 'a': ++as; break;
		case 'b': ++bs; break;
		case 'c': ++cs; break;
		case 'd': ++ds; break;
		case 'e': ++es; break;
		case 'f': ++fs; break;
		default:  ++gs; break;
		}

<bsc>^[abcdefg]	switch(yytext[0]) {
		case 'a': as -= 2; break;
		case 'b': bs -= 2; break;
		case 'c': cs -= 2; break;
		case 'd': ds -= 2; break;
		case 'e': es -= 2; break;
		case 'f': fs -= 2; break;
		default:  gs -= 2; break;
		}
<bsc>[abcdefg]	switch(yytext[0]) {
		case 'a': as += 2; break;
		case 'b': bs += 2; break;
		case 'c': cs += 2; break;
		case 'd': ds += 2; break;
		case 'e': es += 2; break;
		case 'f': fs += 2; break;
		default:  gs += 2; break;
		}
<asc>\}		BEGIN(INITIAL);
<bsc>\]		BEGIN(INITIAL);

<*>^[abcdefg]	switch(yytext[0]) {
		case 'a': as -= 3; break;
		case 'b': bs -= 3; break;
		case 'c': cs -= 3; break;
		case 'd': ds -= 3; break;
		case 'e': es -= 3; break;
		case 'f': fs -= 3; break;
		default:  gs -= 3; break;
		}
<*>[abcdefg]	switch(yytext[0]) {
		case 'a': as += 3; break;
		case 'b': bs += 3; break;
		case 'c': cs += 3; break;
		case 'd': ds += 3; break;
		case 'e': es += 3; break;
		case 'f': fs += 3; break;
		default:  gs += 3; break;
		}

^[abcdefg]	switch(yytext[0]) {
		case 'a': as -= 1000; break;
		case 'b': bs -= 1000; break;
		case 'c': cs -= 1000; break;
		case 'd': ds -= 1000; break;
		case 'e': es -= 1000; break;
		case 'f': fs -= 1000; break;
		default:  gs -= 1000; break;
		}
[abcdefg]	switch(yytext[0]) {
		case 'a': as += 1000; break;
		case 'b': bs += 1000; break;
		case 'c': cs += 1000; break;
		case 'd': ds += 1000; break;
		case 'e': es += 1000; break;
		case 'f': fs += 1000; break;
		default:  gs += 1000; break;
		}
<*>.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4, n5, n6, n7);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl
	     << "c's: " << n3 << endl
	     << "d's: " << n4 << endl
	     << "e's: " << n5 << endl
	     << "f's: " << n6 << endl
	     << "g's: " << n7 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			1	0	0	0	0	0	0
a			0	0	0	0	0	0	0
	ggggg		0	0	0	0	0	0	5
cccc			0	0	2	0	0	0	5
	ddddd		0	0	2	5	0	0	5
	fffff		0	0	2	5	0	5	5
aa			0	0	2	5	0	5	5
a	aaa		2	0	2	5	0	5	5
aa	aaa		5	0	2	5	0	5	5
aa			5	0	2	5	0	5	5
bbb	bbb		5	4	2	5	0	5	5
ddd	dddd		5	4	2	10	0	5	5
ee	ee		5	4	2	10	2	5	5
aa	a		6	4	2	10	2	5	5
a			5	4	2	10	2	5	5
aa	aaa		8	4	2	10	2	5	5
a	a		8	4	2	10	2	5	5
}
[
aa			8	4	2	10	2	5	5
b			8	2	2	10	2	5	5
bb			8	2	2	10	2	5	5
b			8	0	2	10	2	5	5
bb			8	0	2	10	2	5	5
b			8	-2	2	10	2	5	5
bb			8	-2	2	10	2	5	5
b			8	-4	2	10	2	5	5
bb			8	-4	2	10	2	5	5
b			8	-6	2	10	2	5	5
bb			8	-6	2	10	2	5	5
b			8	-8	2	10	2	5	5
	ggggg..........	8	-8	2	10	2	5	15		
	a		10	-8	2	10	2	5	15
a			8	-8	2	16	2	5	15
	ddd		8	-8	2	16	2	5	15
	eeeee		8	-8	2	16	12	5	15
	f		8	-8	2	16	12	7	15
	ee		8	-8	2	16	16	7	15
	ffff		8	-8	2	16	16	15	15
	aaaaaaa		22	-8	2	16	16	15	15
bb			22	-8	2	16	16	15	15
b			22	-10	2	16	16	15	15
bb			22	-10	2	16	16	15	15
b			22	-12	2	16	16	15	15
	cccccccc	22	-12	18	16	16	15	15
	ddddd....	22	-12	18	26	16	15	15
bb			22	-12	18	26	16	15	15
a			20	-12	18	26	16	15	15
	a		22	-12	18	26	16	15	15
	cccc		22	-12	26	26	16	15	15
	ddddd		22	-12	26	36	16	15	15
	ffffff		22	-12	26	36	16	27	15
	ggg		22	-12	26	36	16	27	21
	ddddd		22	-12	26	46	16	27	21
	e		22	-12	26	46	18	27	21
	ffggggg		22	-12	26	46	18	31	31
	ee		22	-12	26	46	22	31	31
	b		22	-10	26	46	22	31	31
	dddd		22	-10	26	54	22	31	31
	eeee		22	-10	26	54	30	31	31
]

	eeeeeeeeee	22	-10	26	54	60	31	31
	eeeeeeeeee	22	-10	26	54	90	31	31
	eeeeeeeeee	22	-10	26	54	120	31	31
b			22	-13	26	54	120	31	31
b			22	-16	26	54	120	31	31
b			22	-19	26	54	120	31	31
b			22	-22	26	54	120	31	31
b			22	-25	26	54	120	31	31
b			22	-28	26	54	120	31	31
bgggggggggggggggggggg	22	-31	26	54	120	31	91
bgggggggggggggggggggg	22	-34	26	54	120	31	151
bgggggggggggggggggggg	22	-37	26	54	120	31	211
				<</textfile>>
				<<textfile "result.out">>
a's: 22
b's: -37
c's: 26
d's: 54
e's: 120
f's: 31
g's: 211
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>

<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>
			<<case "rule-eof-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE <<EOF>>
*/
					<</desc>>
					<<init_code>>
int current_sc = 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &bs, int &cs, int &eofs%}
%actual-param%{ as, bs, cs, eofs %}

%x	asc
%s	bsc
%x	csc

					<</declare_section>>
					<<lex_section>>
<*><<EOF>>		++eofs;
a			BEGIN(asc); current_sc = 1;
b			BEGIN(bsc); current_sc = 2;
c			BEGIN(csc); current_sc = 3;
<asc,bsc,csc>[abc]	switch(yytext[0]) {
			case 'a':
				if(current_sc == 1) {
					BEGIN(INITIAL);
					current_sc = 0;
				}
				else
					as += 2;
				break;
			case 'b':
				if(current_sc == 2) {
					BEGIN(INITIAL);
					current_sc = 0;
				}
				else
					bs += 2;
				break;
			default: 
				if(current_sc == 3) {
					BEGIN(INITIAL);
					current_sc = 0;
				}
				else
					cs += 2;
				break;
			}
			
<*>.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, eofs = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, eofs);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl
	     << "c's: " << n3 << endl
	     << "eof's: " << eofs << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abba	 0 2 0
accca    0 2 3
baaaaaab 6 2 3
cbbbc    6 5 3
bccb     6 5 5
baaaab   105 5
accca    105 8
cccbbbbc 109 8
bccb     10910
aba      101010
				<</textfile>>
				<<textfile "result.out">>
a's: 20
b's: 20
c's: 20
eof's: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>
			<<case "rule-eol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE $
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &lines%}
%actual-param%{ lines %}
					<</declare_section>>
					<<lex_section>>
\.$	++lines;
.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1);
	cout << "lines: " << n1 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
In the time since the 1986 edition of this book, the world of compiler design
has changed significantly. Programming languages have evolved to present new
compilation problems. Computer architectures offer a variety of resources of
which the compiler designer must take advantage. Perhaps most interestingly,
the venerable technology of code optimization has found use outside compilers.
It is now used in tools that find bugs in software, and most importantly, find		1
security holes in existing code. And much of the "front-end" technology -
grammars, regular expressions, parsers, and syntax-directed translators - are
still in wide use.
Thus, our philosophy from previous versions of the book has not changed.
We recognize that few readers will build, or even maintain, a compiler for a		2/3
major programming language. Yet the models, theory, and algorithms associated
with a compiler can be applied to a wide range of problems in software
design and software development . We therefore emphasize problems that are
most commonly encountered in designing a language processor, regardless of
the source language or target machine.
Use of the Book										4
It takes at least two quarters or even two semesters to cover all or most of the
material in this book. It is common to cover the first half in an undergraduate
course and the second half of the book - stressing code optimization - in
a second course at the graduate or mezzanine level. Here is an outline of the
chapters:
Chapter 1 contains motivational material and also presents some background
issues in computer architecture and programming-language principles.
Chapter 2 develops a miniature compiler and introduces many of the important		5
concepts, which are then developed in later chapters. The compiler itself
appears in the appendix.
Chapter 3 covers lexical analysis, regular expressions, finite-state machines, and	6
scanner-generator tools. This material is fundamental to text-processing of all
sorts.
											7
Chapter 4 covers the major parsing methods, top-down (recursive-descent , LL)
and bottom-up (LR and its variant s) .
Chapter 5 introduces the principal ideas in syntax-directed definitions and		8
syntax-directed translations.
Chapter 6 takes the theory of Chapter 5 and shows how to use it to generate		9
intermediate code for a typical programming language.
Chapter 7 covers run-time environment s, especially management of the run-time		10
stack and garbage collection.
Chapter 8 is on object-code generation. It covers construction of basic blocks,		11
generation of code from expressions and basic blocks, and register-allocation
techniques.
Chapter 9 introduces the technology of code optimization, including flow graphs,	12
data-flow frameworks, and iterative algorithms for solving these fr ameworks .
Chapter 10 covers instruction-level optimization. The emphasis is on the extraction	13
of parallelism from small sequences of instructions and scheduling them
on single processors that can do more than one thing at once.
Chapter 11 talks about larger-scale parallelism detection and exploitation. Here,	14
the emphasis is on numeric codes that have many tight loops that range over
multidimensional arrays.
Chapter 12 is on interprocedural analysis. It covers pointer analy sis, aliasing,	15
and data-flow analysis that takes into account the sequence of procedure calls
that reach a given point in the code.
Courses fr om material in this book have been taught at Columbia, Harvard,		16
and Stanford. At Columbia, a senior/first-year graduate course on programming
languages and translators has been regularly offered using material fr om
the first eight chapters. A highlight of this course is a semester-long project
in which students work in small teams to create and implement a little language
of their own design. The student-created languages have covered diverse
application domains including quantum computation, music synthesis, computer
graphics, gaming, matrix operations and many other areas. Students use
compiler-comp onent generators such as ANTLR, Lex, and Yacc and the syntaxdirected
translation techniques discussed in chapters two and five to build their
compilers. A follow-on graduate course has fo cused on material in Chapters 9
through 12, emphasizing code generation and optimization for contemporary
machines including network processors and multiprocessor architectures.
At Stanford, a one-quarter introductory course covers roughly the material		17
in Chapters 1 through 8, although there is an introduction to global code
optimization fr om Chapter 9. The second compiler course covers Chapters 9
through 12, plus the more advanced material on garbage collection from Chapter
7. Students use a locally developed , Java- based system called Joeq for
implementing data-flow analysis algorithms.
											18
The reader should possess some "computer-science sophistication," including
at least a second course on programming, and courses in data structures and
discrete mathematics. Knowledge of several different programming languages
is useful.
Exercises										19
The book contains extensive exercises, with some for almost every section. We
indicate harder exercises or parts of exercises with an exclamation point. The
hardest exercises have a double exclamation point.
Gradiance. On-Line Homeworks								20
A feature of the new edition is that there is an accompanying set of on-line
homeworks using a technology developed by Gradiance Corp. Instructors may
assign these homeworks to their class, or students not enrolled in a class may
enroll in an "omnibus class" that allows them to do the homeworks as a tutorial
(without an instructor-created class) . Gradiance questions look like ordinary
questions, but your solutions are sampled. If you make an incorrect choice you
are given specific advice or feedback to help you correct your solution. If your
instructor permits, you are allowed to try again, until you get a perfect score.
A subscription to the Gradiance service is offered with all new copies of this		21
text sold in North America. For more information, visit the Addison-Wesley
web site www . aw . com/gradiance or send email tocomput ing@aw . com.
Support on the World Wide Web								22
The book's home page is
dragonbook . stanford . edu
Here, you will find errata as we learn of them, and backup materials. We hope
to make available the notes for each offering of compiler-related courses as we
teach them, including homeworks, solutions, and exams. We also plan to post
descriptions of important compilers written by their implementers.
											23
				<</textfile>>
				<<textfile "result.out">>
lines: 23
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>
			<<case "rule-mcall-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: macro call
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
dec	[0-9]
hex	[0-9A-Fa-f]
sign	[\+\-]

%formal-param%{ int &decs, int &hexes, int &signs%}
%actual-param%{ decs, hexes, signs%}

					<</declare_section>>
					<<lex_section>>
{dec}+			++decs;	cout << yytext << " [dec]" << endl;
{hex}+			++hexes; cout << yytext << " [hex]" << endl;
{sign}?({dec}+|{hex}+)	++signs; cout << yytext << " [sign]" << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << "dec's: " << n1 << endl
	     << "hex's: " << n2 << endl
	     << "sign's: " << n3 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
b7809
+-45fb
date: 1999.12.31
date: 2010.01.01
time: 23:59:59
time: 01:00:00
money: $999,999.99
phone: 0086-010-12345678
zip-code: 100233
sample text1
.0000-9990*&*$*&@%&ghf892efs
hello world on the earth
hi world in the universe
no more sample

				<</textfile>>
				<<textfile "result.out">>
b7809 [hex]
-45fb [sign]
da [hex]
e [hex]
1999 [dec]
12 [dec]
31 [dec]
da [hex]
e [hex]
2010 [dec]
01 [dec]
01 [dec]
e [hex]
23 [dec]
59 [dec]
59 [dec]
e [hex]
01 [dec]
00 [dec]
00 [dec]
e [hex]
999 [dec]
999 [dec]
99 [dec]
e [hex]
0086 [dec]
-010 [sign]
-12345678 [sign]
-c [sign]
de [hex]
100233 [dec]
a [hex]
e [hex]
e [hex]
1 [dec]
0000 [dec]
-9990 [sign]
f892ef [hex]
e [hex]
d [hex]
e [hex]
ea [hex]
d [hex]
e [hex]
e [hex]
e [hex]
e [hex]
a [hex]
e [hex]
dec's: 19
hex's: 25
sign's: 5
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>
			<<case "rule-multipattern-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: multi REs share same action
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &goods, int &bads%}
%actual-param%{ goods, bads %}
					<</declare_section>>
					<<lex_section>>
"good"		|
"great"		|
"terrific"	|
"nice"		|
"awesome"	{
		++goods;
	}

"horrible"	|
"terrible"	|
"nightmare"	|
"disastrous"	{
		++bads;
	}
.|\n
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "good-words: " << n1 << endl
	     << "bad-words: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
<--- XDICT --->
good
[gud]
n. ,,
a. ,,,,,,
<--- 5.0 --->
good
*[gud]
n. , , 
a. , , , , , , , 
 ; 
:
  for good
  for good or for evil
  good and
  good for
  hold good for
  in good time
  make good
  to the good
  good-bye
  say good-bye to sb
  as good as
<--- stardict1.3 --->
good
[gud]
n. ,;
a. ,,;
<---  --->
good
/ gUd; ^Jd/ adj (better / 5betE(r); `bZtL/, best /best; bZst/)  1 of high quality; of an acceptable standard; satisfactory ; ; ; : a good lecture, performance, harvest    * good pronunciation, behaviour, eyesight    * a good (eg sharp) knife  * Is the light good enough to take photographs? ? * The car has very good brakes. . * Her English is very good. .  2 (a) ~ (at sth) (often used with names of occupations or with ns derived from vs ) able to perform satisfactorily; competent ; : a good teacher, hairdresser, poet, etc    * good at mathematics, languages, describing things    * a good loser, ie one who doesn't complain when he loses . (b) [pred ] ~ with sth/sb capable when using, dealing with, etc sth/sb   : good with one's hands, eg able to draw, make things, etc   * He's very good with children, ie can look after them well, amuse them, etc. .  3 (a) morally acceptable; virtuous ; : a good deed  * try to lead a good life . (b) (esp of a child) well-behaved , : Try to be a good girl. .  4 ~ (to sb) willing to help others; kind ; ; : You were a good girl to help in the shop. , . * He was very good to me when I was ill. . * Would you be good enough to carry this for me? ?  5 pleasant; agreeable; welcome ; ; ; : The firm has had good times and bad times. . * What good weather we're having! ! * Have you heard the good news about my award? ? * It's good to be home again. , .  6 (of food) fit to be eaten; not yet rotting or rotten , : good eggs, fruit, etc   * Separate the good meat from the bad. .  7 [usu attrib ] not diseased; healthy; strong ; ; : good teeth and bones  * Would you speak into my good ear, I can't hear in the other one. , .  8 (of money) not fake or false; genuine , : This note is counterfeit, but that one's good. , . * (fig ) I gave good money for that camera, and it turned out to be worthless. , .  9 [attrib ] (of clothes, etc) used only for more formal or important occasions : My one good suit is at the cleaner's. . * Wear your good clothes to go to church. .  10 [attrib ] thorough; complete; sound ; ; : give sb a good beating, scolding, telling-off, etc    * go for a good long walk  * We had a good laugh at that. .  11 [usu attrib ] amusing ; : a good story, joke, etc   * `That's a good one!' she said, laughing loudly. !.  12 ~ (for sb/sth) beneficial; wholesome ; : the good (ie clean, refreshing) mountain air  * Is this kind of food good for me? ? * Sunshine is good for your plants. . * This cream is good for (ie soothes and heals) burns. .  13 ~ (for sth/to do sth) suitable; appropriate ; : a good time for buying a house/to buy a house  * This beach is good for swimming but bad for surfing. . * She would be good for the job. .  14 ~ for sth (a) (of a person or his credit) such that he will be able to repay (a sum lent) : He/His credit is good for 5000. []5000. (b) having the necessary energy, fitness, durability, etc   : You're good for (ie will live) a few years yet. . * This car's good for many more miles. . (c) valid for sth : The return half of the ticket is good for three months. .  15 (used in greetings ): Good morning/afternoon/evening! !  16 (fml ) (used as a polite, but more often patronizing, form of address or description , ): my good sir, man, friend, etc    * How is your good lady (ie your wife) ? ?  17 [attrib ] (used as a form of praise ): Good old Fred! ! * Good man! That's just what I wanted. ! .  18 [attrib ] (used in exclamations ): Good Heavens! ! * Good God! !  19 (with aa) [attrib ] (a) great in number, quantity, etc  , : a good many people  * We've come a good (ie long) way/distance. . (b) (used with expressions of measurement, quantity, etc  ) not less than; rather more than ; : We waited for a good hour. . * It's a good three miles to the station. . * She ate a good half of the cake. .  20 (idm ) as good as almost; practically ; : He as good as said I'm a liar, ie suggested that I was a liar without actually using the word `liar'. . * The matter is as good as settled. . good and... (infml ) completely ; : I won't go until I'm good and ready. . a good `few a considerable number (of); several ; : `How many came?' `A good few.' ?. * There are still a good few empty seats. . ,good for `sb, `you, `them, etc (infml ) (used when congratulating sb ) sb, etc did well : She passed the exam? Good for her! ? ! (For other idioms containing good, see entries for other major words in each idiom good, ,  (as) good as gold => gold; in good time => time1.)

adv (US infml ) well : Now, you listen to me good! , !

/ gUd; ^Jd/ n  1 [U] that which is morally right or acceptable ; : the difference between good and evil  * Is religion always a force for good? ?  2 [U] that which gives benefit, profit, advantage, etc   : work for the good of one's country  * I'm giving you this advice for your own good. . * Do social workers do a lot of good? ? Cf  do-gooder (do1).  3 the good [pl v] virtuous people : a gathering of the good and the great .  4 (idm ) be no/not much/any/some `good (doing sth) be of no, not much, etc value  ...: It's no good (my) talking to him. . * Was his advice ever any good? ? * This gadget isn't much good. . * What good is it asking her? ? do (sb) `good benefit sb : Eat more fruit: it will do you good. , . * This cough medicine tastes nice but it doesn't do much good, ie isn't very effective. , . * (usu ironic ) Much good may it do you, ie You won't get much benefit from it. . for `good (and `all) permanently; finally ; ; : She says that she's leaving the country for good, ie intending never to return to it. . to the `good (used to describe sb's financial state) in credit : We are 500 to the good, ie We have 500 more than we had. 500. up to no `good (infml ) doing sth wrong, mischievous, etc ; ; : Where's that naughty child now? I'm sure he'll be up to no good wherever he is. ? , .
<--- WordNet --->
good
good
     adj 1: having desirable or positive qualities especially those
            suitable for a thing specified; "good news from the
            hospital"; "a good report card"; "when she was good
            she was very very good"; "a good knife is one good for
            cutting"; "this stump will make a good picnic table";
            "a good check"; "a good joke"; "a good exterior
            paint"; "a good secretary"; "a good dress for the
            office" [ant: {bad}]
     2: having the normally expected amount; "gives full measure";
        "gives good measure"; "a good mile from here" [syn: {full}]
     3: morally admirable [ant: {evil}]
     4: deserving of esteem and respect; "all respectable companies
        give guarantees"; "ruined the family's good name" [syn: {estimable},
         {honorable}, {respectable}]
     5: promoting or enhancing well-being; "an arms limitation
        agreement beneficial to all countries"; "the beneficial
        effects of a temperate climate"; "the experience was good
        for her" [syn: {beneficial}]
     6: superior to the average; "in fine spirits"; "a fine
        student"; "made good grades"; "morale was good"; "had good
        weather for the parade" [syn: {fine}]
     7: agreeable or pleasing; "we all had a good time"; "good
        manners"
     8: of moral excellence; "a genuinely good person"; "a just
        cause"; "an upright and respectable man"; "the life of the
        nation is secure only while the nation is honest,
        truthful, and virtuous"- Frederick Douglass [syn: {just},
        {upright}, {virtuous}]
     9: having or showing knowledge and skill and aptitude; "adept
        in handicrafts"; "an adept juggler"; "an expert job"; "a
        good mechanic"; "a practiced marksman"; "a proficient
        engineer"; "a lesser-known but no less skillful composer";
        "the effect was achieved by skillful retouching" [syn: {adept},
         {expert}, {practiced}, {proficient}, {skillful}, {skilful}]
     10: thorough; "had a good workout"; "gave the house a good
         cleaning"
     11: with or in a close or intimate relationship; "a good
         friend"; "my sisters and brothers are near and dear"
         [syn: {dear}, {near}]
     12: having or showing or arising from a desire to promote the
         welfare or happiness of others; "his benevolent smile";
         "a benevolent nature" [syn: {benevolent}] [ant: {malevolent}]
     13: financially sound; "a good investment"; "a secure
         investment" [syn: {dependable}, {safe}, {secure}]
     14: most suitable or right for a particular purpose; "a good
         time to plant tomatoes"; "the right time to act"; "the
         time is ripe for great sociological changes" [syn: {right},
          {ripe}]
     15: resulting favorably; "its a good thing that I wasn't there";
         "it is good that you stayed"; "it is well that no one saw
         you"; "all's well that ends well" [syn: {well(p)}]
     16: exerting force or influence; "the law is effective
         immediately"; "a warranty good for two years"; "the law
         is already in effect (or in force)" [syn: {effective}, {in
         effect(p)}, {in force(p)}]
     17: feeling healthy and free of aches and pains; "I feel good"
         [syn: {good(p)}]
     18: capable of pleasing; "good looks"
     19: appealing to the mind; "good music"; "a serious book" [syn:
         {serious}]
     20: in excellent physical condition; "good teeth"; "I still have
         one good leg"; "a sound mind in a sound body" [syn: {sound}]
     21: tending to promote physical well-being; beneficial to
         health; "beneficial effects of a balanced diet"; "a good
         night's sleep"; "the salutary influence of pure air"
         [syn: {beneficial}, {salutary}]
     22: not forged; "a good dollar bill"
     23: not left to spoil; "the meat is still good" [syn: {unspoiled},
          {unspoilt}]
     24: generally admired; "good taste"
     [also: {better}, {best}]

good
     n 1: benefit; "for your own good"; "what's the good of worrying?"
     2: moral excellence or admirableness; "there is much good to be
        found in people" [syn: {goodness}] [ant: {evil}, {evil}]
     3: that which is good or valuable or useful; "weigh the good
        against the bad"; "among the highest goods of all are
        happiness and self-realization" [syn: {goodness}] [ant: {bad},
         {bad}]
     [also: {better}, {best}]

good
     adv 1: (often used as a combining form) in a good or proper or
            satisfactory manner or to a high standard (`good' is a
            nonstandard dialectal variant for `well'); "the
            children behaved well"; "a task well done"; "the party
            went well"; "he slept well"; "a well-argued thesis";
            "a well-planned party"; "the baby can walk pretty
            good" [syn: {well}] [ant: {ill}]
     2: in a complete and thorough manner (`good' is sometimes used
        informally for `thoroughly'); "he was soundly defeated";
        "we beat him good" [syn: {thoroughly}, {soundly}]
     [also: {better}, {best}]
<--- CDICT5 --->
good
[gUd;ud]
< good >
[]
(()) gd., G, G.
<<>>
bet.ter, best
1 
  a good experience 
  good news from the hospital 
2 a. 
     a good exterior paint 
     a good joke 
  b. ; 
     Is this a good dress for the party? ?
3 a. 
     The milk is still good. 
  b. ; 
     a good tooth 
4 a. 
     a good student 
  b. ()  ()
5 a. () 
     a good books 
  b. 
     good taste 
6 ; 
  ruined the family's good name 
7 ; 
  good looks 
8 
  a good night's rest 
9 ; 
  a good machinist 
10 ; 
   a good workout 
11 a. 
     a good investment 
   b. 
     a good reason 
   c. ; 
     a good dollar bill 
12 a. 
     a warranty good for two years 
     a driver's license that is still good 
   b. 
     I'm good for another round of golf. 
13 a. ; 
     Is she good for the money that you lent her? ?
   b. 
     He is always good for a laugh. 
14 a. ; 
     a good income 
   b. 
     a good table 
15 
   It is a good mile from here. 
16 a. ; 
     had a good time at the party 
   b. ; 
     good weather 
     a good omen 
17 a. ; 
     a good person 
   b. ; 
     a good soul 
     a good heart 
   c. ; 
     a good Republican 
18 a. ; 
     a good child 
   b. ; 
     good manners 
19
   The first serve was wide, but the second was good. , 
20 (, )
   Good heavens! !
   Good grief! !
<<>>
1 a. 
  b. ; 
2 ; 
  for the common good 
3 ; ; 
  There is much good to be found in people. 
4 ( goods)
  a. ; 
     frozen goods 
  b. ; 
  c. () 
5 ( goods)
  (()) 
  tried to get the goods on the crook 
<<>>
(()) ; 
<<>>
as good as
; 
as good as new  
for good
; 
I'm moving to Europe for good. 
good and
(()) ; 
I'll do it when I am good and ready. , 
no good
(())
1 
2 ; 
  It's no good arguing with them. 
to the good
1 ; 
2 
  ended up to the good 


<--- XDICT --->
great
[greit]
a. ,,,,,,,
ad. 
<--- 5.0 --->
great
*[greit]
a. , , , , , 
ad. , 
n. , , 
:
  in great detail
  great at
  great on
  great with
  a great many
  a great deal
<--- stardict1.3 --->
great
[greit]
a. ,,;
ad. ,;
<---  --->
great
/ greIt; ^ret/ adj (-er, -est)  1 (a) [attrib ] well above average in size, extent or quantity ; ; ; : The great ship sank below the waves. . * a great expanse of forest  * dive to a great depth  * all creatures great and small  * A great crowd had turned up. . * People had turned up in great numbers. . * The great majority (of people) (ie Most people) approve. . (b) far away in space or time ; : He lives a great distance away. . * That was a great while ago. . (c) [usu attrib ] exceptional in degree or intensity; considerable ; ; : of great value, importance, relevance, significance, etc     * He described it in great detail. . * Take great care to do it properly. . * You have my greatest (ie very great) sympathy. . * be in great demand, ie much wanted . (d) in a very good state of health, morale or well-being; fine ; ; ; ; : I feel great today! ! * in great form, ie very fit and active  * in great spirits, ie very cheerful . (e) [attrib ] with very good or bad effects : It's a great relief to know you're safe. . * You've been a great help. . * the greatest disaster that has ever befallen us. . =>Usage at big big.  2 (a) of remarkable ability or quality; outstanding ; : a great man, artist, musician, etc    * her great deeds  * No one would deny that Beethoven's symphonies are great masterpieces. . * the world's greatest novelist . (b) [attrib ] of high rank or status ; : a great lady  * the great powers, ie important and powerful countries  * Alexander the Great . (c) (infml ) very remarkable; splendid ; ; ; ; : He's great! ! * She's the greatest! ! * It's great that you can come! ! * What a great party! ! * He scored a great goal. . (d) (infml ) ~ (to do sth) very enjoyable or satisfactory ; : We had a great time in Majorca. . * It's great to know you! ! * It's great to have met you! !  3 (a) ~ for sth (infml ) very suitable for sth; ideal or useful for sth ; : This little gadget's great for opening tins. . * These are great shoes for muddy weather. . (b) [pred ] ~ at sth (infml ) clever or skilful at sth ; : She's great at tennis, chess, etc.  . (c) (ironic ) (used to express exasperation, scorn, etc    ): Oh great, I've missed the bus again! , ! * You've been a great help, you have! , !  4 [attrib ] (a) important; noteworthy; ; : The princess was getting married, and everyone was in town for the great occasion. , . * As the great moment approached, she grew more and more nervous. . (b) unequalled; excellent ; ; : She had a great chance/opportunity, but she let it slip. , . (c) the great the most important : The great advantage of this metal is that it doesn't rust. .  5 [attrib ] fully deserving the name of; beyond the ordinary ; ; ; : We are great friends. . * I've never been a great reader, ie I do not read much. . * He's a great one for complaining, ie He constantly complains. .  6 [attrib ] (infml ) (used to intensify another adj of size, etc ) very ; : What a great big idiot! ! * You great fat pig! ! * That's a great thick slice of cake! !  7 [attrib ] (used to name the larger of two types, species, etc  ): the great auk, ie contrasted with the little auk .  8 (added to words for relatives beginning with grand- to show a further stage in relationship grand-, ): one's ,great-`grandfather, ie one's father's or mother's grandfather  * one's ,great-`grandson, ie the grandson of one's son or daughter . =>App 8 8.  9 (dated infml , ) (in exclamations of surprise ): Great Scott! ! * Great heavens! !  10 (idm ) be no great shakes (infml ) not be very good, efficient, suitable, etc ; ; ; : She's no great shakes as an actress. . going great guns (infml ) proceeding vigorously and successfully ; . a good/great deal => deal2. great and small rich and poor, powerful and weak, etc  : Everyone, great and small, is affected by these changes. , . make great/rapid strides => stride. of great price very valuable ; . your need is greater than mine => need.

n  1 (usu pl ) (infml ) person of outstanding ability ; : one of boxing's all-time greats .  2 the great [pl v] great(2) people ; ; : a fashionable affair attended by all the great and the good, ie important and influential people .

NOTE ON USAGE : Britain or Great Britain (GB)consists of the geographical areas of England, Scotland and Wales. GB . It is often also used to refer to the political state, officially called the United Kingdom of Great Britain and Northern Ireland and usually abbreviated to the United Kingdom or the UK. , , UK. *The British Isles are the islands of Britain and Ireland. . There is no noun in British English commonly used to refer to the nationality of the people of Britain; instead the adjective is used : She's British. . * The British are said to have an unusual sense of humour. . Britisher is used in American English. *Britisher . Briton is found in newspaper, etc reports of incidents concerning British people and in statistical information. *Briton . It is also used of the early inhabitants of Britain *Briton: 10 Britons in hijacked plane 10 * According to the latest surveys many Britons suffer from heart disease. , . *  the ancient Britons .
<--- WordNet --->
great
great
     adj 1: relatively large in size or number or extent; larger than
            others of its kind; "a great juicy steak"; "a great
            multitude"; "the great auk"; "a great old oak"; "a
            great ocean liner"; "a great delay"
     2: more than usual; "great expectations"; "great worry"
     3: (used of persons) standing above others in character or
        attainment or reputation; "our distinguished professor";
        "an eminent scholar"; "a great statesman" [syn: {distinguished},
         {eminent}]
     4: of major significance or importance; "a great work of art";
        "Einstein was one of the outstanding figures of the 20th
        century" [syn: {outstanding}]
     5: remarkable or out of the ordinary in degree or magnitude or
        effect; "a great crisis"; "had a great stake in the
        outcome"
     6: very good; "he did a bully job"; "a neat sports car"; "had a
        great time at the party"; "you look simply smashing" [syn:
         {bang-up}, {bully}, {corking}, {cracking}, {dandy}, {groovy},
         {keen}, {neat}, {nifty}, {not bad(p)}, {peachy}, {slap-up},
         {swell}, {smashing}]
     7: uppercase; "capital A"; "great A"; "many medieval
        manuscripts are in majuscule script" [syn: {capital}, {majuscule}]
     8: marked by active interest and enthusiasm; "an avid sports
        fan"; "a great walker"; "an eager beaver" [syn: {avid}, {eager},
         {zealous}]
     9: in an advanced stage of pregnancy; "was big with child";
        "was great with child" [syn: {big(p)}, {enceinte}, {expectant},
         {gravid}, {great(p)}, {large(p)}, {heavy(p)}, {with
        child(p)}]
<--- CDICT5 --->
great
[gret;reit]
< great >
[]
<<>>
great.er, great.est
1 () 
2 
3 () 
  A great throng awaited us. 
4 () 
  a great delay 
5 () 
  a great crisis 
6 ; 
  a great work of art 
7 
  the great house on the estate 
8 () , , 
  "For he was great, ere foutune made him so." (John Dryden)
9 ; 
  one of the great nations of the West 
10 ; 
   a great leader 
11 ; 
12 (()) 
   a great lover of music 
13 (()) 
   great at algebra 
14 (()) ; 
   We had a great time at the dance. 
15 () ()
   a great-granddaughter 
16 (()) 
<<>>
1 (pl. greats, great) 
  a composer considered among the greats 
2
  a. () 
  b. () 
<<>>
(()) 
got along great with the teacher 
<<>>
greatly
<<>>
greatness


<--- XDICT --->
terrific
[trifik]
a. ,,
<--- 5.0 --->
terrific
*[t'rifik]
a. , , 
:
  at a terrific speed
<--- stardict1.3 --->
terrific
[trifik]
a. ,,;
<---  --->
terrific
/ tE5rIfIk; tE`rIfIk/ adj (infml )  1 very great; extreme ; : a terrific storm  *driving at a terrific speed .  2 excellent; wonderful ; : doing a terrific job  * The view was terrific. .
<--- WordNet --->
terrific
terrific
     adj 1: very great or intense; "a terrific noise"; "a terrific
            thunderstorm storm"; "fought a terrific battle"
     2: extraordinarily good; used especially as intensifiers; "a
        fantastic trip to the Orient"; "the film was fantastic!";
        "a howling success"; "a marvelous collection of rare
        books"; "had a rattling conversation about politics"; "a
        tremendous achievement" [syn: {fantastic}, {howling(a)}, {marvelous},
         {marvellous}, {rattling(a)}, {tremendous}, {wonderful}, {wondrous}]
     3: causing extreme terror; "a terrifying wail" [syn: {terrifying}]
<--- CDICT5 --->
terrific
[trIfIk;trifik]
< ter.rif.ic >
<<>>
more ter.rif.ic ; most ter.rif.ic
1 , , 
2 , , 
2 , ; 
<<>>
ter.rif.ic.ness
<<>>
ter.rif.i.cal.ly


<--- XDICT --->
nice
[nais]
a. ,,,,,,,
<--- 5.0 --->
nice
*[nais]
a. , , , , , , , 
:
  be nice to sb
<--- stardict1.3 --->
nice
[nais]
a. ,,;
<---  --->
nice
/ naIs; naIs/ adj (-r, -st)  1 (a) pleasant; agreeable ; ; : a nice person, smile, taste, remark     * a nice day  * nice weather  * a nice little girl  * That tastes nice! ! * We had a nice time at the beach. . * It's not nice to pick your nose. . (b) ~ (to sb) kind; friendly ; : Try to be nice to my father when he visits. . Cf  nasty.  2 (ironic ) bad; unpleasant ; : This is a nice mess you've got us into! ! * That's a nice thing to say! !  3 needing precision and care; fine; subtle ; ; : a nice distinction  * a nice point of law, ie one that may be difficult to decide  * nice (ie very slight) shades of meaning .  4 (a) hard to please; having refined tastes ; : too nice in one's dress . (b) (usu in negative expressions ) respectable; scrupulous ; ; ; : She's not too nice in her business methods. .  5 (idm ) nice and (used before adjs ) (infml approv , ) agreeably : nice and warm by the fire  * nice and cool in the woods . good/nice work => work1. nice work if you can get it (saying ) (used to express envy of what sb has been lucky or clever enough to get or do , ).
<--- WordNet --->
nice
nice
     adj 1: pleasant or pleasing or agreeable in nature or appearance;
            "what a nice fellow you are and we all thought you so
            nasty"- George Meredith; "nice manners"; "a nice
            dress"; "a nice face"; "a nice day"; "had a nice time
            at the party"; "the corn and tomatoes are nice today"
            [ant: {nasty}]
     2: socially or conventionally correct; refined or virtuous;
        "from a decent family"; "a nice girl" [syn: {decent}]
     3: done with delicacy and skill; "a nice bit of craft"; "a job
        requiring nice measurements with a micrometer"; "a nice
        shot" [syn: {skillful}]
     4: excessively fastidious and easily disgusted; "too nice about
        his food to take to camp cooking"; "so squeamish he would
        only touch the toilet handle with his elbow" [syn: {dainty},
         {overnice}, {prissy}, {squeamish}]
     5: noting distinctions with nicety; "a discriminating interior
        designer"; "a nice sense of color"; "a nice point in the
        argument" [syn: {discriminate}]
     6: exhibiting courtesy and politeness; "a nice gesture" [syn: {courteous},
         {gracious}]
<--- CDICT5 --->
nice
[naIs;nais | nis;nis]
< nice >
[]
<<>>
nic.er, nic.est
1 ; 
  had a nice time 
2 ; 
  a nice dress 
  a nice face 
3 
  a nice gesture 
4 ; 
5 ; 
6 ; 
  a nice distinction 
  a nice sense of style 
7 
  a nice bit of craft 
8 ( and , )
  nice and warm 
9
  a. ; 
  b. ; 
     "Ere... / The nice Morn on th' Indian steep, / From her cabin'd loop-hole peep." (John Milton)  / , / 
<<>>
nicely
<<>>
niceness

< Nice >
<<>>


<--- XDICT --->
awesome
[sm]
a. ,
<--- 5.0 --->
awesome
*[':sm]
a. , 
<--- stardict1.3 --->
awesome

a. ,;
<---  --->
awesome
/ -sEm; -sEm/ adj causing awe ; : His strength was awesome. .
<--- WordNet --->
awesome
awesome
     adj : inspiring awe or admiration or wonder; "New York is an
           amazing city"; "the Grand Canyon is an awe-inspiring
           sight"; "the awesome complexity of the universe"; "this
           sea, whose gently awful stirrings seem to speak of some
           hidden soul beneath"- Melville; "Westminster Hall's
           awing majesty, so vast, so high, so silent" [syn: {amazing},
            {awe-inspiring}, {awful}, {awing}]
<--- CDICT5 --->
awesome
[sm;sm]
< awe.some >
<<>>
1 , , 
2 , 
<<>>
awe.some.ly
<<>>
awe.some.ness

<--- XDICT --->
horrible
[hbl]
a. ,,
<--- 5.0 --->
horrible
*['hrbl]
a. , , 
<--- stardict1.3 --->
horrible
[hrbl]
a. ,,;
<---  --->
horrible
/ 5hCrEbl; ?@ 5hR:r-; `hRrEbl/ adj  1 causing horror ; : a horrible crime, nightmare, death   .  2 (infml ) very unpleasant : horrible weather, food, people    * It tastes horrible. . * Don't be so horrible (to me). . 
<--- WordNet --->
horrible
horrible
     adj : provoking horror; "an atrocious automobile accident"; "a
           frightful crime of decapitation"; "an alarming, even
           horrifying, picture"; "war is beyond all words
           horrible"- Winston Churchill; "an ugly wound" [syn: {atrocious},
            {frightful}, {horrifying}, {ugly}]
<--- CDICT5 --->
horrible
[hrbL,hr-;hrbl]
< hor.ri.ble >
<<>>
1 ; 
  "War is beyond all words horrible." (Winston S. Churchill)
2 ; 
<<>>
horri.ble.ness
<<>>
horri.bly


<--- XDICT --->
terrible
[terbl]
a. ,,,;;,;
<--- 5.0 --->
terrible
*['terbl]
a. , , 
<--- stardict1.3 --->
terrible
[terbl]
a. ,,;
<---  --->
terrible
/ 5terEbl; `tZrEbl/ adj  1 causing great fear ordistress; appalling ; ; : a terriblewar, accident, murder   .  2 hard to bear; extreme ; : terrible toothache  * The heat was terrible. .  3 (infml ) very bad ; : I'm terrible at tennis. . * What a terrible meal! ! * He's a terrible bore. .
<--- WordNet --->
terrible
terrible
     adj 1: causing fear or dread or terror; "the awful war"; "an awful
            risk"; "dire news"; "a career or vengeance so direful
            that London was shocked"; "the dread presence of the
            headmaster"; "polio is no longer the dreaded disease
            it once was"; "a dreadful storm"; "a fearful howling";
            "horrendous explosions shook the city"; "a terrible
            curse" [syn: {awful}, {dire}, {direful}, {dread(a)}, {dreaded},
             {dreadful}, {fearful}, {fearsome}, {frightening}, {horrendous},
             {horrific}]
     2: exceptionally bad or displeasing; "atrocious taste";
        "abominable workmanship"; "an awful voice"; "dreadful
        manners"; "a painful performance"; "terrible handwriting";
        "an unspeakable odor came sweeping into the room" [syn: {atrocious},
         {abominable}, {awful}, {dreadful}, {painful}, {unspeakable}]
     3: intensely or extremely bad or unpleasant in degree or
        quality; "severe pain"; "a severe case of flu"; "a
        terrible cough"; "under wicked fire from the enemy's
        guns"; "a wicked cough" [syn: {severe}, {wicked}]
     4: extremely distressing; "fearful slum conditions"; "a
        frightful mistake"; "suffered terrible thirst" [syn: {fearful},
         {frightful}]
<--- CDICT5 --->
terrible
[trbL;terbl]
< ter.ri.ble >
[]
<<>>
1 ; 
  a terrible bolt of lightning 
  a terrible curse 
2 
  terrible responsibilities 
3 ; 
  "the life for which he had paid so terrible a price" (Leslie Fiedler)
4 a. 
     had a terrible time at the party 
  b.
     terrible hypocrisy 
<<>>
terri.ble.ness
<<>>
terri.bly


<--- XDICT --->
nightmare
[naitm]
n. ,,
<--- 5.0 --->
nightmare
*['naitm]
n. , , ()
 , 
<--- stardict1.3 --->
nightmare
[naitm]
n. ,,;
<---  --->
nightmare
n  1 frightening dream ; : I have nightmares about falling off a cliff. .  2 (infml ) very frightening or unpleasantexperience : Driving during the blizzard was a nightmare. . 
<--- WordNet --->
nightmare
nightmare
     n 1: a situation resembling a terrifying dream [syn: {incubus}]
     2: a terrifying or deeply upsetting dream
<--- CDICT5 --->
nightmare
[naItmr;naitm]
< night.mare >
<<>>
1 ; 
2  ()
3 
  
<<>>
nightmar.ish
<<>>
nightmarish.ly
<<>>
nightmarish.ness


<--- XDICT --->
disastrous
[dizstrs]
a. ,
<--- 5.0 --->
disastrous
*[di'z:strs]
a. , 
<--- stardict1.3 --->
disastrous
[dizstrs]
a. ,;
<---  --->
disastrous
/ dI5zB:strEs; ?@ -z5As-; dIz`AstrEs/ adj being or causing a disaster ; ; : disastrous floods  * a defeat that was disastrous to the country  * Buying this house was a disastrous step: it's going to have a main road built behind it. , . 
<--- WordNet --->
disastrous
disastrous
     adj : (of events) having extremely unfortunate or dire
           consequences; bringing ruin; "the stock market crashed
           on Black Friday"; "a calamitous defeat"; "the battle
           was a disastrous end to a disastrous campaign"; "such
           doctrines, if true, would be absolutely fatal to my
           theory"- Charles Darwin; "it is fatal to enter any war
           without the will to win it"- Douglas MacArthur; "a
           fateful error" [syn: {black}, {calamitous}, {fatal}, {fateful}]
<--- CDICT5 --->
disastrous
[dIzstrs;dizstrs]
< dis.as.trous >
<<>>
1 ; 
2 , 
  a disastrous report card 
<<>>
dis.astrous.ly
<<>>
dis.astrous.ness

good: 225
great: 125
terrific: 16
nice: 59
awesome: 10

horrible: 14
terrible: 24
nightmare: 11
disastrous: 14

436/63
				<</textfile>>
				<<textfile "result.out">>
good-words: 435
bad-words: 63
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-useless--->>>
			<<case "rule-useless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: useless expression
*/
					<</desc>>
					<<init_code>>
#include <ctype.h>
					<</init_code>>
					<<declare_section>>
%formal-param%{ int &lowers, int &uppers, int &digits %}
%actual-param%{ lowers, uppers, digits %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			++lowers;
B			++uppers;
<*>[[:alnum:]]		if(isdigit(yytext[0]))
				++digits;
			else if(islower(yytext[0]))
				++lowers;
			else
				++uppers;
<asc>[[:upper:]]	uppers += 2;
<bsc>[[:lower:]]	lowers += 2;
<asc>[[:digit:]]	digits += 2;
.|\n
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex( n1, n2, n3);
	cout << "lower\'s: " << n1 << endl
	     << "upper\'s: " << n2 << endl
	     << "digit\'s: " << n3 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
eeeeeeeeee8888hh22222222hh5555555FFFF..........hhh.hhheeeh55555555hffffffffGG..........FFFFFhDDDDDDDDDhCCCCCfffffccchhhhhddddddddddddhhGGGGGGGGGGh222hh......hhhbbbbh2222hheeeeehhhhhfaaaaaeeeeeecccccc....haaaaaaaaaaaah2222222333333333hhGGGGGGGGhh3333333333hffff888888888hhddddddd000000000heeebbbbbbbbb8888888hhhhCCCCCCCCCBBBBhBBBBBBBBBBhhccccchhhhhhbbbb00333333ggghDaaaaa00000CCCCCCCCCChhhhhBBCCCCCCCfh3555555555eeehbbbbbbbbbbhccccchhFFFFFFFFhh333hh00000hFFFFFFFFFF44444dddDDDDDDDh55554444444444hhhhDD00000fBBBBhfffffbbhEEEEhhhhhh3333hhh..5555555555h000bbbbbbbbb...EEEEEEEEddh5558h........CCCCCCChhh.......hhBBBBBBhaaahCCCCCCCCCGGGGGGGG00000000000000022222h5555hh..........heeeeeeeeeehhaaaaaaaaahgggggggggaaaaaaaggggh000h222ffffffheeeeeeeeeh55555555h..hh0000000
332/159/215
				<</textfile>>
				<<textfile "result.out">>
lower's: 332
upper's: 159
digit's: 215
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-useless--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/rule---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond---------->>>
		<<suite "startcond" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>
			<<case "startcond-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition: duplicated SC

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%x asc
%s asc

					<</declare_section>>
					<<lex_section>>
"{"		BEGIN(asc);
<asc>"}"	BEGIN(INITIAL);
<asc>a		++ncnt; cout << yytext;
a		ncnt += 2; cout << yytext;
<*>\n		cout << "\n";
<asc>.		cout << "_";
.

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << endl << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{sfkiwegfsafa;adska
9348ejfsdjfklaeijofsedaiojdfasijoafiajoiwafo9ijwef320ewfokSAlL
349aew0ifjofl;Sao9pjgvdsnAO9WFMDSOPAAEGDASSODPL;AOPAalaomfaopfkd;klasdfjkfeiwjofkdscmx ,        P2309824390EDWPKOCSMLZX,. D
OPAKFPOAOPAF[al;pafkasdflergjvkldmldsfa[pw4e-=3240r5i0=-ew]pdsv;l  /.CX v,psidjkiewroas[dlc;fmkioopwer[]al;aerpwdsl
}
ajfdslowpef
oepwfasfl;sdfwepfas'
				<</textfile>>
				<<textfile "result.out">>
_________a_a_a___a
_____________a________a_____a____a__a____a____________________
___a___________a____________________________________a_a___a________a_______________________________________________________
_____________a___a__a_________________a______________________________________________a__________________a__a_______

a
aa

29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>
			<<case "startcond-exclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &as2, int &bs, int &bs2%}
%actual-param%{ as, as2, bs, bs2 %}

%x isc

					<</declare_section>>
					<<lex_section>>
\{		BEGIN(isc); cout << yytext;
<isc>\}		BEGIN(INITIAL); cout << yytext;
a		++as; cout << yytext;
<isc>b		++bs2; cout << yytext;
b		++bs; cout << yytext;
<*>a		++as2; cout << yytext;
<isc>.		cout << "_";
<*>\n		cout << endl;
.		cout << "*";
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n11 = 0, n2 = 0, n21 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n11, n2, n21);
	cout << "a's: " << n1 << " at INITIAL" << endl
	     << "a's: " << n11 << " at isc" << endl
	     << "b's: " << n2 << " at INITIAL" << endl
	     << "b's: " << n21 << " at isc" << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
bb~~bbbbbb~aa~aaaaaaaaaaa~~}}}}}}}}}~cccccaaa}}}}~bbbbbb~}~~aaaaabbbbbbbb~~~~cccccccccaaa{{{{{{{{{{aaaaaa~cccccccccc~..........~....bbb~~.~~ccccccc~aaaaaaaaacccccc~~{{{{{{{~~~ccccccc~{{{{{{}}}}}}}}}}~~~~bb~{{{{{cccccccccc}}}}}}{{{aaaaa~{{{{{{}}}}c~cccc~bbbaaaaaaa..........~aaaaaaa~~}}}}}}}}}}~~
.: 25
a: 58
b: 30
{: 37
}: 44
c: 59
~: 42

				<</textfile>>
				<<textfile "result.out">>
bb**bbbbbb*aa*aaaaaaaaaaa*****************aaa*****bbbbbb****aaaaabbbbbbbb*************aaa{_________aaaaaa___________________________bbb_____________aaaaaaaaa________________________________}*************bb*{______________}*****{__aaaaa_______}**********bbbaaaaaaa***********aaaaaaa**************
*****
a****
b****
{____
}****
*****
*****

a's: 39 at INITIAL
a's: 20 at isc
b's: 28 at INITIAL
b's: 3 at isc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>
			<<case "startcond-exclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &n1, int &n2, int &n3%}
%actual-param%{ n1, n2, n3 %}

%x bsc
%x csc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		cout << yytext;
<INITIAL,csc>\{		yy_push_state(bsc); cout << yytext;
<INITIAL,bsc>\[		yy_push_state(csc); cout << yytext;
<bsc>\}			yy_pop_state(); cout << yytext;
<csc>\]			yy_pop_state(); cout << yytext;
<bsc,csc>[\}\]]		cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<*>\n			cout << endl;

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << "a's: " << n1 << " at INITIAL" << endl
	     << "a's: " << n2 << " at bsc" << endl
	     << "a's: " << n3 << " at csc" << endl;


	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
************aaaaaaaaaa*************************[_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]*{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

a's: 10 at INITIAL
a's: 18 at bsc
a's: 1 at csc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>
			<<case "startcond-exclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3, int &n4 %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%x csc
%x dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		cout << yytext;
\{		BEGIN(bsc); cout << yytext;
<bsc>\{		BEGIN(csc); cout << yytext;
<csc>\{		BEGIN(dsc); cout << yytext;
<dsc>\}		BEGIN(csc); cout << yytext;
<csc>\}		BEGIN(bsc); cout << yytext;
<bsc>\}		BEGIN(INITIAL); cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
<dsc>a			++n4; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<dsc>.			cout << "+";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4);
	cout << "SC0: " << n1 << endl
	     << "SC1: " << n2 << endl
	     << "SC2: " << n3 << endl
	     << "SC3: " << n4 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}***********{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}**{{{+aaaaaaaa+aa+++++}}}***{{{++aaaaa}}}******************{{{++++++++++++++}}}******{{{++++++++++++++}}}*************************aaaaaaa*****{{{++}}}************aaaaaaaa***********aaaaaaa{{{+++++++++++++++++++++++++}}}***{{{+++++++++++++++++++++++++}}}**{{{++++++++++++}}}*****aa*********aa******************{{{++++++++++++++}}}*********************aaaaaaa**************aaaaa*aaaaaaaa**a{{{+++++aa+++++++++}}}********
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 49
SC1: 10
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>
			<<case "startcond-inclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &as2, int &bs, int &bs2%}
%actual-param%{ as, as2, bs, bs2 %}

%s isc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+	cout << yytext;
\{		BEGIN(isc); cout << yytext;
<isc>\}		BEGIN(INITIAL); cout << yytext;
a		++as; cout << yytext;
b		++bs; cout << yytext;
<isc>b		++bs2; cout << yytext;
<*>a		++as2; cout << yytext;
.		cout << "*";
<isc>.		cout << "_";
<*>\n		cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n11 = 0, n2 = 0, n21 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n11, n2, n21);
	cout << "SC0-a: " << n1 << endl
	     << "SC1-a: " << n11 << endl
	     << "SC0-b: " << n2 << endl
	     << "SC1-b: " << n21 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
aaaaa}}}}}}}}~bbbbbbbbbb{{{~{{{{{{{{~~~aaaaaaaaaa}}}}}}}}}}}}}}~~~~~~........~{{{{{{{{{~bbbbaaaaaaaaa~{{bbbbbb~b~~~~{c~~}}}~~~{{{~}}}}b~aaaaaaaaa{{{{{{{{bbbbbbbbc~}}}}}}~}}}}}}.~~aaaaaaaaaa{{{{{{{{{{~}}}}}}~~cccccc~~}}}}}}}a
.: 9
a: 19
a: 25
{: 18
}: 16
{: 26
}: 38
b: 10
b: 20
c: 8
~: 35

				<</textfile>>
				<<textfile "result.out">>
aaaaa}}}}}}}}*bbbbbbbbbb{______________aaaaaaaaaa}}}}}}}}}}}}}}***************{_________bbbbaaaaaaaaa___bbbbbb_b________}}}***{___}}}}b*aaaaaaaaa{_______bbbbbbbb__}}}}}}*}}}}}}***aaaaaaaaaa{__________}}}}}}**********}}}}}}}a
***9
a**19
a**25
{__18
}**16
{__26
}**38
b**10
b**20
***8
***35

SC0-a: 27
SC1-a: 19
SC0-b: 13
SC1-b: 19
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>
			<<case "startcond-inclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3%}
%actual-param%{ n1, n2, n3 %}

%s bsc
%s csc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		cout << yytext;
[\}\]]			cout << yytext;
<INITIAL,csc>\{		yy_push_state(bsc); cout << yytext;
<INITIAL,bsc>\[		yy_push_state(csc); cout << yytext;
<bsc>\}			yy_pop_state(); cout << yytext;
<csc>\]			yy_pop_state(); cout << yytext;
<bsc,csc>[\}\]]		cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << "SC0-a: " << n1 << endl
	     << "SC1-a: " << n2 << endl
	     << "SC2-a: " << n3 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
*********]]*aaaaaaaaaa******************]]]]]]][_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]]{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

SC0-a: 10
SC1-a: 18
SC2-a: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>
			<<case "startcond-inclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3, int &n4 %}
%actual-param%{ n1, n2, n3, n4 %}


%s bsc
%s csc
%s dsc
					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		cout << yytext;
[\{\}]		BEGIN(bsc); cout << yytext;
<bsc>\{		BEGIN(csc); cout << yytext;
<csc>\{		BEGIN(dsc); cout << yytext;
<dsc>\}		BEGIN(csc); cout << yytext;
<csc>\}		BEGIN(bsc); cout << yytext;
<bsc>\}		BEGIN(INITIAL); cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
<dsc>a			++n4; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<dsc>.			cout << "+";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4);
	cout << "SC0: " << n1 << endl
	     << "SC1: " << n2 << endl
	     << "SC2: " << n3 << endl
	     << "SC3: " << n4 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>
			<<case "startcond-inex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive & exclusive start-condition

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3, int &n4 %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%s csc
%s dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		cout << yytext;
[\{\}]		BEGIN(bsc); cout << yytext;
<bsc>\{		BEGIN(csc); cout << yytext;
<csc>\{		BEGIN(dsc); cout << yytext;
<dsc>\}		BEGIN(csc); cout << yytext;
<csc>\}		BEGIN(bsc); cout << yytext;
<bsc>\}		BEGIN(INITIAL); cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
<dsc>a			++n4; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<dsc>.			cout << "+";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4);
	cout << "SC0: " << n1 << endl
	     << "SC1: " << n2 << endl
	     << "SC2: " << n3 << endl
	     << "SC3: " << n4 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>
		<<suite "startcond-refer" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-alleof--->>>
			<<case "startcond-refer-alleof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
every start-condition has its own EOF-rule
*/
					<</desc>>
					<<init_code>>
char *pcchFileName[3] = {
	"test1.input",
	"test2.input",
	NULL			
};
int fIndex = 0;
					<</init_code>>
					<<declare_section>>
%x	asc
%x	bsc
%x	csc
					<</declare_section>>
					<<lex_section>>
a		BEGIN(asc);
b		BEGIN(bsc);
c		BEGIN(csc);
<asc>a		BEGIN(INITIAL);
<bsc>b		BEGIN(INITIAL);
<csc>c		BEGIN(INITIAL);
<<EOF>>	{
			printf("File end at SC-INITIAL: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<asc><<EOF>>	{
			printf("File end at SC-asc: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<bsc><<EOF>>	{
			printf("File end at SC-bsc: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<csc><<EOF>>	{
			printf("File end at SC-csc: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<*>.|\n

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
dddddddddeccccccccccc...aaaaaadbbbbbbbbbaaaaaaaccccccceeeebbbbbbbbbeeeeccaaaaaaaecccccccceeeeeeeeeeeeeccccaaaaaaaaaaeeedddaaaaaaaddddeedddddddeddddddddebbbbbbb...dddde...aaaaaaaaaaeeeaaaaaaaaaeddddddddbbbbbbbbbbee.....bbbbbbbbbeeaaaaaaa
.: 14
a: 63
b: 44
c: 32
d: 44
e: 39

				<</textfile>>
				<<textfile "test1.input">>
aaaaaadddddddddeeeee..eeedddddddeeddddddddbbbbbdddddddeddddbbbddeeeebbaaaaaaaaeeacccccebbbbbbcccccccccbbbbbbbeccceaaaaaaaa
.: 2
a: 23
b: 23
c: 17
d: 37
e: 20

				<</textfile>>
				<<textfile "test2.input">>
aaaaaaaee..a.........bbbbbedddddddddedddeeeaaaaddeeeeedddecccccaaeeeebbbbbeccccceeebbbddddcccceddbdee..........ddccccccccccebbbbbbaaaaaaaaaaeeddddddcccccebbbbbbedddedccccccccccccccccdddddddddd........eee....dddddeeeeeeeeee......ebbbbeeeedddddddddebbbbbbbbbbaaaaaaabbbbbbcccccceee
.: 39
a: 31
b: 46
c: 51
d: 60
e: 52

				<</textfile>>
				<<textfile "result.out">>
File end at SC-asc: 2
File end at SC-bsc: 4
File end at SC-bsc: 4
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-alleof--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-allsc--->>>
			<<case "startcond-refer-allsc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
special start-condition <*>
*/
					<</desc>>
					<<init_code>>
#include <ctype.h>

int c1 = 0, c2 = 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ int &beta, int &betb, int &others %}
%actual-param%{ beta, betb, others %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			BEGIN(asc);
			cout << "{";
			c1 = 0;
			++others;
b			BEGIN(bsc);
			cout << "[";
			c2 = 0;
			++others;
<asc>a			BEGIN(INITIAL);
			cout << "}";
			beta += c1;
			++others;
<bsc>b			BEGIN(INITIAL);
			cout << "]";
			beta += c2;
			++others;

<asc>[[:graph:]] 	++c1;
			cout << yytext;
<bsc>[[:graph:]]	++c2;
			cout << yytext;
<*>.			cout << "_";
			++others;
<*>\n			cout << endl;
<*><<EOF>>		others += c1;
			others += c2;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << endl << "chars between a\'s: " << n1 << endl
	     << "chars between b\'s: " << n2 << endl
	     << "others: " << n3 << endl
	     << "total: " << n1 + n2 + n3 << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
bbedddcccccccecccccccccccccceaeeddddddddeeedddddddddd.ddde.......eeeaaebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142

				<</textfile>>
				<<textfile "result.out">>
[]___________________________{eeddddddddeeedddddddddd.ddde.......eee}{ebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142


chars between a's: 38
chars between b's: 0
others: 104
total: 142
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-allsc--->>>

<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-multisc--->>>
			<<case "startcond-refer-multisc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
refer multi start-condition
*/

					<</desc>>
					<<init_code>>
#include <string>
using std::string;
					<</init_code>>
					<<declare_section>>

%formal-param%{ string &qstr, string &mstr, bool &bexpr %}
%actual-param%{ qstr, mstr, bexpr %}

%x	qstr_sc
%x	expr_sc
					<</declare_section>>
					<<lex_section>>

\"						yy_push_state(qstr_sc); bexpr = false;
<qstr_sc>\`					yy_push_state(expr_sc); bexpr = true;
<expr_sc,qstr_sc>\$[[:cidf:]][[:cids:]]*	if(bexpr) mstr += yytext; else qstr += yytext;			 
<expr_sc,qstr_sc>[\+\-\*\/\(\)\[\]\{\}]		if(bexpr) mstr += yytext; else qstr += yytext;
<expr_sc>\`					yy_pop_state(); bexpr = false; mstr += "\n";
<qstr_sc>\"					yy_pop_state(); qstr += "\n";
<expr_sc,qstr_sc,expr_sc>.			if(bexpr) mstr += yytext; else qstr += yytext;

<*>.|\n
					<</lex_section>>
					<<before_init>>
	string qstr, mstr;
	bool b = false;
					<</before_init>>
					<<after_init>>
	int nret = yylex(qstr, mstr, b);

	cout << "qstr: " << qstr << endl;
	cout << "mstr: " << mstr << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
"if test `expr n1 * n2` != 0 then both n1 and n2 are not zero else either n1 or n2 are zero"
print_msg("for your information `echo $msg`")    
print "done"

				<</textfile>>
				<<textfile "result.out">>
qstr: if test  != 0 then both n1 and n2 are not zero else either n1 or n2 are zero
for your information 
done

mstr: expr n1 * n2
echo $msg

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-multisc--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-someeof--->>>
			<<case "startcond-refer-someeof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
some start-conditions have own EOF-rule
*/

					<</desc>>
					<<init_code>>
enum {
	IDX_ASC = 0,
	IDX_BSC,
	IDX_CSC,
	IDX_DSC
};
char *ppchFileName[4] = {
	"test1.input",
	"test2.input",
	"test3.input",
	NULL
};

					<</init_code>>
					<<declare_section>>

%yywrap%{
	return false; 
%}

%x	asc
%x	bsc
%x	csc
%x	dsc
					<</declare_section>>
					<<lex_section>>

a	BEGIN(asc); cout << yytext << endl;
b	BEGIN(bsc); cout << yytext << endl;
c	BEGIN(csc); cout << yytext << endl;
d	BEGIN(dsc); cout << yytext << endl;
<asc>a	BEGIN(INITIAL);
<bsc>b	BEGIN(INITIAL);
<csc>c	BEGIN(INITIAL);
<dsc>d	BEGIN(INITIAL);
<asc><<EOF>>	{
			printf("File end at SC-asc: %d\n", YYSTART());
			yy_delete_buffer();
			for(int i = 2; i >= 0; --i) {
				YYPBUFFER pbuf = yy_new_filebuf(ppchFileName[i]);
				if(! pbuf) {

					printf("failed to open buffer\n");
					yyterminate();
					break;
				}
				else {
					yy_push_buffer(pbuf);
				}
			}
			BEGIN(INITIAL);
		}

<*><<EOF>>		{
			switch(YYSTART()) {
			case bsc:
				printf("File end at SC-bsc: %d\n", YYSTART());
				break;
			case csc:
				printf("File end at SC-csc: %d\n", YYSTART());
				break;
			case dsc:
				printf("File end at SC-dsc: %d\n", YYSTART());
				break;
			}
			yy_delete_buffer();
			BEGIN(INITIAL);
		}

<*>.|\n
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
a
				<</textfile>>
				<<textfile "test1.input">>
b
				<</textfile>>
				<<textfile "test2.input">>
c
				<</textfile>>
				<<textfile "test3.input">>
d
				<</textfile>>
				<<textfile "result.out">>
a
File end at SC-asc: 2
b
File end at SC-bsc: 4
c
File end at SC-csc: 6
d
File end at SC-dsc: 8
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-someeof--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/basic---------->>>

<</suite>>
<<<----------sub-suite: /lex-alone ---------->>>

<<<----------sub-suite: /invoke ---------------->>>
<<suite "invoke" make="subdir-makefile-template">>

<<<----------case: /invoke/default----------------->>>
	<<case "default" make="invoke-make-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	default options
		-o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
ans = 		0
ans = 		1024
ans = 		1024
yy = 		1024
yy = 		1024
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
Error: at 25:1; description: yy is unset variable.
Error: at 28:1; description: goodbye is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/default----------------->>>

<<<----------case: /invoke/option-t----------------->>>
	<<case "option-t" make="invoke-make-stdout-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -t to redirect code output to stdout
		-t
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
ans = 		0
ans = 		1024
ans = 		1024
yy = 		1024
yy = 		1024
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
Error: at 25:1; description: yy is unset variable.
Error: at 28:1; description: goodbye is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-t----------------->>>


<<<----------case: /invoke/option-a----------------->>>
	<<case "option-a" make="invoke-make-template">>
		<<upgen_options>>-al<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -a
		-a -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-a----------------->>>

<<<----------case: /invoke/option-d1----------------->>>
	<<case "option-d1" make="invoke-make-template">>
		<<upgen_options>>-d -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d to enable producing diagnosis information
	for pattern-matching
		-d -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
.................... accept {`sub'}, rule at line: 83 
.................... accept {`='}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`-'}, rule at line: 85 
.................... accept {`-'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`-'}, rule at line: 85 
.................... accept {`+'}, rule at line: 85 
.................... accept {`4'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`4'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`-'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`4'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`%'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`1011'}, rule at line: 78 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`9'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`216'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`24'}, rule at line: 78 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sup'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`('}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`^'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`3'}, rule at line: 78 
.................... accept {`)'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`list'}, rule at line: 82 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`clear'}, rule at line: 81 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sup'}, rule at line: 83 
.................... accept {`?'}, rule at line: 85 
Error: at 8:1; description: sup is unset variable.
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`quit'}, rule at line: 80 
.................... accept unprintable-char{10}, rule at line: 85 
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1----------------->>>

<<<----------case: /invoke/option-D2----------------->>>
	<<case "option-D2" make="invoke-make-template">>
		<<upgen_options>>-D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -D to enable producing diagnosis information
	for parsing
		-D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 91.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 187.
Next symbol is -
Shift -, go to state 28
Next symbol is -
Shift -, go to state 12
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 187.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 222.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
Next symbol is +
Shift +, go to state 11
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 187.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 228.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 241.
Next symbol is %
Shift %, go to state 31
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 174.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 101.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is (
Shift (, go to state 14
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 241.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 187.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 233.
Next symbol is /
Shift /, go to state 30
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 241.
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is LIST
Shift LIST, go to state 9
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 132.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is CLEAR
Shift CLEAR, go to state 8
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 128.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 116.
Next symbol is ?
Shift ?, go to state 34
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 116.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is QUIT
Shift QUIT, go to state 10
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 137.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-D2----------------->>>

<<<----------case: /invoke/option-d1D2----------------->>>
	<<case "option-d1D2" make="invoke-make-template">>
		<<upgen_options>>-d -D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d[debug-level] -D[debug-level] to enable producing diagnosis information
	for pattern-matching and parsing
		-d -D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 91.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 187.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 187.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 222.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 85 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 187.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 228.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`%'}, rule at line: 85 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 241.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 87 
.................... accept {`1011'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 238.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 174.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 101.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`9'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`216'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`24'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`('}, rule at line: 85 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 241.
.................... accept {` '}, rule at line: 87 
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 87 
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`)'}, rule at line: 85 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 187.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 233.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 241.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`list'}, rule at line: 82 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 132.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`clear'}, rule at line: 81 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 128.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 85 
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 116.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 116.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`quit'}, rule at line: 80 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 137.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1D2----------------->>>

<<<----------case: /invoke/option-i----------------->>>
	<<case "option-i" make="invoke-make-template">>
		<<upgen_options>>-il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -i so that pattern will be matched case-insensitively
		-i -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-i----------------->>>

<<<----------case: /invoke/option-l----------------->>>
	<<case "option-l" make="invoke-make-template">>
<<<<-----------<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using option -l to disable location computation
		-l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-l----------------->>>


<<<----------case: /invoke/option-m----------------->>>
	<<case "option-m" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using option -m to disable generating pattern-matching program
		-m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-m----------------->>>

<<<----------case: /invoke/option-p----------------->>>
	<<case "option-p" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using option -p to disable generating pattern-matching program
		-p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-p----------------->>>

<<<----------case: /invoke/option-decl-file----------------->>>
	<<case "option-decl-file" make="invoke-make-template">>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<upgen_options>>-Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		-H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-decl-file----------------->>>


<<<----------case: /invoke/option-sspec----------------->>>
	<<case "option-sspec" make="invoke-make-template">>
		<<upgen_options>>-ls C++<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -s to specify language SPEC to generate code
		-s C++ -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-sspec----------------->>>


<<<----------case: /invoke/option-S----------------->>>
	<<case "option-S" make="invoke-make-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -S to enable default action in pattern-matching
		-S -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-S----------------->>>


<<<----------case: /invoke/option-v----------------->>>
	<<case "option-v" make="invoke-make-template">>
		<<upgen_options>>-lv<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -v to report details on automations
		-v -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-v----------------->>>


<<<----------case: /invoke/option-cmp-d1m----------------->>>
	<<case "option-cmp-d1m" make="invoke-make-template">>
		<<upgen_options>>-d -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1m----------------->>>


<<<----------case: /invoke/option-cmp-d1p----------------->>>
	<<case "option-cmp-d1p" make="invoke-make-template">>
		<<upgen_options>>-d -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
.................... accept {`EOF'}, rule at line: 29 
.................... accept {`['}, rule at line: 32 
undefined symbol `['
.................... accept {`0'}, rule at line: 25 
.................... accept {`-'}, rule at line: 30 
.................... accept {`9'}, rule at line: 25 
.................... accept {`]'}, rule at line: 32 
undefined symbol `]'
.................... accept {`+'}, rule at line: 30 
.................... accept {`quit'}, rule at line: 26 
.................... accept {`-'}, rule at line: 30 
.................... accept {`clear'}, rule at line: 27 
.................... accept {`{'}, rule at line: 32 
undefined symbol `{'
.................... accept {`var'}, rule at line: 29 
.................... accept {`}'}, rule at line: 32 
undefined symbol `}'
.................... accept {`list'}, rule at line: 28 
.................... accept {`+'}, rule at line: 30 
.................... accept {`-'}, rule at line: 30 
.................... accept {`*'}, rule at line: 30 
.................... accept {`/'}, rule at line: 30 
.................... accept {`%'}, rule at line: 30 
.................... accept {`^'}, rule at line: 30 
.................... accept {`='}, rule at line: 30 
.................... accept {`('}, rule at line: 30 
.................... accept {`)'}, rule at line: 30 
.................... accept {`?'}, rule at line: 30 
.................... accept unprintable-char{10}, rule at line: 31 
.................... accept {`\'}, rule at line: 32 
undefined symbol `\'
.................... accept {`n'}, rule at line: 29 
.................... accept unprintable-char{10}, rule at line: 31 
.................... accept {`.'}, rule at line: 32 
undefined symbol `.'
.................... accept unprintable-char{10}, rule at line: 31 
.................... accept {EOF}, rule at line: 34
.................... EOS reached
		<</textfile>>

	<</case>>
<<<----------case: /invoke/option-cmp-d1p----------------->>>


<<<----------case: /invoke/option-cmp-D2p----------------->>>
	<<case "option-cmp-D2p" make="invoke-make-template">>
		<<upgen_options>>-D -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-D -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-D2p----------------->>>


<<<----------case: /invoke/option-cmp-d1D2H----------------->>>
	<<case "option-cmp-d1D2H" make="invoke-make-template">>
		<<upgen_options>>-d -D -Hl<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 90.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 186.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 186.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 221.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 84 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 186.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 227.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`%'}, rule at line: 84 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 240.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 86 
.................... accept {`1011'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 173.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 100.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 86 
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {` '}, rule at line: 86 
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 86 
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 86 
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 86 
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {` '}, rule at line: 86 
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 86 
.................... accept {`9'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 86 
.................... accept {`216'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 86 
.................... accept {`24'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 86 
.................... accept {`('}, rule at line: 84 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 240.
.................... accept {` '}, rule at line: 86 
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 86 
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`)'}, rule at line: 84 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 186.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 232.
.................... accept {` '}, rule at line: 86 
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 86 
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 240.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`list'}, rule at line: 81 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 131.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`clear'}, rule at line: 80 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 127.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 84 
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 115.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 115.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`quit'}, rule at line: 79 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 136.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2H----------------->>>

<<<----------case: /invoke/option-cmp-d1D2l----------------->>>
	<<case "option-cmp-d1D2l" make="invoke-make-template">>
		<<upgen_options>>-d -D<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 91.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 183.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 183.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 218.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 150.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 86 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 183.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 224.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 150.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 183.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 150.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`%'}, rule at line: 86 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 237.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 87 
.................... accept {`1011'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 234.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 171.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 101.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 237.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 86 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 86 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 160.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 155.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 237.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 86 
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`9'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 86 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 155.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`216'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 86 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 160.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`24'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 234.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 155.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`('}, rule at line: 86 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 237.
.................... accept {` '}, rule at line: 87 
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 87 
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`)'}, rule at line: 86 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 183.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 229.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 86 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 160.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`list'}, rule at line: 83 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 131.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`clear'}, rule at line: 82 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 127.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 86 
Next symbol is ?
Error: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 116.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 116.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`quit'}, rule at line: 81 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 136.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2l----------------->>>

<<<----------case: /invoke/option-cmp-d1D2S----------------->>>
	<<case "option-cmp-d1D2S" make="invoke-make-template">>
		<<upgen_options>>-d -D -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -S -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 90.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 186.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 186.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 221.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 84 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 186.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 227.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`%'}, rule at line: 84 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 240.
Next symbol is %
Shift %, go to state 31
.................... accept {`1011'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 173.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 100.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Shift *, go to state 29
.................... accept {`9'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is /
Shift /, go to state 30
.................... accept {`216'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {`24'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`('}, rule at line: 84 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 240.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`)'}, rule at line: 84 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 186.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 232.
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 240.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`list'}, rule at line: 81 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 131.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`clear'}, rule at line: 80 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 127.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 84 
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 115.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 115.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`quit'}, rule at line: 79 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 136.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2S----------------->>>

<<<----------case: /invoke/option-cmp-lS----------------->>>
	<<case "option-cmp-lS" make="invoke-make-template">>
		<<upgen_options>>-S <</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -l -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lS----------------->>>


<<<----------case: /invoke/option-cmp-St----------------->>>
	<<case "option-cmp-St" make="invoke-make-stdout-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -t
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
ans = 		0
ans = 		1024
ans = 		1024
yy = 		1024
yy = 		1024
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
Error: at 25:1; description: yy is unset variable.
Error: at 28:1; description: goodbye is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-St----------------->>>


<<<----------case: /invoke/option-cmp-aS----------------->>>
	<<case "option-cmp-aS" make="invoke-make-template">>
		<<upgen_options>>-a -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-a -S -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-aS----------------->>>


<<<----------case: /invoke/option-cmp-pS----------------->>>
	<<case "option-cmp-pS" make="invoke-make-template">>
		<<upgen_options>>-S -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -p -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-pS----------------->>>


<<<----------case: /invoke/option-cmp-mS----------------->>>
	<<case "option-cmp-mS" make="invoke-make-template">>
		<<upgen_options>>-S -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mS----------------->>>


<<<----------case: /invoke/option-cmp-HS----------------->>>
	<<case "option-cmp-HS" make="invoke-make-template">>
		<<upgen_options>>-S -Hl<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -H -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HS----------------->>>

<<<----------case: /invoke/option-cmp-iS----------------->>>
	<<case "option-cmp-iS" make="invoke-make-template">>
		<<upgen_options>>-S -il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -i -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iS----------------->>>

<<<----------case: /invoke/option-cmp-HsC++----------------->>>
	<<case "option-cmp-HsC++" make="invoke-make-template">>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<upgen_options>>-H -ls C++<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		and option -s to specify the programming language to generate code
		-H -s C++ -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HsC++----------------->>>


<<<----------case: /invoke/option-cmp-Hm----------------->>>
	<<case "option-cmp-Hm" make="invoke-make-template">>
		<<upgen_options>>-Hlm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hm----------------->>>

<<<----------case: /invoke/option-cmp-lm----------------->>>
	<<case "option-cmp-lm" make="invoke-make-template">>
		<<upgen_options>>-m<</upgen_options>>
		<<script "invoke-myscanner-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lm----------------->>>

<<<----------case: /invoke/option-cmp-mp----------------->>>
	<<case "option-cmp-mp" make="make-no-exec">>
		<<upgen_options>>-p -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-p -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Warning: No code generated for script `script.upg',
since both pattern-matching and parsing program generation disabled.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mp----------------->>>

<<<----------case: /invoke/option-cmp-msC++----------------->>>
	<<case "option-cmp-msC++" make="invoke-make-template">>
		<<upgen_options>>-s C++ -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s C++ -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++----------------->>>

<<<----------case: /invoke/option-cmp-msC++t----------------->>>
	<<case "option-cmp-msC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-s C++ -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s C++ -m -t
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++t----------------->>>

<<<----------case: /invoke/option-cmp-Hp----------------->>>
	<<case "option-cmp-Hp" make="invoke-make-template">>
		<<upgen_options>>-Hlp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hp----------------->>>

<<<----------case: /invoke/option-cmp-Hlp----------------->>>
	<<case "option-cmp-Hlp" make="invoke-make-template">>
		<<upgen_options>>-Hp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -l -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hlp----------------->>>

<<<----------case: /invoke/option-cmp-Hip----------------->>>
	<<case "option-cmp-Hip" make="invoke-make-template">>
		<<upgen_options>>-Hilp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quIT
operator: -
keyword: CLEar
identifier: var
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hip----------------->>>

<<<----------case: /invoke/option-cmp-ipt----------------->>>
	<<case "option-cmp-ipt" make="invoke-make-stdout-template">>
		<<upgen_options>>-ilp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -t
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quIT
operator: -
keyword: CLEar
identifier: var
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-ipt----------------->>>

<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>
	<<case "option-cmp-HPzzCMD" make="invoke-make-template">>
		<<upgen_options>>-HlP zz<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>

<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>

<<<----------case: /invoke/option-cmp-HPzz----------------->>>
	<<case "option-cmp-HPzz" make="invoke-make-template">>
		<<upgen_options>>-Hl -P xx<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzz----------------->>>

<<<----------case: /invoke/option-cmp-iPzz----------------->>>
	<<case "option-cmp-iPzz" make="invoke-make-template">>
		<<upgen_options>>-il -P xx<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-i -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sUb = Sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
lISt
CLEAR
CLear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sup = 		378298
ans = 		-630
sub = 		-620
sup = 		378298
		<</textfile>>
		<<textfile "result.err">>
Error: at 4:7; description: Sub is unset variable.
Error: at 9:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iPzz----------------->>>

<<<----------case: /invoke/option-cmp-lPzz----------------->>>
	<<case "option-cmp-lPzz" make="invoke-make-template">>
		<<upgen_options>>-P xx<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lPzz----------------->>>

<<<----------case: /invoke/option-cmp-mPzz----------------->>>
	<<case "option-cmp-mPzz" make="invoke-make-template">>
		<<upgen_options>>-lm -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-m -P zz FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzz----------------->>>

<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>
	<<case "option-cmp-PzzsC++" make="invoke-make-template">>
		<<upgen_options>>-ls C++ -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-s C++ -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>

<<<----------case: /invoke/option-cmp-PzzS----------------->>>
	<<case "option-cmp-PzzS" make="invoke-make-template">>
		<<upgen_options>>-lS -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-S-P zz -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzS----------------->>>

<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>
	<<case "option-cmp-mPzzsC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-lms C++ -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s C++ -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>

<<<----------case: /invoke/option-cmp-mPzztv----------------->>>
	<<case "option-cmp-mPzztv" make="invoke-make-stdout-template">>
		<<upgen_options>>-lmv -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-v -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzztv----------------->>>

<<<----------case: /invoke/option-cmp-lex+parse----------------->>>
	<<case "option-cmp-lex+parse" make="invoke-make-lex-parse-template">>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<parser_options>>-H -lm<</parser_options>>
		<<scanner_options>>-p -P zz<</scanner_options>>
		<<script "invoke-parser-only-template">>
			<<desc>>/*
features to test: put scanner generated by upgen and parser generated by upgen together
this is parser part.
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "scanner.upg">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/

%{

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <string>
using std::string;


#include "./script.h"
using namespace yynsx;

#include <cstdlib>

// to avoid copy yytext
extern string	s_strVarName; 
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*


%%

[0-9]+				yylval.nVal = atoi(yytext);
				return NUM;
"quit"				return QUIT;
"clear"				return CLEAR;
"list"				return LIST;
{var}				s_strVarName = yytext;
				return VARI;
[\+\-\*\/\%\^\=\(\)\?\n]	return yytext[0];

.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;

%%

%%

		<</textfile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lex+parse----------------->>>

<</suite>>
<<<----------sub-suite: /invoke ---------------->>>

<<<----------sub-suite: /empty ---------------->>>
<<suite "empty" make="subdir-makefile-template">>

<<<----------case: /invoke/empty/empty-file----------------->>>
	<<case "empty-file" make="make-no-exec">>
		<<textfile "script.upg">>
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 1:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-file----------------->>>

<<<----------case: /invoke/empty/only-comments----------------->>>
	<<case "only-comments" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: content of script is empty except comments
*/
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 4:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-comments----------------->>>

<<<----------case: /invoke/empty/empty-sect-2----------------->>>
	<<case "empty-sect-2" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-empty-sect-2">>
		<</script>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
		900001
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 0:0.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-2----------------->>>


<<<----------case: /invoke/empty/only-2-sections----------------->>>
	<<case "only-2-sections" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: script contains only 2 sections
*/
%%
.		/* do nothing */
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 6:0.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-2-sections----------------->>>

<<<----------case: /invoke/empty/only-3-sections----------------->>>
	<<case "only-3-sections" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-only-3-sections">>
		<</script>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
		900001
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 0:0.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-3-sections----------------->>>

<<<----------case: /invoke/empty/empty-sect-3----------------->>>
	<<case "empty-sect-3" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "script-empty-sect-3">>
		<</script>>
		<<textfile "test.input">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner." << endl;
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	cout << yytext;
%%

		<</textfile>>
		<<textfile "result.out">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner." << endl;
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	cout << yytext;
%%

		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-3----------------->>>

<</suite>>
<<<----------sub-suite: /empty ---------------->>>


<<<----------sub-suite: /basic ---------------->>>
<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /basic/declare ---------------->>>
	<<suite "declare" make="subdir-makefile-template">>

<<<----------case: /basic/declare/def-header----------------->>>
	<<case "def-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple definition headers
*/
			<</desc>>
			<<declare_section>>

%{
namespace yynsx {
/* definition header 1 */
<<filebuf_decl/>>
int yyparse();

}
%}

%{

using namespace yynsx;

/* definition header 2*/
int main(int argc, char **argv) {

<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");	
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
%}
			<</declare_section>>
		<</script>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/def-header----------------->>>


<<<----------case: /basic/declare/decl-header----------------->>>
	<<case "decl-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple declaration headers
*/
			<</desc>>
			<<declare_section>>

%header%{
namespace yynsx {
/* declaration header 1 */
<<filebuf_decl/>>

}
%}

%header%{
/* declaration header 2*/
void showAccept(void);
%}

%{
/* definition header */
void showAccept(void) {
	printf("This text is accepted by parenthese extracter.\n");
}
%}

			<</declare_section>>
			<<accept_action>>
showAccept();
			<</accept_action>>
			<<code_section>>
using namespace yynsx;
			
int main(int argc, char **argv) {

<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");	
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
			<</code_section>>
		<</script>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
This text is accepted by parenthese extracter.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/decl-header----------------->>>


<<<----------case: /basic/declare/svt-decl-01----------------->>>
	<<case "svt-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: using %union to declare semantic value type
*/
			<</desc>>

			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-01----------------->>>


<<<----------case: /basic/declare/svt-decl-02----------------->>>
	<<case "svt-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define svt-to-be union in definition header
			and declare it as semantic value type by %union 
*/
			<</desc>>

			<<union_code>>
union mysvt_t {
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-02----------------->>>

<<<----------case: /basic/declare/svt-decl-03----------------->>>
	<<case "svt-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 1
*/
			<</desc>>

			<<union_code>>
union mysvt_t {
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>
			<<location_code>>
struct myloc_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};
			<</location_code>>

			<<union_decl>>
%union mysvt_t
%union%{
	int nVal;
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-03----------------->>>

<<<----------case: /basic/declare/svt-decl-04----------------->>>
	<<case "svt-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 2
*/
			<</desc>>
			<<union_code>>
union mysvt_t {
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}

%union%{
	int nVal;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}

%union mysvt_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-04----------------->>>

<<<----------case: /basic/declare/loc-decl-01----------------->>>
	<<case "loc-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define location-to-be struct in definition header
			and declare it as location type by %location 
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
struct myloc_t{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-01----------------->>>

<<<----------case: /basic/declare/loc-decl-02----------------->>>
	<<case "loc-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 1
*/
			<</desc>>

			<<union_code>>
union mysvt_t {
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>
			<<location_code>>
struct myloc_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location myloc_t
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
%}
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-02----------------->>>

<<<----------case: /basic/declare/loc-decl-03----------------->>>
	<<case "loc-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 2
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
struct myloc_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};

struct illegal_loc_t {
	int firstLine;
	int lastLine;
};
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}

%location illegal_loc_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-03----------------->>>

<<<----------case: /basic/declare/loc-decl-04----------------->>>
	<<case "loc-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 3
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}
%location%{
	int firstLine;
	int lastLine;
%}
%location int

			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-04----------------->>>

<<<----------case: /basic/declare/parse-param-01----------------->>>
	<<case "parse-param-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param 
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-01----------------->>>

<<<----------case: /basic/declare/parse-param-02----------------->>>
	<<case "parse-param-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param,
			but declare more than once
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}

/* if it were to use this declaration, C++ compiler would have complained */
%formal-param%{int illegal_declaration%}
%actual-param%{illegal_variable%}
			<</parse_param>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-02----------------->>>


<<<----------case: /basic/declare/destructor-01----------------->>>
	<<case "destructor-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 1: destructor specified by symbol
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
	stack_pop();
%} TagHead

%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
%} '('

%destructor%{
	fprintf(stderr, "discard tail: %s.\n", $$);
%} ')'
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard head: tables.
discard head: table.
discard head: table.
discard head: body.
discard head: html.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-01----------------->>>


<<<----------case: /basic/declare/destructor-02----------------->>>
	<<case "destructor-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 2: destructor for untagged symbols
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard undefined symbol.\n");
%} <>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-02----------------->>>

<<<----------case: /basic/declare/destructor-03----------------->>>
	<<case "destructor-03" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 3: destructor specified by semantic value type
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard tag: %s.\n", $$);
%} <pchval>

%destructor%{
	fprintf(stderr, "discard at level: %d.\n", $$);
%} <level>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard tag: tables.
discard at level: 4.
discard tag: table.
discard at level: 3.
discard tag: table.
discard at level: 2.
discard tag: body.
discard at level: 1.
discard tag: html.
discard at level: 0.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-03----------------->>>


<<<----------case: /basic/declare/destructor-04----------------->>>
	<<case "destructor-04" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: different kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
	stack_pop();
%} TagHead

%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
%} '('

%destructor%{
	fprintf(stderr, "discard tag: %s.\n", $$);
%} <pchval>

%destructor%{
	fprintf(stderr, "discard at level: %d.\n", $$);
%} <level>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-04----------------->>>


<<<----------case: /basic/declare/destructor-05----------------->>>
	<<case "destructor-05" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: all kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
	stack_pop();
%} TagHead

%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
%} '('

%destructor%{
	fprintf(stderr, "discard tag: %s.\n", $$);
%} <pchval>

%destructor%{
	fprintf(stderr, "discard at level: %d.\n", $$);
%} <level>

%destructor%{
	fprintf(stderr, "discard undefined symbol.\n");
%} <>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-05----------------->>>

<<<----------case: /basic/declare/parsevar-decl----------------->>>
	<<case "parsevar-decl" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare local variables in yyparse 
			by %parsevar-decl
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
%}
			<</parsevar_decl>>

			<<exprs_action>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-decl----------------->>>

<<<----------case: /basic/declare/parsevar-init----------------->>>
	<<case "parsevar-init" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: initialize local variables in yyparse 
			by %parsevar-init
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
	triple_t tpl;
%}
			<</parsevar_decl>>

			<<parsevar_init>>
%parsevar-init%{
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
%}
			<</parsevar_init>>

			<<exprs_action>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-init----------------->>>

<<<----------case: /basic/declare/start-symbol----------------->>>
	<<case "start-symbol" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare start symbol by %start
*/
			<</desc>>
			<<start_symbol>>
%start SText
			<</start_symbol>>
			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
Input text is accepted by tag-check grammar.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/start-symbol----------------->>>

<<<----------case: /basic/declare/dprec-rrc----------------->>>
	<<case "dprec-rrc" make="basic-make-template">>
		<<script "script-dprec-rrc">>
		<</script>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[func a b [sub c d]]
[+ [* a [/ b [^ c [* [% d e] f]]]] [sin [cos [tan [exp x]]]]]
[define myfun [a b]
	[cond a] [[display a]]
	[else] [[display b]]
]
Done!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/dprec-rrc----------------->>>

<<<----------case: /basic/declare/lex-init-action----------------->>>
	<<case "lex-init-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare lex initialization action by %lex-init
*/
			<</desc>>
			<<init_code>>
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
			<</init_code>>
			<<lex_init>>
%lex-init%{ fprintf(stdout, "start scanning...\n");%}
			<</lex_init>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
start scanning...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
start scanning...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lex-init-action----------------->>>


<<<----------case: /basic/declare/pre-match-action----------------->>>
	<<case "pre-match-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare pre-match action (just ahead of any lexical action)
			 by %pre-match
*/
			<</desc>>
			<<init_code>>
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
			<</init_code>>
			<<pre_match>>
%pre-match%{ if(yyleng > 0) {++mc;} %}
			<</pre_match>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 54
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 83
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/pre-match-action----------------->>>


<<<----------case: /basic/declare/lexvar-decl----------------->>>
	<<case "lexvar-decl" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare local variables for yylex by %lexvar-decl or %lvar-decl
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
%}
			<</lvar_decl>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-decl----------------->>>


<<<----------case: /basic/declare/lexvar-init----------------->>>
	<<case "lexvar-init" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: initialize local variables for yylex by %lexvar-init or %lvar-init
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
%}
			<</lvar_decl>>

			<<lvar_init>>
%lvar-init%{ ic = 0; rc = 0; oc = 0; mc = 0; dc = 0; %}
			<</lvar_init>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-init----------------->>>

<<<----------case: /basic/declare/yywrap-action----------------->>>
	<<case "yywrap-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare yywrap action by %yywrap
*/
			<</desc>>
			<<init_code>>
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
			<</init_code>>
			<<yywrap>>
%yywrap%{
	fprintf(stdout, "file switching ...\n");
	return false;
%}
			<</yywrap>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
file switching ...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
file switching ...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/yywrap-action----------------->>>

<<<----------case: /basic/declare/lexical-actions----------------->>>
	<<case "lexical-actions" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: using %lex-init %pre-match
			%lexvar-decl %lexvar-init %yywrap
*/
			<</desc>>
<<lvar_decl>>
%lvar-decl%{
// integer counter
int ic;
// real(excluding integer) counter
int rc;
// operator counter
int oc;
// number of matched pattern
int mc;
// discarded symbols;
int dc;
%}
<</lvar_decl>>

<<lvar_init>>
%lvar-init%{ ic = 0; rc = 0; oc = 0; mc = 0; dc = 0; %}
<</lvar_init>>

<<lex_init>>
%lex-init%{ fprintf(stdout, "start scanning...\n");%}
<</lex_init>>

<<pre_match>>
%pre-match%{ if(yyleng > 0) {++mc;} %}
<</pre_match>>

<<yywrap>>
%yywrap%{
	if(yy_has_buffer()) {
		fprintf(stdout, "file switching ...\n");
		return 0;
	}
	return 1;
%}
<</yywrap>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
start scanning...
file switching ...
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 30
start scanning...
file switching ...
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 29
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexical-actions----------------->>>


<<<----------case: /basic/declare/token-decl-01----------------->>>
	<<case "token-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 1
*/
			<</desc>>
			<<token_decl>>
%token '+' '-'
%token '*' '/'
%token '^'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-01----------------->>>

<<<----------case: /basic/declare/token-decl-02----------------->>>
	<<case "token-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 2
*/
			<</desc>>
			<<token_decl>>
%token '\+' '\-'
%token '\*' '\/'
%token '\^'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-02----------------->>>

<<<----------case: /basic/declare/token-decl-03----------------->>>
	<<case "token-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2b' '\x2d'
/* '*' '/' */
%token '\x2a' '\x2f'
/* '^' */
%token '\x5e'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-03----------------->>>

<<<----------case: /basic/declare/token-decl-04----------------->>>
	<<case "token-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\X2B' '\X2D'
/* '*' '/' */
%token '\X2A' '\X2F'
/* '^' */
%token '\X5E'
			<</token_decl>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-04----------------->>>


<<<----------case: /basic/declare/token-decl-05----------------->>>
	<<case "token-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2B' '\X2d'
/* '*' '/' */
%token '\X2a' '\x2F'
/* '^' */
%token '\X5E'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-05----------------->>>


<<<----------case: /basic/declare/token-decl-06----------------->>>
	<<case "token-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\053' '\055'
/* '*' '/' */
%token '\052' '\057'
/* '^' */
%token '\136'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-06----------------->>>


<<<----------case: /basic/declare/type-decl----------------->>>
	<<case "type-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare types(also called non-terminals) in grammar
			by %type
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<type_decl>>
%type<nVal> Lines Task
			<</type_decl>>

			<<other_decl>>
%destructor%{
	fprintf(stdout, "%ld lines included in this task.\n", $$);
%} Task
			<</other_decl>>

			<<type_action_0>>
$$ = $1;
			<</type_action_0>>
			<<type_action_1>>
$$ = $1 + 1;
			<</type_action_1>>
			<<type_action_2>>
$$ = 0;
			<</type_action_2>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
14 lines included in this task.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/type-decl----------------->>>


<<<----------case: /basic/declare/left-decl-01----------------->>>
	<<case "left-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 1
*/
			<</desc>>
			<<token_decl>>
%left '+' '-'
%left '*' '/'
%left '^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-01----------------->>>

<<<----------case: /basic/declare/left-decl-02----------------->>>
	<<case "left-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 2
*/
			<</desc>>
			<<token_decl>>
%left '\+' '\-'
%left '\*' '\/'
%left '\^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-02----------------->>>

<<<----------case: /basic/declare/left-decl-03----------------->>>
	<<case "left-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%left '\x5e'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-03----------------->>>

<<<----------case: /basic/declare/left-decl-04----------------->>>
	<<case "left-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-04----------------->>>


<<<----------case: /basic/declare/left-decl-05----------------->>>
	<<case "left-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-05----------------->>>


<<<----------case: /basic/declare/left-decl-06----------------->>>
	<<case "left-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%left '\136'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-06----------------->>>


<<<----------case: /basic/declare/right-decl-01----------------->>>
	<<case "right-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 1
*/
			<</desc>>
			<<token_decl>>
%right '+' '-'
%right '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-01----------------->>>

<<<----------case: /basic/declare/right-decl-02----------------->>>
	<<case "right-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 2
*/
			<</desc>>
			<<token_decl>>
%right '\+' '\-'
%right '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-02----------------->>>

<<<----------case: /basic/declare/right-decl-03----------------->>>
	<<case "right-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2b' '\x2d'
/* '*' '/' */
%right '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-03----------------->>>

<<<----------case: /basic/declare/right-decl-04----------------->>>
	<<case "right-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\X2B' '\X2D'
/* '*' '/' */
%right '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-04----------------->>>


<<<----------case: /basic/declare/right-decl-05----------------->>>
	<<case "right-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2B' '\X2d'
/* '*' '/' */
%right '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-05----------------->>>


<<<----------case: /basic/declare/right-decl-06----------------->>>
	<<case "right-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\053' '\055'
/* '*' '/' */
%right '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-06----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>
	<<case "nonassoc-decl-01" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 1
*/
			<</desc>>
			<<token_decl>>
%nonassoc '+' '-'
%left '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>
	<<case "nonassoc-decl-02" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 2
*/
			<</desc>>
			<<token_decl>>
%nonassoc '\+' '\-'
%left '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>
	<<case "nonassoc-decl-03" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>
	<<case "nonassoc-decl-04" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>
	<<case "nonassoc-decl-05" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>
	<<case "nonassoc-decl-06" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>


<<<----------case: /basic/declare/parse-init-decl----------------->>>
	<<case "parse-init-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's initialization action by %parse-init,
			which is performed immediate before yyparse is ready to parsing 
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_init>>
%parse-init%{
	fprintf(stdout, "Let\'s get down to work.\n");
	errors = 0;
%}
			<</parse_init>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
Let's get down to work.
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-init-decl----------------->>>


<<<----------case: /basic/declare/parse-exit-decl----------------->>>
	<<case "parse-exit-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's exit action by %parse-exit,
			which is performed immediate before return from yyparse
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_exit>>
%parse-exit%{
	if(errors > 0) {
		fprintf(stdout, "%d errors occurred.\n", errors);
	}
	fprintf(stdout, "Well done! Thank you for your excellent work, Mr. Parser.\n");
%}
			<</parse_exit>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
1 errors occurred.
Well done! Thank you for your excellent work, Mr. Parser.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-exit-decl----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/declare ---------------->>>


<<<----------sub-suite: /basic/interface -------------->>>
	<<suite  "interface" make="subdir-makefile-template">>


<<<----------case: /basic/interface/buffer-stack----------------->>>
	<<case "buffer-stack" make="basic-make-template">>
		<<script "interface-bstack-template">>
		<</script>>

		<<textfile "test.input">>
***************************************
test lcase number test1
lcase> open "cur?*************************
in lcase
abcdefg
close hijklm"
cur?
number> open 'cur?************************
in number
1234567
pop
89'
cur?
test1> open `test1.input`
pop
closing can not be executed, because of popping action
close
text ignored
		<</textfile>>

		<<textfile "test1.input">>
cur?**************************
in test1 test2 ucase
test2> open `test2.input`
cur?
ucase> open "cur?************************
ABCDEF
pop
XYZ"

******************test yy_push_buffer***********************
test2> push `test2.input`
******************test yy_push_buffer***********************
test3> push `test3.input`

pop
abortion can not executed, because of popping action
 
abort
		<</textfile>>

		<<textfile "test2.input">>
cur?**************************
in test2 chinese test3
chinese> open "

close
Over"
test3> open `test3.input`
close
test ignored
		<</textfile>>

		<<textfile "test3.input">>
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
***************************************
test lcase number test1
current buffer: lcase
*************************
in lcase
abcdefg
closing buffer lcase ...
switching to buffer test ...

current buffer: test

current buffer: number
************************
in number
1234567
popping buffer number ...
switching to buffer test ...

current buffer: test

current buffer: test1
**************************
in test1 test2 ucase
current buffer: test2
**************************
in test2 chinese test3


closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

current buffer: test1

current buffer: ucase
************************
ABCDEF
popping buffer ucase ...
switching to buffer test1 ...


******************test yy_push_buffer***********************
current buffer: test2
**************************
in test2 chinese test3


closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

******************test yy_push_buffer***********************
current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.


popping buffer test1 ...
switching to buffer test ...

popping buffer test ...
All buffers closed.
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/buffer-stack----------------->>>

<<<----------case: /basic/interface/ECHO----------------->>>
	<<case "ECHO" make="basic-make-template">>
		<<script "interface-echo-template">>
		<</script>>

		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/ECHO----------------->>>


<<<----------case: /basic/interface/get-bol----------------->>>
	<<case "get-bol" make="basic-make-template">>
		<<script "interface-getbol-template">>
		<</script>>

		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/get-bol----------------->>>


<<<----------case: /basic/interface/line-editor----------------->>>
	<<case "line-editor" make="basic-make-template">>
		<<script "interface-line-editor-template">>
		<</script>>

		<<textfile "test.input">>
Just e!01image!01ine, what is goning to be link!02ke if you are travelling in the outer space.!!no useful
Simply beatui!03utiful, yes that must &be very @-05good.
Hey&, wait a minute@01 it's simply &too good @02 be true. Please &stop, @04 dreaming&!&!&!
		<</textfile>>

		<<textfile "result.out">>
Just imagine, what is goning to be like if you are travelling in the outer space.
Simply beautiful, yes that must be very very good.
Hey, wait a minute, it's simply too good to be true. Please stop, stop dreaming!!!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/line-editor----------------->>>


<<<----------case: /basic/interface/loc2----------------->>>
	<<case "loc2" make="basic-make-template">>
		<<script "interface-loc2-template">>
		<</script>>

		<<textfile "test.input">>
#location_head
%$103
%%$$205
%%%$$$307
%%%%$$$$409
%%%%%$$$$$511
%%%%%%$$$$$$613
%%%%%%%$$$$$$$715
%%%%%%%%$$$$$$$$817

%a02%a06$a10
%%%%$$$$b09
%%%%$$$c08
%%%%$$d07
%%%%$$$$$%%%$%%%$$%%%$%%$$$$$$$e32
#location_tail


#location_head
%	109 %%		125 %%%			149 %%%%				189 %%%%%					1d7 %%%%%%						1j3 %%%%%%%							1p7 %%%%%%%%								1w9  %1x5%1x9	1y5 %%%%				1C5 %%%%			1F7 %%%%		1I1 %%%%	1J7
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#location_tail



tab=8

#tab_replace 0
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#tab_replace

tab?

#line_replace 1
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#line_replace




#orignal 2
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#orignal



#orignal 3
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#orignal

		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
after reseting, line: 1	col: 1
begin scanning tab_replace section by referrence 0
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning tab_replace section is over
begin comparing location(size 15) 0 and its referrence(size 15)
tabsize = 8
after reseting, line: 1	col: 1
begin scanning line_replace section by referrence 1
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning line_replace section is over
begin comparing location(size 15) 1 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 2
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 2 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 3
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 3 and its referrence(size 15)
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc2----------------->>>

<<<----------case: /basic/interface/loc1----------------->>>
	<<case "loc1" make="basic-make-template">>
		<<script "interface-location-template">>
		<</script>>

		<<textfile "test.input">>
tab=8
<test1.input>	217
301 305 309	317		333 337  342   348    355     363	373
tab=6
<test2.input>	519
601 605 609	613		625 629  634   640    647     655	661
		<</textfile>>

		<<textfile "test1.input">>
tab?
 202 206  211	217			229	233
tab=1	307
 402 406  411	415			421	425	
		<</textfile>>

		<<textfile "test2.input">>
tab=3
   204	210	216			228 232
tab?	307
		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
file `test1.input` is open.
tabsize = 4
tabsize is 1 now
file closed.
tabsize is 6 now
file `test2.input` is open.
tabsize is 3 now
tabsize = 3
file closed.
file closed.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc1----------------->>>


<<<----------case: /basic/interface/tinyfp----------------->>>
	<<case "tinyfp" make="basic-make-template">>
		<<script "interface-tinyfp-template">>
		<</script>>

		<<textfile "test.input">>
; scheme sample
#| test parsing expression of scheme
|#


(define (square x) (* x x))
(define (4times x) 
  (
    (lambda (a)
      (* a a))
    (square x)))

(define macro1 "(lambda (x) \'(Hi , x)
)")
;((lambda (x) '(Hi , x)) 3)
(eval macro1 3)
(ceval macro1 "world")

(define f1 "test1.input")
(load f1)


(define (sqrt y)
  
  (define (over? xm xn)
    (if
      (< (ceval m1 (- xm xn)) 0.00001)
      #t
      #f))
  (define (nextx xm)
    (/ (+ xm (/ y xm)) 2))
  (define (xsqrt xm)
    (if (over? xm (nextx xm))
      xm
      (xsqrt (nextx xm))))
  (xsqrt 1)
)

(sqrt 2.0)


(define f1 "test1.input")
(load f1)

(root dsqr 16.0 0.0001)
(root dcub 64.0 0.00001)

		<</textfile>>

		<<textfile "test1.input">>
(define m1 "(define (xabs a)
    (if
      (< a 0)
      (- 0 a)
      a))")

(define (root expr y e)
  (define (fabs n)
    (if (< n 0)
      (- 0 n)
      n))
  (define (ok? x xn)
    (< (fabs (- x xn)) e))
  (define (nextx x)
    (expr x y))
  (define (xroot x)
    (if (ok? x (nextx x))
      x
      (xroot (nextx x))))
  (xroot 1.0)
)

(define dsqr
  (lambda (x y)
    (/
      (+ x (/ y x))
    2.0)
  ))

(define dcub
  (lambda (x y)
   (/
     (+ (* x 2.0) (/ y (* x x)))
   3.0)
  ))
      
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
expand macro `macro1', its content is `(lambda (x) '(Hi , x)
)'
expand macro `macro1', its content is `(lambda (x) '(Hi , x)
)'
open file `f1', its content is `test1.input'
expand macro `m1', its content is `(define (xabs a)(if(< a 0)(- 0 a)a))'
open file `f1', its content is `test1.input'
parsing scheme program succeeded
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/tinyfp----------------->>>


<<<----------case: /basic/interface/yyerror----------------->>>
	<<case "yyerror" make="basic-make-template">>
		<<script "interface-yyerror-template">>
		<</script>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9

		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Redirect to my error-handler ---- Error: syntax error at 1:7.
Redirect to my error-handler ---- Error: syntax error at 2:1.
Redirect to my error-handler ---- Error: syntax error at 3:1.
Redirect to my error-handler ---- Error: syntax error at 4:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/yyerror----------------->>>


<<<----------case: /basic/interface/esc-char-inaction----------------->>>
	<<case "esc-char-inaction" make="basic-make-template">>
		<<script "esc-char-inaction-template">>
		<</script>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9
end
well done!

		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
in parsevar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parsevar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$1 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 1
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 2
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 3
$$ is used to count number of numbers, and $$ is 3
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is begin
$$ is used to count number of numbers, and $$ is 3
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is add
$$ is used to count number of numbers, and $$ is 3
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 4
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 5
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is sub
$$ is used to count number of numbers, and $$ is 5
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 6
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 7
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is div
$$ is used to count number of numbers, and $$ is 7
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 8
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 9
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is end
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is well
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is done
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in yywrap: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-exit: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/esc-char-inaction----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/interface -------------->>>


<</suite>>
<<<----------sub-suite: /basic ---------------->>>


<</suites>>
<<<----------top-level suite: / ---------->>>

<<conf make="config-template">>
<<version>>0.50.101<</version>>
<<email>>upgen.tools@yahoo.com<</email>>
<<diff>>diff<</diff>>
<</conf>>

