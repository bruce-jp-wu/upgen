<<<< ------------------------------ global setting
<<settings>>

	<<group>>
<<<<<<<------------------ input from file
<<buffer_init>>yylexfile(argv[1], false)<</buffer_init>>
<<buffer_init2>>lexfile(argv[1], false)<</buffer_init2>>
<<buffer_init3>>yylexfile(argv[1], false)<</buffer_init3>>
<<filebuf_decl2>>lexfile(const char *, bool);<</filebuf_decl2>>
<<filebuf_decl>>int yylexfile(const char*, bool);<</filebuf_decl>>
<<inputed_file>> $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = fopen(argv[1], "r");<</before_myinput>>
<<stream_type>>c++-file.log<</stream_type>>
>>>>>>>------------------ input from file
	<</group>>


	<<group>>
<<<<<<------------------ input from stdin
<<buffer_init>>yylexfile(NULL, true)<</buffer_init>>
<<buffer_init2>>lexfile(NULL, true)<</buffer_init2>>
<<buffer_init3>>yylexfile(NULL, false)<</buffer_init3>>
<<filebuf_decl>>int yylexfile(const char*, bool);<</filebuf_decl>>
<<filebuf_decl2>>lexfile(const char *, bool);<</filebuf_decl2>>
<<inputed_file>> < $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = stdin;<</before_myinput>>
<<stream_type>>c++-stdin.log<</stream_type>>
>>>>>>------------------- input from stdin
	<</group>>


	<<group>>
<<<<<<<------------------ input from buffer
<<before_buffer_init>>
	if(argc < 2) {
		fprintf(stderr, "Error: file name expected\n");
		return 0;
	}
	struct stat st;
	if(stat(argv[1], &st)) {
		fprintf(stderr, "Error: failed to access file `%s\'.\n", argv[1]);
		return 0;
	}

	char *buffer_content = NULL;
	size_t tt2 = 0;

	if(st.st_size > 0) {

		FILE *infile = fopen(argv[1], "r");
		if( ! infile) {
			fprintf(stderr, "Error: failed to open file `%s\'.\n", argv[1]);
			return 0;
		}

		size_t tt1 = (size_t)st.st_size;
		
		size_t ngot;

		buffer_content = new char[tt1 + 1];
		if( ! buffer_content) {
			fprintf(stderr, "Error: failed to allocate buffer.\n");
			return 0;
		}
		buffer_content[tt1] = '\0';
	
		while(tt1 > 0) {
			if((ngot = fread(&buffer_content[tt2], sizeof(char), tt1, infile)) == 0 
				&& ferror(infile)) {
				if(errno != EINTR) {
					break;
				}
				clearerr(infile);
				errno = 0;
			}
			tt1 -= ngot;
			tt2 += ngot;		
		}
		buffer_content[tt2] = '\0';
		++tt2;

		fclose(infile);
	}
	else {
		buffer_content = new char[2];
		buffer_content[0] = buffer_content[1] = '\0';
		tt2 = 1;
	}

<</before_buffer_init>>

<<after_buffer_usage>>
	if(buffer_content) {
		delete[] buffer_content;
	}
<</after_buffer_usage>>

<<buffer_init>>yylexstr(buffer_content, (int)tt2)<</buffer_init>>
<<buffer_init2>>lexstr(buffer_content, (int)tt2)<</buffer_init2>>
<<buffer_init3>>yylexstr(buffer_content, (int)tt2)<</buffer_init3>>
<<filebuf_decl2>>lexstr(char *, int);<</filebuf_decl2>>
<<filebuf_decl>>int yylexstr(char*, int);<</filebuf_decl>>
<<inputed_file>> $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = fopen(argv[1], "r");<</before_myinput>>
<<stream_type>>c++-buffer.log<</stream_type>>
>>>>>>>------------------ input from buffer
	<</group>>

	<<group>>
<<<<<<<------------------ input from copied buffer
<<before_buffer_init>>
	if(argc < 2) {
		fprintf(stderr, "Error: file name expected.\n");
		return 0;
	}
	struct stat st;
	if(stat(argv[1], &st)) {
		fprintf(stderr, "Error: failed to access file `%s\'.\n", argv[1]);
		return 0;
	}

	char *buffer_content = NULL;
	size_t tt2 = 0;

	if(st.st_size > 0) {

		FILE *infile = fopen(argv[1], "r");
		if( ! infile) {
			fprintf(stderr, "Error: failed to open file `%s\'.\n", argv[1]);
			return 0;
		}

		size_t tt1 = (size_t)st.st_size;
		
		size_t ngot;

		buffer_content = new char[tt1 + 1];
		if( ! buffer_content) {
			fprintf(stderr, "Error: failed to allocate buffer.\n");
			return 0;
		}
		buffer_content[tt1] = '\0';
	
		while(tt1 > 0) {
			if((ngot = fread(&buffer_content[tt2], sizeof(char), tt1, infile)) == 0 
				&& ferror(infile)) {
				if(errno != EINTR) {
					break;
				}
				clearerr(infile);
				errno = 0;
			}
			tt1 -= ngot;
			tt2 += ngot;		
		}
		buffer_content[tt2] = '\0';
		++tt2;

		fclose(infile);
	}
	else {
		buffer_content = new char[2];
		buffer_content[0] = buffer_content[1] = '\0';
		tt2 = 1;
	}

<</before_buffer_init>>

<<after_buffer_usage>>
	if(buffer_content) {
		delete[] buffer_content;
	}
<</after_buffer_usage>>

<<buffer_init>>yylexcstr(buffer_content, (int)tt2)<</buffer_init>>
<<buffer_init2>>lexcstr(buffer_content, (int)tt2)<</buffer_init2>>
<<buffer_init3>>yylexcstr(buffer_content, (int)tt2)<</buffer_init3>>
<<filebuf_decl2>>lexcstr(const char *, int);<</filebuf_decl2>>
<<filebuf_decl>>int yylexcstr(const char*, int);<</filebuf_decl>>
<<inputed_file>> $(srcdir)/test.input <</inputed_file>>
<<before_myinput>>s_pfile = fopen(argv[1], "r");<</before_myinput>>
<<stream_type>>c++-cbuffer.log<</stream_type>>
>>>>>>>------------------ input from copied buffer
	<</group>>


<</settings>>
>>>> ------------------------------------ global setting
<<templs>>

<<<----------template for configure.ac-------------->>>
<<templ "config-template">>AC_INIT([the pattern-matching and parsing program generator], [<<version/>>], [<<email/>>], [upgen])
AM_INIT_AUTOMAKE([])
AC_PROG_CC
AC_PROG_CXX
AC_CHECK_HEADERS([stdio.h])
AC_CHECK_HEADERS([sys/stat.h])
AC_CHECK_HEADERS([string.h])

AC_HEADER_STDC
AC_HEADER_STDBOOL
AC_CHECK_FUNCS([isdigit isalpha memset])
AC_CONFIG_HEADERS([config.h])

UDIFF=<<diff/>>
LOGFILE=../../upgen_test_log/<<stream_type/>>
AC_SUBST([UPGEN_BINDIR])
AC_SUBST([UDIFF])
AC_SUBST([LOGFILE])

AC_CONFIG_FILES(<<makefiles/>>
)
AC_OUTPUT

<</templ>>

<<<----------template for Makefile.am of directories---------->>>
<<templ "subdir-makefile-template">>## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE
SUBDIRS = <<subdirs/>>
DIST_SUBDIRS = <<subdirs/>>

test-suites: clean
	NOK=;\
	NFAIL=;\
	for subdir in $(SUBDIRS) ; do \
		echo Enter "$$subdir" "..." >> $(top_srcdir)/$(LOGFILE) ; \
		( cd "$$subdir" && $(MAKE) test-suites --quiet) ; \
		case $$? in \
			0 ) NOK=0$$NOK;\
				;; \
			* ) NFAIL=0$$NFAIL; \
				;; \
		esac; \
	done ; \
	echo Results: >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NOK@ECHO_C@"|wc -c` succeeded >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NFAIL@ECHO_C@"|wc -c` FAILED >> $(top_srcdir)/$(LOGFILE) ; \
	test "$$NFAIL" = ""

<</templ>>

<<<----------template for Makefile.am of cases---------->>>
<<templ "lex-only-makefile-template">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) <<upgen_options/>> -clLp -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "make-no-exec">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

UPGEN = $(UPGEN_BINDIR)/upgen

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

EXTRA_DIST = script.upg test.input result.out result.err
CLEANFILES = test.out test.err

test-suites: $(srcdir)/script.upg
	$(UPGEN) <<upgen_options/>> -o script.cpp $< >$(srcdir)/test.out 2>$(srcdir)/test.err; \
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<<----------template for script.upg of cases---------->>>
<<templ "lex-only-script-template">><<desc/>>
%{
#include <iostream>
using std::cout;
using std::endl;

<<init_code/>>
%}
<<declare_section/>>
%%
<<lex_section/>>
%%
<<parse_section/>>
%%
<<code_section/>>

using namespace yynsx;

int main(int argc, char **argv) {

<<before_buffer_init/>>
<<before_init/>>
	if(<<buffer_init/>>) {
		return -1;
	}
<<after_init/>>
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "invoke-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -cL <<upgen_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "invoke-make-stdout-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -cL <<upgen_options/>> -t $< >$@ 2>> $(top_srcdir)/$(LOGFILE) ;
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "invoke-make-lex-parse-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp scanner.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg scanner.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = script.cpp scanner.cpp test.out test.err $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -clL <<parser_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
scanner.cpp: $(srcdir)/scanner.upg
	@rm -f scanner.cpp
	$(UPGEN) <<scanner_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "basic-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.cpp

AM_CXXFLAGS = -std=c++11 $(DEPS_CXXFLAGS)

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.cpp $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT)

script.cpp: $(srcdir)/script.upg
	@rm -f script.cpp
	$(UPGEN) -clL <<upgen_options/>> -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>$(srcdir)/test.out 2>$(srcdir)/test.err;	\
	messge=`$(UDIFF) -w -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>

<<templ "invoke-full-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%{

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>


typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

// to avoid copy yytext
static string	s_strVarName; 
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

[0-9]+				<<prefix/>>lval.nVal = atoi(yytext);
				return NUM;
"quit"				return QUIT;
"clear"				return CLEAR;
"list"				return LIST;
{var}				s_strVarName = yytext;
				return VARI;
[\+\-\*\/\%\^\=\(\)\?\n]	return yytext[0];

<<default_action/>>

%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
			cerr << "; description: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: at " << @1.firstLine << ": " << @1.firstColumn;
		cerr << "; description: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
				cerr << "; description: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;

%%

using namespace <<prefix/>>nsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<prefix/>><<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	<<prefix/>>parse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "invoke-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>


typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

// to avoid copy yytext
static string	s_strVarName; 
			
%}


/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

			
%%

[0-9]+				<<prefix/>>lval.nVal = atoi(yytext);
				return NUM;
"quit"				return QUIT;
"clear"				return CLEAR;
"list"				return LIST;
{var}				s_strVarName = yytext;
				return VARI;
[\+\-\*\/\%\^\=\(\)\?\n]	return yytext[0];
<<default_action/>>
			
%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;

			
%%

using namespace <<prefix/>>nsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(<<prefix/>><<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	<<prefix/>>parse();
<<after_buffer_usage/>>
	return 0;
}


<</templ>>

<<templ "invoke-myscanner-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>
#include <ctype.h>


typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

static string	yytext;

static string	s_strVarName;
			
%}

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

			
%%

			
%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
			cerr << "; description: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: at " << @1.firstLine << ": " << @1.firstColumn;
		cerr << "; description: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
				cerr << "; description: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;
			
%%

using namespace <<prefix/>>nsx;

static FILE *s_pfile = NULL;

int myscanner(void) {

	int c;
	bool to_be_var;

	if( ! s_pfile) {
		return 0;
	}

	do {
		to_be_var = false;
		yytext.clear();

		c = fgetc(s_pfile);
		if(EOF == c && feof(s_pfile)) {
			return 0;
		}
		if(isdigit(c)) {
			do {
				yytext += c;
				c = fgetc(s_pfile);
			}while(isdigit(c));

			ungetc(c, s_pfile );
			<<prefix/>>lval.nVal = atoi(yytext.c_str());

			return NUM;
		}

		switch(c) {

		case '+':
		case '-':
		case '*':
		case '/':
		case '%':
		case '^':
		case '=':
		case '(':
		case ')':
		case '\?':
		case '\n':
			yytext += c;
			return c;
		case 'q':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'u') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'i') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {

						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return QUIT;
						}
					}
				}
			}
			break;

		case 'c':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'l') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'e') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 'a') {
						yytext += c;
						c = fgetc(s_pfile);
						if(c == 'r') {
							yytext += c;
							c = fgetc(s_pfile);
							if( ! isalnum(c) && c != '_') {
								ungetc(c, s_pfile);
								return CLEAR;
							}
						}
					}
				}
			}
			break;

		case 'l':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'i') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 's') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {
						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return LIST;
						}
					}
				}
			}
			break;

		default:
			
			if(isalpha(c) || c == '_') {
				to_be_var = true;
			}
			else if(c != EOF) {
				if(c != ' ' && c != '\t' && c != '\v') {
					cerr << "undefined symbol `" << (char)c << '\'' << endl;
				}
			}
			break;
		}

		if(to_be_var) {
			while(isalnum(c) || c == '_') {
				yytext += c;
				c = fgetc(s_pfile);
			}
			ungetc(c, s_pfile);

			s_strVarName = yytext;
			return VARI;
		}

	}while( ! feof(s_pfile));

	return 0;
}

int main(int argc, char **argv) {
	
	<<before_myinput/>>
	<<prefix/>>setlex(myscanner);

	<<prefix/>>parse();
	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}

<</templ>>

<<templ "invoke-myscanner-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>
#include <ctype.h>



typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

static string	yytext;

static string	s_strVarName;
			
%}

/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

			
%%

			
%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;
			
%%

using namespace yynsx;

static FILE *s_pfile = NULL;

int myscanner(void) {

	int c;
	bool to_be_var;

	if( ! s_pfile) {
		return 0;
	}

	do {
		to_be_var = false;
		yytext.clear();

		c = fgetc(s_pfile);
		if(EOF == c && feof(s_pfile)) {
			return 0;
		}
		if(isdigit(c)) {
			do {
				yytext += c;
				c = fgetc(s_pfile);
			}while(isdigit(c));

			ungetc(c, s_pfile );
			<<prefix/>>lval.nVal = atoi(yytext.c_str());

			return NUM;
		}

		switch(c) {

		case '+':
		case '-':
		case '*':
		case '/':
		case '%':
		case '^':
		case '=':
		case '(':
		case ')':
		case '\?':
		case '\n':
			yytext += c;
			return c;
		case 'q':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'u') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'i') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {

						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return QUIT;
						}
					}
				}
			}
			break;

		case 'c':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'l') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 'e') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 'a') {
						yytext += c;
						c = fgetc(s_pfile);
						if(c == 'r') {
							yytext += c;
							c = fgetc(s_pfile);
							if( ! isalnum(c) && c != '_') {
								ungetc(c, s_pfile);
								return CLEAR;
							}
						}
					}
				}
			}
			break;

		case 'l':

			to_be_var = true;
			yytext += c;
			c = fgetc(s_pfile);
			if(c == 'i') {
				yytext += c;
				c = fgetc(s_pfile);
				if(c == 's') {
					yytext += c;
					c = fgetc(s_pfile);
					if(c == 't') {
						yytext += c;
						c = fgetc(s_pfile);
						
						if( ! isalnum(c) && c != '_') {
							ungetc(c, s_pfile);
							return LIST;
						}
					}
				}
			}
			break;

		default:
			
			if(isalpha(c) || c == '_') {
				to_be_var = true;
			}
			else if(c != EOF) {
				if(c != ' ' && c != '\t' && c != '\v') {
					cerr << "undefined symbol `" << (char)c << '\'' << endl;
				}
			}
			break;
		}

		if(to_be_var) {
			while(isalnum(c) || c == '_') {
				yytext += c;
				c = fgetc(s_pfile);
			}
			ungetc(c, s_pfile);

			s_strVarName = yytext;
			return VARI;
		}

	}while( ! feof(s_pfile));

	return 0;
}

int main(int argc, char **argv) {
	
	<<before_myinput/>>
	<<prefix/>>setlex(myscanner);

	<<prefix/>>parse();
	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}

<</templ>>


<<templ "invoke-parser-only-template">>

/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only parsing program.
************************************************************************/

%{

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <string>
using std::string;

#include <cmath>
#include <cstdlib>



typedef pair<string, int> s2i_pair_t;
typedef map<string, int> s2i_map_t;
typedef s2i_map_t::iterator s2i_it_t;
typedef s2i_map_t::const_iterator s2i_cit_t;

#define LBLANS		"ans"

// to avoid copy yytext
extern string	s_strVarName;

namespace zznsx {

extern bool zz<<filebuf_decl2/>>
extern int zzlex(void);
}

%}


/* semantic value type declaration */
%union%{
	int nVal;
	char *pchVal;
%}

/* declaration of local varaibles used in yyparse */
%parsevar-decl%{
	s2i_map_t mapVars;
	string strVar;
	bool bNaN = false;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

%%

Program: %{
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| Program Line		%{

		bNaN = false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if( ! bNaN) {
			mapVars[LBLANS] = $1;
			cout << "ans = \t\t" << $1 << endl;
		}
	%}
	| VARI 			%{
		strVar = s_strVarName;
	%}
	'=' Expr '\n'		%{
		if( ! bNaN) {
			mapVars[strVar] = $4;
			cout << strVar  << " = \t\t" << $4 << endl;
		}
	%}
	| VARI %{

		s2i_cit_t cit = mapVars.find(s_strVarName);
		if(cit != mapVars.end()) {
			cout << s_strVarName << " = \t\t" << cit->second << endl;
		}
		else {
			cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
			cerr << "; description: " << s_strVarName << " is unset variable." << endl;
		}
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear();
		mapVars.insert(s2i_pair_t(LBLANS, 0));
	%}
	| LIST	'\n'		%{
		for(s2i_cit_t cit = mapVars.begin(); cit != mapVars.end(); ++cit) {
			cout << cit->first << " = \t\t" << cit->second << endl;
		}
	%}
	| QUIT	'\n'		%{
		YYACCEPT();
	%}
	| error '\n'		%{
		cerr << "Error: at " << @1.firstLine << ": " << @1.firstColumn;
		cerr << "; description: undefined symbol." << endl;
		yyerrok();
	%}
	;

Expr:	Expr '+' Expr		%{
		if( ! bNaN) {
			$$ = $1 + $3;
		}
	%}
	| Expr '-' Expr		%{
		if( ! bNaN) {
			$$ = $1 - $3;
		}
	%}
	| Expr '*' Expr		%{
		if( ! bNaN) {
			$$ = $1 * $3;
		}
	%}
	| Expr '/' Expr		%{
		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 / $3;
			}
		}
	%}
	| Expr '%' Expr		%{

		if( ! bNaN) {
			if($3 == 0) {
				cerr << "Error: at " << @3.firstLine << ": " << @3.firstColumn;
				cerr << "; description: divided by zero!!" << endl;
				bNaN = true;
			}
			else {
				$$ = $1 % $3;
			}
		}
	%}
	| Expr '^' Expr		%{

		if( ! bNaN) {

			if($3 == 0) {
				$$ = 1;
			}
			else if($1 == 0) {
				$$ = 0;
			}
			else {
				int expo = $3;

				if($3 < 0) {
					expo = - expo;				
				}
			
				$$ = $1;
				int r = 1;
				while(expo > 1) {
				
					if(expo % 2 == 1) {
						r *= $$;
					}
					$$ *= $$;
					expo >>= 1;
				}
				$$ *= r;

				if($3 < 0) {
					$$ = 1 / $$;
				}
			}
		}
	%}
	| '-' %prec MINUS Expr	%{

		if( ! bNaN) {
			$$ = - $2;
		}
	%}
	| '+' %prec MINUS Expr	%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| '(' Expr ')'		%{
		if( ! bNaN) {
			$$ = $2;
		}
	%}
	| NUM			%{
		$$ = $1;
	%}
	| VARI			%{

		if( ! bNaN) {
			s2i_cit_t cit = mapVars.find(s_strVarName);
			if(cit != mapVars.end()) {
				$$ = cit->second;
			}
			else {
			
				cerr << "Error: at " << @1.firstLine << ":" << @1.firstColumn;
				cerr << "; description: " << s_strVarName << " is unset variable." << endl;
				bNaN = true;
			}
		}
	%}
	;

%%

using namespace yynsx;
using namespace zznsx;

string	s_strVarName;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(zz<<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	yysetlex(zzlex);

	yyparse();
<<after_buffer_usage/>>
	return 0;
}


<</templ>>

<<templ "invoke-noparser-template">>
<<desc/>>
/***********************************************************************
	program sample : extract keywords, identifiers, and numbers
************************************************************************/
<<option_prefix/>>
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
		
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*
			
%%

[0-9]+				cout << "number: " << yytext << endl;
"quit"				cout << "keyword: " << yytext << endl;
"clear"				cout << "keyword: " << yytext << endl;
"list"				cout << "keyword: " << yytext << endl;
{var}				cout << "identifier: " << yytext << endl;
[\+\-\*\/\%\^\=\(\)\?]		cout << "operator: " << yytext[0] << endl;
\n				cout << "new line encountered." << endl;
<<default_action/>>
<<EOF>>				cout << "Good-bye!" << endl;
			
%%

			
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(<<prefix/>><<buffer_init2/>>) {
		cerr << "Error: initialization failed." << endl;
		return -1;
	}

	<<prefix/>>lex();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "basic-parentheses-template">>
<<desc/>>
/**********************************************************************
	program sample: extract parentheses from expression,
			and convert them to brackets
***********************************************************************/

<<declare_section/>>
%%

[\(\)]		<<parent_lex_action/>>
		return yytext[0];
\n		printf("\n");
.

%%

Program: PExpr %{
<<accept_action/>>
		YYACCEPT();
	%}
	;

PExpr: PExpr PItem	%{

	%}
	|
	;
PItem: '('		%{
		printf("[");
	%}
	PExpr ')'	%{
		printf("]");
	%}
	;
%%
<<code_section/>>

<</templ>>

<<templ "basic-sentinfo-template">>
<<desc/>>
/****************************************************************
	program sample: count information of sentences in text
*****************************************************************/

%{
<<union_code/>>
<<location_code/>>
static int sentenceCounter = 1;
%}

<<union_decl/>>
<<location_decl/>>

%parsevar-decl%{
int lineCounter = 0;
int wordCounter = 0;
int charCounter = 0;
%}

ws	[ \t]
nows	[^ \t\n\.\?\!]

%token<nVal> TK_WORD TK_WS
%token	TK_ES

%type<nPair> Block Blocks

%%

[\.\?\!]		{
		yylloc.sentenceNo = sentenceCounter;
		++sentenceCounter;
		return TK_ES;
	}

{nows}+	{
		yylloc.sentenceNo = sentenceCounter;
		yylval.nVal = yyleng;
		return TK_WORD;
	}

{ws}+		{
		yylloc.sentenceNo = sentenceCounter;
		yylval.nVal = yyleng;
		return TK_WS;
	}
\n		{
		yylloc.sentenceNo = sentenceCounter;
		return '\n';
	}

%%


SText: Blocks	%{
		fprintf(stdout, "Words: %d\n", wordCounter);
		fprintf(stdout, "Chars: %d\n", charCounter);
		fprintf(stdout, "Sents: %d\n", @1.sentenceNo);
		fprintf(stdout, "Lines: %d\n", lineCounter);
		YYACCEPT();
	%}
	;

Blocks:	Blocks Block	%{
		@$.sentenceNo = @2.sentenceNo;
		if($2.charCounter == -1) {
			++$1.charCounter;
			fprintf(stdout, "S%d\t%d words;\t%d characters.\n",
				@1.sentenceNo,
				$1.wordCounter,
				$1.charCounter);

			++charCounter;

			$$.wordCounter = 0;
			$$.charCounter = 0;
		}
		else {
			$$.wordCounter = $1.wordCounter + $2.wordCounter;
			$$.charCounter = $1.charCounter + $2.charCounter;

			wordCounter += $2.wordCounter;
			charCounter += $2.charCounter;
		}
	%}
	| Block		%{
		@$.sentenceNo = @1.sentenceNo;
		if($1.charCounter == -1) {
			fprintf(stdout, "S%d\t%d words;\t1 characters.\n",
				@1.sentenceNo,
				$1.wordCounter);

			++charCounter;

			$$.wordCounter = 0;
			$$.charCounter = 0;
		}
		else {
			$$.wordCounter = $1.wordCounter;
			$$.charCounter = $1.charCounter;

			wordCounter += $1.wordCounter;
			charCounter += $1.charCounter;
		}
	%}
	;

Block: TK_WORD	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 1;
		$$.charCounter = $1;
	%}
	| TK_WS	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 0;
		$$.charCounter = $1;
	%}
	| '\n'	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 0;
		$$.charCounter = 1;
		++lineCounter;
	%}
	| TK_ES	%{
		@$.sentenceNo = @1.sentenceNo;
		$$.wordCounter = 0;
		$$.charCounter = -1;
	%}
	;

%%

using namespace yynsx;
int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "basic-tagchecker-template">>
<<desc/>>
/**************************************************************
	sample program: tag checker, which determines if
			tag head has corresponding tag tail
***************************************************************/

%{

#include <string.h>

struct triple_t{
	/* max of depth */
	int maxdep;
	/* current depth */
	int curdep;
	/* number of parentheses */
	int pairnum;
};

struct _tag_node_t {

	char *plabel;
	_tag_node_t *pnext;
};

typedef struct _tag_node_t tag_node_t;
typedef tag_node_t *tag_link_t;

/* push tag into stack */
static void stack_push(char *);
/* pop tag from stack */
static char* stack_pop();
/* get most recently pushed tag */
static char* stack_top();
/* free all nodes(not incuding their contents) in stack */
static void stack_clear();
/* allocate a string */
static char* alloc_string(int);
/* free all allocated string */
static void free_string();

/* top of tag stack */
static tag_link_t sttop = NULL;
/* top of allocation stack */
static tag_link_t stravail = NULL;

/* temporary variable */
/* @tempi used as counter in loops */
static int tempi;

<<init_code/>>
%}

/* legal name of tag excludes and string containing
	 ( ) [ ] { } < > , / " ' ; :
*/
tag	[A-Za-z0-9\!\@\#\$\%\^\&\*\+\-\_\~\`\?\.]+

/* semantic value type definition */
%union%{
	char* pchval;
	int level;
%}

%token<pchval> '(' ')'
%type<pchval> TagHead
%type<level> TagItem TagExpr
<<parse_param/>>
<<parsevar_decl/>>
<<parsevar_init/>>
<<destructor/>>
<<start_symbol/>>

%%

"<"{tag}">"	{
		yylval.pchval = alloc_string(yyleng - 1);
		strncpy(yylval.pchval, &yytext[1], yyleng - 2);
		yylval.pchval[yyleng - 2] = '\0';

		return '(';
	}

"</"{tag}">"	{
		yylval.pchval = stack_top();
		yytext[yyleng - 1] = '\0';
		if(!yylval.pchval || strcmp(yylval.pchval, &yytext[2])) {
			return ']';
		}
		return ')';
	}

.|\n		<<deflex_action/>>

%%

Exprs: TagExpr %{
		fprintf(stdout, "Tag checking passed.\n");
		<<exprs_action/>>
	%}
	;

SText: Exprs %{
		fprintf(stdout, "Input text is accepted by tag-check grammar.\n");
		YYACCEPT();
	%}
	;

TagExpr: TagExpr TagItem %{
		$$ = $2;
	%}
	|		%{
		$$ = tpl.curdep;
	%}
	;
TagItem: TagHead TagExpr ')'	%{
		--tpl.curdep;
		++tpl.pairnum;
		stack_pop();

		for(tempi = 0; tempi < tpl.curdep; ++tempi) {
			fprintf(stdout, "\t");
		}
		fprintf(stdout, "</%s>\n", $3);

		$$ = tpl.curdep;
	%}
	| TagHead error ')'	%{
		--tpl.curdep;
		++tpl.pairnum;
		stack_pop();

		for(tempi = 0; tempi < tpl.curdep; ++tempi) {
			fprintf(stdout, "\t");
		}
		fprintf(stdout, "</%s>\n", $3);

		$$ = tpl.curdep;

		yyerrok();
	%}
	;
TagHead: '('	%{

		for(tempi = 0; tempi < tpl.curdep; ++tempi) {
			fprintf(stdout, "\t");
		}
		fprintf(stdout, "<%s>\n", $1);

		++tpl.curdep;
		if(tpl.curdep > tpl.maxdep) {
			tpl.maxdep = tpl.curdep;
		}
		stack_push($1);
		$$ = $1;
	%}
	;
%%

/* push tag into stack */
void stack_push(char *plbl) {
	tag_link_t p;

	p = (tag_link_t)malloc(sizeof(tag_node_t));
	p->plabel = plbl;
	p->pnext = sttop;
	sttop = p;
}

/* pop tag from stack */
char* stack_pop() {
	char *pch;
	tag_link_t p;

	p = sttop;
	if(p) {
		pch = p->plabel;
		sttop = sttop->pnext;
		free(p);
	}
	else {
		pch = NULL;
	}
	return pch;
}

/* get most recently pushed tag */
char* stack_top() {
	return sttop? sttop->plabel: NULL;
}

/* free all nodes(not incuding their contents) in stack */
void stack_clear() {

	tag_link_t p;

	while(sttop) {
		p = sttop->pnext;
		free(sttop);
		sttop = p;	
	}
	sttop = NULL;
}

/* allocate a string */
char* alloc_string(int nlen) {

	tag_link_t p;

	if(nlen <= 0) {
		return NULL;
	}

	p = (tag_link_t)malloc(sizeof(tag_node_t));
	p->plabel = (char*)malloc(sizeof(char)*nlen);
	p->pnext = stravail;
	stravail = p;

	return p->plabel;
}

/* free all allocated string */
void free_string() {
	
	tag_link_t p;

	while(stravail) {
		p = stravail->pnext;
		free(stravail->plabel);
		free(stravail);
		stravail = p;	
	}
	stravail = NULL;
}

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	sttop = NULL;
	stravail = NULL;

	<<before_yyparse/>>
	
	yyparse(<<yyparse_param/>>);

	<<after_yyparse/>>

	stack_clear();
	free_string();
<<after_buffer_usage/>>

	return 0;
}


<</templ>>

<<templ "basic-extr-numopr-template">>
<<desc/>>
/****************************************************************************
*	sample program: number(including integer and float),
*			arithmetic operator(+ - * / % ^ =)
*			extracter
*****************************************************************************/

%{

<<init_code/>>
%}

udec	[0-9]+
sdec	[\-\+]?{udec}
frct	\.{udec}
num	{sdec}{frct}?
opr	[\+\-\*\/\%\^\=]

<<lvar_decl/>>
<<lvar_init/>>
<<lex_init/>>
<<pre_match/>>
<<yywrap/>>

%token FEOF

%%

"#open"[ \t]*\"[^\"\'\n]+\"	{
		++dc;
		yytext[yyleng - 1] = '\0';

		int i = 5;
		while(yytext[i++] != '\"');

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stderr, "Error: failed to open file `%s\'\n", &yytext[i]);
		}
		else {
			yy_switch_buffer(pbuf);
		}
	}
{sdec}		++ic;
{num}		++rc;
{opr}		++oc;
<<EOF>>	yy_delete_buffer();			
		fprintf(stdout, "number of integers: %d\n", ic);
		fprintf(stdout, "number of reals: %d\n", rc);
		fprintf(stdout, "number of operators: %d\n", oc);
		fprintf(stdout, "number of discarded symbols: %d\n", dc);
		fprintf(stdout, "number of matched patterns: %d\n", mc);
		return FEOF;

.|\n		++dc;
%%

Start: Start FEOF 
	| FEOF
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "basic-fdc-template">>
<<desc/>>
/****************************************************************************
*	sample program: calculator for integers and reals
*	the purpose of this is to show how to use following features of upgen
*			%left %right %nonassoc %type
*			%prec %parse-init %parse-exit
*****************************************************************************/
%{
#include <limits.h>
#include <math.h>

enum {
	NT_INT,
	NT_REAL
};
%}

%union%{
	long nVal;
	double dVal;
	struct {
		int nType;
		union {
			long nVal;
			double dVal;
		};
	}xNum;
%}
%yywrap%{
	yy_delete_buffer();
	return 0;
%}

%lvar-decl%{
	char *endptr = NULL;
%}
%pvar-decl%{
	bool berror = false;
	int errors = 0;
%}


udec	[0-9]+
frct	\.{udec}
ureal	{udec}{frct}
opr	[\+\-\*\/\^\(\)]

%token<nVal> TK_INT
%token<dVal> TK_REAL

<<token_decl/>>
<<parse_init/>>
<<parse_exit/>>

%type<xNum> Expr

<<type_decl/>>

<<other_decl/>>

%%

"#open"[ \t]*\"[^\"\'\n]+\"	{

		int i;
		while((i = yyinput()) != '\n' && i != END_OF_FILE);
		yy_set_bol(true);

		yytext[yyleng - 1] = '\0';

		i = 5;
		while(yytext[i++] != '\"');

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stdout, "Error: failed to open file `%s\'\n", &yytext[i]);
		}
		else {
			yy_switch_buffer(pbuf);
		}
	}
{udec}		errno = 0;
		yylval.nVal = strtol(yytext, &endptr, 10);
		if(errno == ERANGE) {
			fprintf(stdout, "Error: integer is out of range.\n");
		}
		else {
			fprintf(stdout, "%s", yytext);
			return TK_INT;
		}

{ureal}		errno = 0;
		yylval.dVal = strtod(yytext, &endptr);
		if(errno == ERANGE) {
			fprintf(stdout, "Error: float number is out of range.\n");
		}
		else {
			fprintf(stdout, "%s", yytext);
			return TK_REAL;
		}
		
{opr}		fprintf(stdout, "%c", yytext[0]);
		return yytext[0];

\n		fprintf(stdout, "\n");		
		return '\n';
[ \t]		fprintf(stdout, "%c", yytext[0]);

.

%%

Task: Lines		%{
<<type_action_0/>>
	%}
	;

Lines: Lines Line	%{
<<type_action_1/>>
	%}
	|		%{
<<type_action_2/>>
	%}
	;
Line: Expr '\n'		%{
		if(!berror) {
			if($1.nType == NT_INT) {
				fprintf(stdout, "\t\t%ld[INT]\n", $1.nVal);
			}
			else {
				fprintf(stdout, "\t\t%g[REAL]\n", $1.dVal);
			}
		}

		errors += berror? 1: 0;

		berror = false;
	%}
	| error '\n'	%{

		errors += berror? 1: 0;

		berror = false;
		yyerrok();
	%}
	| '\n'		%{
		berror = false;
	%}
	;

Expr: Expr '+' Expr	%{
		if(!berror) {

			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				$$.nVal = $1.nVal + $3.nVal;
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal + $3.dVal;
				}
				else if($3.nType == NT_INT) {
					$$.dVal = $1.dVal + (double)$3.nVal;
				}
				else {
					$$.dVal = $1.dVal + $3.dVal;
				}
			}
		}
	%}
	| Expr '-' Expr	%{
		if(!berror) {
			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				$$.nVal = $1.nVal - $3.nVal;
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal - $3.dVal;
				}
				else if($3.nType == NT_INT) {
					$$.dVal = $1.dVal - (double)$3.nVal;
				}
				else {
					$$.dVal = $1.dVal - $3.dVal;
				}
			}
		}
	%}
	| Expr '*' Expr	%{

		if(!berror) {
			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				$$.nVal = $1.nVal * $3.nVal;
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal * $3.dVal;
				}
				else if($3.nType == NT_INT) {
					$$.dVal = $1.dVal * (double)$3.nVal;
				}
				else {
					$$.dVal = $1.dVal * $3.dVal;
				}
			}
		}
	%}
	| Expr '/' Expr	%{

		if(!berror) {
			if($1.nType == NT_INT && $3.nType == NT_INT) {
				$$.nType = NT_INT;
				if($3.nVal == 0) {
					fprintf(stdout, "Error: divided by zero!\n");
					berror = true;
				}
				else {
					$$.nVal = $1.nVal / $3.nVal;
				}
			}
			else {
				$$.nType = NT_REAL;
				if($1.nType == NT_INT) {
					$$.dVal = (double)$1.nVal / $3.dVal;
				}
				else if($3.nType == NT_INT) {
					if($3.nVal == 0) {
						fprintf(stdout, "Error: divided by zero!\n");
						berror = true;
					}
					else {
						$$.dVal = $1.dVal / (double)$3.nVal;
					}
				}
				else {
					$$.dVal = $1.dVal / $3.dVal;
				}
			}
		}
	%}
	| Expr '^' Expr %{

		if(!berror) {
			errno = 0;
			$$.nType = NT_REAL;
			if($1.nType == NT_INT) {
				if($3.nType == NT_INT) {
					$$.dVal = pow($1.nVal, $3.nVal);
				}
				else {
					$$.dVal = pow($1.nVal, $3.dVal);
				}
			}
			else {
				if($3.nType == NT_INT) {
					$$.dVal = pow($1.dVal, $3.nVal);
				}
				else {
					$$.dVal = pow($1.dVal, $3.dVal);
				}
			}
			if(errno) {
				switch(errno) {
				case EDOM:
					fprintf(stdout, "Error: domain error, x is negative while y is non-integer.\n");
					break;
				default:
					fprintf(stdout, "Error: number is out of range.\n");
					break;
				}
				berror = true;
			}
		}
	%}
	| '(' Expr ')'	%{

		if(!berror) {
			$$.nType = $2.nType;
			if($2.nType == NT_INT) {
				$$.nVal = $2.nVal;
			}
			else {
				$$.dVal = $2.dVal;
			}
		}
	%}
	| '+' <<prec_refer/>> Expr	%{

		if(!berror) {
			$$.nType = $2.nType;
			if($2.nType == NT_INT) {
				$$.nVal = $2.nVal;
			}
			else {
				$$.dVal = $2.dVal;
			}
		}
	%}
	| '-' <<prec_refer/>> Expr	%{

		if(!berror) {
			$$.nType = $2.nType;
			if($2.nType == NT_INT) {
				$$.nVal = - $2.nVal;
			}
			else {
				$$.dVal = - $2.dVal;
			}
		}
	%}
	| TK_INT		%{
		$$.nType = NT_INT;
		$$.nVal = $1;
	%}
	| TK_REAL		%{
		$$.nType = NT_REAL;
		$$.dVal = $1;
	%}
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stdout, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "interface-scanner-template">><<desc/>>
%{
#include <iostream>
using std::cout;
using std::endl;

<<init_code/>>
%}
<<declare_section/>>
%%
<<lex_section/>>
%%

Start: /* empty */

%%
<<code_section/>>

using namespace yynsx;

int main(int argc, char **argv) {

<<before_buffer_init/>>
<<before_init/>>
	if(<<buffer_init/>>) {
		return -1;
	}
<<after_init/>>
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-bstack-template">>
/*
	sample program: test buffer operations
	feature to test:
		yy_current_buffer, yy_has_buffer, yy_push_buffer, yy_pop_buffer,
		yy_new_filebuf, yy_new_cstrbuf, yy_new_strbuf, yy_switch_buffer,
		yy_delete_buffer
*/

%{
#include <vector>
using std::vector;
#include <string>
using std::string;

typedef void* pvoid_t;


typedef vector<char*> vpchar_t;
typedef vpchar_t::size_type vpc_size_t;

//namespace yynsx {
//class bufbase_t;
//typedef bufbase_t * YYPBUFFER;
//}

using namespace yynsx;


static void regbuffer(YYPBUFFER, const char *, unsigned int);
static const char* buffername(YYPBUFFER);

static vpchar_t vbufname;
static char *temp_buffer = NULL;

%}

%lvar-decl%{
	int i, j, d;
%}

%yywrap%{
	const char* pbn = buffername(yy_current_buffer());
	if(pbn) {
		fprintf(stderr, "buffer `%s\' is coming.\n", pbn);
	}
	return false;
%}

%x	RSTRT

fname	\`[^\"\'\`\n\r]+\`
str	\"[^\"\'\`]+\"
cstr	\'[^\"\'\`]+\'
bname	[[:cidf:]][[:cids:]]*


%parse-init%{

	regbuffer(yy_current_buffer(), "test", 4);
%}
%token FEOF

%%

{bname}">"[ \t]*"open"[ \t]+{fname}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '`');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for file `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"push"[ \t]+{fname}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '`');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_filebuf(&yytext[i]);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for file `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		}
	}
		
{bname}">"[ \t]*"open"[ \t]+{str}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\"');
		++i;

		d = yyleng - i;
		if(temp_buffer) {
			delete[] temp_buffer;
		}

		temp_buffer = new char[d];
		strncpy(temp_buffer, &yytext[i], d - 1);
		temp_buffer[d - 1] = '\0';
		

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_strbuf(temp_buffer, d);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"push"[ \t]+{str}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\"');
		++i;

		d = yyleng - i;
		if(temp_buffer) {
			delete[] temp_buffer;
		}

		temp_buffer = new char[d];
		strncpy(temp_buffer, &yytext[i], d - 1);
		temp_buffer[d - 1] = '\0';

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_strbuf(temp_buffer, d);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"open"[ \t]+{cstr}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\'');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_cstrbuf(&yytext[i], yyleng - i);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for constant string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		}
	}

{bname}">"[ \t]*"push"[ \t]+{cstr}	{

		yytext[yyleng - 1] = '\0';
		i = yyleng - 2;
		while(yytext[--i] != '\'');
		++i;

		j = 0;
		while(yytext[++j] != '>');
		yytext[j] = '\0';

		YYPBUFFER pbuf = yy_new_cstrbuf(&yytext[i], yyleng - i);
		if(!pbuf) {
			fprintf(stderr, "Error: failed create buffer for constant string `%s\'.\n", yytext);
			YYABORT();
		}
		else {
			regbuffer(pbuf, yytext, j);

			yy_push_buffer(pbuf);
		}
	}

"has?"		{
		if(yy_has_buffer()) {
			fprintf(stderr, "Yes, there are buffers!\n");
		}
		else {
			fprintf(stderr, "Oh, no! It\'s impossible!!!\n");
			YYABORT();
		}
	}

"cur?"		{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "current buffer: %s\n", pbn);
		}
		else {
			fprintf(stderr, "Oh, no name for current buffer! It\'s impossible!!!\n");
			YYABORT();
		}
	}

"close"		{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "closing buffer %s ...\n", pbn);
			yy_delete_buffer();
			if(yy_has_buffer()) {
				pbn = buffername(yy_current_buffer());
				if(pbn) {
					fprintf(stderr, "switching to buffer %s ...\n", pbn);
				}
				else {
					fprintf(stderr, "Oh, no name for to-be-switched buffer! It\'s impossible!!!\n");
					YYABORT();
				}
			}
		}
		else {
			fprintf(stderr, "Oh, no name for to-be-deleted buffer! It\'s impossible!!!\n");
			YYABORT();
		}
	}
"abort"		{
		fprintf(stderr, "program exit abnormal ...\n");
		YYABORT();
	}
"pop"		{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "popping buffer %s ...\n", pbn);
			yy_pop_buffer();
			if(yy_has_buffer()) {
				pbn = buffername(yy_current_buffer());
				if(pbn) {
					fprintf(stderr, "switching to buffer %s ...\n", pbn);
				}
				else {
					fprintf(stderr, "Oh, no name for to-be-switched buffer! It\'s impossible!!!\n");
					YYABORT();
				}
			}
		}
		else {
			fprintf(stderr, "Oh, no name for to-be-popped buffer! It\'s impossible!!!\n");
			YYABORT();
		}
	}

"restart"	{

		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "restarting buffer %s ...\n", pbn);
			
			yyrestart();
			BEGIN(RSTRT);
		}
		else {
			fprintf(stderr, "Oh, no name for to-be-restarted buffer! It\'s impossible!!!\n");
			YYABORT();
		}

	}

<*>.|\n		fprintf(stderr, "%s", yytext);

<RSTRT><<EOF>>	{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "buffer `%s\' is abort to leave.\n", pbn);
		}
		BEGIN(INITIAL);
		yy_delete_buffer();
		return FEOF;
	}

<*><<EOF>>	{
		const char *pbn = buffername(yy_current_buffer());
		if(pbn) {
			fprintf(stderr, "buffer `%s\' is abort to leave.\n", pbn);
		}
		yy_delete_buffer();
		return FEOF;
	}

%%

Start: Texts %{
		if(yy_has_buffer()) {
			fprintf(stderr, "There are still buffers!\n");
			YYABORT();
		}
		else {
			fprintf(stderr, "All buffers closed.\n");
		}
	%}
	;

Texts: Texts FEOF
	|
	;

%%

using namespace yynsx;

void regbuffer(YYPBUFFER pbuf, const char *pbname, unsigned int sz){

	if(pbuf) {
		char *pc = new char[sz + 1];
		strncpy(pc, pbname, sz);
		pc[sz] = '\0';

		vpc_size_t n = vbufname.size();
		vbufname.push_back(pc);
		pbuf->setdata((void*)n);
	}
}

const char* buffername(YYPBUFFER pbuf) {
	
	if(pbuf) {
		vpc_size_t n = (vpc_size_t)pbuf->getdata();
		if(n < vbufname.size()) {
			return vbufname[n];
		}
	}
	return NULL;
}

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init3/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}

	yyparse();

	if(temp_buffer) {
		delete[] temp_buffer;
	}
	for(int i = 0; i < (int)vbufname.size(); ++i) {
		if(vbufname[i]) {
			delete[] vbufname[i];
		}
	}
<<after_buffer_usage/>>
	return 0;
}


<</templ>>

<<templ "interface-echo-template">>
/*
 *	sample program: test ECHO
 */

num	[0-9]+
xnum	0x[0-9]{2}

%%

^{num}	ECHO();

{xnum}	ECHO();
\n	ECHO();
.	ECHO();

%%

Start:
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>


<<templ "interface-getbol-template">>
/*
 *	sample program: test yy_get_bol
 */

num	[0-9]+
xnum	0x[0-9]{2}

%%

^{num}	int n = atoi(yytext);
	if(n != yylloc.firstLine) {
		fprintf(stderr, "Error: at %d:%d failed to verify line number.\n",
			yylloc.firstLine, yylloc.firstColumn);
	}

{xnum}	int n = atoi(&yytext[2]);
	if(n != yylloc.firstLine) {
		fprintf(stderr, "Error: at %d:%d failed to verify line number.\n",
			yylloc.firstLine, yylloc.firstColumn);
	}
\n	if( ! yy_get_bol()) {
		fprintf(stderr, "Error: at %d:%d failed to verify value of bol.\n",
			yylloc.firstLine, yylloc.firstColumn);
	}
.

%%

Start:
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>


<<templ "interface-line-editor-template">>
/*
	sample program: special line editor
	feature to test: yymore yyless  yyinput yyterminate /
*/

%%

"&"		{
		--yyleng;
		if(yyleng > 0) {
			yytext[yyleng] = '\0';
			fprintf(stdout, "%s", yytext);
		}
	}
"&&"		{
		--yyleng;
		yytext[yyleng] = '\0';
		yymore();
	}
"&!"		{
		--yyleng;
		yytext[yyleng - 1] = '!';
		yytext[yyleng] = '\0';
		yymore();
	}
"&@"		{
		--yyleng;
		yytext[yyleng - 1] = '@';
		yytext[yyleng] = '\0';
		yymore();
	}
"!!"		{
		yyleng -= 2;
		yytext[yyleng] = '\0';
		if(yyleng > 0) {
			fprintf(stdout, "%s", yytext);
		}

		int c;
		while((c = yyinput()) != '\n' && c != END_OF_FILE);
		if(c == '\n') {
			fprintf(stdout, "\n");
			yy_set_bol(true);
		}
	}
"!!!"		{
		yyleng -= 3;
		yytext[yyleng] = '\0';
		if(yyleng > 0) {
			fprintf(stdout, "%s", yytext);
		}
		yyterminate();
	}

[^\@\&\!\n]+/"@"[0-9][0-9]	{

		yytext[yyleng] = '\0';
		fprintf(stdout, "%s", yytext);
		
		char *endptr;
		int n = (int)strtol(&yytext[yyleng + 1], &endptr, 10);

		if(n > 0) {
			if(n > yyleng) {
				n = yyleng;
			}
			yytext[n] = '\0';
			fprintf(stdout, "%s", yytext);
		}
		// throw away 3 chars followed: @##
		yyinput();
		yyinput();
		yyinput();
	}
[^\@\&\!\n]+/"@-"[0-9][0-9]	{

		yytext[yyleng] = '\0';
		yylaleng = yyleng;
		
		char *endptr;
		int n = (int)strtol(&yytext[yyleng + 2], &endptr, 10);

		fprintf(stdout, "%s", yytext);

		n = yyleng - n;
		if(n > 0 && n < yyleng) {
			yyless(n);
		}
	}
[^\@\&\!\n]+/"!"[0-9][0-9]	{

		char *endptr;
		int n = (int)strtol(&yytext[yyleng + 1], &endptr, 10);

		if(n > yyleng) {
			n = yyleng;
		}
		yyleng -= n;
		yytext[yyleng] = '\0';

		if(yyleng > 0) {

			fprintf(stdout, "%s", yytext);
		}
		// throw away 3 chars followed: @##
		yyinput();
		yyinput();
		yyinput();
	}

"@-"[0-9][0-9]	{
		yyleng -= 4;
		yytext[yyleng] = '\0';
		yymore();			
	}

.		yymore();

\n		fprintf(stdout, "%s", yytext);
		

<<EOF>>		{
		if(yyleng > 0) {
			fprintf(stdout, "%s", yytext);
		}
		fflush(stdout);
	}
%%

Start: /* empty */
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-loc2-template">>
/*
	sample program: location counter 2
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
		yyinput yyunput yyunget
*/

%{
#include <vector>
using std::vector;

#include <string>
using std::string;

#include <ctype.h>

struct loc_pair_t {
	int line;
	int col;

	loc_pair_t(void)
	: line(0)
	, col(0) {
	}

	loc_pair_t(int ln, int cl)
	: line(ln)
	, col(cl) {
	}

	loc_pair_t(const loc_pair_t &src)
	: line(src.line)
	, col(src.col){
	}
	
	loc_pair_t& operator=(const loc_pair_t &src) {
		if(&src == this) {
			return *this;
		}
		line = src.line;
		col = src.col;
		return *this;
	}

	bool operator==(const loc_pair_t &src) const {
		return line == src.line && col == src.col;
	}

	bool operator!=(const loc_pair_t &src) const {
		return line != src.line || col != src.col;
	}
};

typedef vector<loc_pair_t> vlpair_t;

typedef vector< vlpair_t* > vpvlp_t;

%}

%union%{
	loc_pair_t locVal;
	int nVal;
	vlpair_t * pvpVal;
%}
%formal-param%{ vpvlp_t &vvprLocs, string &strBuf, int &nLastLoc %}
%actual-param%{ vvprLocs, strBuf, nLastLoc %}

locn	[[:alnum:]]{2}[[:digit:]]
num	[[:digit:]]+

%x	LOC_SC
%x	TOL_SC
%x	PUT_SC

%token LOC_HEAD LOC_TAIL PUT_TAIL
%token TR_TAIL LR_TAIL OR_TAIL
%token<nVal> TR_HEAD LR_HEAD OR_HEAD
%token<locVal> LOCN

%type<pvpVal> TabLine
%%

"#location_head"[ \t]*\r?\n		{

		BEGIN(LOC_SC);
		return LOC_HEAD;
	}

<LOC_SC>"#location_tail"[ \t]*\r?\n	{

		BEGIN(INITIAL);
		return LOC_TAIL;
	}

"#line_replace"[ \t]+{num}[ \t]*\r?\n	|
"#orignal"[ \t]+{num}[ \t]*\r?\n	|
"#tab_replace"[ \t]+{num}[ \t]*\r?\n	{

		yyset_lineno(1);
		yyset_colno(1);
		fprintf(stdout, "after reseting, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());

		int i = yyleng - 1;
		while( ! isdigit(yytext[--i]));
		yytext[i + 1] = '\0';
		while( isdigit(yytext[--i]));
		++i;

		char *endptr;
		errno = 0;
		yylval.nVal = (int)strtol(&yytext[i], &endptr, 10);
		if(errno) {
			perror("strtol");
		}
		
		strBuf.clear();

		BEGIN(TOL_SC);

		switch(yytext[1]) {
		case 'l':
			return LR_HEAD;
			break;
		case 'o':
			return OR_HEAD;
			break;
		default:
			return TR_HEAD;
			break;
		}
	}

<TOL_SC>"#line_replace"[ \t]*\r?\n	|
<TOL_SC>"#orignal"[ \t]*\r?\n		|
<TOL_SC>"#tab_replace"[ \t]*\r?\n	{

		strBuf += yytext;

		BEGIN(INITIAL);

		switch(yytext[1]) {
		case 'l':
			return LR_TAIL;
			break;
		case 'o':
			return OR_TAIL;
			break;
		default:
			return TR_TAIL;
			break;
		};
	}

<PUT_SC>"#line_replace"			|
<PUT_SC>"#orignal"			|
<PUT_SC>"#tab_replace"			{

		BEGIN(INITIAL);
		return PUT_TAIL;
	}

"tab?"				{
		fprintf(stdout, "tabsize = %d\n", yyget_tabsize());
	}

"tab="[[:digit:]]		{

		int n = (int)(yytext[4] - '0');
		yyset_tabsize(n);
		fprintf(stdout, "tabsize is %d now\n", yyget_tabsize());
	}

<*>{locn}		{
		if(isdigit(yytext[0])) {
			yylval.locVal.line = (int)(yytext[0] - '0');
		}
		else  if(islower(yytext[0])) {
			yylval.locVal.line = (int)(yytext[0] - 'a') + 10;
		}
		else {
			yylval.locVal.line = (int)(yytext[0] - 'A') + 36;
		}


		if(isdigit(yytext[1])) {
			yylval.locVal.col = (int)(yytext[1] - '0') * 10 + (int)(yytext[2] - '0');
		}
		else if(islower(yytext[1])) {
			yylval.locVal.col = (int)(yytext[1] - 'a') * 10 + 100 + (int)(yytext[2] - '0');
		}
		else {
			yylval.locVal.col = (int)(yytext[1] - 'A') * 10 + 360 + (int)(yytext[2] - '0');
		}

		if(YYSTART() == TOL_SC) {
			strBuf += yytext;
		}

		return LOCN;
	}

<*>.|\n		{
		if(YYSTART() == TOL_SC) {
			strBuf += yytext;
		}
	}

%%

File:	File Section
	| Section
	;

Section: LocSect
	| RLSect
	| RTSect
	| OrgSect
	| TabLine PUT_TAIL	%{
		if(nLastLoc < 0) {
			fprintf(stdout, "Error: OOPS!!!\n");
		}
		else {
			vlpair_t *pLoc = vvprLocs[nLastLoc];
			fprintf(stdout, "begin comparing location(size %d) %d and its referrence(size %d)\n",
				 (int)pLoc->size(), nLastLoc, (int)$1->size());
			for(vlpair_t::size_type i = 0; i < $1->size() && i < pLoc->size(); ++i) {
				if((*pLoc)[i] != (*$1)[i]) {
					fprintf(stdout, "refer.line = %d\trefer.col = %d"
						"\tLoc.line = %d\tLoc.col = %d\n",
						(*$1)[i].line, (*$1)[i].col, (*pLoc)[i].line, (*pLoc)[i].col);
				}
			}
		}
		delete $1;
	%}
	;

LocSect: LOC_HEAD
	 %{ nLastLoc = -1; %}
	 TabLine LOC_TAIL	%{
		vvprLocs.push_back($3);
	%}
	;
RLSect: LR_HEAD
	 %{
		nLastLoc = -2;
		fprintf(stdout, "begin scanning line_replace section by referrence %d\n", $1);
	 %}
	 TabLine LR_TAIL		%{
		nLastLoc = $1;
		fprintf(stdout, "before putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		if(strBuf.size() > 0) {
			for(string::size_type i = strBuf.size(); i > 0; --i) {
				if(strBuf[i - 1] != '\n') {
					yyunget();
				}
				else {
					yyunput('*');
				}
			}
		}
		strBuf.clear();
		fprintf(stdout, "after putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		fprintf(stdout, "scanning line_replace section is over\n");
		BEGIN(PUT_SC);
	%}
	;
RTSect: TR_HEAD
	 %{
		nLastLoc = -3;
		fprintf(stdout, "begin scanning tab_replace section by referrence %d\n", $1);
	 %}
	 TabLine TR_TAIL		%{
		nLastLoc = $1;
		fprintf(stdout, "before putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());

		if(strBuf.size() > 0) {
			for(string::size_type i = strBuf.size(); i > 0; --i) {
				if(strBuf[i- 1] != '\t') {
					yyunget();
				}
				else {
					yyunput('*');
				}
			}
		}
		strBuf.clear();

		fprintf(stdout, "after putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		fprintf(stdout, "scanning tab_replace section is over\n");

		BEGIN(PUT_SC);
	%}
	;
OrgSect: OR_HEAD
	 %{
		nLastLoc = -4;
		fprintf(stdout, "begin scanning orignal section by referrence %d\n", $1);
	 %}
	 TabLine OR_TAIL 	%{
		nLastLoc = $1;
		fprintf(stdout, "before putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		if(strBuf.size() > 0) {
			for(string::size_type i = strBuf.size(); i > 0; --i) {
				yyunget();
			}
		}
		strBuf.clear();
		fprintf(stdout, "after putback, line: %d\tcol: %d\n", yyget_lineno(), yyget_colno());
		fprintf(stdout, "scanning orignal section is over\n");

		BEGIN(PUT_SC);
	%}
	;

TabLine: TabLine LOCN	%{
		if(nLastLoc >= -1) {
			$$ = $1;
			if( nLastLoc > -1) {
				$$->push_back(loc_pair_t(@2.firstLine, @2.firstColumn));
			}
			else {
				$$->push_back($2);
			}
		}
		else {
			if(@2.firstLine != $2.line || @2.firstColumn != $2.col) {
				fprintf(stdout, "`@2.firstLine = %d\t`@2.firstColumn = %d"
						"\tLoc.line = %d\tLoc.col = %d\n",
						@2.firstLine, @2.firstColumn, $2.line, $2.col);
			}
		}
	%}
	| LOCN		%{
		if(nLastLoc >= -1) {
			$$ = new vlpair_t;
			if(nLastLoc > -1) {
				$$->push_back(loc_pair_t(@1.firstLine, @1.firstColumn));
			}
			else {
				$$->push_back($1);
			}
		}
		else {
			if(@1.firstLine != $1.line || @1.firstColumn != $1.col) {
				fprintf(stdout, "`@1.firstLine = %d\t`@1.firstColumn = %d"
						"\tLoc.line = %d\tLoc.col = %d\n",
						@1.firstLine, @1.firstColumn, $1.line, $1.col);
			}
		}
	%}
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}

	vpvlp_t vvLocs;
	int nLoc = -1;
	string strBuf;
	yyparse(vvLocs, strBuf, nLoc);

	for(vpvlp_t::size_type i = 0; i < vvLocs.size(); ++i) {
		if(vvLocs[i]) {
			delete vvLocs[i];
		}
	}
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-location-template">>
/*
	sample program: location counter
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
*/
fname	"<"[^\<\>\n\*\/\\\?]+">"
locn	[[:digit:]]{3}

%yywrap%{ return false; %}

%union%{
	struct {
		int line;
		int col;
	} locVal;
	int nVal;
%}

%token TABGET TABSET FOPENED FCLOSED
%token<locVal> LOCN

%%

"tab?"			fprintf(stdout, "tabsize = %d\n", yyget_tabsize());
			return TABGET;

"tab="[[:digit:]]	int n = (int)(yytext[4] - '0');
			yyset_tabsize(n);
			fprintf(stdout, "tabsize is %d now\n", yyget_tabsize());
			return TABSET;

{fname}			yytext[yyleng - 1] = '\0';
			YYPBUFFER pbuf = yy_new_filebuf(&yytext[1]);
			if(! pbuf) {
				fprintf(stderr, "Error: failed to open file `%s`\n", &yytext[1]);
				return -1;
			}
			else {
				fprintf(stdout, "file `%s` is open.\n", &yytext[1]);
			}
			yy_switch_buffer(pbuf);
			return FOPENED;

{locn}			yylval.locVal.line = (int)(yytext[0] - '0');
			yylval.locVal.col = (int)(yytext[1] - '0') * 10 + (int)(yytext[2] - '0');
			return LOCN;

\n			return '\n';

.

<<EOF>>		yy_delete_buffer();
			fprintf(stdout, "file closed.\n");
			return FCLOSED;

%%

Files:	Files File FCLOSED
	| File FCLOSED
	;

File:	File Line
	| Line
	;

Line:	FOPENED
	| TabLine '\n'
	;
TabLine: TabLine TLItem
	| TLItem
	;

TLItem: TABGET
	| TABSET
	| LOCN	%{
		if(@1.firstLine != $1.line || @1.firstColumn != $1.col) {
			fprintf(stderr, "Error: failed to verify location information. `@1.firstLine = %d\t`@1.firstColumn = %d"
					"\tLoc.line = %d\tLoc.col = %d\n",
					@1.firstLine, @1.firstColumn, $1.line, $1.col);
		}
	%}
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-tinyfp-template">>
/*
	sample program: analyse tiny functional programming language
	feature to test:	YYSTART, yy_push_state, yy_pop_state, yy_top_state
		yy_set_bol
		yy_current_buffer, yy_has_buffer, yy_push_buffer, yy_pop_buffer,
		yy_new_filebuf, yy_new_cstrbuf, yy_new_strbuf,
		yy_delete_buffer, yy_switch_buffer, yyrestart,
		yyinput, yyunput,

*/

%{

#include <string>
using std::string;
#include <map>
using std::map;
using std::iterator;
using std::pair;
#include <vector>
using std::vector;
#include <stack>
using std::stack;

#include <cassert>

//// to create name of constant
//#define CNBASE	"(C"
// to create name of unnamed function
#define FNBASE	"(F"

enum datatype_t {

	DT_UNK,
	DT_VOID,
	DT_BOOL,
	DT_INT,
	DT_REAL,
	DT_CHAR,
	DT_STR,
	DT_LIST,
	DT_FUNC,
	
};

class environ_t;
struct glist_t;

struct symbol_t {

	// constant, built-in operator: read-only
	// others: read/write
	bool writable;

	// symbol value type
	datatype_t vtype;

	// symbol name
	// constant has no name, so @strname is NULL
	string *strname;
	
	// value
	union {
		// vtype = DT_BOOL
		bool bval;
		// vtype = DT_CHAR
		char cval;
		// vtype = DT_INT
		int nval;
		// vtype = DT_REAL
		double dval;
		// vtype = DT_STR
		string *strval;
		// vtype = DT_LIST
		glist_t *lstval;

		// vtype = DT_FUNC
		struct {
			// number of formal-params
			int fpcnt: 16;
			// indicate if there are optional params
			int more: 16;
			// return-value type
			datatype_t rtype;
			// symbol's environment
			environ_t *table;
		};
	};
};

enum gltype_t {
	GLT_SYMB,
	GLT_LIST
};

struct glist_t {
	gltype_t vtype;
	union {
		struct {
			glist_t *head;
			glist_t *tail;
		};
		symbol_t *symb;
	};
};

typedef pair<string, symbol_t*> s2sym_pair_t;
typedef map<string, symbol_t*> s2sym_map_t;
typedef s2sym_map_t::iterator s2sym_it_t;
typedef s2sym_map_t::const_iterator s2sym_cit_t;

// return-value's type for insertion of s2sym_map_t's object
typedef pair<s2sym_it_t, bool> s2sym_insert_t;

typedef vector<symbol_t*> vsymbol_t;

static string* alloc_string(void);
static glist_t* alloc_list(void);
static symbol_t* alloc_symbol(void);
static string* get_ufname(void);

class environ_t {
public:
	environ_t(environ_t *prnt)
	: parent(prnt) {
	}

	inline symbol_t* snew(string *pstrname, symbol_t *symb = NULL) {

		assert(pstrname);
		s2sym_insert_t sit = symmap.insert(s2sym_pair_t(*pstrname, symb));
		if(sit.second) {

			if( ! symb) {
				sit.first->second = alloc_symbol();
				sit.first->second->strname = pstrname;
			}
		}
		else {
			if(symb) {
				sit.first->second = symb;
			}
		}
		return sit.first->second;
	}
	inline symbol_t* snew(const string &strname, symbol_t *symb = NULL) {

		s2sym_insert_t sit = symmap.insert(s2sym_pair_t(strname, symb));
		if(sit.second) {
			if( ! symb) {
				sit.first->second = alloc_symbol();
			}
		}
		else {
			if(symb) {
				sit.first->second = symb;
			}
		}
		return sit.first->second;
	}

	symbol_t* sfind(string *pstrname) {

		environ_t *penv = this;
		while(penv) {
			s2sym_cit_t cit = penv->symmap.find(*pstrname);
			if(cit != penv->symmap.end()) {
				return cit->second;
			}
			penv = penv->parent;
		}
		return NULL;
	}
	symbol_t* sfind(const string &strname) {

		environ_t *penv = this;
		while(penv) {
			s2sym_cit_t cit = penv->symmap.find(strname);
			if(cit != penv->symmap.end()) {
				return cit->second;
			}
			penv = penv->parent;
		}
		return NULL;
	}

	inline void update(string *pstrname, symbol_t *nsymb) {
		assert(pstrname);
		symmap.erase(*pstrname);
		s2sym_insert_t sit = symmap.insert(s2sym_pair_t(*pstrname, nsymb));
	}

private:
	s2sym_map_t symmap;
	environ_t* parent;
};

typedef stack<environ_t*> env_stack_t;

static symbol_t * snew_unk(void);
static symbol_t * snew_const (void);
static symbol_t * snew_const(bool b, bool rw = false);
static symbol_t * snew_const(char c, bool rw = false);
static symbol_t * snew_const(int n, bool rw = false);
static symbol_t * snew_const(double d, bool rw = false);
static symbol_t * snew_const(string *str, bool rw = false);
static symbol_t * snew_const(glist_t *glst, bool rw = false);
static symbol_t * snew_func(string *sname, int fps, int mr, datatype_t rt, bool rw = false);

static char *s_temp_buffer = NULL;

%}

%lexvar-decl%{
	int c, d;
	char *endptr;
	string *quotedstr;
%}

%yywrap%{
	return false;
%}

%x	QT_SC
%x	STR1_SC
%x	STR2_SC

oct	\\[0-3][0-7][0-7]
hex	\\x[[:xdigit:]]
esc	\\[0abfnrtv\?\"\'\`]
dqcc	({oct}|{hex}|{esc}|(\r?\n)|[^\"])
rqcc	({oct}|{hex}|{esc}|(\r?\n)|[^\`])
idc	[^ \t\0\r\n\(\)\;\"\'\`\|\[\]\{\}]
sid	{idc}+


%formal-param%{environ_t &topenv, env_stack_t &stenv%}
%actual-param%{topenv, stenv%}

%union%{
	bool bVal;
	char cVal;
	int nVal;
	double dVal;
	string *strVal;
	symbol_t *symbVal;
	glist_t *listVal;
	vsymbol_t *vsymVal;
%}

%parsevar-decl%{
	int i;
%}

%token LIF LELSE LCASE LCOND LDEFINE LLET LLAMBDA
%token LQUOTE LSET

%token<strVal> SID LSTR
%token<cVal> LCHAR
%token<bVal> LBOOL
%token<nVal> LINT
%token<dVal> LREAL
%token<symbVal> LOPTR

%type<symbVal> Const
%type<listVal> List ListItems ListItem
%type<symbVal> FName BForm DForm ExeExpr Expr
%type<symbVal> NForm SForm QuoteExpr SetExpr UNDefExpr
%type<symbVal> IfExpr CaseExpr CaseItems ElseExpr CondExpr CondItems
%type<symbVal> DefineExpr DefinSign LetExpr LambdaExpr

%type<vsymVal> Exprs0 Exprs1
%type<vsymVal> LetParams SIDList
%%

<INITIAL,QT_SC>";"		{
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);
	}
<INITIAL,QT_SC>"#|"		{
		c = yyinput();
		while(c != END_OF_FILE) {
			if(c == '|') {
				c = yyinput();
				if(c == '#') {
					break;
				}
			}
			if(c != '|') {
				c = yyinput();
			}
		}	
	}

<INITIAL,QT_SC>[\(\)]		return yytext[0];

[\+\-\*\/]		{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* arithmetic operators */
		return LOPTR;
	}

[\>\<\=]	|
">="		|
"<="		|
"<>"			{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* relational operators */
		return LOPTR;
	}

"and"		|
"or"		|
"not"			{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* logical operators */
		return LOPTR;
	}

"car"		|
"cdr"		|
"head"		|
"tail"		|
"cons"		|
"list"		|
"null?"		|
"length"	|
"number?"	|
"integer?"	|
"real?"		|
"make-string"	|
"string?"		{
		/* find symbol */
		yylval.symbVal = topenv.sfind(yytext);

		/* top-level built-in function object */
		return LOPTR;
	}

"if"		return LIF;
"cond"		return LCOND;
"case"		return LCASE;
"else"		return LELSE;
"let"		return LLET;
"lambda"	return LLAMBDA;
"define"	return LDEFINE;
"quote"			{
		yy_push_state(QT_SC);
		return LQUOTE;
	}
"set!"		return LSET;
"eval"[ \t]+{sid}	{

		c = 4;
		while(yytext[++c] == ' ' || yytext[c] == '\t');
		symbol_t *symb = stenv.top()->sfind(&yytext[c]);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else if(symb->vtype != DT_STR) {
			fprintf(stderr, "Error: at %d:%d, `%s` is not a macro\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else {
			if(s_temp_buffer) {
				delete[] s_temp_buffer;
			}
			d = symb->strval->size();
			s_temp_buffer = new char[d + 2];
			strncpy(s_temp_buffer, symb->strval->c_str(), d);
			s_temp_buffer[d] = '\0';
			s_temp_buffer[d + 1] = '\0';
			fprintf(stderr, "expand macro `%s\', its content is `%s\'\n", &yytext[c], s_temp_buffer);
			YYPBUFFER pbuf = yy_new_cstrbuf(s_temp_buffer, d + 1);
			if( ! pbuf) {
				fprintf(stderr, "Error: at %d:%d, failed to create constant string buffer for macro `%s`\n",
					yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
				YYABORT();
			}
			else {
				yy_switch_buffer(pbuf);
			}
		}
	}

"(load"[ \t]+{sid}")"	{

		yytext[yyleng - 1] = '\0';
		c = 5;
		while(yytext[++c] == ' ' || yytext[c] == '\t');
		symbol_t *symb = stenv.top()->sfind(&yytext[c]);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else if(symb->vtype != DT_STR) {
			fprintf(stderr, "Error: at %d:%d, `%s` is not a macro\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else {
			fprintf(stderr, "open file `%s\', its content is `%s\'\n", &yytext[c], symb->strval->c_str());
			YYPBUFFER pbuf = yy_new_filebuf(symb->strval->c_str());
			if( ! pbuf) {
				fprintf(stderr, "Error: at %d:%d, failed to create buffer for file `%s`\n",
					yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
				YYABORT();
			}
			else {
				yy_switch_buffer(pbuf);
			}
		}
	}

"ceval"[ \t]+{sid}	{

		c = 4;
		while(yytext[++c] == ' ' || yytext[c] == '\t');
		symbol_t *symb = stenv.top()->sfind(&yytext[c]);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else if(symb->vtype != DT_STR) {
			fprintf(stderr, "Error: at %d:%d, `%s` is not a macro\n",
				yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
			YYABORT();
		}
		else {
			if(s_temp_buffer) {
				delete[] s_temp_buffer;
			}
			d = symb->strval->size();
			s_temp_buffer = new char[d + 2];
			strncpy(s_temp_buffer, symb->strval->c_str(), d);
			s_temp_buffer[d] = '\0';
			s_temp_buffer[d + 1] = '\0';
			fprintf(stderr, "expand macro `%s\', its content is `%s\'\n", &yytext[c], s_temp_buffer);
			YYPBUFFER pbuf = yy_new_strbuf(s_temp_buffer, d + 1);
			if( ! pbuf) {
				fprintf(stderr, "Error: at %d:%d, failed to create string buffer for macro `%s`\n",
					yylloc.firstLine, yylloc.firstColumn, &yytext[c]);
				YYABORT();
			}
			else {
				yy_switch_buffer(pbuf);
			}
		}
	}

"#t"	{
		yylval.bVal = true;
		return LBOOL;
	}
"#f"	{
		yylval.bVal = false;
		return LBOOL;
	}


"#b"[01]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal <<= 1;
			yylval.nVal += (int)(yytext[c] - '0');
		}
		return LINT;
	}
"#o"[0-7]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal <<= 3;
			yylval.nVal += (int)(yytext[c] - '0');
		}
		return LINT;
	}
"#d"?[0-9]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal = (yylval.nVal << 1) + (yylval.nVal << 3);
			yylval.nVal += (int)(yytext[c] - '0');
		}
		return LINT;
	}
			
"#x"[0-9a-f]+	{
		yylval.nVal = 0;
		for(c = 2; c < yyleng; ++c) {
			yylval.nVal <<= 4;
			d = (int)(yytext[c] - '0');
			if(d < 10) {
				yylval.nVal += d;
			}
			else if(d < 23) {
				yylval.nVal += d - 7;
			}
			else {
				yylval.nVal += d - 39;
			}
		}
		return LINT;		
	}
[0-9]+\.[0-9]+[sfdl]?	{

		yytext[yyleng - 1] = '\0';
		yylval.dVal = strtod(yytext, &endptr);

		return LREAL;
	}

"#\\"[[:graph:]]	{
		yylval.cVal = yytext[2];
		return LCHAR;
	}

"#\\U\+"[0-9a-f]{2}	{
		yylval.cVal = 0;
		for(c = 4; c < yyleng; ++c) {
			yylval.cVal <<= 4;
			d = (int)(yytext[c] - '0');
			if(d < 10) {
				yylval.cVal += (char)d;
			}
			else if(d < 23) {
				yylval.cVal += (char)(d - 7);
			}
			else {
				yylval.cVal += (char)(d - 39);
			}
		}
		return LCHAR;
	}

<INITIAL,QT_SC>{sid}		{
		yylval.strVal = alloc_string();
		*yylval.strVal += yytext;
		if(YYSTART() == INITIAL) {
			return SID;
		}
		else {
			return LSTR;
		}
	}

<INITIAL,QT_SC>\"		{
		quotedstr = alloc_string();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yy_push_state(STR1_SC);
	}
<STR1_SC>{dqcc}	{

		if(yytext[0] == '\\') {
			if(yyleng == 4) {
				switch(yytext[1]) {
				case 'x':
				case 'X':
				{
					d = (int)(yytext[2] - '0');
					if(d < 10) {
						c = d;
					}
					else if(d < 23) {
						c = d - 7;
					}
					else {
						c = d - 39;
					}

					d = (int)(yytext[3] - '0');
					c <<= 4;

					if(d < 10) {
						c += d;
					}
					else if(d < 23) {
						c += d - 7;
					}
					else {
						c += d - 39;
					}
								
				}
					break;
				default:
				{
					c = (int)(yytext[1] - '0');
					c <<= 3;
					c += (int)(yytext[2] - '0');
					c <<= 3;
					c += (int)(yytext[3] - '0');
				}
					break;
				}
				*quotedstr += (char)c;
			}
			else { // yyleng == 2
				*quotedstr += yytext[1];
			}
		}
		else {
			*quotedstr += yytext[0];
		}
	}
<STR1_SC>\r?\n	{
		*quotedstr += yytext;
	}
<STR1_SC>\"	{
		yy_pop_state();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yylval.strVal = quotedstr;

		return LSTR;
	}
<INITIAL,QT_SC>\`		{
		quotedstr = alloc_string();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yy_push_state(STR2_SC);
	}
<STR2_SC>{rqcc}	{

		if(yytext[0] == '\\') {
			if(yyleng == 4) {
				switch(yytext[1]) {
				case 'x':
				case 'X':
				{
					d = (int)(yytext[2] - '0');
					if(d < 10) {
						c = d;
					}
					else if(d < 23) {
						c = d - 7;
					}
					else {
						c = d - 39;
					}

					d = (int)(yytext[3] - '0');
					c <<= 4;

					if(d < 10) {
						c += d;
					}
					else if(d < 23) {
						c += d - 7;
					}
					else {
						c += d - 39;
					}
								
				}
					break;
				default:
				{
					c = (int)(yytext[1] - '0');
					c <<= 3;
					c += (int)(yytext[2] - '0');
					c <<= 3;
					c += (int)(yytext[3] - '0');
				}
					break;
				}
				*quotedstr += (char)c;
			}
			else { // yyleng == 2
				*quotedstr += yytext[1];
			}
		}
		else {
			*quotedstr += yytext[0];
		}
	}
<STR2_SC>\r?\n	{
		*quotedstr += yytext;
	}
<STR2_SC>\`	{
		yy_pop_state();
		if(YYSTART() == QT_SC) {
			*quotedstr += yytext[0];
		}
		yylval.strVal = quotedstr;
		return LSTR;
	}
<*><<EOF>>	yy_delete_buffer();
\'			{
		yy_push_state(QT_SC);
		return yytext[0];
	}
<*><<EOF>>	yy_delete_buffer();

<*>[ \t\n\r]+
<*>.

%%

Program: Exprs0		%{
		fprintf(stderr, "parsing scheme program succeeded\n");
		YYACCEPT();
	%}
	;
Exprs0: Exprs0 Expr	%{
		$$ = $1;
		$$->push_back($2);
	%}
	|	%{
		$$ = new vsymbol_t;
	%}
	;
Exprs1:	Exprs1 Expr	%{
		$$ = $1;
		$$->push_back($2);
	%}
	| Expr		%{
		$$ = new vsymbol_t;
		$$->push_back($1);
	%}
	;
Expr:	NForm		%{
		$$ = $1;
	%}
	| SForm		%{
		$$ = $1;
	%}
	;
NForm:	Const		%{
		$$ = $1;
	%}
	| SID		%{
		$$ = stenv.top()->sfind(*$1);
		if( !$$) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				@1.firstLine, @1.firstColumn, $1->c_str());
			YYABORT();
		}
	%}
	| LOPTR		%{
		$$ = $1;
	%}
	| List		%{
		$$ = snew_const($1);
	%}
	| QuoteExpr	%{
		$$ = $1;
	%}
	| ExeExpr	%{
		$$ = $1;
	%}
	;
ExeExpr: '(' FName Exprs0 ')'	%{

		if($2->vtype == DT_UNK) {
			if($3->size() > 0) {
				$$ = (*$3)[$3->size() - 1];
			}
			else {
				$$ = snew_const();
			}
		}
		else if($2->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@2.firstLine, @2.firstColumn);
			YYABORT();
		}
		else {
			if($2->more) {
				if($2->fpcnt > (int)$3->size()) {
					fprintf(stderr, "Error: at %d:%d, function signature unmatched,\n"
						"expected number of parameters: %d, given: %d\n",
						@2.firstLine, @2.firstColumn, $2->fpcnt, (int)$3->size());
					YYABORT();
				}
			}
			else if($2->fpcnt != (int)$3->size()) {
				fprintf(stderr, "Error: at %d:%d, function signature unmatched,\n"
					"expected number of parameters: %d, given: %d\n",
					@2.firstLine, @2.firstColumn, $2->fpcnt, (int)$3->size());
				YYABORT();
			}
			else {
				//for(i = 0; i < $2->fpcnt; ++i) {
				//	
				//}

				if($3->size() > 0) {
					$$ = (*$3)[$3->size() - 1];
				}
				else {
					$$ = snew_const();
				}
			}
		}
		delete $3;
	%}
	;

SForm: BForm		%{
		$$ = $1;
	%}
	| DForm		%{
		$$ = $1;
	%}
	| SetExpr	%{
		$$ = $1;
	%}
	;
BForm: IfExpr		%{
		$$ = $1;
	%}
	| CaseExpr	%{
		$$ = $1;
	%}
	| CondExpr	%{
		$$ = $1;
	%}
	;
DForm: DefineExpr	%{
		$$ = $1;
	%}
	| UNDefExpr	%{
		$$ = $1;
	%}
	;
UNDefExpr: LetExpr	%{
		$$ = $1;
	%}
	| LambdaExpr	%{
		$$ = $1;
	%}
	;

IfExpr: '(' LIF ExeExpr Expr ')'	%{
		$$ = $4;
	%}
	| '(' LIF ExeExpr Expr Expr ')'	%{
		$$ = $5;
	%}
	;
CaseExpr: '(' LCASE ExeExpr CaseItems ')'	%{
		$$ = $4;
	%}
	| '(' LCASE ExeExpr CaseItems ElseExpr ')'	%{
		$$ = $5;
	%}
	;
CaseItems: CaseItems '(' List Exprs1 ')'	%{
		$$ = (*$4)[$4->size() - 1];
		delete $4;
	%}
	| '(' List Exprs1 ')'	%{
		$$ = (*$3)[$3->size() - 1];
		delete $3;
	%}
	;
ElseExpr: '(' LELSE Exprs1 ')'	%{
		$$ = (*$3)[$3->size() - 1];
		delete $3;
	%}
	;
CondExpr: '(' LCOND ExeExpr CondItems ')'	%{
		$$ = $4;
	%}
	| '(' LCOND ExeExpr CondItems ElseExpr ')'	%{
		$$ = $5;
	%}
	;
CondItems: CondItems '(' ExeExpr Exprs1 ')'	%{
		$$ = (*$4)[$4->size() - 1];
		delete $4;
	%}
	| '(' ExeExpr Exprs1 ')'	%{
		$$ = (*$3)[$3->size() - 1];
		delete $3;
	%}
	;

DefineExpr: '(' LDEFINE SID NForm ')'	%{
		$$ = $4;
		stenv.top()->snew($3, $4);
	%}
	| '(' LDEFINE SID UNDefExpr ')'	%{
		$$ = $4;
		stenv.top()->snew($3, $4);
	%}
	| '(' LDEFINE DefinSign Exprs1 ')'	%{

		$$ = $3;
		$$->rtype = (*$4)[$4->size() - 1]->vtype;
		stenv.pop();
	%}
	;

DefinSign: '(' SID %{

		symbol_t *symb = stenv.top()->snew($2);
		symb->writable = false;
		symb->vtype = DT_FUNC;
		symb->table = new environ_t(stenv.top());
		stenv.push(symb->table);
		$<symbVal>$ = symb;
	%}
	SIDList ')' %{
		$<symbVal>3->fpcnt = (int)$4->size();
		$$ = $<symbVal>3;
	%}
	;

LetExpr: '(' LLET %{
		string *str = get_ufname();
		symbol_t *symb = stenv.top()->snew(str);
		symb->writable = false;
		symb->vtype = DT_FUNC;
		symb->table = new environ_t(stenv.top());
		stenv.push(symb->table);
		$<symbVal>$ = symb;
	%}
	'(' LetParams %{
		$<symbVal>3->fpcnt = (int)$5->size();
	%}
	')' Exprs1 ')' %{
		$<symbVal>3->rtype = (*$8)[$8->size() - 1]->vtype;
		$$ = (*$8)[$8->size() - 1];
		delete $8;
		stenv.pop();
	%}
	;
LetParams: LetParams '(' SID Expr ')'	%{

		$4->writable = true;
		symbol_t *symb = stenv.top()->snew($3, $4);
		$$->push_back(symb);
	%}
	|		%{
		$$ = new vsymbol_t;
	%}
	;
LambdaExpr: '(' LLAMBDA %{

		string *str = get_ufname();
		symbol_t *symb = stenv.top()->snew(str);
		symb->writable = false;
		symb->vtype = DT_FUNC;
		symb->table = new environ_t(stenv.top());
		stenv.push(symb->table);
		$<symbVal>$ = symb;

	%} '(' SIDList %{
		$<symbVal>3->fpcnt = (int)$5->size();
		$<symbVal>3->more = 0;
	%}
	')' Exprs1 ')' %{
		$<symbVal>3->rtype = (*$8)[$8->size() - 1]->vtype;
		$$ = $<symbVal>3;
		delete $8;

		stenv.pop();
	%}
	;
SIDList: SIDList SID	%{

		symbol_t *symb = stenv.top()->snew($2);
		symb->vtype = DT_UNK;
		symb->writable = true;
		$$ = $1;
		$$->push_back(symb);
	%}
	|		%{
		$$ = new vsymbol_t;
	%}
	;

SetExpr: '(' LSET SID Expr ')'		%{
		symbol_t* symb = stenv.top()->sfind($3);
		if( !symb) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				@3.firstLine, @3.firstColumn, $3->c_str());
			YYABORT();
		}
		else {
			stenv.top()->update($3, $4);
			$$ = snew_const();
		}
	%}
	;

QuoteExpr: '(' LQUOTE LSTR	%{
		yy_pop_state();
	%}
	')'	%{
		$$ = snew_const($3);
	%}
	| '(' LQUOTE List	%{
		yy_pop_state();
	%}
	')'	%{
		$$ = snew_const($3);
	%}
	| '\'' LSTR		%{
		yy_pop_state();
		$$ = snew_const($2);
	%}
	| '\'' List		%{
		yy_pop_state();
		$$ = snew_const($2);
	%}
	;

List: '(' ListItems ')'	%{
		$$ = $2;
	%}
	| '(' ')'	%{

		$$ = alloc_list();
		$$->vtype = GLT_LIST;
		$$->head = NULL;
		$$->tail = NULL;
	%}
	;
ListItems: ListItem ListItems	%{

		$$ = alloc_list();
		$$->vtype = GLT_LIST;
		$$->head = $1;
		$$->tail = $2;
	%}
	| ListItem	%{

		$$ = alloc_list();
		$$->head = $1;
		$$->tail = NULL;
	%}
	;

ListItem: LSTR		%{

		$$ = alloc_list();
		$$->vtype = GLT_SYMB;
		$$->symb = snew_const($1);
	%}
	| List		%{
		$$ = $1;
	%}
	;

Const: LINT	%{
		$$ = snew_const($1);
	%}
	| LREAL	%{
		$$ = snew_const($1);
	%}
	| LCHAR	%{
		$$ = snew_const($1);
	%}
	| LSTR	%{
		$$ = snew_const($1);
	%}
	| LBOOL	%{
		$$ = snew_const($1);
	%}
	;

FName: SID	%{
		$$ = stenv.top()->sfind(*$1);
		if( !$$) {
			fprintf(stderr, "Error: at %d:%d, undefined symbol `%s`\n",
				@1.firstLine, @1.firstColumn, $1->c_str());
			YYABORT();
		}
	%}
	| LOPTR	%{
		$$ = $1;
	%}
	| BForm	%{
		if($1->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@1.firstLine, @1.firstColumn);
			YYABORT();
		}
		$$ = $1;
	%}
	| DForm %{
		if($1->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@1.firstLine, @1.firstColumn);
			YYABORT();
		}
		$$ = $1;		
	%}
	| ExeExpr	%{
		if($1->vtype != DT_FUNC) {
			fprintf(stderr, "Error: at %d:%d, object is not function\n",
				@1.firstLine, @1.firstColumn);
			YYABORT();
		}
		$$ = $1;
	%}
	;
%%

using namespace yynsx;

#define INIT_POOL_SIZE	128
#define INCR_POOL_SIZE	64
#define REALLOC(VARI, TYPE, SIZE, NEWSIZE) {\
	TYPE* p = new TYPE[(NEWSIZE)];\
	if( !p ) {\
		exit(-1);\
	}\
	memcpy(p, VARI, sizeof(TYPE) * SIZE);\
	delete[] VARI;\
	VARI = p;\
	SIZE = NEWSIZE;\
}


template<class T, int init_size = INIT_POOL_SIZE,
	int incr_size = INCR_POOL_SIZE>
class allocator_t {
public:
	allocator_t(void)
	: base(NULL)
	, size(init_size)
	, top(0) {

		base = new T*[size];
	}
	~allocator_t(void) {
		for(int i = 0; i < top; ++i) {
			delete base[i];
		}
		delete[] base;
	}

	T* alloc(void) {
		if(size == top) {
			REALLOC(base, T*, size, size + incr_size);
		}
		base[top] = new T;
		return base[top++];
	}
private:
	T** base;
	int size, top;
};

string* alloc_string(void) {
	static allocator_t<string> stralloc;
	return stralloc.alloc();
}

glist_t* alloc_list(void) {
	static allocator_t<glist_t> glalloc;
	return glalloc.alloc();
}
symbol_t* alloc_symbol(void) {
	static allocator_t<symbol_t> symalloc;
	return symalloc.alloc();
}
string* get_ufname(void) {

	static int lamidx = 0;
	++lamidx;

	string* pstr = alloc_string();
	*pstr = string(FNBASE);

	// this name is illegal for any named symbols,
	// therefore, name conflict is not a problem
	char rem;

	int qot = lamidx;
	do {
		rem = (char)(qot % 10) + '0';
		*pstr += rem;

		qot = qot / 10;		
	}while(qot > 0);

	return pstr;
}

symbol_t * snew_unk(void) {
	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_UNK;
	symb->strname = NULL;
	return symb;
}

symbol_t * snew_const (void) {
	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_VOID;
	symb->writable = false;
	return symb;
}

symbol_t * snew_const(bool b, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_BOOL;
	symb->strname = NULL;
	symb->writable = rw;
	symb->bval = b;
	return symb;
}
symbol_t * snew_const(char c, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_CHAR;
	symb->strname = NULL;
	symb->cval = c;
	symb->writable = rw;
	return symb;
}
symbol_t * snew_const(int n, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_INT;
	symb->strname = NULL;
	symb->nval = n;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_const(double d, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_REAL;
	symb->strname = NULL;
	symb->dval = d;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_const(string *str, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_STR;
	symb->strname = NULL;
	symb->strval = str;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_const(glist_t *glst, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_LIST;
	symb->strname = NULL;
	symb->lstval = glst;
	symb->writable = rw;

	return symb;
}
symbol_t * snew_func(string *sname, int fps, int mr, datatype_t rt, bool rw) {

	symbol_t *symb = alloc_symbol();
	symb->vtype = DT_FUNC;
	symb->strname = sname;
	symb->fpcnt = fps;
	symb->more = mr;
	symb->rtype = rt;
	symb->writable = rw;

	return symb;
}


void init_top_env(environ_t &env) {
	
	symbol_t *symb;
	
	symb = env.snew("+");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("-");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;
	
	symb = env.snew("*");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("/");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew(">");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("<");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew(">=");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("<=");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("<>");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("=");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_BOOL;


	symb = env.snew("and");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("or");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;

	symb = env.snew("not");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 1;
	symb->rtype = DT_UNK;


	symb = env.snew("car");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_UNK;

	symb = env.snew("cdr");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_LIST;

	symb = env.snew("head");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_UNK;

	symb = env.snew("tail");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_UNK;

	symb = env.snew("cons");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 2;
	symb->more = 0;
	symb->rtype = DT_LIST;

	symb = env.snew("list");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_LIST;

	symb = env.snew("null?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("null?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_INT;

	symb = env.snew("number?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("number?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("integer?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("real?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("string?");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 1;
	symb->more = 0;
	symb->rtype = DT_BOOL;

	symb = env.snew("make-string");
	symb->writable = false;
	symb->vtype = DT_FUNC;
	symb->fpcnt = 0;
	symb->more = 1;
	symb->rtype = DT_STR;
}

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return 0;
	}

	environ_t topenv(NULL);
	env_stack_t stenv;

	init_top_env(topenv);
	stenv.push(&topenv);

	int nret = yyparse(topenv, stenv);
	if(nret != 0) {
		fprintf(stderr, "Error: parsing program failed\n");
	}
	if(s_temp_buffer) {
		delete[] s_temp_buffer;
	}
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<<templ "interface-yyerror-template">>
/*
 *	sample program: test yyerror
 */

num	[[:digit:]]+
cid	[A-Za-z_][A-Za-z_0-9]*

%token NUM CID

%%

{num}	return NUM;
{cid}	return CID;

[ \t]
\r?\n	return '\n';
.

%%

Lines: Lines Line
	|
	;
Line: Numbers '\n'
	;
Numbers: Numbers Unit
	|
	;
Unit: NUM
	| error '\n' %{
		yyerrok();
	%}
	;
%%
using namespace yynsx;

void myerror(const char* msg) {
	
	fprintf(stderr, "Redirect to my error-handler ---- %s\n", msg);
}

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	yyseterror(myerror);

	yyparse();
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "esc-char-inaction-template">>
/*
	feature to test: using escape char, transform meta-symbols such as
		 $$, $n, @$, @n, %}, $<..>$, $<...>n
		to literal text in %{ %} embraced actions
*/

%header%{
#include <iostream>
using std::cerr;
using std::endl;
/*in declaration header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
%}

%{

/*in definition header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
%}

%lex-init%{
	cerr << "in lex-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%pre-match%{
	cerr <<  "in pre-match: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%lvar-decl%{
	cerr << "in lexvar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}
%lvar-init%{
	cerr << "in lexvar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%yywrap%{
	cerr << "in yywrap: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%destructor%{
	cerr << "in destruct<>: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%} <>

%parse-init%{
	cerr << "in parse-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%parse-exit%{
	cerr << "in parse-exit: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%union%{
	/*in SVT defintion: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
	int nVal;
	char *pchVal;
%}

%location%{
	/*in location type definiton: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
%}

%pvar-decl%{
	cerr << "in parsevar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}
%pvar-init%{
	cerr << "in parsevar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}" << endl;
%}

%formal-param%{int &n/*in formal-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/%}
%actual-param%{n/*in actual-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}*/%}

%token<pchVal> NUM
%token<pchVal> CID

%type<nVal> Symbols

%%

[[:digit:]]+	{
		yylval.pchVal = new char[yyleng + 1];
		strncpy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] = '\0';

		return NUM;
	}
[[:cidf:]][[:cids:]]*	{
		yylval.pchVal = new char[yyleng + 1];
		strncpy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] = '\0';

		return CID;
	}
.|\n

%%

Start: Symbols
	;
Symbols: Symbols CID	%{
		++n;
		cerr << "`$2 is a C-style ID, its value is " << $2  << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	| Symbols NUM	%{
		++$$;
		cerr << "`$2 is a number, its value is " << $2 << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	| CID		%{
		n = 1;
		cerr << "`$1 is a C-style ID, its value is " << $1 << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	| NUM		%{
		$$ = 1;
		cerr << "`$1 is a number, its value is " << $1 << endl;
		cerr << "`$$ is used to count number of numbers, and `$$ is " << $$ << endl;
	%}
	;

%%

using namespace yynsx;

int main(int argc, char **argv) {

<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");
		return -1;
	}

	int ncnt = 0;
	yyparse(ncnt);
<<after_buffer_usage/>>
	return 0;
}

<</templ>>

<<templ "script-empty-sect-2">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/
%{
#include <iostream>
using std::cout;
using std::endl;

%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ cout << "\t\t" << $1 << endl; %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ = $1; %}
	| Number Digit	%{ $$ = $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ = 0; %}
	| '1'		%{ $$ = 1; %}
	| '2'		%{ $$ = 2; %}
	| '3'		%{ $$ = 3; %}
	| '4'		%{ $$ = 4; %}
	| '5'		%{ $$ = 5; %}
	| '6'		%{ $$ = 6; %}
	| '7'		%{ $$ = 7; %}
	| '8'		%{ $$ = 8; %}
	| '9'		%{ $$ = 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
%%

using namespace yynsx;

static FILE *s_pfile = NULL;
int myinput(void) {

	if( ! s_pfile) {
		return 0;
	}

	int c = fgetc(s_pfile);
	if(c == EOF && feof(s_pfile)) {
		return 0;
	}
	return c;
}

int main(int argc, char **argv) {

	<<before_myinput/>>

	yysetlex(myinput);
	yyparse();

	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}
<</templ>>

<<templ "script-only-3-sections">>

/*************************************************************************
feature to test: scannerless parser (section 2 of script is empty)
	 	 without user-code section
**************************************************************************/
%{
#include <iostream>
using std::cout;
using std::endl;

namespace yynsx {

typedef int(*yylex_t)(void);

yylex_t yysetlex(yylex_t);
int yyparse(void);

}

using namespace yynsx;

static FILE *s_pfile = NULL;

int myinput(void) {

	if( ! s_pfile) {
		return 0;
	}

	int c = fgetc(s_pfile);
	if(c == EOF && feof(s_pfile)) {
		return 0;
	}
	return c;
}

int main(int argc, char **argv) {

	<<before_myinput/>>

	yysetlex(myinput);
	yyparse();

	if(s_pfile && s_pfile != stdin) {
		fclose(s_pfile);
	}
	return 0;
}

%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ cout << "\t\t" << $1 << endl; %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ = $1; %}
	| Number Digit	%{ $$ = $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ = 0; %}
	| '1'		%{ $$ = 1; %}
	| '2'		%{ $$ = 2; %}
	| '3'		%{ $$ = 3; %}
	| '4'		%{ $$ = 4; %}
	| '5'		%{ $$ = 5; %}
	| '6'		%{ $$ = 6; %}
	| '7'		%{ $$ = 7; %}
	| '8'		%{ $$ = 8; %}
	| '9'		%{ $$ = 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
<</templ>>

<<templ "script-empty-sect-3">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

namespace yynsx {
<<filebuf_decl/>>
int yylex(void);

}

using namespace yynsx;
int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner." << endl;
		return -1;
	}
	
	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	cout << yytext;
%%

<</templ>>

<<templ "script-dprec-rrc">>
/*
testing program: extract parentheses from expression, and convert them to brackets
	the purpose of this program is to show how to resolve reduce-reduce conflicts
	by %dprec
*/

%left '(' ')'
%%

[\(\)]		return yytext[0];
\n		printf("\n");
.		printf("%c", yytext[0]);
%%

Program: PExpr %dprec 2 %{
		printf("Done!\n");
		YYACCEPT();
	%}
	;
PExpr: PExpr PExpr %dprec 3
	| '(' 
	%{ printf("["); %}
	PExpr ')' %{ printf("]"); %}
	| %dprec 1
	;
%%

using namespace yynsx;

int main(int argc, char **argv) {
<<before_buffer_init/>>	
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");	
		return -1;
	}
	yyparse();
<<after_buffer_usage/>>
	return 0;
}
<</templ>>

<</templs>>

<<<----------top-level suite: / ---------->>>
<<suites make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone ---------->>>
<<suite "lex-alone" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/begin---------->>>
	<<suite "begin" make="subdir-makefile-template">>

<<<----case: /lex-alone/begin/case-insensitive---->>>
		<<case "case-insensitive" make="lex-only-makefile-template">>
			<<upgen_options>>-i<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: case-insensitive
*/
				<</desc>>
				<<init_code>>
	int abcs = 0;
	int XYZs = 0;
				<</init_code>>
				<<lex_section>>
abc	cout << yytext << " ---> `abc\'" << endl; ++abcs;
XYZ	cout << yytext << " ---> `XYZ\'" << endl; ++XYZs;
.|\n	/* do nothing*/
				<</lex_section>>
				<<after_init>>
	yylex();
	cout << "abc's = " << abcs << endl;
	cout << "XYZ's = " << XYZs << endl;
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
ABCD
xyz1232
abcd
XYZJFSLK
			<</textfile>>
			<<textfile "result.out">>
ABC ---> `abc'
xyz ---> `XYZ'
abc ---> `abc'
XYZ ---> `XYZ'
abc's = 2
XYZ's = 2
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/case-insensitive---->>>


<<<----case: /lex-alone/begin/debug-option---->>>
		<<case "debug-option" make="lex-only-makefile-template">>
			<<upgen_options>>-d<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%x	SC1
				<</declare_section>>
				<<lex_section>>
\{	BEGIN(SC1);
<SC1>\}	BEGIN(INITIAL);

<*>abc	++abcs;
<*>.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
acde
ABCabc
{
aabc
cccabc

			<</textfile>>
			<<textfile "result.out">>
			<</textfile>>
			<<textfile "result.err">>
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`a'}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`d'}, rule at line: 23 
.................... accept {`e'}, rule at line: 23 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`A'}, rule at line: 23 
.................... accept {`B'}, rule at line: 23 
.................... accept {`C'}, rule at line: 23 
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`{'}, rule at line: 19 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`a'}, rule at line: 23 
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`c'}, rule at line: 23 
.................... accept {`abc'}, rule at line: 22 
.................... accept unprintable-char{10}, rule at line: 23 
.................... accept unprintable-char{10}, rule at line: 23 
.................... EOF reached
.................... EOS reached
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/debug-option---->>>


<<<----case: /lex-alone/begin/entry-param---->>>
		<<case "entry-param" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%formal-param%{int abc, char def %}
%actual-param%{abc, def %}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	int nret = yylex(0, 0);
	if(nret) {
		return nret;
	}
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/entry-param---->>>

<<<----case: /lex-alone/begin/eol-lookahead---->>>
		<<case "eol-lookahead" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/* test operator '$' */
				<</desc>>

				<<lex_section>>
.+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
		yytext[yyleng] = '\0';
		fprintf(stdout, "matched-text = \"%s\".\n", yytext);

\n		fprintf(stdout, "a newline is matched.\n");
				<</lex_section>>
				<<after_init>>
	int nret = yylex();
	if(nret) {
		return nret;
	}
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
/* test operator '$' */

%%

.+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
		yytext[yyleng] = '\0';
		fprintf(stdout, "matched-text = \"%s\".\n", yytext);

\n		fprintf(stdout, "a newline is matched.\n");

%%

/* empty */

%%

using namespace yynsx;

int main(int argc, char **argv) {

	if(argc < 2) {
		yylexfile(NULL, true);
	}
	else {
		if(yylexfile(argv[1], false)) {
			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
			return -1;
		}
	}

	return yylex();
}
			<</textfile>>
			<<textfile "result.out">>
whole-text = "/* test operator '$' */
".
lookahead-text = "
".
matched-text = "/* test operator '$' */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);".
a newline is matched.
whole-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);".
a newline is matched.
whole-text = "		yytext[yyleng] = '\0';
".
lookahead-text = "
".
matched-text = "		yytext[yyleng] = '\0';".
a newline is matched.
whole-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);".
a newline is matched.
a newline is matched.
whole-text = "\n		fprintf(stdout, "a newline is matched.\n");
".
lookahead-text = "
".
matched-text = "\n		fprintf(stdout, "a newline is matched.\n");".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "/* empty */
".
lookahead-text = "
".
matched-text = "/* empty */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "using namespace yynsx;
".
lookahead-text = "
".
matched-text = "using namespace yynsx;".
a newline is matched.
a newline is matched.
whole-text = "int main(int argc, char **argv) {
".
lookahead-text = "
".
matched-text = "int main(int argc, char **argv) {".
a newline is matched.
a newline is matched.
whole-text = "	if(argc < 2) {
".
lookahead-text = "
".
matched-text = "	if(argc < 2) {".
a newline is matched.
whole-text = "		yylexfile(NULL, true);
".
lookahead-text = "
".
matched-text = "		yylexfile(NULL, true);".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
whole-text = "	else {
".
lookahead-text = "
".
matched-text = "	else {".
a newline is matched.
whole-text = "		if(yylexfile(argv[1], false)) {
".
lookahead-text = "
".
matched-text = "		if(yylexfile(argv[1], false)) {".
a newline is matched.
whole-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
".
lookahead-text = "
".
matched-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);".
a newline is matched.
whole-text = "			return -1;
".
lookahead-text = "
".
matched-text = "			return -1;".
a newline is matched.
whole-text = "		}
".
lookahead-text = "
".
matched-text = "		}".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
a newline is matched.
whole-text = "	return yylex();
".
lookahead-text = "
".
matched-text = "	return yylex();".
a newline is matched.
whole-text = "}
".
lookahead-text = "
".
matched-text = "}".
a newline is matched.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eol-lookahead---->>>

<<<----case: /lex-alone/begin/eos-action---->>>
		<<case "eos-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined END-OF-FILE action
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%yywrap%{
	cout << "YYSTART = " << YYSTART() << endl;
	return false;
%}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
YYSTART = 0
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eos-action---->>>


<<<----case: /lex-alone/begin/lex-init-action---->>>
		<<case "lex-init-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined lex-init action, which is executed
	before pattern-matching
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<declare_section>>
%lex-init{

	cout << "Let\'s get started" << endl;
%}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
Let's get started
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/lex-init-action---->>>


<<<----case: /lex-alone/begin/prematch-action---->>>
		<<case "prematch-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined prematch action, which is executed just before
	action corresponding matched pattern
*/
				<</desc>>
				<<init_code>>
#include <cstring>

int abcs = 0;
int matches = 0;
				<</init_code>>
				<<declare_section>>
%pre-match{

	if(strcmp(yytext, "abc") == 0) {
		++matches;
	}
%}
				<</declare_section>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	
	cout << "number of \"abc\" is " << abcs << endl;
	cout << "number of matches is " << matches << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
	if(abcs == matches) {
		cout << "abcs equals matches" << endl;
	}
	else {
		cout << "abcs is different from matches" << endl;
	}
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
number of matches is 4
abcs equals matches
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/prematch-action---->>>


<<<----case: /lex-alone/begin/simplest---->>>
		<<case "simplest" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test simplest case to check basic features
*/
				<</desc>>
				<<init_code>>
int abcs = 0;
				<</init_code>>
				<<lex_section>>
abc	++abcs;
.|\n	/* do nothing*/
<<EOF>>	cout << "number of \"abc\" is " << abcs << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/simplest---->>>


<<<----case: /lex-alone/begin/yyterminate---->>>
		<<case "yyterminate" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-interface: yyterminate
*/
				<</desc>>
				<<lex_section>>
q|Q	cout << endl << "It is time to say goodbye." << endl;	
	yyterminate();

.|\n	cout << yytext;

<<EOF>>	cout << "Something wrong happened." << endl;
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>
			<<textfile "test.input">>
hello, yyterminate
no more to say
q
			<</textfile>>
			<<textfile "result.out">>
hello, yyterminate
no more to say

It is time to say goodbye.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/yyterminate---->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/begin---------->>>


<<<----------sub-suite: /lex-alone/basic---------->>>
	<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/basic/action---->>>
		<<suite "action" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/action/ECHO---->>>
			<<case "ECHO" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: ECHO
*/
					<</desc>>
					<<declare_section>>
cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	cout << "Start scanning upgen script ..." << endl;
%}
					<</declare_section>>
					<<lex_section>>
int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); cout << "... keyword." << endl;

{cid}		ECHO(); cout << "... identifier." << endl;
{digit}		ECHO(); cout << "... number" << endl;
{punct}
.|\n
					<</lex_section>>
					<<after_init>>
		yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test built-in routines: ECHO
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	cout << "Start scanning upgen script ..." << endl;
%}

%%

int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); cout << "... keyword." << endl;

{cid}		ECHO(); cout << "... identifier." << endl;
{digit}		ECHO(); cout << "... number" << endl;
{punct}
.|\n

%%
				<</textfile>>
				<<textfile "result.out">>
Start scanning upgen script ...
test... identifier.
built... identifier.
in... identifier.
routines... identifier.
ECHO... identifier.
#include... keyword.
iostream... identifier.
using... keyword.
std... identifier.
cout... identifier.
using... keyword.
std... identifier.
endl... identifier.
cid... identifier.
cidf... identifier.
cids... identifier.
digit... identifier.
digit... identifier.
punct... identifier.
punct... identifier.
lex... identifier.
init... identifier.
cout... identifier.
Start... identifier.
scanning... identifier.
upgen... identifier.
script... identifier.
endl... identifier.
int... keyword.
void... keyword.
if... keyword.
return... keyword.
NULL... keyword.
using... keyword.
#include... keyword.
ECHO... identifier.
cout... identifier.
keyword... identifier.
endl... identifier.
cid... identifier.
ECHO... identifier.
cout... identifier.
identifier... identifier.
endl... identifier.
digit... identifier.
ECHO... identifier.
cout... identifier.
number... identifier.
endl... identifier.
punct... identifier.
n... identifier.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/ECHO---->>>


<<<----------case: /lex-alone/basic/action/yy_buffer---->>>
			<<case "yy_buffer" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yy_new_filebuf(file-name): buffer-object
	yy_push_buffer(buffer-object)
	yy_pop_buffer(): buffer-object
	yy_delete_buffer()
	yy_switch_buffer(buffer-object)
	yy_has_buffer(): false/true
	yy_current_buffer(): buffer-object
	yy_set_bol(false/true)
	yyinput(): char
*/
					<</desc>>
					<<init_code>>
#include <cstring>

#define MAX_BUF_NUM	10
char *fnlist[MAX_BUF_NUM];
int cur_size = 0;
					<</init_code>>
					<<declare_section>>
fn	[^\\\/\*\r\n\t ]+
					<</declare_section>>
					<<lex_section>>
#include[ \t]*\<{fn}\>	{

		int c = END_OF_FILE;
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		yy_set_bol(true);

		if(cur_size <  MAX_BUF_NUM) {

			int beg = 8;
			while(yytext[beg] != '<') ++beg;
			++beg;
			char *pch = new char[yyleng - beg];
			strncpy(pch, &yytext[beg], yyleng - beg - 1);
			beg = yyleng - beg - 1;
			pch[beg] = '\0';

			YYPBUFFER pnewbuf = yy_new_filebuf(pch);
			if(pnewbuf) {
				YYPBUFFER poldbuf = yy_current_buffer();
				yy_push_buffer(pnewbuf);
				yy_push_buffer(poldbuf);
				fnlist[cur_size++] = pch;
			}
			else {
				cout << "Warning: failed to open file `" << pch << "\'" << endl;
				delete[] pch;
			}		
		}
	}

#open[ \t]*\<{fn}\>	{

		int c = END_OF_FILE;
		while((c = yyinput()) != END_OF_FILE && c != '\n');
		if(cur_size <  MAX_BUF_NUM) {

			int beg = 5;
			while(yytext[beg] != '<') ++beg;
			++beg;
			char *pch = new char[yyleng - beg];
			strncpy(pch, &yytext[beg], yyleng - beg - 1);
			beg = yyleng - beg - 1;
			pch[beg] = '\0';
	
			YYPBUFFER pnewbuf = yy_new_filebuf(pch);
			if(pnewbuf) {
				yy_push_buffer(pnewbuf);
				fnlist[cur_size++] = pch;
				yy_set_bol(true);
			}
			else {
				cout << "Warning: failed to open file `" << pch << "\'" << endl;
				delete[] pch;
			}
				
		}
    }

#overwrite[ \t]*\<{fn}\>	{

		int c = END_OF_FILE;
		while((c = yyinput()) != END_OF_FILE && c != '\n');

		if(cur_size <  MAX_BUF_NUM) {

			int beg = 5;
			while(yytext[beg] != '<') ++beg;
			++beg;
			char *pch = new char[yyleng - beg];
			strncpy(pch, &yytext[beg], yyleng - beg - 1);
			beg = yyleng - beg - 1;
			pch[beg] = '\0';
	
			yy_delete_buffer();

			YYPBUFFER pnewbuf = yy_new_filebuf(pch);
			if(pnewbuf) {

				yy_push_buffer(pnewbuf);
				fnlist[cur_size++] = pch;
				yy_set_bol(true);
			}
			else {
				cout << "Warning: failed to open file `" << pch << "\'" << endl;
				delete[] pch;
			}		
		}
    }

<<EOF>>		{

	cout << endl;
	if(yy_has_buffer()) {

		yy_pop_buffer();
		yy_set_bol(true);
	}
    }
.|\n		cout << yytext;
					<</lex_section>>
					<<after_init>>
	yylex();
	for(int i = 0; i < cur_size; ++i) {

		delete[] fnlist[i];
	}

					<</after_init>>
				<</script>>
				<<textfile "test.input">>
******** test.input begin **********
#include<test1.input>
aaa
aaa
#open <test2.input>
aaa
******** test.input over ***********
				<</textfile>>
				<<textfile "test1.input">>
******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********
				<</textfile>>
				<<textfile "test2.input">>
******** test2.input begin **********
ccc
ccc
#overwrite<test3.input>
ccc
******** test2.input over ***********
				<</textfile>>
				<<textfile "test3.input">>
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********
				<</textfile>>
				<<textfile "result.out">>
******** test.input begin **********
aaa
aaa
******** test2.input begin **********
ccc
ccc
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********

aaa
******** test.input over ***********

******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yy_buffer---->>>


<<<----------case: /lex-alone/basic/action/yyinput---->>>
			<<case "yyinput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyinput(): char
	yyunput(char)
	yy_set_bol(false/true)
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

					<</declare_section>>
					<<lex_section>>
"/*"	int c = END_OF_FILE;
	while((c = yyinput()) != END_OF_FILE) {

		if(c == '*') {

			if((c = yyinput()) == (int)((unsigned char)'/')
			    || c == END_OF_FILE) {

				break;
			}
			yyunput(c);
		}	
	}

"//"	int c = END_OF_FILE;
	while((c = yyinput()) != END_OF_FILE) {

		if(c == (int)((unsigned char)'\n')) {

			break;
		}
	}
	yy_set_bol(true);

^[ \t]+.*\n	cout << yytext;
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
 just test for yyinput & yyunput
*/show me
 you can see me
 if there is not `beautiful life', then life is awful
//something wrong must be happened
/*
 
*************
/
Oops!
************/
 beautiful life
//***********************/
I am Prince of Darkness, so you can't see me
//************/**************/**********/
 and God will always be with you.
				<</textfile>>
				<<textfile "result.out">>
 you can see me
 if there is not `beautiful life', then life is awful
 beautiful life
 and God will always be with you.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyinput---->>>


<<<----------case: /lex-alone/basic/action/yyless---->>>
			<<case "yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyless(number-of-chars)
*/
					<</desc>>
					<<lex_section>>
"hello, world"	cout << yytext; yyless(7);
"world"		cout << yytext;
"Hi, guys"	cout << yytext; yyless(4);
"guys"		cout << yytext;
\n		cout << endl;
.

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
104 101 108 108 111 44 32 119 111 114 108 100 10 72 105 44 
32 103 117 121 115 10 10 -43 -116 58 -98 -119 88 -127 -96 15 
-47 82 -73 -50 -100 -62 -49 -8 79 -68 108 90 -112 -90 -3 124 
-80 37 32 -48 -52 -84 -93 64 -107 10 -110 66 -82 85 51 -42 
74 -72 36 38 -67 -123 92 119 -94 80 -40 -36 16 101 97 103 
47 12 -115 -113 105 114 -75 22 -57 -2 30 -12 3 -65 102 -121 
44 -22 -60 -44 -64 33 99 107 120 115 -104 55 28 77 -109 57 
83 69 98 42 -91 96 87 -106 65 11 41 94 126 8 29 -66 
-111 7 0 -39 95 113 48 61 -46 40 -18 100 123 -53 -99 -74 
49 1 -30 86 -5 45 -37 -85 89 34 -114 -10 24 116 -79 -89 
54 -23 60 62 76 -9 59 -117 -76 -95 31 127 -35 -17 68 -15 
84 -38 26 53 -54 -16 56 -105 78 110 -124 81 17 -19 -6 93 
-4 -78 -13 67 109 -83 117 122 91 -41 52 2 125 -97 -126 -25 
6 -24 70 -77 13 104 20 72 -1 -70 43 -103 46 -7 -108 -21 
-45 121 35 -31 39 -20 -26 25 -125 106 27 -81 -55 -92 19 -88 
-102 -61 -128 -120 -101 71 14 -51 -11 -59 -29 -28 -122 5 -71 -34 
73 4 -14 -69 -32 75 -87 18 -27 63 112 -58 23 -63 -56 111 
21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
hello, worldworld
Hi, guysguys


				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyless---->>>


<<<----------case: /lex-alone/basic/action/yymore--->>>
			<<case "yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>
/*
test built-in routines:
	yymore()
*/
					<</desc>>
					<<lex_section>>
"It\'s"		cout << yytext << endl; yymore();
"nice to"	cout << yytext << endl; yymore();
"see you!"	cout << yytext << endl; yymore();
" "		cout << "*" << endl; yymore();
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
It's nice to see you!
None of these are available.
				<</textfile>>
				<<textfile "result.out">>
It's
*
It's nice to
*
It's nice to see you!
*
*
*
*
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yymore---->>>


<<<----------case: /lex-alone/basic/action/yyrestart--->>>
			<<case "yyrestart" make="lex-only-makefile-template">>
				<<EXTRA_DIST>>test1.input<</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyrestart()
*/
					<</desc>>
					<<init_code>>
#define MAX_OPEN_TIMES	8

bool useFile = false;
int reopen_times = 0;
					<</init_code>>
					<<declare_section>>
%yywrap%{

	if(!useFile) {
		YYPBUFFER pbuf = yy_new_filebuf("test1.input");
		if( !pbuf) {
			cout << "failed to open `test1.input\'" << endl;
			yyterminate();
		}
		else {
			yy_switch_buffer(pbuf);
		}
	}
	useFile = true;

	return 0;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
	
a	cout << yytext; ++ncnt;

<<EOF>>	{
		cout << endl;
		if(useFile && reopen_times < MAX_OPEN_TIMES) {

			++reopen_times;
			yyrestart();
			yy_set_bol(true);
		}
	}

.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << endl << "a\'s occurrences: " << ncnt << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
aa
				<</textfile>>
				<<textfile "test1.input">>
aa
				<</textfile>>
				<<textfile "result.out">>
aa
aa
aa
aa
aa
aa
aa
aa
aa

a's occurrences: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyrestart---->>>



<<<----------case: /lex-alone/basic/action/yysc_state--->>>
			<<case "yysc_state" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	YYSTART()
	yy_push_state(DFA-begin-state)
 	yy_pop_state()
*/
					<</desc>>
					<<init_code>>
#include <iomanip>
using std::setw;
					<</init_code>>
					<<declare_section>>
%x	sc1
%x	sc2
%x	sc3
%x	sc4
					<</declare_section>>
					<<lex_section>>
<INITIAL,sc1,sc2,sc3>"("	{
		
		switch(YYSTART()) {
		case INITIAL:
			yy_push_state(sc1);
			break;
		case sc1:
			yy_push_state(sc2);
			break;
		case sc2:
			yy_push_state(sc3);
			break;
		case sc3:
			yy_push_state(sc4);
			break;
		}
	}

<sc1,sc2,sc3,sc4>")"	yy_pop_state();

<*>[[:space:]]+

<sc1>[^\(\)\r\n \t]+	{
		cout << "\t" << yytext << endl;
	}
<sc2>[^\(\)\r\n \t]+	{
		cout << "\t\t" << yytext << endl;
	}
<sc3>[^\(\)\r\n \t]+	{
		cout << "\t\t\t" << yytext << endl;
	}
<sc4>[^\(\)\r\n \t]+	{
		cout << "\t\t\t\t" << yytext << endl;
	}
[^\(\)\n\r \t]+	{
		cout << yytext << endl;
	}

<*>.|\r?\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
	(define
		(right-branch
		tree)
		(cadr
		tree))
	(define
		(symbols
		tree)
		(if
			(leaf?
			tree)
			(list
				(symbol-leaf
				tree))
			(caddr tree)))
	(define
		(weight
		tree)
		(if
			(leaf?
			tree)
			(weight-leaf
			tree)
			(cadddr tree)))
				<</textfile>>
				<<textfile "result.out">>
	define
		right-branch
		tree
		cadr
		tree
	define
		symbols
		tree
		if
			leaf?
			tree
			list
				symbol-leaf
				tree
			caddr
			tree
	define
		weight
		tree
		if
			leaf?
			tree
			weight-leaf
			tree
			cadddr
			tree
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yysc_state---->>>


<<<----------case: /lex-alone/basic/action/yyunput--->>>
			<<case "yyunput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyunput(char-to-put)
*/
					<</desc>>
					<<declare_section>>
%lex-init%{
	cout << "Play game of `Change Word\'" << endl;
%}
					<</declare_section>>
					<<lex_section>>
bad	yyunput('d');
	yyunput('o');
	yyunput('o');
	yyunput('g');

ugly	yyunput('e');
	yyunput('t');
	yyunput('u');
	yyunput('c');

cruel	yyunput('d');
	yyunput('n');
	yyunput('i');
	yyunput('k');

lie	yyunput('h');
	yyunput('t');
	yyunput('u');
	yyunput('r');
	yyunput('t');

proud	yyunput('e');
	yyunput('l');
	yyunput('b');
	yyunput('m');
	yyunput('u');
	yyunput('h');

.|\n	cout << yytext;

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
Once upon a time, there is very bad, ugly guy. He is alway very cruel to people around him, and force himself to tell at leat a lie everyday. What's more, he is a very proud man.
				<</textfile>>
				<<textfile "result.out">>
Play game of `Change Word'
Once upon a time, there is very good, cute guy. He is alway very kind to people around him, and force himself to tell at leat a truth everyday. What's more, he is a very humble man.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyunput---->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/action---->>>



<<<----------sub-suite: /lex-alone/basic/charset---->>>
		<<suite "charset" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/charset/charset-blank--->>>
			<<case "charset-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
[ \t]		++ncnt;
[ \t]{5}	ncnt += 10;
[ \t]+		ncnt += yyleng * 3;

.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
 a a a a
					b
          c
				<</textfile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>	
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>
			<<case "charset-cesc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
	escape char in C language
*/
					<</desc>>
					<<init_code>>
int ncnt = 0;
					<</init_code>>
					<<declare_section>>
cesc1	[\0\?\\\"\'\a\b\f\n\r\t\v]
cesc2	\0|\?|\\|\"|\'|\a|\b|\f|\n|\r|\t|\v
cesc3	"\0"|"\?"|"\\"|"\""|"\'"|"\a"|"\b"|"\f"|"\n"|"\r"|"\t"|"\v"

					<</declare_section>>
					<<lex_section>>
{cesc1}		++ncnt;
{cesc2}{5}	ncnt += 10;
{cesc3}+	ncnt += yyleng * 3;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	cout << ncnt << endl;
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
7 65 0 65 9 65 10 65 63 34 39 63 39 65 11 13 
11 13 92 92 92 92 13 34
				<</bytefile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>


<<<----------case: /lex-alone/basic/charset/charset-concat--->>>
			<<case "charset-concat" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation:
	concat
*/
					<</desc>>
					<<declare_section>>
int	[\+\-]?([1-9][0-9]*|0)
hex	\\[Xx][0-9A-Fa-f][0-9A-Fa-f]
oct	\\[0-3][0-7][0-7]
real	{int}|{int}"\."[0-9]+
					<</declare_section>>
					<<lex_section>>
{int}	|
{hex}	|
{oct}	|
{real}	cout << yytext << endl;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/+100 c-999 a7777
\xffe wiof\X33kis \\x4232 \XDCE
dd\001\777\888\999\aaa
43.90a 48.23b1233204.738429sfsj4332
				<</textfile>>
				<<textfile "result.out">>
+100
-999
7777
\xff
\X33
\x42
32
\XDC
\001
777
888
999
43.90
48.23
1233204.738429
4332
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-concat--->>>


<<<----------case: /lex-alone/basic/charset/charset-email--->>>
			<<case "charset-email" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze email address 
*/
					<</desc>>
					<<init_code>>
int ncnt = 0;
					<</init_code>>
					<<declare_section>>
/* name section */
nsect	[0-9A-Za-z\_\-]{1,}
/* name */
name	{nsect}("."{nsect})*
emaddr	{name}\@{name}
					<</declare_section>>
					<<lex_section>>
{emaddr}	cout << yytext << endl; ++ncnt;

.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	cout << ncnt << endl;
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
somebody.upgen@robot.com
somebody.upgen@r@obot.com
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
				<</textfile>>
				<<textfile "result.out">>
somebody.upgen@robot.com
somebody.upgen@r
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
3
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-email--->>>


<<<----------case: /lex-alone/basic/charset/charset-hex--->>>
			<<case "charset-hex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning hexadecimal numbers
*/
					<</desc>>
					<<init_code>>
int blanks = 0;
int spaces = 0;
int digits = 0;
int uppers = 0;
int lowers = 0;
int eofs = 0;
int nansis = 0;
					<</init_code>>
					<<declare_section>>
blank	[\x09\x20]
space	[\x09-\x0D]
digit	[\x30-\x39]
upper	[\X41-\X5a]
lower	[\x61-\X7A]
eof	[\XFf]
nansi	[\X80-\xff]
					<</declare_section>>
					<<lex_section>>
{blank}		++blanks;
{space}		++spaces;
{digit}		++digits;
{upper}		++uppers;
{lower}		++lowers;
{eof}		++eofs;
{nansi}		++nansis;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "blanks: " << blanks << endl
	     << "spaces: " << spaces << endl
	     << "digits: " << digits << endl
	     << "uppers: " << uppers << endl
	     << "lowers: " << lowers << endl
	     << "eofs: " << eofs << endl
	     << "nansis: " << nansis << endl;

					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-43 -116 58 -98 -119 88 -127 -96 15 -47 82 -73 -50 -100 -62 -49 
-8 79 -68 108 90 -112 -90 -3 124 -80 37 32 -48 -52 -84 -93 
64 -107 10 -110 66 -82 85 51 -42 74 -72 36 38 -67 -123 92 
119 -94 80 -40 -36 16 101 97 103 47 12 -115 -113 105 114 -75 
22 -57 -2 30 -12 3 -65 102 -121 44 -22 -60 -44 -64 33 99 
107 120 115 -104 55 28 77 -109 57 83 69 98 42 -91 96 87 
-106 65 11 41 94 126 8 29 -66 -111 7 0 -39 95 113 48 
61 -46 40 -18 100 123 -53 -99 -74 49 1 -30 86 -5 45 -37 
-85 89 34 -114 -10 24 116 -79 -89 54 -23 60 62 76 -9 59 
-117 -76 -95 31 127 -35 -17 68 -15 84 -38 27 53 -54 -16 56 
-105 78 110 -124 81 17 -19 -6 93 -4 -78 -13 67 109 -83 117 
122 91 -41 52 2 125 -97 -126 -25 6 -24 70 -77 13 104 20 
72 -1 -70 43 -103 46 -7 -108 -21 -45 121 35 -31 39 -20 -26 
25 -125 106 27 -81 -55 -92 19 -88 -102 -61 -128 -120 -101 71 14 
-51 -11 -59 -29 -28 -122 5 -71 -34 73 4 -14 -69 -32 75 -87 
18 -27 63 112 -58 23 -63 -56 111 21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
blanks: 2
spaces: 4
digits: 10
uppers: 26
lowers: 26
eofs: 1
nansis: 127
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-hex--->>>


<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>
			<<case "charset-ipaddress" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze ip address 
*/
					<</desc>>
					<<init_code>>
int selfs = 0;
int ipaddrs = 0;
					<</init_code>>
					<<declare_section>>
self	"127"\.0{1,3}\.0{1,3}\.(0?0)?1
ipsect	[01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5]
ipaddr	({ipsect})(\.({ipsect})){3}
					<</declare_section>>
					<<lex_section>>
{self}		++selfs; cout << "localhost " << selfs << ": " << yytext << endl;
{ipaddr}	++ipaddrs; cout << "ip " << ipaddrs << ": " << yytext << endl;
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "localhosts: " << selfs << endl
	     << "others: " << ipaddrs << endl;
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
localhost1: 127.0.0.1
localhost2: 127.000.000.001
localhost3: 127.0.00.001
ip1: 192.156.173.115
ip3: 0.0.0.1
ip4: 0.0.0.0
ip5: 255.255.255.255
ip6: 256.001.002.003
ip7: 128.a.9.3
ip8: 116.119.121.34
ip2: 99.77.88.10
				<</textfile>>
				<<textfile "result.out">>
localhost 1: 127.0.0.1
localhost 2: 127.000.000.001
localhost 3: 127.0.00.001
ip 1: 192.156.173.115
ip 2: 0.0.0.1
ip 3: 0.0.0.0
ip 4: 255.255.255.255
ip 5: 56.001.002.003
ip 6: 116.119.121.34
ip 7: 99.77.88.10
localhosts: 3
others: 7
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>


<<<----------case: /lex-alone/basic/charset/charset-meta--->>>
			<<case "charset-meta" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
meta-char as escape char
*/
					<</desc>>
					<<init_code>>
int meta1s = 0,
 meta2s = 0,
 meta3s = 0,
 meta4s = 0;
					<</init_code>>
					<<declare_section>>
meta1	[\%\(\)\[\]\{\}\<\>\|\<\>\:\$\^\/\*\+\,\;\.\?\-]
meta2	\%|\(|\)|\[|\]|\{|\}|\<|\>|\||\<|\>|\:|\$|\^|\/|\*|\+|\,|\;|\.|\?|\-
meta3	"\%"|"\("|"\)"|"\["|"\]"|"\{"|"\}"|"\<"|"\>"|"\|"|"\<"|"\>"|"\:"|"\$"|"\^"|"\/"|"\*"|"\+"|"\,"|"\;"|"\."|"\?"|"\-"
meta4	"%"|"("|")"|"["|"]"|"{"|"}"|"<"|">"|"|"|"<"|">"|":"|"$"|"^"|"/"|"*"|"+"|","|";"|"."|"?"|"-"

					<</declare_section>>
					<<lex_section>>
{meta1}		++meta1s; cout << yytext;
{meta2}		++meta2s; cout << yytext;
{meta3}		++meta3s; cout << yytext;
{meta4}		++meta4s; cout << yytext;
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "\nmeta1s = " << meta1s << endl
	     << "meta2s = " << meta2s << endl
	     << "meta3s = " << meta3s << endl
	     << "meta4s = " << meta4s << endl;
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
				<</textfile>>
				<<textfile "result.out">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
meta1s = 41
meta2s = 0
meta3s = 0
meta4s = 0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-meta--->>>


<<<----------case: /lex-alone/basic/charset/charset-negator--->>>
			<<case "charset-negator" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation:
	negator(^)
*/
					<</desc>>
					<<init_code>>
int blanks = 0,
 spaces = 0,
 ansis = 0,
 eofs = 0,
 others = 0,
 nospcs = 0,
 noblks = 0,
 neofs = 0;
					<</init_code>>
					<<declare_section>>
ansi	[\000-\177]
other	[^\000-\177]
blank	[ \t]
noblk	[^ \t]
space	[[:space:]]
nospc	[^[:space:]]
eof		[\xFF]
neof	[^\xff]

					<</declare_section>>
					<<lex_section>>
{blank}		++blanks;
{space}		++spaces;
{ansi}		++ansis;
{eof}		++eofs;
{other}		++others;

{nospc}		++nospcs;
{noblk}		++noblks;
{neof}		++neofs;

.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	cout << "blanks: " << blanks << endl
	     << "spaces: " << spaces << endl
	     << "ansis: " << ansis << endl
	     << "eofs: " << eofs << endl
	     << "others: " << others << endl
	     << "nospcs: " << nospcs << endl
	     << "noblks: " << noblks << endl
	     << "neofs: " << neofs << endl;
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 
48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 
80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 
96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 
112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 
-128 -127 -126 -125 -124 -123 -122 -121 -120 -119 -118 -117 -116 -115 -114 -113 
-112 -111 -110 -109 -108 -107 -106 -105 -104 -103 -102 -101 -100 -99 -98 -97 
-96 -95 -94 -93 -92 -91 -90 -89 -88 -87 -86 -85 -84 -83 -82 -81 
-80 -79 -78 -77 -76 -75 -74 -73 -72 -71 -70 -69 -68 -67 -66 -65 
-64 -63 -62 -61 -60 -59 -58 -57 -56 -55 -54 -53 -52 -51 -50 -49 
-48 -47 -46 -45 -44 -43 -42 -41 -40 -39 -38 -37 -36 -35 -34 -33 
-32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 
-16 -15 -14 -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1
				<</bytefile>>
				<<textfile "result.out">>
blanks: 2
spaces: 4
ansis: 122
eofs: 1
others: 127
nospcs: 0
noblks: 0
neofs: 0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-negator--->>>


<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>
			<<case "charset-normal-esc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
normal char as escape char
*/
					<</desc>>
					<<init_code>>
int norm2 = 0,
 norm3 = 0,
 norm4 = 0,
 norm5 = 0;	
					<</init_code>>
					<<declare_section>>

norm1	\\[A-Zc-eg-mo-qsuw-z_\#\&\=\@\`\~]
norm2	"\A"|"\B"|"\C"|"\D"|"\E"|"\F"|"\G"|"\H"|"\I"|"\J"|"\K"|"\L"|"\M"|"\N"|"\O"|"\P"|"\Q"|"\R"|"\S"|"\T"|"\U"|"\V"|"\W"|"\X"|"\Y"|"\Z"|"\c"|"\d"|"\e"|"\g"|"\h"|"\i"|"\j"|"\k"|"\l"|"\m"|"\o"|"\p"|"\q"|"\s"|"\u"|"\w"|"\x"|"\y"|"\z"|"\_"|"\#"|"\&"|"\="|"\@"|"\`"|"\~"
norm3	"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"|"c"|"d"|"e"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"o"|"p"|"q"|"s"|"u"|"w"|"x"|"y"|"z"|"_"|"#"|"&"|"="|"@"|"`"|"~"
norm4	\A|\B|\C|\D|\E|\F|\G|\H|\I|\J|\K|\L|\M|\N|\O|\P|\Q|\R|\S|\T|\U|\V|\W|\X|\Y|\Z|\c|\d|\e|\g|\h|\i|\j|\k|\l|\m|\o|\p|\q|\s|\u|\w|\x|\y|\z|\_|\#|\&|\=|\@|\`|\~
norm5	A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|c|d|e|g|h|i|j|k|l|m|o|p|q|s|u|w|x|y|z|_|#|&|=|@|`|~

					<</declare_section>>
					<<lex_section>>
{norm2}		++norm2; cout << yytext;
{norm3}		++norm3; cout << yytext;
{norm4}		++norm4; cout << yytext;
{norm5}		++norm5; cout << yytext;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	yylex();
	cout << "\nnorm2:" << norm2 << endl
	     << "norm3:" << norm3 << endl
	     << "norm4:" << norm4 << endl
	     << "norm5:" << norm5 << endl;

					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
8 -43 -30 120 -90 29 110 54 120 -14 -67 8 -80 -94 97 23 
105 -21 -111 8 65 -77 98 125 0 22 -102 27 71 -77 -10 80 
-120 -40 -56 46 -11 54 100 109 40 33 118 -40 -61 -41 -17 45 
-62 -128 53 3 51 -104 -127 52 -82 27 79 -11 -50 69 69 86 
29 13 -123 19 67 -23 -128 107 11 -10 67 -50 -50 50 -5 -112 
-78 49 -108 -26 -55 21 27 119 48 105 108 -2 -82 -78 84 -53 
-65 -39 -34 3 -61 95 110 -50 85 -78 -100 35 -28 -104 -76 -105 
-55 72 125 -110 93 -105 9 -115 0 117 -117 -82 39 -33 121 -25 
-71 88 -22 124 -73 88 74 12 10 -26 48 -17 126 -28 -122 71 
44 3 -39 -119 -102 -30 22 -102 88 -95 72 127 -128 -63 102 57 
25 80 -75 -48 -87
				<</bytefile>>
				<<textfile "result.out">>
xxiAGPdmOEEVCkCwilT_U#HuyXXJ~GXHP
norm2:33
norm3:0
norm4:0
norm5:0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>


<<<----------case: /lex-alone/basic/charset/charset-oct--->>>
			<<case "charset-oct" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning octal numbers
*/
					<</desc>>
					<<init_code>>
#include <string>
using std::string;
int digits = 0,
 uppers = 0,
 lowers = 0;
int eofs = 0,
 nansis = 0;
string strd,
 stru,
 strl;
					<</init_code>>
					<<declare_section>>
digit	[\060-\071]
upper	[\101-\132]
lower	[\141-\172]
eof		[\377]
nansi	[\200-\377]
					<</declare_section>>
					<<lex_section>>
{digit}		++digits; strd += yytext;
{upper}		++uppers; stru += yytext;
{lower}		++lowers; strl += yytext;
{eof}		++eofs;
{nansi}		++nansis;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	yylex();
	cout << "\ndigits: " << strd << " " << digits << " in total." << endl
	     << "uppers: " << stru << " " << uppers << " in total." << endl
	     << "lowers: " << strl << " " << lowers << " in total." << endl
	     << "eofs: " << eofs << endl
	     << "nansis: " << nansis << endl;

					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
127 120 -93 -30 32 116 -64 2 -87 120 62 116 95 68 68 83 
-51 88 9 -21 -77 25 65 0 -69 -42 -115 -29 -74 127 -34 53 
-9 -127 24 23 -10 -40 25 -97 81 87 19 -80 -100 87 4 105 
-81 13 84 98 39 -106 98 -30 108 -16 -59 34 111 -92 88 102 
37 112 125 27 72 -105 -69 -103 -18 -50 74 -118 38 78 -12 -43 
91 72 56 -126 -34 -102 100 74 -118 42 109 -7 -50 -59 95 -13 
53 -35 15 125 116 -54 23 98 -104 97 -19 -66 -81 -31 -108 10 
41 -52 -115 8 102 -15 82 -15 27 -65 -22 -23 -124 74 -35 -71 
39 -20 55 -101 -74 78 -3 78 -81 -22 13 94 -53 -95 104 -11 
109 -11 -3 -45 -25 79 -60 2 15 -81 -20 -109 -7 -55 77 32 
-75 -124 -69 107 -46 -72 -71 -127 -93 -58 -33 110 103 71 99 -44 
61 96 -88 36 -80 108 38 -65 27 18 82 20 -37 -97 52 -112 
35 -17 -5 -11 -88 -75 118 75 123 85 -71 -29 -99 29 -73 -38 
125 95 -2 45 -52 36 -20 -25 55 63 -4 18 -34 48 -93 2 
32 -98 -9 -56 83 110 19 -49 -61 -52 -78 96 -23 105 58 103 
-55 56 -108 -107 93 -127 124 -108 -64 120 -90 -98 -87 73 -96 -55 
-24 -104 -111 59 6 -92 10 -55 112 -68 42 90 38 100 -63 -17 
-99 85 -124 -6 -42 0 -114 -106 121 52 53 34 126 -43 -21 102 
109 124 -95 115 32 -84 61 -112 104 103 -22 -114 -53 -85 125 104 
1 1 98 -41 2 -16 110 123 37 -93 -99 -93 120 -120 9 -26 
4 -86 89 36 86 -106 -76 -65 -3 -97 77 -55 74 -53 49 75 
-52 -108 35 -50 -124 -111 73 -87 52 -26 76 -84 110 85 -110 114 
0 -20 -106 86 -126 75 21 -128 -22 99 73 52 46 122 -128 -6 
14 -93 -55 -109 52 18 60 104 -7 -119 20 103 -34 -89 -38 -34 
-109 112 53 21 -69 74 -107 -91 -83 -34 -38 -37 89 90 -42 103 
-3 -97 -6 49 -79 55 -103 -86 -64 -83 18 -98 84 -20 125 -25 
92 -78 -3 24 -4 -110 -67 -86 113 -105 -123 -54 -15 91 49 -18 
-6 44 31 -84 99 -72 86 35 102 104 -63 -70 84 62 -94 -79 
-16 -97 -55 -19 49 -122 -105 -94 30 28 108 15 120 -98 -2 114 
-54 29 30 45 -42 117 80 60 -35 17 -10 50 80 -104 -29 64 
55 -84 45 105 50 -60 11 80 -31 120 96 89 22 94 -53 -32 
123 -22 13 81 95 93 -115 60 110 -124 110 -66 28 81 
				<</bytefile>>
				<<textfile "result.out">>

digits: 5857470845144451711272 22 in total.
uppers: DDSXAQWWTXHJNHJRJNNOMGRKUSIZUYVMJKILUVKIJYZTVTPPPYQQ 52 in total.
lowers: xtxtibblofpdmtbafhmkngclvnigxpdyfmshghbnxnrczhgpgqcfhlxruixnn 61 in total.
eofs: 0
nansis: 257
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-oct--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>
			<<case "charset-posix-alnum" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alnum
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

alnum	[[:alnum:]]

					<</declare_section>>
					<<lex_section>>
{alnum}		++ncnt; cout << yytext << " +1" << endl;
{alnum}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{alnum}+	ncnt += yyleng * 3; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-37 -96 60 -108 -49 -92 47 -81 -7 75 -102 -11 50 -112 -35 6 
104 -75 -88 109 -98 34 -54 49 -114 102 97 -67 -20 -46 56 -100 
118 64 24 -13 -128 36 -79 120 -59 89 42 51 -66 18 -47 68 
-60 43 -70 127 57 -74 -34 53 -50 -68 22 115 29 76 17 -40 
15 112 -76 96 -87 0 122 -12 -9 -17 65 -124 -15 -110 8 41 
114 78 46 98 -39 -83 86 119 -14 -78 -5 101 -57 -71 38 -89 
-27 -52 -117 87 -120 63 117 13 25 100 -122 69 83 27 40 -44 
59 -62 -73 91 80 31 -106 -103 -21 -51 -82 -94 -36 99 -25 -1 
-104 58 -126 55 -4 -109 14 -63 33 -18 11 -118 -64 -41 -99 72 
-33 -16 27 -84 110 113 45 -90 10 48 -72 37 92 93 1 77 
-45 -121 62 -86 -95 -6 -42 -125 -69 -65 -113 52 -111 16 -31 -107 
-38 70 121 81 106 108 103 85 123 90 82 54 73 -3 -115 -26 
-55 105 -8 88 -85 107 94 -2 124 74 -127 -105 12 116 -80 44 
23 -43 -32 67 -28 19 -24 -97 95 -119 30 21 126 79 -48 -53 
39 71 125 2 -77 4 9 20 35 -10 -22 5 -23 32 7 -29 
-30 -61 -93 61 -56 111 -58 -91 3 -19 84 66 -116 -123 -101 28
				<</bytefile>>
				<<textfile "result.out">>
K +1
2 +1
h +1
m +1
1 +1
fa +4
8 +1
v +1
x +1
Y +1
3 +1
D +1
9 +1
5 +1
s +1
L +1
p +1
z +1
A +1
rN +4
b +1
Vw +4
e +1
W +1
u +1
d +1
ES +4
P +1
c +1
7 +1
H +1
nq +4
0 +1
M +1
4 +1
FyQjlgU +21
ZR6I +12
i +1
X +1
k +1
J +1
t +1
C +1
O +1
G +1
o +1
TB +4
96
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>
			<<case "charset-posix-alpha" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alpha
*/
					<</desc>>
					<<declare_section>>
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
{alpha}		++ncnt; cout << yytext << " +1" << endl;
{alpha}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{alpha}+	ncnt += yyleng * 3; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
96 -34 -73 -66 -14 56 39 -45 -43 111 120 -56 67 -86 6 89 
106 -94 13 87 -28 84 45 16 110 36 117 15 102 -122 -78 -109 
-20 22 -72 58 94 23 -59 12 126 66 -62 28 -19 -26 -91 -67 
107 -89 59 -44 -92 -93 52 103 -83 -33 -75 -104 -102 7 63 55 
74 79 -16 -63 -12 35 100 40 121 71 70 -127 -90 -55 61 -23 
3 0 -96 5 80 57 43 -70 -69 -9 -111 -52 34 77 24 69 
-11 90 14 91 33 -21 41 27 92 29 -82 47 -58 -35 73 86 
46 98 37 -107 95 -37 118 119 10 72 122 123 124 125 25 127 
-128 75 -126 -125 -124 -123 105 -121 -120 -119 -118 -117 -116 -115 -114 -113 
-112 97 -110 31 -108 115 -106 -105 50 -103 60 -101 -100 -99 -98 -97 
82 -95 17 53 54 112 76 49 -88 -87 18 -85 -84 83 114 -81 
-80 -79 30 -77 -76 116 -74 2 104 -71 19 88 -68 48 21 -65 
-64 113 42 -61 -60 38 108 -57 11 93 -54 -53 99 -51 -50 -49 
-48 -47 -46 78 51 8 -42 -41 -40 -39 -38 27 -36 109 1 85 
-32 -31 -30 -29 20 -27 64 -25 -24 65 -22 101 32 44 -18 -17 
9 -15 4 -13 68 81 -10 62 -8 -7 -6 -5 -4 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
ox +4
C +1
Yj +4
W +1
T +1
n +1
u +1
f +1
B +1
k +1
g +1
JO +4
d +1
yGF +9
P +1
M +1
E +1
Z +1
IV +4
b +1
vw +4
Hz +4
K +1
i +1
a +1
s +1
R +1
pL +4
Sr +4
t +1
h +1
X +1
q +1
l +1
c +1
N +1
m +1
U +1
A +1
e +1
DQ +4
76
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>
			<<case "charset-posix-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - blank
*/

					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}
blank	[[:blank:]]
					<</declare_section>>
					<<lex_section>>
{blank}		++ncnt; cout << yytext << " +1" << endl;
{blank}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{blank}+	ncnt += yyleng * 3; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
80 -104 -125 -100 -42 84 120 -57 -58 40 -114 6 -1 115 10 -28 
16 -74 -62 -12 -7 -75 65 47 -90 -76 2 -67 54 -65 -69 88 
-96 -95 34 17 -101 68 15 -18 0 46 -91 -36 -107 96 -120 -92 
123 -97 -127 75 126 43 -117 116 111 71 -21 -20 94 41 -38 86 
95 30 44 124 11 39 114 -43 102 19 -13 -121 106 28 98 -32 
-17 105 69 63 1 13 -25 -31 -30 -82 77 -81 74 -24 90 85 
49 -109 -94 103 55 27 -79 -122 -16 83 -23 7 127 -88 -11 42 
-80 -68 76 -110 93 -2 -48 51 104 25 -106 -85 59 61 67 -59 
-70 8 -34 73 -124 60 -33 112 -78 -14 18 64 -123 -54 -93 35 
122 113 5 -66 -51 101 78 -9 107 -113 20 27 -84 57 92 -47 
-8 -116 -45 -98 50 22 33 -22 -72 -118 4 -126 -44 87 -87 -111 
56 -71 66 14 81 -37 125 -29 29 32 -52 -61 -99 23 9 89 
3 -40 -49 -119 -39 119 58 -102 31 121 100 -50 -63 52 72 62 
79 24 -77 -56 -103 -83 -108 108 37 53 -89 -64 97 91 -46 -26 
-19 -112 -86 99 -35 38 118 109 48 -27 -15 -128 36 70 -115 -105 
82 -55 -41 45 21 110 -10 -60 -53 -73 -6 -5 -4 -3 117 12 
				<</bytefile>>
				<<textfile "result.out">>
  +1
	 +1
2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>
			<<case "charset-posix-cid" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - cid
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{cidf}{cids}*		cout << yytext << endl; ++ncnt;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test posix charset - cid
*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]

%%

{cidf}{cids}*		cout << yytext << endl; ++ncnt;
.|\n

%%

using namespace yynsx;

int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
posix
charset
cid
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
cidf
cidf
cids
cids
cidf
cids
cout
yytext
endl
ncnt
n
using
namespace
yynsx
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
51
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-cntrl--->>>
			<<case "charset-posix-cntrl" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - cntrl
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

digit	[[:digit:]]
xdigt	[[:xdigit:]]
lower	[[:lower:]]
upper	[[:upper:]]
alnum	[[:alnum:]]
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{cntrl}			++ncnt;	cout << (int)yytext[0] << " +1" << endl;
{cntrl}{2}		ncnt += 4; cout << (int)yytext[0] << " " << (int)yytext[1] << " +4" << endl;
{cntrl}+		ncnt += 3 * yyleng;
			for(int i = 0; i < yyleng; ++i) {
				cout << (int)yytext[i] << " ";
			}
			cout << "+" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-100 -25 -72 103 -126 106 83 53 117 46 -81 42 126 -111 -23 -105 
14 -128 87 80 1 -95 98 5 74 -79 -115 27 -68 -119 -113 10 
-69 -97 26 -87 -53 -50 34 118 41 -8 105 119 -74 15 73 -1 
20 78 70 35 0 -75 121 47 -125 28 116 -2 66 110 92 -92 
-84 -55 52 38 -31 -61 -11 111 -20 -47 -109 -118 59 -96 94 43 
16 93 -80 -58 -14 102 12 9 -32 -46 -103 40 115 7 -54 123 
6 49 -90 -29 -42 -121 65 79 31 55 23 -43 97 -21 -3 -73 
69 122 -62 125 67 -123 124 62 -70 -36 60 3 120 -120 96 4 
-101 -94 -78 68 -57 -88 -18 11 39 54 -26 -56 -9 81 -108 -93 
44 -49 33 13 22 -122 -16 32 21 -40 104 25 63 8 127 -7 
88 -37 -10 -71 108 -15 100 -67 -24 61 50 57 29 -99 -44 -13 
-6 -91 -98 101 17 90 75 2 -63 -30 -38 -106 -82 -102 -27 -89 
-114 58 99 -4 -64 24 19 95 109 -41 -86 107 -34 112 48 -65 
-110 30 64 -48 51 -83 45 -22 -117 -35 89 114 -77 91 -66 76 
18 -124 82 -33 -107 56 37 -60 -45 84 -52 36 -85 72 85 -59 
-116 86 -12 77 -112 -5 71 -17 -76 -51 -127 -19 -39 -104 -28 113
				<</bytefile>>
				<<textfile "result.out">>
14 +1
1 +1
5 +1
27 +1
10 +1
26 +1
15 +1
20 +1
0 +1
28 +1
16 +1
12 9 +4
7 +1
6 +1
31 +1
23 +1
3 +1
4 +1
11 +1
13 22 +4
21 +1
25 +1
8 127 +4
29 +1
17 +1
2 +1
24 19 +4
30 +1
18 +1
41
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-cntrl--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>
			<<case "charset-posix-digit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - digit
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

digit	[[:digit:]]
xdigt	[[:xdigit:]]
lower	[[:lower:]]
upper	[[:upper:]]
alnum	[[:alnum:]]
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{digit}		++ncnt; cout << yytext << " +1" << endl;
{digit}{2}	ncnt += 4; cout << yytext << " +4" << endl;
{digit}+	ncnt += 3 * yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
105 -64 -121 -114 -94 -25 -51 16 54 -50 33 28 -75 -58 84 -61 
-14 -91 123 -69 86 93 22 110 -74 65 14 85 -6 -78 9 55 
114 94 29 42 64 -92 -48 -49 90 60 -77 -100 -111 111 -102 8 
49 -2 126 -47 -79 122 -19 124 40 70 -43 -30 98 20 -93 -105 
-104 -83 3 27 -82 45 127 -10 51 -36 -117 27 -76 -26 7 79 
32 56 -95 -97 -120 102 74 -106 5 88 66 -20 -66 91 53 -41 
6 25 106 118 121 41 17 -88 -57 96 -23 43 -12 -67 -54 -60 
83 30 -112 -70 67 0 39 44 -42 -98 -17 68 -34 1 -128 -16 
-55 -52 97 -53 35 -56 -81 -5 -37 -115 -119 -90 107 -18 81 61 
47 -87 58 13 72 -35 -96 104 -109 -116 -38 34 117 31 108 69 
-80 2 -108 95 -32 115 36 -28 -84 -118 -8 -1 -24 -113 82 -124 
120 -11 52 -73 18 113 -39 87 -68 92 -123 80 -62 -107 -33 -9 
-71 -63 24 -21 77 -45 -13 100 -27 -7 -72 112 -29 89 76 59 
-122 99 -127 116 109 -89 -85 62 57 15 -110 63 10 38 -3 4 
119 -59 21 -40 73 125 78 -65 12 19 -4 -103 -125 37 -101 103 
-126 -86 11 23 75 101 46 -22 50 -44 -15 -31 48 -46 71 -99
				<</bytefile>>
				<<textfile "result.out">>
6 +1
7 +1
1 +1
3 +1
8 +1
5 +1
4 +1
9 +1
2 +1
0 +1
10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>
			<<case "charset-posix-graph" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - graph
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{graph}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{graph}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{graph}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-100 -54 -41 127 91 -15 40 -14 -78 -22 95 -102 -111 -52 -43 -88 
-89 -12 99 103 94 48 -44 74 -29 -113 -36 -94 -103 71 -55 -83 
72 77 114 -116 -26 3 -71 38 -39 -120 -118 98 52 23 -4 -73 
-80 -31 -87 56 2 106 109 -99 89 -112 -59 -70 -119 29 90 -1 
66 115 -33 19 79 104 -79 -86 9 82 69 -96 33 119 17 51 
-34 -121 -25 -35 101 -75 121 5 -108 -17 -24 108 -127 -47 -48 120 
-122 84 105 -93 -64 43 -37 -62 -60 -77 -13 -11 50 68 -38 86 
73 -72 122 -61 -65 -23 41 123 14 62 25 12 10 -95 -82 18 
57 -51 -30 111 53 -97 110 15 -49 83 -2 67 64 31 -3 45 
-85 -28 92 -42 -101 30 -27 55 42 -92 118 -128 -91 16 60 -90 
96 59 -66 39 -18 -21 28 7 4 -32 -63 80 -67 -123 37 -76 
-40 -74 21 27 -7 -6 -126 107 102 -117 -109 -115 81 76 27 113 
32 88 1 -53 -125 -58 -9 -110 0 -68 -19 6 -69 -57 54 124 
70 -114 -105 -10 44 -8 126 63 8 75 20 49 -124 11 22 125 
-5 61 -45 58 87 78 -50 -84 46 93 -16 85 -46 97 24 47 
117 116 65 -20 100 13 34 36 -98 -81 112 35 -107 -106 -104 -56 
				<</bytefile>>
				<<textfile "result.out">>
[ +1
( +1
_ +1
cg^0 +12
J +1
G +1
HMr +9
& +1
b4 +4
8 +1
jm +4
Y +1
Z +1
Bs +4
Oh +4
RE +4
!w +4
3 +1
e +1
y +1
l +1
x +1
Ti +4
+ +1
2D +4
VI +4
z +1
){ +4
> +1
9 +1
o5 +4
n +1
S +1
C@ +4
- +1
\ +1
7* +4
v +1
< +1
`; +4
' +1
P +1
% +1
kf +4
QL +4
q +1
X +1
6|F +9
, +1
~? +4
K +1
1 +1
} +1
= +1
:WN +9
.] +4
U +1
a +1
/utA +12
d +1
"$ +4
p# +4
168 94
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>
			<<case "charset-posix-lower" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - lower
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
lower	[[:lower:]]

%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}
					<</declare_section>>
					<<lex_section>>
{lower}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{lower}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{lower}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-81 -95 86 58 -122 -116 -14 -27 110 -63 0 -105 19 16 -69 -39 
49 -60 -79 14 -15 -33 8 43 112 -128 -88 -62 -89 -67 88 -20 
62 -46 -2 -23 74 -101 -10 10 -28 40 -55 18 -61 106 -85 126 
-92 101 -47 -26 -48 -34 -86 -87 -3 66 123 47 118 -64 117 56 
-16 57 3 73 79 99 -125 82 59 6 -51 17 55 -112 68 -19 
32 28 11 67 36 115 -83 69 13 127 -74 -107 -96 98 -66 -77 
24 2 90 -108 114 -102 -73 7 -98 9 64 -12 29 72 -41 -40 
52 -123 -113 -109 -49 21 89 38 -1 108 -118 92 33 95 -6 105 
-24 -5 -13 -103 12 65 -94 -22 -35 54 -4 103 100 -38 -59 -111 
25 -21 35 34 -84 -18 -93 27 63 -32 -68 -78 84 5 -100 -58 
30 -25 85 -117 27 75 87 22 20 31 122 125 -124 4 94 -8 
-57 -50 -110 -104 83 78 -99 1 -75 -17 -56 51 -71 91 53 -80 
-127 -42 -29 111 -106 -31 61 107 -11 71 46 23 77 15 -44 -7 
-114 42 -65 119 48 -90 -30 -126 80 81 41 -9 -43 93 97 104 
50 39 116 -120 102 -76 121 120 -52 -97 -119 44 -121 -70 -82 96 
70 -53 -91 -72 37 -36 45 113 -115 109 -37 60 -54 76 124 -45 
				<</bytefile>>
				<<textfile "result.out">>
n +1
p +1
j +1
e +1
v +1
u +1
c +1
s +1
b +1
r +1
l +1
i +1
gd +4
z +1
o +1
k +1
w +1
ah +4
t +1
f +1
yx +4
q +1
m +1
32 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>
			<<case "charset-posix-print" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - print
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

print	[[:print:]]
					<</declare_section>>
					<<lex_section>>

{print}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{print}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{print}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
45 -115 61 96 -10 -11 -86 -118 -92 -2 62 114 -70 52 53 58 
124 -28 27 -45 21 -105 95 -44 -25 123 46 79 54 -93 -124 -89 
31 51 -3 -22 -24 110 -94 -74 -12 36 19 -23 4 -59 -56 102 
10 -119 70 72 -96 -110 -5 68 -36 -127 0 -98 126 -112 -123 90 
108 35 -6 60 -34 -126 38 -68 -15 127 44 -82 -72 -9 94 -35 
105 -16 100 -113 -32 -27 103 48 -63 32 -4 -17 91 -47 -54 -128 
65 -95 -29 37 -40 -26 101 -99 13 97 -21 -43 116 -53 -57 49 
-90 1 14 88 -71 -33 16 -73 104 3 80 93 -108 -101 -78 84 
-8 89 111 20 122 98 29 28 -42 85 -61 117 -31 -116 18 22 
119 30 33 -103 -81 12 9 42 47 -121 27 -13 74 -100 -107 -97 
-49 78 -39 -18 -76 -104 67 120 77 109 -83 -120 17 -60 -41 15 
-65 -19 -102 107 -20 -7 -88 -1 81 63 -62 -77 -80 34 -106 -87 
83 -69 -111 -14 75 8 -64 71 64 -50 106 -55 -38 -91 -46 25 
-52 2 -85 121 -51 39 87 -79 57 125 24 -114 -58 -66 -30 41 
86 7 118 -125 -122 23 55 92 -75 40 43 113 -67 -109 -84 56 
11 59 99 76 112 73 -48 82 5 6 50 66 -117 69 -37 115 
				<</bytefile>>
				<<textfile "result.out">>
- +1
=` +4
>r +4
45:| +12
_ +1
{.O6 +12
3 +1
n +1
$ +1
f +1
FH +4
D +1
~ +1
Zl# +9
< +1
& +1
, +1
^ +1
i +1
d +1
g0 +4
  +1
[ +1
A +1
% +1
e +1
a +1
t +1
1 +1
X +1
h +1
P] +4
T +1
Yo +4
zb +4
U +1
u +1
w +1
! +1
*/ +4
J +1
N +1
CxMm +12
k +1
Q? +4
" +1
S +1
K +1
G@ +4
j +1
y +1
'W +4
9} +4
)V +4
v +1
7\ +4
(+q +9
8 +1
;cLpI +15
R +1
2B +4
E +1
s +1
171 95
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-punct--->>>
			<<case "charset-posix-punct" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - punct

*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

punct	[[:punct:]]

					<</declare_section>>
					<<lex_section>>

{punct}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{punct}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{punct}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-58 59 -89 -123 -35 94 -40 -10 6 37 -55 84 125 26 96 103 
-120 -127 -21 -99 -2 -78 95 117 -6 77 -25 -116 -12 -73 -106 107 
56 -128 -76 1 -100 -43 -109 93 90 14 -80 126 -50 50 122 -125 
-64 -30 31 62 -34 52 -54 -5 111 -62 87 65 -122 -98 64 106 
86 48 -105 33 60 2 -74 -70 21 16 -47 -61 -39 20 -16 -45 
127 108 40 81 -93 -88 -124 17 -85 80 -108 -86 -112 -95 -82 39 
43 -11 67 -38 -83 22 74 -63 85 69 -57 -46 41 7 -37 -117 
-107 99 98 -52 -90 -56 10 -97 -91 -65 104 36 101 -36 -66 71 
70 -51 123 46 4 35 -8 -110 -71 -3 27 91 78 -115 -126 112 
68 -94 -102 -44 15 -72 45 -32 -33 -31 -77 79 -81 -75 -69 -15 
100 121 -14 83 120 25 24 -121 29 76 -9 8 -1 -79 -28 53 
-20 105 -18 57 109 34 82 -23 -67 55 51 -119 -101 -4 11 116 
0 61 -22 38 13 -48 -42 -53 -49 42 102 28 119 54 -60 110 
3 44 -26 -111 -113 88 -7 -24 30 115 47 63 92 5 -59 -92 
-103 9 -68 89 72 58 -84 97 -29 66 124 -41 12 118 18 19 
-118 23 -27 32 49 113 73 -114 -13 114 -19 -17 -87 75 -96 -104 
				<</bytefile>>
				<<textfile "result.out">>
; +1
^ +1
% +1
} +1
` +1
_ +1
] +1
~ +1
> +1
@ +1
!< +4
( +1
'+ +4
) +1
$ +1
{. +4
# +1
[ +1
- +1
" +1
= +1
& +1
* +1
, +1
/?\ +9
: +1
| +1
44 32
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-punct--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>
			<<case "charset-posix-space" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - space
*/
					<</desc>>
					<<declare_section>>

%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

space	[[:space:]]
					<</declare_section>>
					<<lex_section>>
{space}			++ncnt; ++nchars; cout << yytext << " +1" << endl;
{space}{2}		ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{space}+		ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
111 -113 11 107 -106 2 -51 76 -112 -119 102 -121 -122 27 -47 77 
-109 32 3 -64 44 25 -9 -31 33 17 69 51 31 -99 67 1 
-1 97 -44 -85 -3 61 -62 78 -65 -111 -83 112 -38 -126 -21 43 
-84 84 56 48 -63 113 -79 68 16 6 -29 39 -59 123 71 41 
-37 4 42 -34 95 86 14 91 19 85 -8 45 -71 -90 -98 89 
10 -32 62 -58 -80 23 74 -43 118 98 -86 126 63 -35 -10 66 
109 -13 -127 72 46 -94 -19 58 -102 -81 122 -11 -55 121 83 117 
-72 116 -114 101 -16 9 53 -5 -69 -15 -95 -50 52 -117 -33 -66 
-49 -92 124 -115 99 28 -7 108 -110 0 -2 -107 -77 55 -18 94 
-78 88 12 7 -4 37 -74 -24 22 -46 -52 64 15 -89 8 103 
-30 -45 -97 114 -101 -96 -20 -26 -128 -36 -57 18 5 -48 -40 79 
-22 -91 13 29 -104 100 73 -108 -88 70 75 -6 -53 57 -73 93 
-76 92 -123 80 105 -75 21 81 -67 -103 -42 82 -125 -68 -17 -120 
115 59 87 -124 120 90 -28 -27 106 24 96 -14 119 30 26 60 
-118 47 -82 -25 110 104 -70 49 65 -56 20 34 -61 -105 50 -23 
-93 -60 40 35 54 38 125 127 -100 -41 -87 36 -39 -54 -12 -116 
				<</bytefile>>
				<<bytefile "result.out">>
11 32 43 49 10 32 32 43 49 10 10 32 43 49 10 9 
32 43 49 10 12 32 43 49 10 13 32 43 49 10 54 32 
54 10
				<</bytefile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>
			<<case "charset-posix-upper" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - upper
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

upper	[[:upper:]]
					<</declare_section>>
					<<lex_section>>
{upper}			++ncnt; ++nchars; cout << yytext << " +1" << endl;
{upper}{2}		ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{upper}+		ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
-34 -84 -47 -124 91 80 -37 87 -104 48 74 -16 -126 -61 1 -62 
-67 58 102 34 32 -33 110 65 -102 85 75 124 -77 -125 122 -25 
7 -118 28 -13 70 -15 107 83 104 13 -65 27 49 42 46 10 
-23 69 90 101 -4 -80 5 -95 -49 120 119 62 15 23 66 67 
44 45 -53 20 -127 12 24 60 76 99 -20 57 59 -121 30 -123 
93 -103 29 -5 -31 -113 -41 118 72 21 0 -98 -22 54 73 -101 
-63 100 43 -6 -99 113 97 -10 38 -97 -40 17 11 -71 71 36 
-17 82 -26 -35 86 121 4 64 98 -114 -78 -46 -105 -30 94 -57 
117 63 25 22 -94 39 -119 -11 40 78 -106 -86 -54 111 95 18 
123 77 -39 89 52 -91 -115 -109 127 -48 50 33 -120 -100 79 68 
126 55 -9 2 -68 -107 -90 -89 -88 -87 -117 -85 14 -83 -82 -81 
53 -79 -122 19 -76 -75 -74 -73 -72 109 -70 -69 -92 16 -66 61 
-64 96 51 41 -60 -59 -58 8 -56 -55 -116 88 -52 -51 -50 56 
81 -93 -112 -45 -44 -43 -42 116 106 -110 -38 6 -36 115 -128 27 
-32 84 125 -29 -28 -27 114 31 -24 9 92 -21 47 -19 -18 112 
108 37 -14 35 -12 -111 103 3 -8 -7 -96 105 -108 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
P +1
W +1
J +1
A +1
UK +4
F +1
S +1
EZ +4
BC +4
L +1
H +1
I +1
G +1
R +1
V +1
N +1
M +1
Y +1
OD +4
X +1
Q +1
T +1
34 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>
			<<case "charset-posix-xdigit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - xdigit
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

xdigt	[[:xdigit:]]
					<</declare_section>>
					<<lex_section>>

{xdigt}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{xdigt}{2}	ncnt += 4; nchars +=2; cout << yytext << " +4" << endl;
{xdigt}+	ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<bytefile "test.input">>
121 -78 -90 74 45 -59 -107 80 -96 112 78 -54 -113 -84 56 -63 
-73 9 -79 10 8 -8 42 69 111 104 118 57 -88 117 95 -87 
-81 38 -40 70 85 54 -67 -121 -37 -45 32 44 127 -60 -19 22 
40 -46 109 -122 3 -68 29 43 99 90 -98 -76 -117 -125 -4 61 
-111 53 -62 31 123 2 -39 68 -126 103 86 -118 11 -24 114 -72 
50 115 27 -14 18 -53 94 -77 -103 126 13 -31 -23 72 -22 -42 
89 -16 -34 -94 63 -70 -66 75 -12 -51 -100 -85 -35 60 5 28 
-115 -120 65 -30 79 98 -128 -97 -92 -1 6 113 -36 -102 -29 15 
119 37 -6 105 27 -61 36 19 25 21 39 -91 -114 110 -21 91 
-112 30 24 67 34 35 -38 1 -9 58 -11 -93 -26 -17 -3 -20 
4 73 17 66 -104 -7 -47 -32 -127 0 -2 64 -65 -50 -74 -110 
-123 106 -105 -124 83 33 52 122 -15 -108 102 100 -75 88 125 107 
-95 -10 -5 51 -58 93 97 49 71 -116 108 -44 23 -71 124 -101 
82 62 46 -82 -86 14 55 -41 47 76 12 77 101 48 -64 59 
-55 116 87 -13 7 -119 -52 20 81 -28 92 -99 -33 -56 -49 -69 
-48 -109 -106 -89 41 -80 -27 120 -25 96 -57 -83 84 16 -43 -18 
				<</bytefile>>
				<<textfile "result.out">>
8 +1
E +1
9 +1
F +1
6 +1
c +1
5 +1
D +1
2 +1
A +1
b +1
C +1
B +1
4 +1
fd +4
3 +1
a1 +4
7 +1
e0 +4
28 22
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>


<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>
			<<case "charset-single-a" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
Test charset set has only a single char
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ int &ncnt, int &nchars %}
%actual-param%{ ncnt, nchars %}

aset	[a]
					<</declare_section>>
					<<lex_section>>
{aset}		++ncnt; ++nchars; cout << yytext << " +1" << endl;
{aset}{2,5}	ncnt += 2 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 2 << endl;
{aset}+		ncnt += 3 * yyleng; nchars += yyleng; cout << yytext << " +" << yyleng * 3 << endl;
.|\n

					<</lex_section>>
					<<before_init>>
	int ncnt = 0, nchars = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt, nchars);
	cout << ncnt << " " << nchars << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abbbbbbaaaaaaaaaabbaaaaaaaaabbbbbbaaaaaaaabaaaaaaaaaaaaaaabbbaaaaaaaabbaaaaabbbaaabaabbaaaabbbaaabbabbbaabbbbb
				<</textfile>>
				<<textfile "result.out">>
a +1
aaaaaaaaaa +30
aaaaaaaaa +27
aaaaaaaa +24
aaaaaaaaaaaaaaa +45
aaaaaaaa +24
aaaaa +10
aaa +6
aa +4
aaaa +8
aaa +6
a +1
aa +4
190 71
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/charset---------->>>



<<<----------sub-suite: /lex-alone/basic/lookahead---->>>
		<<suite "lookahead" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>
			<<case "lookahead-mixture" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore, yyless, yyunput
*/
					<</desc>>
					<<lex_section>>
"hell"			
"hello"(\,?" ")?	cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;
			yymore();

"seat"			cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;
			yyless(1);
			yyunput('b');

"beat"			cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;

"seat"/tle		cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;
			yyless(1);
			yyunput('b');

"beat"/tle		cout << endl;
			cout << "whole-text = " << yytext << endl;	
			cout << "lookahead-text = " << &yytext[yyleng] << endl;
			cout << "valid-text = " << yytext << endl;

.|\n			cout << yytext;
					<</lex_section>>

					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
seat-eh, hello, seattle
				<</textfile>>
				<<textfile "result.out">>

whole-text = seat
lookahead-text = 
valid-text = seat

whole-text = beat
lookahead-text = 
valid-text = beat
-eh, 
whole-text = hello, 
lookahead-text = 
valid-text = hello, 

whole-text = hello, seattle
lookahead-text = tle
valid-text = hello, seattle
bello, 
whole-text = seattle
lookahead-text = tle
valid-text = seattle

whole-text = beattle
lookahead-text = tle
valid-text = beattle
tle
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>
			<<case "lookahead-multiple" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/
					<</desc>>
					<<init_code>>
int lineno = 1;
bool bla = false;
					<</init_code>>
					<<declare_section>>

cid	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	for(--yyleng; yytext[yyleng] == ' ' || yytext[yyleng] == '\t'; --yyleng) {
				
			}
			++yyleng;
			yytext[yyleng] = '\0';
			bla = true;
			cout << "k" << lineno << ":" << yytext << endl;	
if		|
else		|
return		|
#include		cout << "t" << lineno << ":" << yytext << endl; 
.			if(bla) {
				cout << yytext << endl;
			}
			bla = false;
\n			++lineno;
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/

%{

#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*

%%
	int lineno = 1;
	bool bla = false;

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	for(--yyleng; yytext[yyleng] == ' ' || yytext[yyleng] == '\t'; --yyleng) {
				
			}
			++yyleng;
			yytext[yyleng] = '\0';
			bla = true;
			cout << "k" << lineno << ":" << yytext << endl;	
if		|
else		|
return		|
#include		cout << "t" << lineno << ":" << yytext << endl; 
.			if(bla) {
				cout << yytext << endl;
			}
			bla = false;
\n			++lineno;
%%
/*do nothing */

using namespace yynsx;

int main(int argc, char **argv) {

	if(0 != yylex(NULL)) {
		
		return -1;
	}
	else {
		return 0;
	}
}
				<</textfile>>
				<<textfile "result.out">>
k7:#include
<
t18:if
t19:else
t20:return
t21:#include
t28:if
t29:else
k30:return
	
t31:#include
k32:if
(
k44:if
(
k46:return
 
k48:else
{
k49:return
 
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>
			<<case "lookahead-single" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test basic functionality of lookahead feature
*/
					<</desc>>
					<<init_code>>
int abcs = 0;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
abc/d	++abcs;
	cout << "whole-text = " << yytext << endl;	
	cout << "lookahead-text = " << &yytext[yyleng] << endl;
	yytext[yyleng] = '\0';
	cout << "valid-text = " << yytext << endl;

abc
.|\n	cout << yytext;

<<EOF>>	cout << "number of \"abc/d\" is " << abcs << endl;
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abcd
abc
babcd
babc
				<</textfile>>
				<<textfile "result.out">>
whole-text = abcd
lookahead-text = d
valid-text = abc
d

bwhole-text = abcd
lookahead-text = d
valid-text = abc
d
b
number of "abc/d" is 2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>
			<<case "lookahead-yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yyless
*/
					<</desc>>
					<<init_code>>
bool bla = false;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
gabcde/f	cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		yyless(1);
		bla = true;

abc/d		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		yyless(1);
		bla = true;

b/c		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;

abc		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = false;

.|\n		if(bla) {
			cout << yytext << endl;
		}
		bla = false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
gabcdefg
				<</textfile>>
				<<textfile "result.out">>
whole-text = gabcdef
lookahead-text = f
valid-text = gabcde
whole-text = abcd
lookahead-text = d
valid-text = abc
whole-text = bc
lookahead-text = c
valid-text = b
c
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>
			<<case "lookahead-yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore
*/
					<</desc>>
					<<init_code>>
bool bla = false;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
Hello\,\040/world\!	{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;
		yymore();
	}
world\!			{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = false;
	}
Michael/" "Jodan	{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;
		yymore();
	}
" "Jodan		{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = false;
	}

Jackson"--"/King" of "R"&"R	{	
		cout << "whole-text = " << yytext << endl;	
		cout << "lookahead-text = " << &yytext[yyleng] << endl;
		yytext[yyleng] = '\0';
		cout << "valid-text = " << yytext << endl;
		bla = true;
	}

.|\n		if(bla) {
			cout << yytext << endl;
		}
		bla = false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
Hello, world!
Michael Jodan
Jackson--King of R&R
abc
				<</textfile>>
				<<textfile "result.out">>
whole-text = Hello, world!
lookahead-text = world!
valid-text = Hello, 
whole-text = Hello, world!
lookahead-text = 
valid-text = Hello, world!
whole-text = Michael Jodan
lookahead-text =  Jodan
valid-text = Michael
whole-text = Michael Jodan
lookahead-text = 
valid-text = Michael Jodan
whole-text = Jackson--King of R&R
lookahead-text = King of R&R
valid-text = Jackson--
K
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/lookahead---->>>


<<<----------sub-suite: /lex-alone/basic/option---->>>
		<<suite "option" make="subdir-makefile-template">>


<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>
			<<case "lex-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: duplicated option

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%option debug=1
%option debug=yes
%option debug="yes"
					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>


<<<----------case: /lex-alone/basic/option/lex-option1--->>>
			<<case "lex-option1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test option setting
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	{
		cout << yytext << endl;
		++ncnt;
	}
.|\n

					<</lex_section>>
					<<before_init>>
int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test option setting
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*

%%
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	{
		cout << yytext << endl;
		++ncnt;
	}
.|\n

%%

using namespace yynsx;

int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
option
setting
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
option
debug
option
debug1
option
verbose
off
option
detail
on
option
just
test
yes
option
you
are
joking
true
option
file
path
upgen
option
file
name
no
title
c
cpp
id
cidf
cids
Aa
Dd
Ss
Uu
Bb
Mm
Uu
Ll
Dd
Ii
Vv
id
cout
yytext
endl
ncnt
n
using
namespace
yynsx
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
89
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-option1--->>>


<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>
			<<case "lex-unsupported" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: unsupported options
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%array
%pointer
%8bit
%case-insentitive

					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/option---->>>


<<<----------sub-suite: /lex-alone/basic/reop---->>>
		<<suite "reop" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>
			<<case "charset-plus" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexical analyse float number in C
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &ints, int &floats %}
%actual-param%{ ints, floats %}

int		[\+\-]?[0-9]+
basic		{int}(\.[0-9]+)?
float		{basic}([EFef]{int})?
					<</declare_section>>
					<<lex_section>>
{int}
		cout << yytext << endl;
		++ints;
{float}

		cout << yytext << endl;

		++floats;
.|\n

					<</lex_section>>
					<<before_init>>
	int ni = 0, nf = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ni, nf);
	cout << "number of integer: " << ni << endl
	     << "number of float: " << nf << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
123
39999999900000000000E
234.5Fa3423
23f4.5
566666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
39999999900000000000
234.5
3423
23f4
5
566666
3
45e0
3
4.5
6E8
4E34
5
6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9
7F3
4
number of integer: 10
number of float: 11
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>

<<<----------case: /lex-alone/basic/reop/charset-range--->>>
			<<case "charset-range" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: range

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &cnt1, int &cnt2, int &cnt3, int &cnt4 %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

eq4a	a{4}
lt3b	b{,3}
gt2c	c{2,}
d2t5	d{2,5}
					<</declare_section>>
					<<lex_section>>

{eq4a}		++cnt1; cout << yytext << " --> match {eq4a}" << endl;
{lt3b}		++cnt2; cout << yytext << " --> match {lt3b}" << endl;
{gt2c}		++cnt3; cout << yytext << " --> match {gt2c}" << endl;
{d2t5}		++cnt4; cout << yytext << " --> match {d2t5}" << endl;
.|\n
<<EOF>>		cout << "end of file reached." << endl;
					<</lex_section>>
					<<before_init>>
	int ncnt1 = 0, ncnt2 = 0, ncnt3 = 0, ncnt4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex( ncnt1, ncnt2, ncnt3, ncnt4);
	cout << "aaa: " << ncnt1 << endl
	     << "-bbb: " << ncnt2 << endl
	     << "cc-: " << ncnt3 << endl
	     << "dd-ddddd: " << ncnt4 << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
.aaaddd.........aaaadddddddd.......aaaaaabbabbbbbbbbbbbbbbbaaaaaaaaabdddddddddd.......................................ddd................ccccccccccddddddddddddddddddddddddddddddaaaaaaabbbbbbbbbbbbbbbbdddd..ddddddd...............ddddd...ccccdddddddddddddddddddddddcccccccdbbbbbbbbbbcccccccccccccccccccccccdddd...aaaaaaaaaacccccccccddddddddddddbbbbbbbbbcccccc........aaaaaaaaa.........aaaddd......ddd......bbbbbbbbbbcccccccccccddd......aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadddddddddd.ccccccdddddddddddddddddddddddcccccccccddddddddddddaabbbbbbbbbbbbbbbbbbbbbbdddddd........................ccccccddddd
				<</textfile>>
				<<textfile "result.out">>
ddd --> match {d2t5}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddd --> match {d2t5}
aaaa --> match {eq4a}
bb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
b --> match {lt3b}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
cccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
aaaa --> match {eq4a}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
dddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
ddddd --> match {d2t5}
cccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccc --> match {gt2c}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccccccccccccccc --> match {gt2c}
dddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
cccccc --> match {gt2c}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddd --> match {d2t5}
ddd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccc --> match {gt2c}
ddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
end of file reached.
aaa: 22
-bbb: 32
cc-: 10
dd-ddddd: 40
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-range--->>>

<<<----------case: /lex-alone/basic/reop/charset-star--->>>
			<<case "charset-star" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexically analyse real number in PASCAL
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

/* unsigned positve integer */
nonzero		[1-9][0-9]*
/* natural number */
natural		0|{nonzero}
/* mantissa */
mant		[0-9]*[1-9]
/* basic representation of real number*/
basic		[\+\-]?{natural}(\.{mant})?
/* scientific representatio of real number */
/*scient		{basic}[Ee][\+\-]{nonzero}*/
/* pascal real number */
preal		{basic}([Ee][\+\-]?{nonzero})?
					<</declare_section>>
					<<lex_section>>

{preal}		{
		cout << yytext << endl;
		++ncnt;
		}

.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << ncnt << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
123
234.5ea3423
23e4.5
566a666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
234.5
3423
23e4
5
566
666
3
45
0.3
4.5
6E8
4E34
5
6E8
9.7
34
9
7
3
4
21
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-star--->>>

<<<----------case: /lex-alone/basic/reop/charset-union--->>>
			<<case "charset-union" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: union
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &cnt1, int &cnt2, int &cnt3, int &cnt4 %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

int	(\+|\-)?((0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*|0)
hex	\\(X|x)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)
oct	\\(0|1|2|3)(0|1|2|3|4|5|6|7)(0|1|2|3|4|5|6|7)
real	{int}(\.(0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*)?
					<</declare_section>>
					<<lex_section>>

{int}		++cnt1;
		cout << yytext << endl;
{hex}		++cnt2;
		cout << yytext << endl;
{oct}		++cnt3;
		cout << yytext << endl;
{real}		++cnt4;
		cout << yytext << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int ncnt1 = 0, ncnt2 = 0, ncnt3 = 0, ncnt4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt1, ncnt2, ncnt3, ncnt4);
	cout << "int: " << ncnt1 << endl
	     << "hex: " << ncnt2 << endl
	     << "oct: " << ncnt3 << endl
	     << "real: " << ncnt4 << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
\X3289f
434.3300.342.43423.9324.4320
\580523
\2347843
tfghui90ioik568io
00.00.00.00.00.00.090000
00x9000

				<</textfile>>
				<<textfile "result.out">>
\X32
89
434.33
0
0.342
43423.9324
432
0
58
0523
\234
7843
9
0
568
0
0.0
0.0
0.0
0.0
0.0
0.09
0
0
0
0
0
0
9
0
0
0
int: 21
hex: 1
oct: 1
real: 9
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-union--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/reop---->>>


<<<----------sub-suite: /lex-alone/basic/rule---->>>
		<<suite "rule" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>
			<<case "rule-bol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test bol(beginning of line) flag
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{int &bols, int &nbols%}
%actual-param%{bols, nbols%}
					<</declare_section>>
					<<lex_section>>
^"#include"	{
		cout << yytext << " => matched ^\"#include\"" << endl;
		++bols;
	}
"#include"	{
		cout << yytext << " => matched \"#include\"" << endl;
		++nbols;
	}
"#import"	{
		cout << yytext << " => matched \"#import\"" << endl;
		++nbols;
	}
^"#if"		{
		cout << yytext << " => matched ^\"#if\"" << endl;
		++bols;
	}
"#if"		{
		cout << yytext << " => matched \"#if\"" << endl;
		++nbols;
	}
"#cond"		{
		cout << yytext << " => matched \"#cond\"" << endl;
		++nbols;
	}
.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "at_bol: " << n1 << endl 
	     << "not_at_bol: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
/*
test regular expression: bol flag is set

Sample:
#include
 #include
#import
	#import
#if #if
#cond
#cond

*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{int &bols, int &nbols%}
%actual-param%{bols, nbols%}

%%
^"#include"	{
		cout << yytext << " => matched ^\"#include\"" << endl;
		++bols;
	}
"#include"	{
		cout << yytext << " => matched \"#include\"" << endl;
		++nbols;
	}
"#import"	{
		cout << yytext << " => matched \"#import\"" << endl;
		++nbols;
	}
^"#if"		{
		cout << yytext << " => matched ^\"#if\"" << endl;
		++bols;
	}
"#if"		{
		cout << yytext << " => matched \"#if\"" << endl;
		++nbols;
	}
"#cond"		{
		cout << yytext << " => matched \"#cond\"" << endl;
		++nbols;
	}
.|\n

%%

using namespace yynsx;

int main(int argc, char **argv) {

	int n1 = 0, n2 = 0;
	int nret = yylex(NULL, n1, n2);
	
	cout << "at_bol: " << n1 << endl 
	     << "not_at_bol: " << n2 << endl;
	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
#include => matched ^"#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched ^"#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
#include => matched ^"#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
at_bol: 3
not_at_bol: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>
			<<case "rule-bol-sc-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 1
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &as, int &bs%}
%actual-param%{ as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	as += 2; cout << yytext << " => matched `^a\'" << endl;
a	++as; cout << yytext << " => matched `a\'" << endl;
^b	bs += 2; cout << yytext << " => matched `^b\'" << endl;
b	++bs; cout << yytext << " => matched `b\'" << endl;

.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abc		2	1
actual bonus	5	2
beta		6	4
beattles	7	6
business man	8	8
blog address	9	10
as useful tool	11	10

				<</textfile>>
				<<textfile "result.out">>
a => matched `^a'
b => matched `b'
a => matched `^a'
a => matched `a'
b => matched `b'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
a => matched `^a'
a's: 11
b's: 10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>
			<<case "rule-bol-sc-2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 2
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &as, int &bs%}
%actual-param%{ as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	as += 2; cout << yytext << " => matched `^a\'" << endl;
a	++as; cout << yytext << " => matched `a\'" << endl;
b	++bs; cout << yytext << " => matched `b\'" << endl;
^bb	bs += 4; cout << yytext << " => matched `^bb\'" << endl;

.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
bbcc...aaa	3	4
aa		6	4
bbbbbb		6	12
cccaacccc	8	12
aaaaaaaa	17	12
...bbcbbb	17	17
ccaaa		20	17
aaax		24	17
xaaa		27	17
...aa		29	17
bbabjjabaa	33	23
bababa		36	26
a......aa	40	26
aa		43	26
aaabbb		47	29
				<</textfile>>
				<<textfile "result.out">>
bb => matched `^bb'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
bb => matched `^bb'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
bb => matched `^bb'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
a's: 47
b's: 29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>
			<<case "rule-bol-sc-3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &bs, int &cs, int &ds, int &es, int &fs, int &gs%}
%actual-param%{ as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>

a|b		if(yytext[0] == 'a') {

			++as;
			yy_push_state(asc);
		}
		else {
			++bs;
			yy_push_state(bsc);
		}
<*>[cd]		switch(yytext[0]) {
		case 'c': cs += 2; break;
		default:  ds += 2; break;
		}
<asc,bsc>[abce]	switch(yytext[0]) {
		case 'a': as += 3; break;
		case 'b': bs += 3; break;
		case 'c': cs += 3; break;
		default:  es += 3; break;
		}
<asc>f		fs += 4;
<bsc>[fg]	if(yytext[0] == 'f')
			fs += 5;
		else
			gs += 5;
<asc>aa		yy_pop_state(); as += 6;
<bsc>bb		yy_pop_state(); bs += 6;
<*>.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4, n5, n6, n7);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl
	     << "c's: " << n3 << endl
	     << "d's: " << n4 << endl
	     << "e's: " << n5 << endl
	     << "f's: " << n6 << endl
	     << "g's: " << n7 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			7	0	0	0	0	0	0
a			8	0	0	0	0	0	0
	ggggg		8	0	0	0	0	0	0
	cccc		8	0	8	0	0	0	0
	ddddd		8	0	8	10	0	0	0
	fffff		8	0	8	10	0	20	0
aa			14	0	8	10	0	20	0
a			15	0	8	10	0	20	0
aa			21	0	8	10	0	20	0
a			22	0	8	10	0	20	0
	bbbbbbb		22	21	8	10	0	20	0
	ddddddddd	22	21	8	28	0	20	0
	ee		22	21	8	28	6	20	0
aa			28	21	8	28	6	20	0
a			29	21	8	28	6	20	0
aa			35	21	8	28	6	20	0
a			36	21	8	28	6	20	0
aa			42	21	8	28	6	20	0
b			42	22	8	28	6	20	0
bb			42	28	8	28	6	20	0
b			42	29	8	28	6	20	0
bb			42	35	8	28	6	20	0
b			42	36	8	28	6	20	0
bb			42	42	8	28	6	20	0
b			42	43	8	28	6	20	0
bb			42	49	8	28	6	20	0
b			42	50	8	28	6	20	0
bb			42	56	8	28	6	20	0
b			42	57	8	28	6	20	0
	ggggg..........	42	57	8	28	6	20	25
	g		42	57	8	28	6	20	30
	a		45	57	8	28	6	20	30
	ddddddd		45	57	8	42	6	20	30
	eeeee		45	57	8	42	21	20	30
	f		45	57	8	42	21	25	30
	eeeeeeeee	45	57	8	42	48	25	30
	ffff		45	57	8	42	48	45	30
	aaaaaaa		66	57	8	42	48	45	30
bb			66	63	8	42	48	45	30
b			66	64	8	42	48	45	30
bb			66	70	8	42	48	45	30
b			66	71	8	42	48	45	30
	cccccccc	66	71	24	42	48	45	30
	ddddd....	66	71	24	52	48	45	30
bb			66	77	24	52	48	45	30
a			67	77	24	52	48	45	30
	a		70	77	24	52	48	45	30
	cccc		70	77	32	52	48	45	30
	ddddd		70	77	32	62	48	45	30
	ffffff		70	77	32	62	48	69	30
	gggggg		70	77	32	62	48	69	30
	ddddd		70	77	32	72	48	69	30
	e		70	77	32	72	51	69	30
	ffggggg		70	77	32	72	51	77	30
	ee		70	77	32	72	57	77	30
	b		70	80	32	72	57	77	30
	dddd		70	80	32	80	57	77	30
	eeee		70	80	32	80	69	77	30
				<</textfile>>
				<<textfile "result.out">>
a's: 70
b's: 80
c's: 32
d's: 80
e's: 69
f's: 77
g's: 30
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>
			<<case "rule-bol-sc-4" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 4
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &bs, int &cs, int &ds, int &es, int &fs, int &gs%}
%actual-param%{ as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc

					<</declare_section>>
					<<lex_section>>

\{|\[		switch(yytext[0]) {
		case '{': BEGIN(asc); break;
		default:  BEGIN(bsc); break;
		}
<asc>^[abcdefg]	switch(yytext[0]) {
		case 'a': --as; break;
		case 'b': --bs; break;
		case 'c': --cs; break;
		case 'd': --ds; break;
		case 'e': --es; break;
		case 'f': --fs; break;
		default:  --gs; break;
		}

<asc>[abcdefg]	switch(yytext[0]) {
		case 'a': ++as; break;
		case 'b': ++bs; break;
		case 'c': ++cs; break;
		case 'd': ++ds; break;
		case 'e': ++es; break;
		case 'f': ++fs; break;
		default:  ++gs; break;
		}

<bsc>^[abcdefg]	switch(yytext[0]) {
		case 'a': as -= 2; break;
		case 'b': bs -= 2; break;
		case 'c': cs -= 2; break;
		case 'd': ds -= 2; break;
		case 'e': es -= 2; break;
		case 'f': fs -= 2; break;
		default:  gs -= 2; break;
		}
<bsc>[abcdefg]	switch(yytext[0]) {
		case 'a': as += 2; break;
		case 'b': bs += 2; break;
		case 'c': cs += 2; break;
		case 'd': ds += 2; break;
		case 'e': es += 2; break;
		case 'f': fs += 2; break;
		default:  gs += 2; break;
		}
<asc>\}		BEGIN(INITIAL);
<bsc>\]		BEGIN(INITIAL);

<*>^[abcdefg]	switch(yytext[0]) {
		case 'a': as -= 3; break;
		case 'b': bs -= 3; break;
		case 'c': cs -= 3; break;
		case 'd': ds -= 3; break;
		case 'e': es -= 3; break;
		case 'f': fs -= 3; break;
		default:  gs -= 3; break;
		}
<*>[abcdefg]	switch(yytext[0]) {
		case 'a': as += 3; break;
		case 'b': bs += 3; break;
		case 'c': cs += 3; break;
		case 'd': ds += 3; break;
		case 'e': es += 3; break;
		case 'f': fs += 3; break;
		default:  gs += 3; break;
		}

^[abcdefg]	switch(yytext[0]) {
		case 'a': as -= 1000; break;
		case 'b': bs -= 1000; break;
		case 'c': cs -= 1000; break;
		case 'd': ds -= 1000; break;
		case 'e': es -= 1000; break;
		case 'f': fs -= 1000; break;
		default:  gs -= 1000; break;
		}
[abcdefg]	switch(yytext[0]) {
		case 'a': as += 1000; break;
		case 'b': bs += 1000; break;
		case 'c': cs += 1000; break;
		case 'd': ds += 1000; break;
		case 'e': es += 1000; break;
		case 'f': fs += 1000; break;
		default:  gs += 1000; break;
		}
<*>.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4, n5, n6, n7);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl
	     << "c's: " << n3 << endl
	     << "d's: " << n4 << endl
	     << "e's: " << n5 << endl
	     << "f's: " << n6 << endl
	     << "g's: " << n7 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			1	0	0	0	0	0	0
a			0	0	0	0	0	0	0
	ggggg		0	0	0	0	0	0	5
cccc			0	0	2	0	0	0	5
	ddddd		0	0	2	5	0	0	5
	fffff		0	0	2	5	0	5	5
aa			0	0	2	5	0	5	5
a	aaa		2	0	2	5	0	5	5
aa	aaa		5	0	2	5	0	5	5
aa			5	0	2	5	0	5	5
bbb	bbb		5	4	2	5	0	5	5
ddd	dddd		5	4	2	10	0	5	5
ee	ee		5	4	2	10	2	5	5
aa	a		6	4	2	10	2	5	5
a			5	4	2	10	2	5	5
aa	aaa		8	4	2	10	2	5	5
a	a		8	4	2	10	2	5	5
}
[
aa			8	4	2	10	2	5	5
b			8	2	2	10	2	5	5
bb			8	2	2	10	2	5	5
b			8	0	2	10	2	5	5
bb			8	0	2	10	2	5	5
b			8	-2	2	10	2	5	5
bb			8	-2	2	10	2	5	5
b			8	-4	2	10	2	5	5
bb			8	-4	2	10	2	5	5
b			8	-6	2	10	2	5	5
bb			8	-6	2	10	2	5	5
b			8	-8	2	10	2	5	5
	ggggg..........	8	-8	2	10	2	5	15		
	a		10	-8	2	10	2	5	15
a			8	-8	2	16	2	5	15
	ddd		8	-8	2	16	2	5	15
	eeeee		8	-8	2	16	12	5	15
	f		8	-8	2	16	12	7	15
	ee		8	-8	2	16	16	7	15
	ffff		8	-8	2	16	16	15	15
	aaaaaaa		22	-8	2	16	16	15	15
bb			22	-8	2	16	16	15	15
b			22	-10	2	16	16	15	15
bb			22	-10	2	16	16	15	15
b			22	-12	2	16	16	15	15
	cccccccc	22	-12	18	16	16	15	15
	ddddd....	22	-12	18	26	16	15	15
bb			22	-12	18	26	16	15	15
a			20	-12	18	26	16	15	15
	a		22	-12	18	26	16	15	15
	cccc		22	-12	26	26	16	15	15
	ddddd		22	-12	26	36	16	15	15
	ffffff		22	-12	26	36	16	27	15
	ggg		22	-12	26	36	16	27	21
	ddddd		22	-12	26	46	16	27	21
	e		22	-12	26	46	18	27	21
	ffggggg		22	-12	26	46	18	31	31
	ee		22	-12	26	46	22	31	31
	b		22	-10	26	46	22	31	31
	dddd		22	-10	26	54	22	31	31
	eeee		22	-10	26	54	30	31	31
]

	eeeeeeeeee	22	-10	26	54	60	31	31
	eeeeeeeeee	22	-10	26	54	90	31	31
	eeeeeeeeee	22	-10	26	54	120	31	31
b			22	-13	26	54	120	31	31
b			22	-16	26	54	120	31	31
b			22	-19	26	54	120	31	31
b			22	-22	26	54	120	31	31
b			22	-25	26	54	120	31	31
b			22	-28	26	54	120	31	31
bgggggggggggggggggggg	22	-31	26	54	120	31	91
bgggggggggggggggggggg	22	-34	26	54	120	31	151
bgggggggggggggggggggg	22	-37	26	54	120	31	211
				<</textfile>>
				<<textfile "result.out">>
a's: 22
b's: -37
c's: 26
d's: 54
e's: 120
f's: 31
g's: 211
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>

<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>
			<<case "rule-eof-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE <<EOF>>
*/
					<</desc>>
					<<init_code>>
int current_sc = 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &bs, int &cs, int &eofs%}
%actual-param%{ as, bs, cs, eofs %}

%x	asc
%s	bsc
%x	csc

					<</declare_section>>
					<<lex_section>>
<*><<EOF>>		++eofs;
a			BEGIN(asc); current_sc = 1;
b			BEGIN(bsc); current_sc = 2;
c			BEGIN(csc); current_sc = 3;
<asc,bsc,csc>[abc]	switch(yytext[0]) {
			case 'a':
				if(current_sc == 1) {
					BEGIN(INITIAL);
					current_sc = 0;
				}
				else
					as += 2;
				break;
			case 'b':
				if(current_sc == 2) {
					BEGIN(INITIAL);
					current_sc = 0;
				}
				else
					bs += 2;
				break;
			default: 
				if(current_sc == 3) {
					BEGIN(INITIAL);
					current_sc = 0;
				}
				else
					cs += 2;
				break;
			}
			
<*>.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, eofs = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, eofs);
	cout << "a's: " << n1 << endl
	     << "b's: " << n2 << endl
	     << "c's: " << n3 << endl
	     << "eof's: " << eofs << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
abba	 0 2 0
accca    0 2 3
baaaaaab 6 2 3
cbbbc    6 5 3
bccb     6 5 5
baaaab   105 5
accca    105 8
cccbbbbc 109 8
bccb     10910
aba      101010
				<</textfile>>
				<<textfile "result.out">>
a's: 20
b's: 20
c's: 20
eof's: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>
			<<case "rule-eol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE $
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &lines%}
%actual-param%{ lines %}
					<</declare_section>>
					<<lex_section>>
\.$	++lines;
.|\n

					<</lex_section>>
					<<before_init>>
	int n1 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1);
	cout << "lines: " << n1 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
In the time since the 1986 edition of this book, the world of compiler design
has changed significantly. Programming languages have evolved to present new
compilation problems. Computer architectures offer a variety of resources of
which the compiler designer must take advantage. Perhaps most interestingly,
the venerable technology of code optimization has found use outside compilers.
It is now used in tools that find bugs in software, and most importantly, find		1
security holes in existing code. And much of the "front-end" technology -
grammars, regular expressions, parsers, and syntax-directed translators - are
still in wide use.
Thus, our philosophy from previous versions of the book has not changed.
We recognize that few readers will build, or even maintain, a compiler for a		2/3
major programming language. Yet the models, theory, and algorithms associated
with a compiler can be applied to a wide range of problems in software
design and software development . We therefore emphasize problems that are
most commonly encountered in designing a language processor, regardless of
the source language or target machine.
Use of the Book										4
It takes at least two quarters or even two semesters to cover all or most of the
material in this book. It is common to cover the first half in an undergraduate
course and the second half of the book - stressing code optimization - in
a second course at the graduate or mezzanine level. Here is an outline of the
chapters:
Chapter 1 contains motivational material and also presents some background
issues in computer architecture and programming-language principles.
Chapter 2 develops a miniature compiler and introduces many of the important		5
concepts, which are then developed in later chapters. The compiler itself
appears in the appendix.
Chapter 3 covers lexical analysis, regular expressions, finite-state machines, and	6
scanner-generator tools. This material is fundamental to text-processing of all
sorts.
											7
Chapter 4 covers the major parsing methods, top-down (recursive-descent , LL)
and bottom-up (LR and its variant s) .
Chapter 5 introduces the principal ideas in syntax-directed definitions and		8
syntax-directed translations.
Chapter 6 takes the theory of Chapter 5 and shows how to use it to generate		9
intermediate code for a typical programming language.
Chapter 7 covers run-time environment s, especially management of the run-time		10
stack and garbage collection.
Chapter 8 is on object-code generation. It covers construction of basic blocks,		11
generation of code from expressions and basic blocks, and register-allocation
techniques.
Chapter 9 introduces the technology of code optimization, including flow graphs,	12
data-flow frameworks, and iterative algorithms for solving these fr ameworks .
Chapter 10 covers instruction-level optimization. The emphasis is on the extraction	13
of parallelism from small sequences of instructions and scheduling them
on single processors that can do more than one thing at once.
Chapter 11 talks about larger-scale parallelism detection and exploitation. Here,	14
the emphasis is on numeric codes that have many tight loops that range over
multidimensional arrays.
Chapter 12 is on interprocedural analysis. It covers pointer analy sis, aliasing,	15
and data-flow analysis that takes into account the sequence of procedure calls
that reach a given point in the code.
Courses fr om material in this book have been taught at Columbia, Harvard,		16
and Stanford. At Columbia, a senior/first-year graduate course on programming
languages and translators has been regularly offered using material fr om
the first eight chapters. A highlight of this course is a semester-long project
in which students work in small teams to create and implement a little language
of their own design. The student-created languages have covered diverse
application domains including quantum computation, music synthesis, computer
graphics, gaming, matrix operations and many other areas. Students use
compiler-comp onent generators such as ANTLR, Lex, and Yacc and the syntaxdirected
translation techniques discussed in chapters two and five to build their
compilers. A follow-on graduate course has fo cused on material in Chapters 9
through 12, emphasizing code generation and optimization for contemporary
machines including network processors and multiprocessor architectures.
At Stanford, a one-quarter introductory course covers roughly the material		17
in Chapters 1 through 8, although there is an introduction to global code
optimization fr om Chapter 9. The second compiler course covers Chapters 9
through 12, plus the more advanced material on garbage collection from Chapter
7. Students use a locally developed , Java- based system called Joeq for
implementing data-flow analysis algorithms.
											18
The reader should possess some "computer-science sophistication," including
at least a second course on programming, and courses in data structures and
discrete mathematics. Knowledge of several different programming languages
is useful.
Exercises										19
The book contains extensive exercises, with some for almost every section. We
indicate harder exercises or parts of exercises with an exclamation point. The
hardest exercises have a double exclamation point.
Gradiance. On-Line Homeworks								20
A feature of the new edition is that there is an accompanying set of on-line
homeworks using a technology developed by Gradiance Corp. Instructors may
assign these homeworks to their class, or students not enrolled in a class may
enroll in an "omnibus class" that allows them to do the homeworks as a tutorial
(without an instructor-created class) . Gradiance questions look like ordinary
questions, but your solutions are sampled. If you make an incorrect choice you
are given specific advice or feedback to help you correct your solution. If your
instructor permits, you are allowed to try again, until you get a perfect score.
A subscription to the Gradiance service is offered with all new copies of this		21
text sold in North America. For more information, visit the Addison-Wesley
web site www . aw . com/gradiance or send email tocomput ing@aw . com.
Support on the World Wide Web								22
The book's home page is
dragonbook . stanford . edu
Here, you will find errata as we learn of them, and backup materials. We hope
to make available the notes for each offering of compiler-related courses as we
teach them, including homeworks, solutions, and exams. We also plan to post
descriptions of important compilers written by their implementers.
											23
				<</textfile>>
				<<textfile "result.out">>
lines: 23
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>
			<<case "rule-mcall-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: macro call
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
dec	[0-9]
hex	[0-9A-Fa-f]
sign	[\+\-]

%formal-param%{ int &decs, int &hexes, int &signs%}
%actual-param%{ decs, hexes, signs%}

					<</declare_section>>
					<<lex_section>>
{dec}+			++decs;	cout << yytext << " [dec]" << endl;
{hex}+			++hexes; cout << yytext << " [hex]" << endl;
{sign}?({dec}+|{hex}+)	++signs; cout << yytext << " [sign]" << endl;
.|\n
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << "dec's: " << n1 << endl
	     << "hex's: " << n2 << endl
	     << "sign's: " << n3 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
b7809
+-45fb
date: 1999.12.31
date: 2010.01.01
time: 23:59:59
time: 01:00:00
money: $999,999.99
phone: 0086-010-12345678
zip-code: 100233
sample text1
.0000-9990*&*$*&@%&ghf892efs
hello world on the earth
hi world in the universe
no more sample

				<</textfile>>
				<<textfile "result.out">>
b7809 [hex]
-45fb [sign]
da [hex]
e [hex]
1999 [dec]
12 [dec]
31 [dec]
da [hex]
e [hex]
2010 [dec]
01 [dec]
01 [dec]
e [hex]
23 [dec]
59 [dec]
59 [dec]
e [hex]
01 [dec]
00 [dec]
00 [dec]
e [hex]
999 [dec]
999 [dec]
99 [dec]
e [hex]
0086 [dec]
-010 [sign]
-12345678 [sign]
-c [sign]
de [hex]
100233 [dec]
a [hex]
e [hex]
e [hex]
1 [dec]
0000 [dec]
-9990 [sign]
f892ef [hex]
e [hex]
d [hex]
e [hex]
ea [hex]
d [hex]
e [hex]
e [hex]
e [hex]
e [hex]
a [hex]
e [hex]
dec's: 19
hex's: 25
sign's: 5
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>
			<<case "rule-multipattern-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: multi REs share same action
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &goods, int &bads%}
%actual-param%{ goods, bads %}
					<</declare_section>>
					<<lex_section>>
"good"		|
"great"		|
"terrific"	|
"nice"		|
"awesome"	{
		++goods;
	}

"horrible"	|
"terrible"	|
"nightmare"	|
"disastrous"	{
		++bads;
	}
.|\n
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2);
	cout << "good-words: " << n1 << endl
	     << "bad-words: " << n2 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
<--- XDICT英汉辞典 --->
good
[gud]
n. 善行,好处,利益
a. 好的,优良的,上等的,愉快的,有益的,好心的,慈善的
<--- 朗道英漢字典5.0 --->
good
*[gud]
n. 善行, 好處, 利益
a. 好的, 優良的, 上等的, 愉快的, 有益的, 好心的, 慈善的, 虔誠的
【經】 貨物; 好的
相關詞組:
  for good
  for good or for evil
  good and
  good for
  hold good for
  in good time
  make good
  to the good
  good-bye
  say good-bye to sb
  as good as
<--- stardict1.3英汉辞典 --->
good
[gud]
n. 善行,好处;
a. 好的,优良的,上等的;
<--- 牛津現代英漢雙解詞典 --->
good
/ gUd; ^Jd/ adj (better / 5betE(r); `bZtL/, best /best; bZst/)  1 of high quality; of an acceptable standard; satisfactory 好的; 優質的; 符合標準的; 令人滿意的: a good lecture, performance, harvest 好的演講、 表演、 收成 * good pronunciation, behaviour, eyesight 好的發音、 行為、 視力 * a good (eg sharp) knife 快的刀 * Is the light good enough to take photographs? 光線適合照相嗎? * The car has very good brakes. 這輛汽車的剎車很靈. * Her English is very good. 她的英語很好.  2 (a) ~ (at sth) (often used with names of occupations or with ns derived from vs 常與職業名稱或動詞派生的名詞連用) able to perform satisfactorily; competent 表現令人滿意的; 有能力的: a good teacher, hairdresser, poet, etc 優秀的教師、 理發師、 詩人等 * good at mathematics, languages, describing things 擅長數學、 語言、 敘事 * a good loser, ie one who doesn't complain when he loses 輸得起的人. (b) [pred 作表語] ~ with sth/sb capable when using, dealing with, etc sth/sb 善於使用某物、 處事、 待人或用人: good with one's hands, eg able to draw, make things, etc 手巧（如會畫、 會做東西等） * He's very good with children, ie can look after them well, amuse them, etc. 他很會照看孩子.  3 (a) morally acceptable; virtuous 有道德的; 高尚的: a good deed 合乎道德的行為 * try to lead a good life 努力過高尚的生活. (b) (esp of a child) well-behaved （尤指兒童）守規矩的, 乖的: Try to be a good girl. 要做個乖女孩.  4 ~ (to sb) willing to help others; kind 樂於助人的; 好心的; 仁慈的: You were a good girl to help in the shop. 你幫店裡幹活兒, 是個好姑娘. * He was very good to me when I was ill. 我生病時他幫了我的大忙. * Would you be good enough to carry this for me? 勞駕給我拿著這個行嗎?  5 pleasant; agreeable; welcome 快樂的; 愉快的; 隨和的; 令人喜悅的: The firm has had good times and bad times. 這公司經歷過順境和逆境. * What good weather we're having! 天氣多好哇! * Have you heard the good news about my award? 你聽到我獲獎的好消息了嗎? * It's good to be home again. 重返家園, 令人快慰.  6 (of food) fit to be eaten; not yet rotting or rotten （指食物）適合食用的, 未腐敗的: good eggs, fruit, etc 新鮮的雞蛋、 水果等 * Separate the good meat from the bad. 把鮮肉和腐肉分開.  7 [usu attrib 通常作定語] not diseased; healthy; strong 無病的; 健康的; 強健的: good teeth and bones 健康的牙齒和骨骼 * Would you speak into my good ear, I can't hear in the other one. 請對著我這只沒毛病的耳朵說, 那只耳朵聽不見.  8 (of money) not fake or false; genuine （指錢）非偽造的, 真的: This note is counterfeit, but that one's good. 這張鈔票是假的, 那張是真的. * (fig 比喻) I gave good money for that camera, and it turned out to be worthless. 我買那架照相機可真花了一大筆錢, 結果卻不能用.  9 [attrib 作定語] (of clothes, etc) used only for more formal or important occasions （指衣服等）僅用於莊重的或重要的場合的: My one good suit is at the cleaner's. 我那套講究的衣服還在洗衣店裡呢. * Wear your good clothes to go to church. 要穿上像樣的衣服去做禮拜.  10 [attrib 作定語] thorough; complete; sound 徹底的; 完全的; 著實的: give sb a good beating, scolding, telling-off, etc 給某人一頓痛打、 痛罵、 痛斥等 * go for a good long walk 好好地散散步 * We had a good laugh at that. 那件事情叫我們笑個痛快.  11 [usu attrib 通常作定語] amusing 有趣的; 好玩的: a good story, joke, etc 有趣的故事、 笑話等 * `That's a good one!' she said, laughing loudly. ‵這個真有意思!′她大笑著說.  12 ~ (for sb/sth) beneficial; wholesome 有益的; 有益健康的: the good (ie clean, refreshing) mountain air 山中清新的空氣 * Is this kind of food good for me? 這種食物對我身體有益嗎? * Sunshine is good for your plants. 你的花草要多曬太陽. * This cream is good for (ie soothes and heals) burns. 這種油膏治燒傷和燙傷很管事兒.  13 ~ (for sth/to do sth) suitable; appropriate 適合的; 相宜的: a good time for buying a house/to buy a house 買房子的適當時機 * This beach is good for swimming but bad for surfing. 這個海濱適於遊泳而不適於沖浪. * She would be good for the job. 她做這工作很合適.  14 ~ for sth (a) (of a person or his credit) such that he will be able to repay (a sum lent) （指人或其信貸）有償還（借款）能力的: He/His credit is good for 5000. 他[憑他信用]可獲貸款5000英鎊. (b) having the necessary energy, fitness, durability, etc 有必要的精力、 健康條件、 忍耐力等的: You're good for (ie will live) a few years yet. 你還能活幾年呢. * This car's good for many more miles. 這輛汽車還能行駛很多英裡. (c) valid for sth 有效的: The return half of the ticket is good for three months. 回程票三個月內有效.  15 (used in greetings 用於問候): Good morning/afternoon/evening! 你好!  16 (fml 文) (used as a polite, but more often patronizing, form of address or description 用作敬稱或客氣的描述, 但多含屈尊俯就之意): my good sir, man, friend, etc 我的好先生、 好人、 好朋友等 * How is your good lady (ie your wife) ? 尊夫人好嗎?  17 [attrib 作定語] (used as a form of praise 用作讚語): Good old Fred! 忠厚的弗雷德! * Good man! That's just what I wanted. 好心人! 那正是我想要的.  18 [attrib 作定語] (used in exclamations 用於感嘆句): Good Heavens! 天哪! * Good God! 上帝呀!  19 (with a與a連用) [attrib 作定語] (a) great in number, quantity, etc （數目、 數量等）很大的, 很多的: a good many people 很多人 * We've come a good (ie long) way/distance. 我們是遠道而來的. (b) (used with expressions of measurement, quantity, etc 與表示量度、 數量等的短語連用) not less than; rather more than 不少於; 稍多於: We waited for a good hour. 我們足足等了一小時. * It's a good three miles to the station. 離車站至少三英裡. * She ate a good half of the cake. 那個蛋糕她整整吃了一半.  20 (idm 習語) as good as almost; practically 幾乎; 實際上: He as good as said I'm a liar, ie suggested that I was a liar without actually using the word `liar'. 他無異於說我撒謊（只是未用‵撒謊′一詞罷了. * The matter is as good as settled. 這事等於解決了. good and... (infml 口) completely 完全; 徹底: I won't go until I'm good and ready. 我完全準備好了才去. a good `few a considerable number (of); several 相當多（的）; 幾個: `How many came?' `A good few.' ‵來了多少?′‵很不少.′ * There are still a good few empty seats. 還有好幾個空位子. ,good for `sb, `you, `them, etc (infml 口) (used when congratulating sb 用以祝賀某人) sb, etc did well 某人幹得好: She passed the exam? Good for her! 她考試及格了? 真行! (For other idioms containing good, see entries for other major words in each idiom 查閱其他含有good一詞的習語, 見該習語中含有其他主要詞的詞條, 如 (as) good as gold => gold; in good time => time1.)

adv (US infml 口) well 好好地: Now, you listen to me good! 喂, 你好好聽我說!

/ gUd; ^Jd/ n  1 [U] that which is morally right or acceptable 有道德的事; 善: the difference between good and evil 善惡之分 * Is religion always a force for good? 宗教一向是誨人從善的力量嗎?  2 [U] that which gives benefit, profit, advantage, etc 好處、 利益、 益處等: work for the good of one's country 為國家利益工作 * I'm giving you this advice for your own good. 我勸你是為你好. * Do social workers do a lot of good? 社會工作者的貢獻大嗎? Cf 參看 do-gooder (do1).  3 the good [pl v] virtuous people 高尚的人: a gathering of the good and the great 賢人偉人薈萃.  4 (idm 習語) be no/not much/any/some `good (doing sth) be of no, not much, etc value 沒有、 沒什麼...好處: It's no good (my) talking to him. （我）同他談沒有用. * Was his advice ever any good? 他的建議有什麼價值嗎? * This gadget isn't much good. 這小機械沒什麼用處. * What good is it asking her? 問她有什麼好處? do (sb) `good benefit sb 有益於（某人）: Eat more fruit: it will do you good. 多吃水果, 對你有好處. * This cough medicine tastes nice but it doesn't do much good, ie isn't very effective. 這咳嗽藥不難吃, 但作用不大. * (usu ironic 通常作反語) Much good may it do you, ie You won't get much benefit from it. 但願對你大有好處（其實對你沒什麼好處）. for `good (and `all) permanently; finally 永久; 永遠; 決定性地: She says that she's leaving the country for good, ie intending never to return to it. 她說她要永遠離開這個國家. to the `good (used to describe sb's financial state) in credit （用以記述某人的財務狀況）盈余: We are 500 to the good, ie We have 500 more than we had. 我們盈余500英鎊. up to no `good (infml 口) doing sth wrong, mischievous, etc 做壞事; 淘氣; 惡作劇: Where's that naughty child now? I'm sure he'll be up to no good wherever he is. 那調皮孩子哪兒去了? 我看, 他到哪兒也做不出好事來.
<--- WordNet --->
good
good
     adj 1: having desirable or positive qualities especially those
            suitable for a thing specified; "good news from the
            hospital"; "a good report card"; "when she was good
            she was very very good"; "a good knife is one good for
            cutting"; "this stump will make a good picnic table";
            "a good check"; "a good joke"; "a good exterior
            paint"; "a good secretary"; "a good dress for the
            office" [ant: {bad}]
     2: having the normally expected amount; "gives full measure";
        "gives good measure"; "a good mile from here" [syn: {full}]
     3: morally admirable [ant: {evil}]
     4: deserving of esteem and respect; "all respectable companies
        give guarantees"; "ruined the family's good name" [syn: {estimable},
         {honorable}, {respectable}]
     5: promoting or enhancing well-being; "an arms limitation
        agreement beneficial to all countries"; "the beneficial
        effects of a temperate climate"; "the experience was good
        for her" [syn: {beneficial}]
     6: superior to the average; "in fine spirits"; "a fine
        student"; "made good grades"; "morale was good"; "had good
        weather for the parade" [syn: {fine}]
     7: agreeable or pleasing; "we all had a good time"; "good
        manners"
     8: of moral excellence; "a genuinely good person"; "a just
        cause"; "an upright and respectable man"; "the life of the
        nation is secure only while the nation is honest,
        truthful, and virtuous"- Frederick Douglass [syn: {just},
        {upright}, {virtuous}]
     9: having or showing knowledge and skill and aptitude; "adept
        in handicrafts"; "an adept juggler"; "an expert job"; "a
        good mechanic"; "a practiced marksman"; "a proficient
        engineer"; "a lesser-known but no less skillful composer";
        "the effect was achieved by skillful retouching" [syn: {adept},
         {expert}, {practiced}, {proficient}, {skillful}, {skilful}]
     10: thorough; "had a good workout"; "gave the house a good
         cleaning"
     11: with or in a close or intimate relationship; "a good
         friend"; "my sisters and brothers are near and dear"
         [syn: {dear}, {near}]
     12: having or showing or arising from a desire to promote the
         welfare or happiness of others; "his benevolent smile";
         "a benevolent nature" [syn: {benevolent}] [ant: {malevolent}]
     13: financially sound; "a good investment"; "a secure
         investment" [syn: {dependable}, {safe}, {secure}]
     14: most suitable or right for a particular purpose; "a good
         time to plant tomatoes"; "the right time to act"; "the
         time is ripe for great sociological changes" [syn: {right},
          {ripe}]
     15: resulting favorably; "its a good thing that I wasn't there";
         "it is good that you stayed"; "it is well that no one saw
         you"; "all's well that ends well" [syn: {well(p)}]
     16: exerting force or influence; "the law is effective
         immediately"; "a warranty good for two years"; "the law
         is already in effect (or in force)" [syn: {effective}, {in
         effect(p)}, {in force(p)}]
     17: feeling healthy and free of aches and pains; "I feel good"
         [syn: {good(p)}]
     18: capable of pleasing; "good looks"
     19: appealing to the mind; "good music"; "a serious book" [syn:
         {serious}]
     20: in excellent physical condition; "good teeth"; "I still have
         one good leg"; "a sound mind in a sound body" [syn: {sound}]
     21: tending to promote physical well-being; beneficial to
         health; "beneficial effects of a balanced diet"; "a good
         night's sleep"; "the salutary influence of pure air"
         [syn: {beneficial}, {salutary}]
     22: not forged; "a good dollar bill"
     23: not left to spoil; "the meat is still good" [syn: {unspoiled},
          {unspoilt}]
     24: generally admired; "good taste"
     [also: {better}, {best}]

good
     n 1: benefit; "for your own good"; "what's the good of worrying?"
     2: moral excellence or admirableness; "there is much good to be
        found in people" [syn: {goodness}] [ant: {evil}, {evil}]
     3: that which is good or valuable or useful; "weigh the good
        against the bad"; "among the highest goods of all are
        happiness and self-realization" [syn: {goodness}] [ant: {bad},
         {bad}]
     [also: {better}, {best}]

good
     adv 1: (often used as a combining form) in a good or proper or
            satisfactory manner or to a high standard (`good' is a
            nonstandard dialectal variant for `well'); "the
            children behaved well"; "a task well done"; "the party
            went well"; "he slept well"; "a well-argued thesis";
            "a well-planned party"; "the baby can walk pretty
            good" [syn: {well}] [ant: {ill}]
     2: in a complete and thorough manner (`good' is sometimes used
        informally for `thoroughly'); "he was soundly defeated";
        "we beat him good" [syn: {thoroughly}, {soundly}]
     [also: {better}, {best}]
<--- CDICT5英漢辭典 --->
good
[gUd;ɡud]
< good >
[基本字彙]
((縮)) gd., G, G.
<<形容詞>>
bet.ter, best
1 好的
  a good experience 一個好的經驗
  good news from the hospital 來自醫院的好消息
2 a. 上等的
     a good exterior paint 上等的油漆
     a good joke 上乘的笑話
  b. 符合理想的; 適合的
     Is this a good dress for the party? 這件衣服適合這個宴會嗎?
3 a. 未腐壞的
     The milk is still good. 牛奶還沒有壞掉
  b. 情況極好的; 健全的
     a good tooth 健康的牙齒
4 a. 優秀的
     a good student 優秀的學生
  b. (指美國政府) 肉類分級的其中一級 (介於標準級與精選級之間)
5 a. (品質) 優良的
     a good books 好書
  b. 辨識力佳的
     good taste 好的鑑賞力
6 值得尊敬的; 尊貴的
  ruined the family's good name 破壞家族尊貴的名聲
7 吸引人的; 俊美的
  good looks 姣好的面貌
8 有益健康的
  a good night's rest 有益健康的夜間休息
9 能勝任的; 老練的
  a good machinist 技術老練的機械師
10 完整的; 徹底的
   a good workout 完整的測驗
11 a. 可信賴的
     a good investment 一項可信賴的投資
   b. 正當的
     a good reason 正當的理由
   c. 真品的; 真正的
     a good dollar bill 真正的一元鈔票
12 a. 有效力的
     a warranty good for two years 二年有效的保證
     a driver's license that is still good 依然有效的駕駛執照
   b. 可以繼續的
     I'm good for another round of golf. 我還可以再打一場高爾夫球
13 a. 有能力付的; 付得起的
     Is she good for the money that you lent her? 她還得起你借給她的錢嗎?
   b. 能引人…的
     He is always good for a laugh. 他總能引人發笑
14 a. 充足的; 很多的
     a good income 收入相當不錯
   b. 豐富的
     a good table 豐盛的一餐
15 充分的
   It is a good mile from here. 從這裡去足足有一英哩的路程
16 a. 快樂的; 愉快的
     had a good time at the party 在舞會上玩得很愉快
   b. 適合的; 方便的
     good weather 合適的天氣
     a good omen 一個好的預兆
17 a. 品行端正的; 正直的
     a good person 正直的人
   b. 善良的; 仁慈的
     a good soul 善良的人
     a good heart 慈悲心腸
   c. 忠誠的; 忠實的
     a good Republican 忠誠的共和黨黨員
18 a. 行為良好的; 守規矩的
     a good child 守規矩的小孩
   b. 有禮貌的; 合宜的
     good manners 合宜的舉止
19『運動』場內球
   The first serve was wide, but the second was good. 第一球發得太遠了, 第二球就發得剛好
20 (用於感嘆句, 表示驚訝、驚愕)
   Good heavens! 老天啊!
   Good grief! 真可悲啊!
<<名詞>>
1 a. 好東西
  b. 長處; 優點
2 福利; 利益
  for the common good 為了大眾的利益
3 善; 善良; 美德
  There is much good to be found in people. 在人們身上可以找到很多的美德
4 (常作 goods)
  a. 商品; 貨品
     frozen goods 冷凍食品
  b. 財產; 動產
  c. (與單數或複數動詞連用) 布料
5 (常作 goods)
  ((俚語)) 罪證
  tried to get the goods on the crook 設法得到犯罪者的罪證
<<副詞>>
((口語)) 順利地; 好地
<<慣用語>>
as good as
和…一樣; 幾乎等於
as good as new  幾乎和新的一樣
for good
永遠地; 永久地
I'm moving to Europe for good. 我要搬到歐洲長住
good and
((口語)) 非常地; 完全地
I'll do it when I am good and ready. 當我完全準備好時, 我就會去做
no good
((口語))
1 沒有價值的
2 無益的; 沒用的
  It's no good arguing with them. 和他們爭辯是沒有用的
to the good
1 有利的; 方便的
2 有盈餘的
  ended up to the good 結果賺錢了


<--- XDICT英汉辞典 --->
great
[greit]
a. 大的,非常的,主要的,重大的,崇高的,大写的,强烈的,伟大的
ad. 顺利地
<--- 朗道英漢字典5.0 --->
great
*[greit]
a. 大的, 非常的, 主要的, 重大的, 崇高的, 偉大的
ad. 順利地, 得意地
n. 全部, 大人物, 大師
相關詞組:
  in great detail
  great at
  great on
  great with
  a great many
  a great deal
<--- stardict1.3英汉辞典 --->
great
[greit]
a. 大的,非常的,主要的;
ad. 顺利地,得意地;
<--- 牛津現代英漢雙解詞典 --->
great
/ greIt; ^ret/ adj (-er, -est)  1 (a) [attrib 作定語] well above average in size, extent or quantity 大的; 巨大的; 非常的; 很多的: The great ship sank below the waves. 巨輪在滾滾浪濤中沉沒. * a great expanse of forest 廣闊的森林 * dive to a great depth 潛到極深處 * all creatures great and small 大大小小的生物 * A great crowd had turned up. 來了一大群人. * People had turned up in great numbers. 來了成批的人. * The great majority (of people) (ie Most people) approve. 大多數人讚成. (b) far away in space or time 距離遙遠的; 時間久遠的: He lives a great distance away. 他住得很遠. * That was a great while ago. 那是很久以前的事了. (c) [usu attrib 通常作定語] exceptional in degree or intensity; considerable （程度或強度）異乎尋常的; 格外的; 相當的: of great value, importance, relevance, significance, etc 價值、 重要性、 關系、 意義等頗大的 * He described it in great detail. 他描述得相當詳細. * Take great care to do it properly. 要格外用心地把這事做好. * You have my greatest (ie very great) sympathy. 我非常同情你. * be in great demand, ie much wanted 需求甚大. (d) in a very good state of health, morale or well-being; fine 健康的; 精神好的; 安寧的; 平安的; 好的: I feel great today! 我今天覺得精神好極了! * in great form, ie very fit and active 精力充沛 * in great spirits, ie very cheerful 心情很愉快. (e) [attrib 作定語] with very good or bad effects 有極好的或極壞的效果的: It's a great relief to know you're safe. 知你平安無事才放下心來. * You've been a great help. 你幫了大忙. * the greatest disaster that has ever befallen us. 我們遭受的最嚴重的災難. =>Usage at big 用法見big.  2 (a) of remarkable ability or quality; outstanding 偉大的; 傑出的: a great man, artist, musician, etc 偉人、 偉大的藝術家、 偉大的音樂家 * her great deeds 她的偉大事跡 * No one would deny that Beethoven's symphonies are great masterpieces. 人人都認為貝多芬的交響樂是偉大的傑作. * the world's greatest novelist 世界最傑出的小說家. (b) [attrib 作定語] of high rank or status 級別高的; 地位高的: a great lady 貴婦人 * the great powers, ie important and powerful countries 強國 * Alexander the Great 亞歷山大大帝. (c) (infml 口) very remarkable; splendid 非常的; 非凡的; 出眾的; 絕妙的; 了不起的: He's great! 他真了不起! * She's the greatest! 她真是不得了! * It's great that you can come! 你能來太好了! * What a great party! 這聚會真棒! * He scored a great goal. 他射入的一球真絕. (d) (infml 口) ~ (to do sth) very enjoyable or satisfactory 非常愉快的; 令人滿意的: We had a great time in Majorca. 我們在馬霍卡玩兒得真痛快. * It's great to know you! 認識您很高興! * It's great to have met you! 與您會面令人十分愉快!  3 (a) ~ for sth (infml 口) very suitable for sth; ideal or useful for sth 對某事物極適合的; 對某事物理想的或有用的: This little gadget's great for opening tins. 這小玩意兒開罐頭挺好用. * These are great shoes for muddy weather. 這種鞋在雨天泥濘的地上走最合適. (b) [pred 作表語] ~ at sth (infml 口) clever or skilful at sth 擅長某事; 精於某事: She's great at tennis, chess, etc. 她對網球、 象棋什麼的都擅長. (c) (ironic 反語) (used to express exasperation, scorn, etc 用以表示惱怒、 憤怒、 輕蔑、 嘲笑等): Oh great, I've missed the bus again! 真倒霉, 我又沒趕上公共汽車! * You've been a great help, you have! 你可幫大忙了, 幫倒忙!  4 [attrib 作定語] (a) important; noteworthy重要的; 顯著的; 值得注意的: The princess was getting married, and everyone was in town for the great occasion. 公主那時即將成婚, 人人都在首都等待這一盛典. * As the great moment approached, she grew more and more nervous. 她因那重要時刻漸近而越來越緊張. (b) unequalled; excellent 無比的; 無雙的; 極好的: She had a great chance/opportunity, but she let it slip. 她曾有個絕好的機會, 但沒抓住. (c) the great the most important 最重要的: The great advantage of this metal is that it doesn't rust. 這種金屬最大的優點是不生鏽.  5 [attrib 作定語] fully deserving the name of; beyond the ordinary 名符其實的; 真正的; 不一般的; 不尋常的: We are great friends. 我們是真正的朋友. * I've never been a great reader, ie I do not read much. 我讀書不多. * He's a great one for complaining, ie He constantly complains. 他是個抱怨大王（他總抱怨）.  6 [attrib 作定語] (infml 口) (used to intensify another adj of size, etc 用以加強表示體積等另一形容詞的詞義) very 非常; 很: What a great big idiot! 純粹的大傻瓜! * You great fat pig! 你這大肥豬! * That's a great thick slice of cake! 那是一大塊蛋糕哇!  7 [attrib 作定語] (used to name the larger of two types, species, etc 用以指稱兩類、 兩種生物等之較大者): the great auk, ie contrasted with the little auk 大海雀（與小海雀相對）.  8 (added to words for relatives beginning with grand- to show a further stage in relationship 冠於以grand-起首的表示親屬的詞之前, 以示更高或更低一輩的親屬關系): one's ,great-`grandfather, ie one's father's or mother's grandfather 某人之曾祖父（或外曾祖父） * one's ,great-`grandson, ie the grandson of one's son or daughter 某人的曾孫. =>App 8 見附錄8.  9 (dated infml 舊, 口) (in exclamations of surprise 用於驚嘆句中): Great Scott! 哎呀! * Great heavens! 天哪!  10 (idm 習語) be no great shakes (infml 口) not be very good, efficient, suitable, etc 並非很好; 不太有效; 不怎麼適合; 沒什麼了不起: She's no great shakes as an actress. 她不是什麼名角兒. going great guns (infml 口) proceeding vigorously and successfully 順利; 成功. a good/great deal => deal2. great and small rich and poor, powerful and weak, etc 貧富、 強弱等: Everyone, great and small, is affected by these changes. 所有的人, 無論高低貴賤都受這些變革的影響. make great/rapid strides => stride. of great price very valuable 很有價值的; 很貴重的. your need is greater than mine => need.

n  1 (usu pl 通常作復數) (infml 口) person of outstanding ability 高手; 名家: one of boxing's all-time greats 一位空前的拳擊高手.  2 the great [pl v] great(2) people 大人物; 顯要人物; 要人: a fashionable affair attended by all the great and the good, ie important and influential people 顯要人物都出席的社交盛事.

NOTE ON USAGE 用法: Britain or Great Britain (GB)consists of the geographical areas of England, Scotland and Wales. 不列顛或大不列顛（GB）由英格蘭、 蘇格蘭和威爾士的地域組成. It is often also used to refer to the political state, officially called the United Kingdom of Great Britain and Northern Ireland and usually abbreviated to the United Kingdom or the UK. 這一名稱也常用以表示行政上的國家, 官方稱為大不列顛及北愛爾蘭聯合王國, 通常簡稱為聯合王國或UK. *The British Isles are the islands of Britain and Ireland. 不列顛群島包括不列顛和愛爾蘭等島嶼. There is no noun in British English commonly used to refer to the nationality of the people of Britain; instead the adjective is used 在英式英語中沒有表示英國人國籍的通用名詞而用形容詞: She's British. 她是英國人. * The British are said to have an unusual sense of humour. 據說英國人有一種特殊的幽默感. Britisher is used in American English. *Britisher 用於美式英語. Briton is found in newspaper, etc reports of incidents concerning British people and in statistical information. *Briton 見於報刊等涉及英國人的報道及統計資料. It is also used of the early inhabitants of Britain *Briton也用以指不列顛早期的居民: 10 Britons in hijacked plane 被劫持飛機上的10個英國人 * According to the latest surveys many Britons suffer from heart disease. 據最近調查顯示, 許多英國人患心臟病. *  the ancient Britons 古代不列顛人.
<--- WordNet --->
great
great
     adj 1: relatively large in size or number or extent; larger than
            others of its kind; "a great juicy steak"; "a great
            multitude"; "the great auk"; "a great old oak"; "a
            great ocean liner"; "a great delay"
     2: more than usual; "great expectations"; "great worry"
     3: (used of persons) standing above others in character or
        attainment or reputation; "our distinguished professor";
        "an eminent scholar"; "a great statesman" [syn: {distinguished},
         {eminent}]
     4: of major significance or importance; "a great work of art";
        "Einstein was one of the outstanding figures of the 20th
        century" [syn: {outstanding}]
     5: remarkable or out of the ordinary in degree or magnitude or
        effect; "a great crisis"; "had a great stake in the
        outcome"
     6: very good; "he did a bully job"; "a neat sports car"; "had a
        great time at the party"; "you look simply smashing" [syn:
         {bang-up}, {bully}, {corking}, {cracking}, {dandy}, {groovy},
         {keen}, {neat}, {nifty}, {not bad(p)}, {peachy}, {slap-up},
         {swell}, {smashing}]
     7: uppercase; "capital A"; "great A"; "many medieval
        manuscripts are in majuscule script" [syn: {capital}, {majuscule}]
     8: marked by active interest and enthusiasm; "an avid sports
        fan"; "a great walker"; "an eager beaver" [syn: {avid}, {eager},
         {zealous}]
     9: in an advanced stage of pregnancy; "was big with child";
        "was great with child" [syn: {big(p)}, {enceinte}, {expectant},
         {gravid}, {great(p)}, {large(p)}, {heavy(p)}, {with
        child(p)}]
<--- CDICT5英漢辭典 --->
great
[gret;ɡreit]
< great >
[基本字彙]
<<形容詞>>
great.er, great.est
1 (尺寸) 大的
2 巨大的
3 (數量) 大的
  A great throng awaited us. 大批的群眾等著我們
4 (時間、距離) 廣闊的
  a great delay 延遲很久
5 (程度上) 顯著的
  a great crisis 大災難
6 意義非凡的; 非常重要的
  a great work of art 偉大的藝術品
7 主要的
  the great house on the estate 在地產上主要的房屋
8 (品質、品德) 傑出的, 崇高的, 偉大的
  "For he was great, ere foutune made him so." (John Dryden)他天生是個偉大的人物
9 有力的; 有影響力的
  one of the great nations of the West 西方的強權國家之一
10 卓越的; 超群的
   a great leader 卓越的領袖
11 有威嚴的; 貴族的
12 ((口語)) 狂熱的
   a great lover of music 音樂的愛好者
13 ((口語)) 擅長的
   great at algebra 擅長代數
14 ((口語)) 極佳的; 一流的
   We had a great time at the dance. 我們在舞會上玩得很盡興
15 (常用於複合字) (表示輩份)
   a great-granddaughter 曾孫女
16 ((古語)) 懷孕的
<<名詞>>
1 (pl. greats, great) 偉大的人物
  a composer considered among the greats 被認定為大師級的作曲家
2『音樂』
  a. (管樂器的) 分節
  b. (其他樂器) 類似的分節
<<副詞>>
((口語)) 很好地
got along great with the teacher 和這位老師相處融洽
<<副詞>>
greatly
<<名詞>>
greatness


<--- XDICT英汉辞典 --->
terrific
[tәˊrifik]
a. 非常的,极端的,可怕的
<--- 朗道英漢字典5.0 --->
terrific
*[tә'rifik]
a. 非常好的, 極端的, 可怕的
相關詞組:
  at a terrific speed
<--- stardict1.3英汉辞典 --->
terrific
[tәˊrifik]
a. 非常的,极端的,可怕的;
<--- 牛津現代英漢雙解詞典 --->
terrific
/ tE5rIfIk; tE`rIfIk/ adj (infml 口)  1 very great; extreme 很大的; 極端的: a terrific storm 狂風暴雨 *driving at a terrific speed 以極高的速度駕駛.  2 excellent; wonderful 極好的; 了不起的: doing a terrific job 幹得很棒 * The view was terrific. 景色美極了.
<--- WordNet --->
terrific
terrific
     adj 1: very great or intense; "a terrific noise"; "a terrific
            thunderstorm storm"; "fought a terrific battle"
     2: extraordinarily good; used especially as intensifiers; "a
        fantastic trip to the Orient"; "the film was fantastic!";
        "a howling success"; "a marvelous collection of rare
        books"; "had a rattling conversation about politics"; "a
        tremendous achievement" [syn: {fantastic}, {howling(a)}, {marvelous},
         {marvellous}, {rattling(a)}, {tremendous}, {wonderful}, {wondrous}]
     3: causing extreme terror; "a terrifying wail" [syn: {terrifying}]
<--- CDICT5英漢辭典 --->
terrific
[tәˋrIfIk;tәˊrifik]
< ter.rif.ic >
<<形容詞>>
more ter.rif.ic ; most ter.rif.ic
1 非常厲害的, 驚人的, 非同小可的
2 很棒的, 極好的, 絕妙的
2 可怕的, 恐怖的; 嚇人的
<<名詞>>
ter.rif.ic.ness
<<副詞>>
ter.rif.i.cal.ly


<--- XDICT英汉辞典 --->
nice
[nais]
a. 美好的,和蔼的,正派的,体贴的,精密的,细微的,挑剔的,拘泥的
<--- 朗道英漢字典5.0 --->
nice
*[nais]
a. 美好的, 和藹的, 正派的, 做得好的, 精密的, 細微的, 挑剔的, 謹慎的
相關詞組:
  be nice to sb
<--- stardict1.3英汉辞典 --->
nice
[ˊnais]
a. 美好的,体贴的,精密的;
<--- 牛津現代英漢雙解詞典 --->
nice
/ naIs; naIs/ adj (-r, -st)  1 (a) pleasant; agreeable 好的; 令人愉快的; 宜人的: a nice person, smile, taste, remark 令人愉快的人、 微笑、 味道、 言語 * a nice day 美好的一天 * nice weather 好天氣 * a nice little girl 可愛的姑娘 * That tastes nice! 味道挺好! * We had a nice time at the beach. 我們在海濱時開心極了. * It's not nice to pick your nose. 挖鼻孔很不雅觀. (b) ~ (to sb) kind; friendly 親切的; 友好的: Try to be nice to my father when he visits. 我父親到這裡來時盡量對他好些. Cf 參看 nasty.  2 (ironic 反語) bad; unpleasant 壞的; 令人不愉快的: This is a nice mess you've got us into! 你把我們弄到了這種地步! * That's a nice thing to say! 這種好話能說得出口!  3 needing precision and care; fine; subtle 需精確和慎重的; 細微的; 微妙的: a nice distinction 細微的區別 * a nice point of law, ie one that may be difficult to decide 法律上難以決定之處 * nice (ie very slight) shades of meaning 意義的細微差別.  4 (a) hard to please; having refined tastes 難以取悅的; 講究的: too nice in one's dress 衣著過分講究. (b) (usu in negative expressions 通常用於否定用語) respectable; scrupulous 體面的; 高尚的; 謹慎的; 細致的: She's not too nice in her business methods. 她的經營方法不敢恭維.  5 (idm 習語) nice and (used before adjs 用於形容詞之前) (infml approv 口, 褒) agreeably 宜人地: nice and warm by the fire 在火邊暖烘烘的 * nice and cool in the woods 森林裡涼爽宜人. good/nice work => work1. nice work if you can get it (saying 諺) (used to express envy of what sb has been lucky or clever enough to get or do 因某人幸運或聰明而得到或得以做某事物, 用此語表達羨慕或忌妒之意).
<--- WordNet --->
nice
nice
     adj 1: pleasant or pleasing or agreeable in nature or appearance;
            "what a nice fellow you are and we all thought you so
            nasty"- George Meredith; "nice manners"; "a nice
            dress"; "a nice face"; "a nice day"; "had a nice time
            at the party"; "the corn and tomatoes are nice today"
            [ant: {nasty}]
     2: socially or conventionally correct; refined or virtuous;
        "from a decent family"; "a nice girl" [syn: {decent}]
     3: done with delicacy and skill; "a nice bit of craft"; "a job
        requiring nice measurements with a micrometer"; "a nice
        shot" [syn: {skillful}]
     4: excessively fastidious and easily disgusted; "too nice about
        his food to take to camp cooking"; "so squeamish he would
        only touch the toilet handle with his elbow" [syn: {dainty},
         {overnice}, {prissy}, {squeamish}]
     5: noting distinctions with nicety; "a discriminating interior
        designer"; "a nice sense of color"; "a nice point in the
        argument" [syn: {discriminate}]
     6: exhibiting courtesy and politeness; "a nice gesture" [syn: {courteous},
         {gracious}]
<--- CDICT5英漢辭典 --->
nice
[naIs;nais | nis;niːs]
< nice >
[基本字彙]
<<形容詞>>
nic.er, nic.est
1 愉快的; 宜人的
  had a nice time 愉快的時光
2 外表美好的; 優美的
  a nice dress 漂亮的衣服
  a nice face 美麗的臉蛋
3 優雅的
  a nice gesture 優雅的姿勢
4 高尚的; 值得尊敬的
5 過份講究的; 難侍候的
6 精確的; 敏感的
  a nice distinction 精確的差別
  a nice sense of style 對風尚很敏感
7 精細的
  a nice bit of craft 精細的手工藝品
8 (與 and 連用, 用作加強語氣)
  nice and warm 溫暖而舒適
9『廢』
  a. 放肆的; 浪蕩的
  b. 佯裝羞澀的; 顯得嬌羞的
     "Ere... / The nice Morn on th' Indian steep, / From her cabin'd loop-hole peep." (John Milton) 在那時… / 印地安峭壁嬌羞的晨曦, / 窺視她的房間
<<副詞>>
nicely
<<名詞>>
niceness

< Nice >
<<名詞>>
『地名』尼斯

<--- XDICT英汉辞典 --->
awesome
[ˊɒːsәm]
a. 引起敬畏的,可怕的
<--- 朗道英漢字典5.0 --->
awesome
*['ɒ:sәm]
a. 引起敬畏的, 可怕的
<--- stardict1.3英汉辞典 --->
awesome

a. 引起敬畏的,可怕的;
<--- 牛津現代英漢雙解詞典 --->
awesome
/ -sEm; -sEm/ adj causing awe 使人敬畏的; 使人驚懼的: His strength was awesome. 他的力量大得怕人.
<--- WordNet --->
awesome
awesome
     adj : inspiring awe or admiration or wonder; "New York is an
           amazing city"; "the Grand Canyon is an awe-inspiring
           sight"; "the awesome complexity of the universe"; "this
           sea, whose gently awful stirrings seem to speak of some
           hidden soul beneath"- Melville; "Westminster Hall's
           awing majesty, so vast, so high, so silent" [syn: {amazing},
            {awe-inspiring}, {awful}, {awing}]
<--- CDICT5英漢辭典 --->
awesome
[ˋɒsәm;ˊɒːsәm]
< awe.some >
<<形容詞>>
1 可怕的, 有威嚴的, 令人敬畏的
2 表示敬畏的, 感到恭敬的
<<副詞>>
awe.some.ly
<<名詞>>
awe.some.ness

<--- XDICT英汉辞典 --->
horrible
[ˊhɑːәbl]
a. 可怕的,极可憎的,极可厌的
<--- 朗道英漢字典5.0 --->
horrible
*['hɒrәbl]
a. 可怕的, 遭透的, 極討厭的
<--- stardict1.3英汉辞典 --->
horrible
[ˊhɒrәbl]
a. 可怕的,极可憎的,极可厌的;
<--- 牛津現代英漢雙解詞典 --->
horrible
/ 5hCrEbl; ?@ 5hR:r-; `hRrEbl/ adj  1 causing horror 可怕的; 令人恐懼的: a horrible crime, nightmare, death 駭人聽聞的罪行、 叫人心驚膽顫的惡夢、 令人恐懼的死亡.  2 (infml 口) very unpleasant 令人極不愉快的: horrible weather, food, people 糟糕的天氣、 難吃的食物、 極不友好的人 * It tastes horrible. 這味道很不好. * Don't be so horrible (to me). 別那麼（讓我）討厭. 
<--- WordNet --->
horrible
horrible
     adj : provoking horror; "an atrocious automobile accident"; "a
           frightful crime of decapitation"; "an alarming, even
           horrifying, picture"; "war is beyond all words
           horrible"- Winston Churchill; "an ugly wound" [syn: {atrocious},
            {frightful}, {horrifying}, {ugly}]
<--- CDICT5英漢辭典 --->
horrible
[ˋhɒrәbL,ˋhɑr-;ˊhɒrәbl]
< hor.ri.ble >
<<形容詞>>
1 毛骨悚然的; 可怕的
  "War is beyond all words horrible." (Winston S. Churchill)戰爭的可怕非筆墨所能描述
2 令人討厭的; 不愉快的
<<名詞>>
horri.ble.ness
<<副詞>>
horri.bly


<--- XDICT英汉辞典 --->
terrible
[ˊterәbl]
a. 可怕的,可怖的,骇人的,令人敬畏的;极度的;极坏的,很糟的;极妙的
<--- 朗道英漢字典5.0 --->
terrible
*['terәbl]
a. 可怕的, 令人恐懼的, 極壞的
<--- stardict1.3英汉辞典 --->
terrible
[ˊterәbl]
a. 可怕的,令人恐惧的,极坏的;
<--- 牛津現代英漢雙解詞典 --->
terrible
/ 5terEbl; `tZrEbl/ adj  1 causing great fear ordistress; appalling 可怕的; 使人苦惱的; 駭人的: a terriblewar, accident, murder 可怕的戰爭、 事故、 謀殺案.  2 hard to bear; extreme 難以忍受的; 極端的: terrible toothache 難以忍受的牙疼 * The heat was terrible. 熱得受不了.  3 (infml 口) very bad 極壞的; 很糟的: I'm terrible at tennis. 我打網球打得很不好. * What a terrible meal! 這頓飯糟透了! * He's a terrible bore. 他這人討厭極了.
<--- WordNet --->
terrible
terrible
     adj 1: causing fear or dread or terror; "the awful war"; "an awful
            risk"; "dire news"; "a career or vengeance so direful
            that London was shocked"; "the dread presence of the
            headmaster"; "polio is no longer the dreaded disease
            it once was"; "a dreadful storm"; "a fearful howling";
            "horrendous explosions shook the city"; "a terrible
            curse" [syn: {awful}, {dire}, {direful}, {dread(a)}, {dreaded},
             {dreadful}, {fearful}, {fearsome}, {frightening}, {horrendous},
             {horrific}]
     2: exceptionally bad or displeasing; "atrocious taste";
        "abominable workmanship"; "an awful voice"; "dreadful
        manners"; "a painful performance"; "terrible handwriting";
        "an unspeakable odor came sweeping into the room" [syn: {atrocious},
         {abominable}, {awful}, {dreadful}, {painful}, {unspeakable}]
     3: intensely or extremely bad or unpleasant in degree or
        quality; "severe pain"; "a severe case of flu"; "a
        terrible cough"; "under wicked fire from the enemy's
        guns"; "a wicked cough" [syn: {severe}, {wicked}]
     4: extremely distressing; "fearful slum conditions"; "a
        frightful mistake"; "suffered terrible thirst" [syn: {fearful},
         {frightful}]
<--- CDICT5英漢辭典 --->
terrible
[ˋtєrәbL;ˊterәbl]
< ter.ri.ble >
[常用字]
<<形容詞>>
1 可怕的; 駭人的
  a terrible bolt of lightning 可怖的閃電
  a terrible curse 可怕的詛咒
2 艱鉅的
  terrible responsibilities 艱鉅的責任
3 極端的; 非常的
  "the life for which he had paid so terrible a price" (Leslie Fiedler)他的生活負擔很重
4 a. 極壞的
     had a terrible time at the party 舞會上很不愉快的時光
  b.令人討厭的
     terrible hypocrisy 令人討厭的虛偽行為
<<名詞>>
terri.ble.ness
<<副詞>>
terri.bly


<--- XDICT英汉辞典 --->
nightmare
[ˊnaitmєә]
n. 梦魇,恶梦,可怕的经验
<--- 朗道英漢字典5.0 --->
nightmare
*['naitmєә]
n. 夢魘, 惡夢, 可怕的事物(或情景、人物)
【醫】 夢魘, 惡夢
<--- stardict1.3英汉辞典 --->
nightmare
[ˊnaitmєә]
n. 梦魇,恶梦,可怕的经验;
<--- 牛津現代英漢雙解詞典 --->
nightmare
n  1 frightening dream 惡夢; 夢魘: I have nightmares about falling off a cliff. 我作惡夢夢見從懸崖上摔下來了.  2 (infml 口) very frightening or unpleasantexperience 非常可怕的或不愉快的經歷: Driving during the blizzard was a nightmare. 在暴風雪中開車真嚇人. 
<--- WordNet --->
nightmare
nightmare
     n 1: a situation resembling a terrifying dream [syn: {incubus}]
     2: a terrifying or deeply upsetting dream
<--- CDICT5英漢辭典 --->
nightmare
[ˋnaItˏmєr;ˊnaitmєә]
< night.mare >
<<名詞>>
1 惡夢; 夢魘
2 令人極度沮喪的經驗 (事件)
3 睡魔
  困擾人睡眠使生惡夢的惡魔
<<形容詞>>
nightmar.ish
<<副詞>>
nightmarish.ly
<<名詞>>
nightmarish.ness


<--- XDICT英汉辞典 --->
disastrous
[diˊzɑːstrәs]
a. 损失惨重的,悲伤的
<--- 朗道英漢字典5.0 --->
disastrous
*[di'zɑ:strәs]
a. 損失慘重的, 悲傷的
<--- stardict1.3英汉辞典 --->
disastrous
[diˊzɑːstrәs]
a. 损失惨重的,悲伤的;
<--- 牛津現代英漢雙解詞典 --->
disastrous
/ dI5zB:strEs; ?@ -z5As-; dIz`AstrEs/ adj being or causing a disaster 災難性的; 造成災害的; 失敗的: disastrous floods 災難性的洪水 * a defeat that was disastrous to the country 給國家帶來災難的一場敗仗 * Buying this house was a disastrous step: it's going to have a main road built behind it. 買下這所房子是一大失策, 因為房後就要建一條公路了. 
<--- WordNet --->
disastrous
disastrous
     adj : (of events) having extremely unfortunate or dire
           consequences; bringing ruin; "the stock market crashed
           on Black Friday"; "a calamitous defeat"; "the battle
           was a disastrous end to a disastrous campaign"; "such
           doctrines, if true, would be absolutely fatal to my
           theory"- Charles Darwin; "it is fatal to enter any war
           without the will to win it"- Douglas MacArthur; "a
           fateful error" [syn: {black}, {calamitous}, {fatal}, {fateful}]
<--- CDICT5英漢辭典 --->
disastrous
[dIzˋæstrәs;diˊzɑːstrәs]
< dis.as.trous >
<<形容詞>>
1 災害的; 悲慘的
2 糟糕的, 可怕的
  a disastrous report card 很糟糕的成績單
<<副詞>>
dis.astrous.ly
<<名詞>>
dis.astrous.ness

good: 225
great: 125
terrific: 16
nice: 59
awesome: 10

horrible: 14
terrible: 24
nightmare: 11
disastrous: 14

436/63
				<</textfile>>
				<<textfile "result.out">>
good-words: 435
bad-words: 63
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-useless--->>>
			<<case "rule-useless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: useless expression
*/
					<</desc>>
					<<init_code>>
#include <ctype.h>
					<</init_code>>
					<<declare_section>>
%formal-param%{ int &lowers, int &uppers, int &digits %}
%actual-param%{ lowers, uppers, digits %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			++lowers;
B			++uppers;
<*>[[:alnum:]]		if(isdigit(yytext[0]))
				++digits;
			else if(islower(yytext[0]))
				++lowers;
			else
				++uppers;
<asc>[[:upper:]]	uppers += 2;
<bsc>[[:lower:]]	lowers += 2;
<asc>[[:digit:]]	digits += 2;
.|\n
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex( n1, n2, n3);
	cout << "lower\'s: " << n1 << endl
	     << "upper\'s: " << n2 << endl
	     << "digit\'s: " << n3 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
eeeeeeeeee8888hh22222222hh5555555FFFF..........hhh.hhheeeh55555555hffffffffGG..........FFFFFhDDDDDDDDDhCCCCCfffffccchhhhhddddddddddddhhGGGGGGGGGGh222hh......hhhbbbbh2222hheeeeehhhhhfaaaaaeeeeeecccccc....haaaaaaaaaaaah2222222333333333hhGGGGGGGGhh3333333333hffff888888888hhddddddd000000000heeebbbbbbbbb8888888hhhhCCCCCCCCCBBBBhBBBBBBBBBBhhccccchhhhhhbbbb00333333ggghDaaaaa00000CCCCCCCCCChhhhhBBCCCCCCCfh3555555555eeehbbbbbbbbbbhccccchhFFFFFFFFhh333hh00000hFFFFFFFFFF44444dddDDDDDDDh55554444444444hhhhDD00000fBBBBhfffffbbhEEEEhhhhhh3333hhh..5555555555h000bbbbbbbbb...EEEEEEEEddh5558h........CCCCCCChhh.......hhBBBBBBhaaahCCCCCCCCCGGGGGGGG00000000000000022222h5555hh..........heeeeeeeeeehhaaaaaaaaahgggggggggaaaaaaaggggh000h222ffffffheeeeeeeeeh55555555h..hh0000000
332/159/215
				<</textfile>>
				<<textfile "result.out">>
lower's: 332
upper's: 159
digit's: 215
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-useless--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/rule---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond---------->>>
		<<suite "startcond" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>
			<<case "startcond-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition: duplicated SC

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%x asc
%s asc

					<</declare_section>>
					<<lex_section>>
"{"		BEGIN(asc);
<asc>"}"	BEGIN(INITIAL);
<asc>a		++ncnt; cout << yytext;
a		ncnt += 2; cout << yytext;
<*>\n		cout << "\n";
<asc>.		cout << "_";
.

					<</lex_section>>
					<<before_init>>
	int ncnt = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(ncnt);
	cout << endl << ncnt << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{sfkiwegfsafa;adska
9348ejfsdjfklaeijofsedaiojdfasijoafiajoiwafo9ijwef320ewfokSAlL
349aew0ifjofl;Sao9pjgvdsnAO9WFMDSOPAAEGDASSODPL;AOPAalaomfaopfkd;klasdfjkfeiwjofkdscmx ,        P2309824390EDWPKOCSMLZX,. D
OPAKFPOAOPAF[al;pafkasdflergjvkldmldsfa[pw4e-=3240r5i0=-ew]pdsv;l  /.CX v,psidjkiewroas[dlc;fmkioopwer[]al;aerpwdsl
}
ajfdslowpef
oepwfasfl;sdfwepfas'
				<</textfile>>
				<<textfile "result.out">>
_________a_a_a___a
_____________a________a_____a____a__a____a____________________
___a___________a____________________________________a_a___a________a_______________________________________________________
_____________a___a__a_________________a______________________________________________a__________________a__a_______

a
aa

29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>
			<<case "startcond-exclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &as2, int &bs, int &bs2%}
%actual-param%{ as, as2, bs, bs2 %}

%x isc

					<</declare_section>>
					<<lex_section>>
\{		BEGIN(isc); cout << yytext;
<isc>\}		BEGIN(INITIAL); cout << yytext;
a		++as; cout << yytext;
<isc>b		++bs2; cout << yytext;
b		++bs; cout << yytext;
<*>a		++as2; cout << yytext;
<isc>.		cout << "_";
<*>\n		cout << endl;
.		cout << "*";
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n11 = 0, n2 = 0, n21 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n11, n2, n21);
	cout << "a's: " << n1 << " at INITIAL" << endl
	     << "a's: " << n11 << " at isc" << endl
	     << "b's: " << n2 << " at INITIAL" << endl
	     << "b's: " << n21 << " at isc" << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
bb~~bbbbbb~aa~aaaaaaaaaaa~~}}}}}}}}}~cccccaaa}}}}~bbbbbb~}~~aaaaabbbbbbbb~~~~cccccccccaaa{{{{{{{{{{aaaaaa~cccccccccc~..........~....bbb~~.~~ccccccc~aaaaaaaaacccccc~~{{{{{{{~~~ccccccc~{{{{{{}}}}}}}}}}~~~~bb~{{{{{cccccccccc}}}}}}{{{aaaaa~{{{{{{}}}}c~cccc~bbbaaaaaaa..........~aaaaaaa~~}}}}}}}}}}~~
.: 25
a: 58
b: 30
{: 37
}: 44
c: 59
~: 42

				<</textfile>>
				<<textfile "result.out">>
bb**bbbbbb*aa*aaaaaaaaaaa*****************aaa*****bbbbbb****aaaaabbbbbbbb*************aaa{_________aaaaaa___________________________bbb_____________aaaaaaaaa________________________________}*************bb*{______________}*****{__aaaaa_______}**********bbbaaaaaaa***********aaaaaaa**************
*****
a****
b****
{____
}****
*****
*****

a's: 39 at INITIAL
a's: 20 at isc
b's: 28 at INITIAL
b's: 3 at isc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>
			<<case "startcond-exclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ int &n1, int &n2, int &n3%}
%actual-param%{ n1, n2, n3 %}

%x bsc
%x csc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		cout << yytext;
<INITIAL,csc>\{		yy_push_state(bsc); cout << yytext;
<INITIAL,bsc>\[		yy_push_state(csc); cout << yytext;
<bsc>\}			yy_pop_state(); cout << yytext;
<csc>\]			yy_pop_state(); cout << yytext;
<bsc,csc>[\}\]]		cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<*>\n			cout << endl;

					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << "a's: " << n1 << " at INITIAL" << endl
	     << "a's: " << n2 << " at bsc" << endl
	     << "a's: " << n3 << " at csc" << endl;


	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
************aaaaaaaaaa*************************[_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]*{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

a's: 10 at INITIAL
a's: 18 at bsc
a's: 1 at csc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>
			<<case "startcond-exclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3, int &n4 %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%x csc
%x dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		cout << yytext;
\{		BEGIN(bsc); cout << yytext;
<bsc>\{		BEGIN(csc); cout << yytext;
<csc>\{		BEGIN(dsc); cout << yytext;
<dsc>\}		BEGIN(csc); cout << yytext;
<csc>\}		BEGIN(bsc); cout << yytext;
<bsc>\}		BEGIN(INITIAL); cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
<dsc>a			++n4; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<dsc>.			cout << "+";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4);
	cout << "SC0: " << n1 << endl
	     << "SC1: " << n2 << endl
	     << "SC2: " << n3 << endl
	     << "SC3: " << n4 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}***********{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}**{{{+aaaaaaaa+aa+++++}}}***{{{++aaaaa}}}******************{{{++++++++++++++}}}******{{{++++++++++++++}}}*************************aaaaaaa*****{{{++}}}************aaaaaaaa***********aaaaaaa{{{+++++++++++++++++++++++++}}}***{{{+++++++++++++++++++++++++}}}**{{{++++++++++++}}}*****aa*********aa******************{{{++++++++++++++}}}*********************aaaaaaa**************aaaaa*aaaaaaaa**a{{{+++++aa+++++++++}}}********
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 49
SC1: 10
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>
			<<case "startcond-inclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &as, int &as2, int &bs, int &bs2%}
%actual-param%{ as, as2, bs, bs2 %}

%s isc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+	cout << yytext;
\{		BEGIN(isc); cout << yytext;
<isc>\}		BEGIN(INITIAL); cout << yytext;
a		++as; cout << yytext;
b		++bs; cout << yytext;
<isc>b		++bs2; cout << yytext;
<*>a		++as2; cout << yytext;
.		cout << "*";
<isc>.		cout << "_";
<*>\n		cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n11 = 0, n2 = 0, n21 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n11, n2, n21);
	cout << "SC0-a: " << n1 << endl
	     << "SC1-a: " << n11 << endl
	     << "SC0-b: " << n2 << endl
	     << "SC1-b: " << n21 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
aaaaa}}}}}}}}~bbbbbbbbbb{{{~{{{{{{{{~~~aaaaaaaaaa}}}}}}}}}}}}}}~~~~~~........~{{{{{{{{{~bbbbaaaaaaaaa~{{bbbbbb~b~~~~{c~~}}}~~~{{{~}}}}b~aaaaaaaaa{{{{{{{{bbbbbbbbc~}}}}}}~}}}}}}.~~aaaaaaaaaa{{{{{{{{{{~}}}}}}~~cccccc~~}}}}}}}a
.: 9
a: 19
a: 25
{: 18
}: 16
{: 26
}: 38
b: 10
b: 20
c: 8
~: 35

				<</textfile>>
				<<textfile "result.out">>
aaaaa}}}}}}}}*bbbbbbbbbb{______________aaaaaaaaaa}}}}}}}}}}}}}}***************{_________bbbbaaaaaaaaa___bbbbbb_b________}}}***{___}}}}b*aaaaaaaaa{_______bbbbbbbb__}}}}}}*}}}}}}***aaaaaaaaaa{__________}}}}}}**********}}}}}}}a
***9
a**19
a**25
{__18
}**16
{__26
}**38
b**10
b**20
***8
***35

SC0-a: 27
SC1-a: 19
SC0-b: 13
SC1-b: 19
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>
			<<case "startcond-inclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3%}
%actual-param%{ n1, n2, n3 %}

%s bsc
%s csc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		cout << yytext;
[\}\]]			cout << yytext;
<INITIAL,csc>\{		yy_push_state(bsc); cout << yytext;
<INITIAL,bsc>\[		yy_push_state(csc); cout << yytext;
<bsc>\}			yy_pop_state(); cout << yytext;
<csc>\]			yy_pop_state(); cout << yytext;
<bsc,csc>[\}\]]		cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << "SC0-a: " << n1 << endl
	     << "SC1-a: " << n2 << endl
	     << "SC2-a: " << n3 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
*********]]*aaaaaaaaaa******************]]]]]]][_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]]{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

SC0-a: 10
SC1-a: 18
SC2-a: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>
			<<case "startcond-inclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3, int &n4 %}
%actual-param%{ n1, n2, n3, n4 %}


%s bsc
%s csc
%s dsc
					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		cout << yytext;
[\{\}]		BEGIN(bsc); cout << yytext;
<bsc>\{		BEGIN(csc); cout << yytext;
<csc>\{		BEGIN(dsc); cout << yytext;
<dsc>\}		BEGIN(csc); cout << yytext;
<csc>\}		BEGIN(bsc); cout << yytext;
<bsc>\}		BEGIN(INITIAL); cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
<dsc>a			++n4; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<dsc>.			cout << "+";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4);
	cout << "SC0: " << n1 << endl
	     << "SC1: " << n2 << endl
	     << "SC2: " << n3 << endl
	     << "SC3: " << n4 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>
			<<case "startcond-inex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive & exclusive start-condition

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ int &n1, int &n2, int &n3, int &n4 %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%s csc
%s dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		cout << yytext;
[\{\}]		BEGIN(bsc); cout << yytext;
<bsc>\{		BEGIN(csc); cout << yytext;
<csc>\{		BEGIN(dsc); cout << yytext;
<dsc>\}		BEGIN(csc); cout << yytext;
<csc>\}		BEGIN(bsc); cout << yytext;
<bsc>\}		BEGIN(INITIAL); cout << yytext;
a			++n1; cout << yytext;
<bsc>a			++n2; cout << yytext;
<csc>a			++n3; cout << yytext;
<dsc>a			++n4; cout << yytext;
.			cout << "*";
<bsc>.			cout << "-";
<csc>.			cout << "_";
<dsc>.			cout << "+";
<*>\n			cout << endl;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3, n4);
	cout << "SC0: " << n1 << endl
	     << "SC1: " << n2 << endl
	     << "SC2: " << n3 << endl
	     << "SC3: " << n4 << endl;

	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>
		<<suite "startcond-refer" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-alleof--->>>
			<<case "startcond-refer-alleof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
every start-condition has its own EOF-rule
*/
					<</desc>>
					<<init_code>>
char *pcchFileName[3] = {
	"test1.input",
	"test2.input",
	NULL			
};
int fIndex = 0;
					<</init_code>>
					<<declare_section>>
%x	asc
%x	bsc
%x	csc
					<</declare_section>>
					<<lex_section>>
a		BEGIN(asc);
b		BEGIN(bsc);
c		BEGIN(csc);
<asc>a		BEGIN(INITIAL);
<bsc>b		BEGIN(INITIAL);
<csc>c		BEGIN(INITIAL);
<<EOF>>	{
			printf("File end at SC-INITIAL: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<asc><<EOF>>	{
			printf("File end at SC-asc: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<bsc><<EOF>>	{
			printf("File end at SC-bsc: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<csc><<EOF>>	{
			printf("File end at SC-csc: %d\n", YYSTART());
			if(fIndex < 2) {

				yy_delete_buffer();
				YYPBUFFER pbuf = yy_new_filebuf(pcchFileName[fIndex]);
				if(! pbuf) {
					
					printf("failed to open buffer\n");
					yyterminate();
				}
				else {
					yy_switch_buffer(pbuf);
					++fIndex;
					BEGIN(INITIAL);
					yy_set_bol(true);
				}
			}
		}
<*>.|\n

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
dddddddddeccccccccccc...aaaaaadbbbbbbbbbaaaaaaaccccccceeeebbbbbbbbbeeeeccaaaaaaaecccccccceeeeeeeeeeeeeccccaaaaaaaaaaeeedddaaaaaaaddddeedddddddeddddddddebbbbbbb...dddde...aaaaaaaaaaeeeaaaaaaaaaeddddddddbbbbbbbbbbee.....bbbbbbbbbeeaaaaaaa
.: 14
a: 63
b: 44
c: 32
d: 44
e: 39

				<</textfile>>
				<<textfile "test1.input">>
aaaaaadddddddddeeeee..eeedddddddeeddddddddbbbbbdddddddeddddbbbddeeeebbaaaaaaaaeeacccccebbbbbbcccccccccbbbbbbbeccceaaaaaaaa
.: 2
a: 23
b: 23
c: 17
d: 37
e: 20

				<</textfile>>
				<<textfile "test2.input">>
aaaaaaaee..a.........bbbbbedddddddddedddeeeaaaaddeeeeedddecccccaaeeeebbbbbeccccceeebbbddddcccceddbdee..........ddccccccccccebbbbbbaaaaaaaaaaeeddddddcccccebbbbbbedddedccccccccccccccccdddddddddd........eee....dddddeeeeeeeeee......ebbbbeeeedddddddddebbbbbbbbbbaaaaaaabbbbbbcccccceee
.: 39
a: 31
b: 46
c: 51
d: 60
e: 52

				<</textfile>>
				<<textfile "result.out">>
File end at SC-asc: 2
File end at SC-bsc: 4
File end at SC-bsc: 4
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-alleof--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-allsc--->>>
			<<case "startcond-refer-allsc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
special start-condition <*>
*/
					<</desc>>
					<<init_code>>
#include <ctype.h>

int c1 = 0, c2 = 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ int &beta, int &betb, int &others %}
%actual-param%{ beta, betb, others %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			BEGIN(asc);
			cout << "{";
			c1 = 0;
			++others;
b			BEGIN(bsc);
			cout << "[";
			c2 = 0;
			++others;
<asc>a			BEGIN(INITIAL);
			cout << "}";
			beta += c1;
			++others;
<bsc>b			BEGIN(INITIAL);
			cout << "]";
			beta += c2;
			++others;

<asc>[[:graph:]] 	++c1;
			cout << yytext;
<bsc>[[:graph:]]	++c2;
			cout << yytext;
<*>.			cout << "_";
			++others;
<*>\n			cout << endl;
<*><<EOF>>		others += c1;
			others += c2;
					<</lex_section>>
					<<before_init>>
	int n1 = 0, n2 = 0, n3 = 0;
					<</before_init>>
					<<after_init>>
	int nret = yylex(n1, n2, n3);
	cout << endl << "chars between a\'s: " << n1 << endl
	     << "chars between b\'s: " << n2 << endl
	     << "others: " << n3 << endl
	     << "total: " << n1 + n2 + n3 << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
bbedddcccccccecccccccccccccceaeeddddddddeeedddddddddd.ddde.......eeeaaebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142

				<</textfile>>
				<<textfile "result.out">>
[]___________________________{eeddddddddeeedddddddddd.ddde.......eee}{ebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142


chars between a's: 38
chars between b's: 0
others: 104
total: 142
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-allsc--->>>

<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-multisc--->>>
			<<case "startcond-refer-multisc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
refer multi start-condition
*/

					<</desc>>
					<<init_code>>
#include <string>
using std::string;
					<</init_code>>
					<<declare_section>>

%formal-param%{ string &qstr, string &mstr, bool &bexpr %}
%actual-param%{ qstr, mstr, bexpr %}

%x	qstr_sc
%x	expr_sc
					<</declare_section>>
					<<lex_section>>

\"						yy_push_state(qstr_sc); bexpr = false;
<qstr_sc>\`					yy_push_state(expr_sc); bexpr = true;
<expr_sc,qstr_sc>\$[[:cidf:]][[:cids:]]*	if(bexpr) mstr += yytext; else qstr += yytext;			 
<expr_sc,qstr_sc>[\+\-\*\/\(\)\[\]\{\}]		if(bexpr) mstr += yytext; else qstr += yytext;
<expr_sc>\`					yy_pop_state(); bexpr = false; mstr += "\n";
<qstr_sc>\"					yy_pop_state(); qstr += "\n";
<expr_sc,qstr_sc,expr_sc>.			if(bexpr) mstr += yytext; else qstr += yytext;

<*>.|\n
					<</lex_section>>
					<<before_init>>
	string qstr, mstr;
	bool b = false;
					<</before_init>>
					<<after_init>>
	int nret = yylex(qstr, mstr, b);

	cout << "qstr: " << qstr << endl;
	cout << "mstr: " << mstr << endl;
	if(nret) {
		return nret;
	}
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
"if test `expr n1 * n2` != 0 then both n1 and n2 are not zero else either n1 or n2 are zero"
print_msg("for your information `echo $msg`")    
print "done"

				<</textfile>>
				<<textfile "result.out">>
qstr: if test  != 0 then both n1 and n2 are not zero else either n1 or n2 are zero
for your information 
done

mstr: expr n1 * n2
echo $msg

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-multisc--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-someeof--->>>
			<<case "startcond-refer-someeof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
some start-conditions have own EOF-rule
*/

					<</desc>>
					<<init_code>>
enum {
	IDX_ASC = 0,
	IDX_BSC,
	IDX_CSC,
	IDX_DSC
};
char *ppchFileName[4] = {
	"test1.input",
	"test2.input",
	"test3.input",
	NULL
};

					<</init_code>>
					<<declare_section>>

%yywrap%{
	return false; 
%}

%x	asc
%x	bsc
%x	csc
%x	dsc
					<</declare_section>>
					<<lex_section>>

a	BEGIN(asc); cout << yytext << endl;
b	BEGIN(bsc); cout << yytext << endl;
c	BEGIN(csc); cout << yytext << endl;
d	BEGIN(dsc); cout << yytext << endl;
<asc>a	BEGIN(INITIAL);
<bsc>b	BEGIN(INITIAL);
<csc>c	BEGIN(INITIAL);
<dsc>d	BEGIN(INITIAL);
<asc><<EOF>>	{
			printf("File end at SC-asc: %d\n", YYSTART());
			yy_delete_buffer();
			for(int i = 2; i >= 0; --i) {
				YYPBUFFER pbuf = yy_new_filebuf(ppchFileName[i]);
				if(! pbuf) {

					printf("failed to open buffer\n");
					yyterminate();
					break;
				}
				else {
					yy_push_buffer(pbuf);
				}
			}
			BEGIN(INITIAL);
		}

<*><<EOF>>		{
			switch(YYSTART()) {
			case bsc:
				printf("File end at SC-bsc: %d\n", YYSTART());
				break;
			case csc:
				printf("File end at SC-csc: %d\n", YYSTART());
				break;
			case dsc:
				printf("File end at SC-dsc: %d\n", YYSTART());
				break;
			}
			yy_delete_buffer();
			BEGIN(INITIAL);
		}

<*>.|\n
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				<<textfile "test.input">>
a
				<</textfile>>
				<<textfile "test1.input">>
b
				<</textfile>>
				<<textfile "test2.input">>
c
				<</textfile>>
				<<textfile "test3.input">>
d
				<</textfile>>
				<<textfile "result.out">>
a
File end at SC-asc: 2
b
File end at SC-bsc: 4
c
File end at SC-csc: 6
d
File end at SC-dsc: 8
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-someeof--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/basic---------->>>

<</suite>>
<<<----------sub-suite: /lex-alone ---------->>>

<<<----------sub-suite: /invoke ---------------->>>
<<suite "invoke" make="subdir-makefile-template">>

<<<----------case: /invoke/default----------------->>>
	<<case "default" make="invoke-make-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	default options
		-o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
ans = 		0
ans = 		1024
ans = 		1024
yy = 		1024
yy = 		1024
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
Error: at 25:1; description: yy is unset variable.
Error: at 28:1; description: goodbye is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/default----------------->>>

<<<----------case: /invoke/option-t----------------->>>
	<<case "option-t" make="invoke-make-stdout-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -t to redirect code output to stdout
		-t
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
ans = 		0
ans = 		1024
ans = 		1024
yy = 		1024
yy = 		1024
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
Error: at 25:1; description: yy is unset variable.
Error: at 28:1; description: goodbye is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-t----------------->>>


<<<----------case: /invoke/option-a----------------->>>
	<<case "option-a" make="invoke-make-template">>
		<<upgen_options>>-al<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -a
		-a -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-a----------------->>>

<<<----------case: /invoke/option-d1----------------->>>
	<<case "option-d1" make="invoke-make-template">>
		<<upgen_options>>-d -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d to enable producing diagnosis information
	for pattern-matching
		-d -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
.................... accept {`sub'}, rule at line: 83 
.................... accept {`='}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`2'}, rule at line: 78 
.................... accept {`-'}, rule at line: 85 
.................... accept {`-'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`-'}, rule at line: 85 
.................... accept {`+'}, rule at line: 85 
.................... accept {`4'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`4'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`-'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`4'}, rule at line: 78 
.................... accept {`^'}, rule at line: 85 
.................... accept {`3'}, rule at line: 78 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`%'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`1011'}, rule at line: 78 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`9'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`216'}, rule at line: 78 
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`24'}, rule at line: 78 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sup'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`('}, rule at line: 85 
.................... accept {`sub'}, rule at line: 83 
.................... accept {` '}, rule at line: 87 
.................... accept {`^'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`3'}, rule at line: 78 
.................... accept {`)'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`list'}, rule at line: 82 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`clear'}, rule at line: 81 
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`sup'}, rule at line: 83 
.................... accept {`?'}, rule at line: 85 
Error: at 8:1; description: sup is unset variable.
.................... accept unprintable-char{10}, rule at line: 85 
.................... accept {`quit'}, rule at line: 80 
.................... accept unprintable-char{10}, rule at line: 85 
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1----------------->>>

<<<----------case: /invoke/option-D2----------------->>>
	<<case "option-D2" make="invoke-make-template">>
		<<upgen_options>>-D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -D to enable producing diagnosis information
	for parsing
		-D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 91.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 187.
Next symbol is -
Shift -, go to state 28
Next symbol is -
Shift -, go to state 12
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 187.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 222.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
Next symbol is +
Shift +, go to state 11
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 187.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 228.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 241.
Next symbol is %
Shift %, go to state 31
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 174.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 101.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
Next symbol is (
Shift (, go to state 14
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 241.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 187.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 233.
Next symbol is /
Shift /, go to state 30
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 241.
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is LIST
Shift LIST, go to state 9
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 132.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is CLEAR
Shift CLEAR, go to state 8
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 128.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 116.
Next symbol is ?
Shift ?, go to state 34
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 116.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
Next symbol is QUIT
Shift QUIT, go to state 10
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 137.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-D2----------------->>>

<<<----------case: /invoke/option-d1D2----------------->>>
	<<case "option-d1D2" make="invoke-make-template">>
		<<upgen_options>>-d -D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d[debug-level] -D[debug-level] to enable producing diagnosis information
	for pattern-matching and parsing
		-d -D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 91.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 187.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 187.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 222.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 85 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`-'}, rule at line: 85 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 187.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 228.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 187.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 152.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`%'}, rule at line: 85 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 241.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 87 
.................... accept {`1011'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 238.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 174.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 101.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 241.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`9'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`216'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 238.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 85 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`24'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 238.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 157.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 85 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`('}, rule at line: 85 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 241.
.................... accept {` '}, rule at line: 87 
.................... accept {`^'}, rule at line: 85 
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 87 
.................... accept {`3'}, rule at line: 78 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 238.
.................... accept {`)'}, rule at line: 85 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 187.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 233.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 85 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 241.
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 162.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`list'}, rule at line: 82 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 132.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`clear'}, rule at line: 81 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 128.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 83 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 85 
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 116.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 116.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`quit'}, rule at line: 80 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 85 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 137.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1D2----------------->>>

<<<----------case: /invoke/option-i----------------->>>
	<<case "option-i" make="invoke-make-template">>
		<<upgen_options>>-il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -i so that pattern will be matched case-insensitively
		-i -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-i----------------->>>

<<<----------case: /invoke/option-l----------------->>>
	<<case "option-l" make="invoke-make-template">>
<<<<-----------<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using option -l to disable location computation
		-l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-l----------------->>>


<<<----------case: /invoke/option-m----------------->>>
	<<case "option-m" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using option -m to disable generating pattern-matching program
		-m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-m----------------->>>

<<<----------case: /invoke/option-p----------------->>>
	<<case "option-p" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using option -p to disable generating pattern-matching program
		-p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-p----------------->>>

<<<----------case: /invoke/option-decl-file----------------->>>
	<<case "option-decl-file" make="invoke-make-template">>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<upgen_options>>-Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		-H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-decl-file----------------->>>


<<<----------case: /invoke/option-sspec----------------->>>
	<<case "option-sspec" make="invoke-make-template">>
		<<upgen_options>>-ls C++<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -s to specify language SPEC to generate code
		-s C++ -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-sspec----------------->>>


<<<----------case: /invoke/option-S----------------->>>
	<<case "option-S" make="invoke-make-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -S to enable default action in pattern-matching
		-S -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-S----------------->>>


<<<----------case: /invoke/option-v----------------->>>
	<<case "option-v" make="invoke-make-template">>
		<<upgen_options>>-lv<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -v to report details on automations
		-v -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-v----------------->>>


<<<----------case: /invoke/option-cmp-d1m----------------->>>
	<<case "option-cmp-d1m" make="invoke-make-template">>
		<<upgen_options>>-d -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1m----------------->>>


<<<----------case: /invoke/option-cmp-d1p----------------->>>
	<<case "option-cmp-d1p" make="invoke-make-template">>
		<<upgen_options>>-d -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
.................... accept {`EOF'}, rule at line: 29 
.................... accept {`['}, rule at line: 32 
undefined symbol `['
.................... accept {`0'}, rule at line: 25 
.................... accept {`-'}, rule at line: 30 
.................... accept {`9'}, rule at line: 25 
.................... accept {`]'}, rule at line: 32 
undefined symbol `]'
.................... accept {`+'}, rule at line: 30 
.................... accept {`quit'}, rule at line: 26 
.................... accept {`-'}, rule at line: 30 
.................... accept {`clear'}, rule at line: 27 
.................... accept {`{'}, rule at line: 32 
undefined symbol `{'
.................... accept {`var'}, rule at line: 29 
.................... accept {`}'}, rule at line: 32 
undefined symbol `}'
.................... accept {`list'}, rule at line: 28 
.................... accept {`+'}, rule at line: 30 
.................... accept {`-'}, rule at line: 30 
.................... accept {`*'}, rule at line: 30 
.................... accept {`/'}, rule at line: 30 
.................... accept {`%'}, rule at line: 30 
.................... accept {`^'}, rule at line: 30 
.................... accept {`='}, rule at line: 30 
.................... accept {`('}, rule at line: 30 
.................... accept {`)'}, rule at line: 30 
.................... accept {`?'}, rule at line: 30 
.................... accept unprintable-char{10}, rule at line: 31 
.................... accept {`\'}, rule at line: 32 
undefined symbol `\'
.................... accept {`n'}, rule at line: 29 
.................... accept unprintable-char{10}, rule at line: 31 
.................... accept {`.'}, rule at line: 32 
undefined symbol `.'
.................... accept unprintable-char{10}, rule at line: 31 
.................... accept {EOF}, rule at line: 34
.................... EOS reached
		<</textfile>>

	<</case>>
<<<----------case: /invoke/option-cmp-d1p----------------->>>


<<<----------case: /invoke/option-cmp-D2p----------------->>>
	<<case "option-cmp-D2p" make="invoke-make-template">>
		<<upgen_options>>-D -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-D -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-D2p----------------->>>


<<<----------case: /invoke/option-cmp-d1D2H----------------->>>
	<<case "option-cmp-d1D2H" make="invoke-make-template">>
		<<upgen_options>>-d -D -Hl<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 90.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 186.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 186.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 221.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 84 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 186.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 227.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`%'}, rule at line: 84 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 240.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 86 
.................... accept {`1011'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 173.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 100.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 86 
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {` '}, rule at line: 86 
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 86 
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 86 
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 86 
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {` '}, rule at line: 86 
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 86 
.................... accept {`9'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 86 
.................... accept {`216'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {` '}, rule at line: 86 
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 86 
.................... accept {`24'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 86 
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 86 
.................... accept {`('}, rule at line: 84 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 240.
.................... accept {` '}, rule at line: 86 
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 86 
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`)'}, rule at line: 84 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 186.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 232.
.................... accept {` '}, rule at line: 86 
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 86 
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 240.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`list'}, rule at line: 81 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 131.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`clear'}, rule at line: 80 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 127.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 84 
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 115.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 115.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`quit'}, rule at line: 79 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 136.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2H----------------->>>

<<<----------case: /invoke/option-cmp-d1D2l----------------->>>
	<<case "option-cmp-d1D2l" make="invoke-make-template">>
		<<upgen_options>>-d -D<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 91.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 183.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 183.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 218.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 150.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 86 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`-'}, rule at line: 86 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 183.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 224.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 150.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 183.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 183.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 150.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`%'}, rule at line: 86 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 237.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 87 
.................... accept {`1011'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 234.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 171.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 101.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 237.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 86 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 86 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 160.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`31'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 155.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 237.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 86 
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`9'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 86 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 155.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`216'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 234.
.................... accept {` '}, rule at line: 87 
.................... accept {`*'}, rule at line: 86 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 160.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 87 
.................... accept {`24'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 234.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 155.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 87 
.................... accept {`='}, rule at line: 86 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 107.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 87 
.................... accept {`('}, rule at line: 86 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 237.
.................... accept {` '}, rule at line: 87 
.................... accept {`^'}, rule at line: 86 
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 87 
.................... accept {`3'}, rule at line: 79 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 234.
.................... accept {`)'}, rule at line: 86 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 183.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 229.
.................... accept {` '}, rule at line: 87 
.................... accept {`/'}, rule at line: 86 
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 87 
.................... accept {`ans'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 160.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 107.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`list'}, rule at line: 83 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 131.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`clear'}, rule at line: 82 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 127.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`sup'}, rule at line: 84 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 86 
Next symbol is ?
Error: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 116.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 116.
Reduce action: Program Line => Program, go to state 2 by rule at 94.
.................... accept {`quit'}, rule at line: 81 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 86 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 136.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2l----------------->>>

<<<----------case: /invoke/option-cmp-d1D2S----------------->>>
	<<case "option-cmp-d1D2S" make="invoke-make-template">>
		<<upgen_options>>-d -D -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -S -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Reduce action: => Program, go to state 2 by rule at 90.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 186.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 186.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 221.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 84 
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`-'}, rule at line: 84 
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 186.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 227.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 186.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 151.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`%'}, rule at line: 84 
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 240.
Next symbol is %
Shift %, go to state 31
.................... accept {`1011'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 173.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 100.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {`31'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 240.
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Shift *, go to state 29
.................... accept {`9'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is /
Shift /, go to state 30
.................... accept {`216'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 237.
.................... accept {`*'}, rule at line: 84 
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is *
Shift *, go to state 29
.................... accept {`24'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 237.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 156.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 84 
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 106.
Next symbol is =
Shift =, go to state 33
.................... accept {`('}, rule at line: 84 
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 240.
.................... accept {`^'}, rule at line: 84 
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 77 
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 237.
.................... accept {`)'}, rule at line: 84 
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 186.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 232.
.................... accept {`/'}, rule at line: 84 
Next symbol is /
Shift /, go to state 30
.................... accept {`ans'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 240.
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 161.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 106.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`list'}, rule at line: 81 
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 131.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`clear'}, rule at line: 80 
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 127.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`sup'}, rule at line: 82 
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 84 
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 115.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 115.
Reduce action: Program Line => Program, go to state 2 by rule at 93.
.................... accept {`quit'}, rule at line: 79 
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 84 
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 136.
Clearup : Pop up unprintable-char{10} from stack
Clearup : Pop up QUIT from stack
Clearup : Pop up Program from stack
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2S----------------->>>

<<<----------case: /invoke/option-cmp-lS----------------->>>
	<<case "option-cmp-lS" make="invoke-make-template">>
		<<upgen_options>>-S <</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -l -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lS----------------->>>


<<<----------case: /invoke/option-cmp-St----------------->>>
	<<case "option-cmp-St" make="invoke-make-stdout-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -t
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
ans = 		0
ans = 		1024
ans = 		1024
yy = 		1024
yy = 		1024
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
Error: at 25:1; description: yy is unset variable.
Error: at 28:1; description: goodbye is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-St----------------->>>


<<<----------case: /invoke/option-cmp-aS----------------->>>
	<<case "option-cmp-aS" make="invoke-make-template">>
		<<upgen_options>>-a -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-a -S -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-aS----------------->>>


<<<----------case: /invoke/option-cmp-pS----------------->>>
	<<case "option-cmp-pS" make="invoke-make-template">>
		<<upgen_options>>-S -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -p -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-pS----------------->>>


<<<----------case: /invoke/option-cmp-mS----------------->>>
	<<case "option-cmp-mS" make="invoke-make-template">>
		<<upgen_options>>-S -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mS----------------->>>


<<<----------case: /invoke/option-cmp-HS----------------->>>
	<<case "option-cmp-HS" make="invoke-make-template">>
		<<upgen_options>>-S -Hl<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -H -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HS----------------->>>

<<<----------case: /invoke/option-cmp-iS----------------->>>
	<<case "option-cmp-iS" make="invoke-make-template">>
		<<upgen_options>>-S -il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -i -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iS----------------->>>

<<<----------case: /invoke/option-cmp-HsC++----------------->>>
	<<case "option-cmp-HsC++" make="invoke-make-template">>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<upgen_options>>-H -ls C++<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		and option -s to specify the programming language to generate code
		-H -s C++ -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HsC++----------------->>>


<<<----------case: /invoke/option-cmp-Hm----------------->>>
	<<case "option-cmp-Hm" make="invoke-make-template">>
		<<upgen_options>>-Hlm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hm----------------->>>

<<<----------case: /invoke/option-cmp-lm----------------->>>
	<<case "option-cmp-lm" make="invoke-make-template">>
		<<upgen_options>>-m<</upgen_options>>
		<<script "invoke-myscanner-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lm----------------->>>

<<<----------case: /invoke/option-cmp-mp----------------->>>
	<<case "option-cmp-mp" make="make-no-exec">>
		<<upgen_options>>-p -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-p -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Warning: No code generated for script `script.upg',
since both pattern-matching and parsing program generation disabled.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mp----------------->>>

<<<----------case: /invoke/option-cmp-msC++----------------->>>
	<<case "option-cmp-msC++" make="invoke-make-template">>
		<<upgen_options>>-s C++ -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s C++ -m -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++----------------->>>

<<<----------case: /invoke/option-cmp-msC++t----------------->>>
	<<case "option-cmp-msC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-s C++ -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s C++ -m -t
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++t----------------->>>

<<<----------case: /invoke/option-cmp-Hp----------------->>>
	<<case "option-cmp-Hp" make="invoke-make-template">>
		<<upgen_options>>-Hlp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hp----------------->>>

<<<----------case: /invoke/option-cmp-Hlp----------------->>>
	<<case "option-cmp-Hlp" make="invoke-make-template">>
		<<upgen_options>>-Hp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -l -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hlp----------------->>>

<<<----------case: /invoke/option-cmp-Hip----------------->>>
	<<case "option-cmp-Hip" make="invoke-make-template">>
		<<upgen_options>>-Hilp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -o FILE
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quIT
operator: -
keyword: CLEar
identifier: var
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hip----------------->>>

<<<----------case: /invoke/option-cmp-ipt----------------->>>
	<<case "option-cmp-ipt" make="invoke-make-stdout-template">>
		<<upgen_options>>-ilp<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -t
*/
			<</desc>>
<<default_action>>.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;
<</default_action>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quIT
operator: -
keyword: CLEar
identifier: var
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
undefined symbol `['
undefined symbol `]'
undefined symbol `{'
undefined symbol `}'
undefined symbol `\'
undefined symbol `.'
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-ipt----------------->>>

<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>
	<<case "option-cmp-HPzzCMD" make="invoke-make-template">>
		<<upgen_options>>-HlP zz<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>

<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>

<<<----------case: /invoke/option-cmp-HPzz----------------->>>
	<<case "option-cmp-HPzz" make="invoke-make-template">>
		<<upgen_options>>-Hl -P xx<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzz----------------->>>

<<<----------case: /invoke/option-cmp-iPzz----------------->>>
	<<case "option-cmp-iPzz" make="invoke-make-template">>
		<<upgen_options>>-il -P xx<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-i -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sUb = Sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
lISt
CLEAR
CLear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sup = 		378298
ans = 		-630
sub = 		-620
sup = 		378298
		<</textfile>>
		<<textfile "result.err">>
Error: at 4:7; description: Sub is unset variable.
Error: at 9:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iPzz----------------->>>

<<<----------case: /invoke/option-cmp-lPzz----------------->>>
	<<case "option-cmp-lPzz" make="invoke-make-template">>
		<<upgen_options>>-P xx<</upgen_options>>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lPzz----------------->>>

<<<----------case: /invoke/option-cmp-mPzz----------------->>>
	<<case "option-cmp-mPzz" make="invoke-make-template">>
		<<upgen_options>>-lm -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-m -P zz FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzz----------------->>>

<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>
	<<case "option-cmp-PzzsC++" make="invoke-make-template">>
		<<upgen_options>>-ls C++ -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-s C++ -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>

<<<----------case: /invoke/option-cmp-PzzS----------------->>>
	<<case "option-cmp-PzzS" make="invoke-make-template">>
		<<upgen_options>>-lS -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-S-P zz -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzS----------------->>>

<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>
	<<case "option-cmp-mPzzsC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-lms C++ -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s C++ -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>

<<<----------case: /invoke/option-cmp-mPzztv----------------->>>
	<<case "option-cmp-mPzztv" make="invoke-make-stdout-template">>
		<<upgen_options>>-lmv -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-v -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzztv----------------->>>

<<<----------case: /invoke/option-cmp-lex+parse----------------->>>
	<<case "option-cmp-lex+parse" make="invoke-make-lex-parse-template">>
		<<EXTRA_DIST>>script.h<</EXTRA_DIST>>
		<<parser_options>>-H -lm<</parser_options>>
		<<scanner_options>>-p -P zz<</scanner_options>>
		<<script "invoke-parser-only-template">>
			<<desc>>/*
features to test: put scanner generated by upgen and parser generated by upgen together
this is parser part.
*/
			<</desc>>
<<option_prefix>>%option prefix=yy<</option_prefix>>
<<prefix>>yy<</prefix>>
		<</script>>
		<<textfile "scanner.upg">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/

%{

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <string>
using std::string;


#include "./script.h"
using namespace yynsx;

#include <cstdlib>

// to avoid copy yytext
extern string	s_strVarName; 
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*


%%

[0-9]+				yylval.nVal = atoi(yytext);
				return NUM;
"quit"				return QUIT;
"clear"				return CLEAR;
"list"				return LIST;
{var}				s_strVarName = yytext;
				return VARI;
[\+\-\*\/\%\^\=\(\)\?\n]	return yytext[0];

.				cerr << "undefined symbol `" << yytext[0] << '\'' << endl;

%%

%%

		<</textfile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lex+parse----------------->>>

<</suite>>
<<<----------sub-suite: /invoke ---------------->>>

<<<----------sub-suite: /empty ---------------->>>
<<suite "empty" make="subdir-makefile-template">>

<<<----------case: /invoke/empty/empty-file----------------->>>
	<<case "empty-file" make="make-no-exec">>
		<<textfile "script.upg">>
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 1:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-file----------------->>>

<<<----------case: /invoke/empty/only-comments----------------->>>
	<<case "only-comments" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: content of script is empty except comments
*/
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 4:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-comments----------------->>>

<<<----------case: /invoke/empty/empty-sect-2----------------->>>
	<<case "empty-sect-2" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-empty-sect-2">>
		<</script>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
		900001
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 0:0.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-2----------------->>>


<<<----------case: /invoke/empty/only-2-sections----------------->>>
	<<case "only-2-sections" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: script contains only 2 sections
*/
%%
.		/* do nothing */
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 6:0.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-2-sections----------------->>>

<<<----------case: /invoke/empty/only-3-sections----------------->>>
	<<case "only-3-sections" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-only-3-sections">>
		<</script>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
		900001
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 0:0.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-3-sections----------------->>>

<<<----------case: /invoke/empty/empty-sect-3----------------->>>
	<<case "empty-sect-3" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "script-empty-sect-3">>
		<</script>>
		<<textfile "test.input">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner." << endl;
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	cout << yytext;
%%

		<</textfile>>
		<<textfile "result.out">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner." << endl;
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	cout << yytext;
%%

		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-3----------------->>>

<</suite>>
<<<----------sub-suite: /empty ---------------->>>


<<<----------sub-suite: /basic ---------------->>>
<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /basic/declare ---------------->>>
	<<suite "declare" make="subdir-makefile-template">>

<<<----------case: /basic/declare/def-header----------------->>>
	<<case "def-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple definition headers
*/
			<</desc>>
			<<declare_section>>

%{
namespace yynsx {
/* definition header 1 */
<<filebuf_decl/>>
int yyparse();

}
%}

%{

using namespace yynsx;

/* definition header 2*/
int main(int argc, char **argv) {

<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");	
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
%}
			<</declare_section>>
		<</script>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/def-header----------------->>>


<<<----------case: /basic/declare/decl-header----------------->>>
	<<case "decl-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple declaration headers
*/
			<</desc>>
			<<declare_section>>

%header%{
namespace yynsx {
/* declaration header 1 */
<<filebuf_decl/>>

}
%}

%header%{
/* declaration header 2*/
void showAccept(void);
%}

%{
/* definition header */
void showAccept(void) {
	printf("This text is accepted by parenthese extracter.\n");
}
%}

			<</declare_section>>
			<<accept_action>>
showAccept();
			<</accept_action>>
			<<code_section>>
using namespace yynsx;
			
int main(int argc, char **argv) {

<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		fprintf(stderr, "Error: failed to initialize scanner.\n");	
		return -1;
	}

	yyparse();
<<after_buffer_usage/>>
	return 0;
}
			<</code_section>>
		<</script>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
This text is accepted by parenthese extracter.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/decl-header----------------->>>


<<<----------case: /basic/declare/svt-decl-01----------------->>>
	<<case "svt-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: using %union to declare semantic value type
*/
			<</desc>>

			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-01----------------->>>


<<<----------case: /basic/declare/svt-decl-02----------------->>>
	<<case "svt-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define svt-to-be union in definition header
			and declare it as semantic value type by %union 
*/
			<</desc>>

			<<union_code>>
union mysvt_t {
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-02----------------->>>

<<<----------case: /basic/declare/svt-decl-03----------------->>>
	<<case "svt-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 1
*/
			<</desc>>

			<<union_code>>
union mysvt_t {
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>
			<<location_code>>
struct myloc_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};
			<</location_code>>

			<<union_decl>>
%union mysvt_t
%union%{
	int nVal;
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-03----------------->>>

<<<----------case: /basic/declare/svt-decl-04----------------->>>
	<<case "svt-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 2
*/
			<</desc>>
			<<union_code>>
union mysvt_t {
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}

%union%{
	int nVal;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}

%union mysvt_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-04----------------->>>

<<<----------case: /basic/declare/loc-decl-01----------------->>>
	<<case "loc-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define location-to-be struct in definition header
			and declare it as location type by %location 
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
struct myloc_t{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-01----------------->>>

<<<----------case: /basic/declare/loc-decl-02----------------->>>
	<<case "loc-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 1
*/
			<</desc>>

			<<union_code>>
union mysvt_t {
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
};
			<</union_code>>
			<<location_code>>
struct myloc_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location myloc_t
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
%}
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-02----------------->>>

<<<----------case: /basic/declare/loc-decl-03----------------->>>
	<<case "loc-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 2
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
struct myloc_t {
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
};

struct illegal_loc_t {
	int firstLine;
	int lastLine;
};
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}

%location illegal_loc_t
			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-03----------------->>>

<<<----------case: /basic/declare/loc-decl-04----------------->>>
	<<case "loc-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 3
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union%{
	int nVal;
	struct {
		int wordCounter;
		int charCounter;
	} nPair;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	int firstLine;
	int firstColumn;
	int lastLine;
	int lastColumn;
	int sentenceNo;
%}
%location%{
	int firstLine;
	int lastLine;
%}
%location int

			<</location_decl>>
		<</script>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-04----------------->>>

<<<----------case: /basic/declare/parse-param-01----------------->>>
	<<case "parse-param-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param 
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-01----------------->>>

<<<----------case: /basic/declare/parse-param-02----------------->>>
	<<case "parse-param-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param,
			but declare more than once
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}

/* if it were to use this declaration, C++ compiler would have complained */
%formal-param%{int illegal_declaration%}
%actual-param%{illegal_variable%}
			<</parse_param>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-02----------------->>>


<<<----------case: /basic/declare/destructor-01----------------->>>
	<<case "destructor-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 1: destructor specified by symbol
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
	stack_pop();
%} TagHead

%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
%} '('

%destructor%{
	fprintf(stderr, "discard tail: %s.\n", $$);
%} ')'
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard head: tables.
discard head: table.
discard head: table.
discard head: body.
discard head: html.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-01----------------->>>


<<<----------case: /basic/declare/destructor-02----------------->>>
	<<case "destructor-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 2: destructor for untagged symbols
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard undefined symbol.\n");
%} <>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-02----------------->>>

<<<----------case: /basic/declare/destructor-03----------------->>>
	<<case "destructor-03" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 3: destructor specified by semantic value type
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard tag: %s.\n", $$);
%} <pchval>

%destructor%{
	fprintf(stderr, "discard at level: %d.\n", $$);
%} <level>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard tag: tables.
discard at level: 4.
discard tag: table.
discard at level: 3.
discard tag: table.
discard at level: 2.
discard tag: body.
discard at level: 1.
discard tag: html.
discard at level: 0.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-03----------------->>>


<<<----------case: /basic/declare/destructor-04----------------->>>
	<<case "destructor-04" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: different kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
	stack_pop();
%} TagHead

%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
%} '('

%destructor%{
	fprintf(stderr, "discard tag: %s.\n", $$);
%} <pchval>

%destructor%{
	fprintf(stderr, "discard at level: %d.\n", $$);
%} <level>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-04----------------->>>


<<<----------case: /basic/declare/destructor-05----------------->>>
	<<case "destructor-05" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: all kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
	stack_pop();
%} TagHead

%destructor%{
	fprintf(stderr, "discard head: %s.\n", $$);
%} '('

%destructor%{
	fprintf(stderr, "discard tag: %s.\n", $$);
%} <pchval>

%destructor%{
	fprintf(stderr, "discard at level: %d.\n", $$);
%} <level>

%destructor%{
	fprintf(stderr, "discard undefined symbol.\n");
%} <>
			<</destructor>>

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-05----------------->>>

<<<----------case: /basic/declare/parsevar-decl----------------->>>
	<<case "parsevar-decl" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare local variables in yyparse 
			by %parsevar-decl
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
%}
			<</parsevar_decl>>

			<<exprs_action>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-decl----------------->>>

<<<----------case: /basic/declare/parsevar-init----------------->>>
	<<case "parsevar-init" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: initialize local variables in yyparse 
			by %parsevar-init
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
	triple_t tpl;
%}
			<</parsevar_decl>>

			<<parsevar_init>>
%parsevar-init%{
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
%}
			<</parsevar_init>>

			<<exprs_action>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-init----------------->>>

<<<----------case: /basic/declare/start-symbol----------------->>>
	<<case "start-symbol" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare start symbol by %start
*/
			<</desc>>
			<<start_symbol>>
%start SText
			<</start_symbol>>
			<<parse_param>>
/* parameters for yyparse */
%formal-param%{triple_t &tpl%}
%actual-param%{tpl%}
			<</parse_param>>

			

			<<before_yyparse>>
	triple_t tpl;
	tpl.maxdep = 0;
	tpl.curdep = 0;
	tpl.pairnum = 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	fprintf(stdout, "max depth: %d\tnumber of parenthese: %d\n", tpl.maxdep, tpl.pairnum);
			<</after_yyparse>>

		<</script>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
			</table>
		</table>
	</body>
</html>
Tag checking passed.
Input text is accepted by tag-check grammar.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 2:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/start-symbol----------------->>>

<<<----------case: /basic/declare/dprec-rrc----------------->>>
	<<case "dprec-rrc" make="basic-make-template">>
		<<script "script-dprec-rrc">>
		<</script>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[func a b [sub c d]]
[+ [* a [/ b [^ c [* [% d e] f]]]] [sin [cos [tan [exp x]]]]]
[define myfun [a b]
	[cond a] [[display a]]
	[else] [[display b]]
]
Done!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/dprec-rrc----------------->>>

<<<----------case: /basic/declare/lex-init-action----------------->>>
	<<case "lex-init-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare lex initialization action by %lex-init
*/
			<</desc>>
			<<init_code>>
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
			<</init_code>>
			<<lex_init>>
%lex-init%{ fprintf(stdout, "start scanning...\n");%}
			<</lex_init>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
start scanning...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
start scanning...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lex-init-action----------------->>>


<<<----------case: /basic/declare/pre-match-action----------------->>>
	<<case "pre-match-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare pre-match action (just ahead of any lexical action)
			 by %pre-match
*/
			<</desc>>
			<<init_code>>
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
			<</init_code>>
			<<pre_match>>
%pre-match%{ if(yyleng > 0) {++mc;} %}
			<</pre_match>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 54
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 83
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/pre-match-action----------------->>>


<<<----------case: /basic/declare/lexvar-decl----------------->>>
	<<case "lexvar-decl" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare local variables for yylex by %lexvar-decl or %lvar-decl
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
%}
			<</lvar_decl>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-decl----------------->>>


<<<----------case: /basic/declare/lexvar-init----------------->>>
	<<case "lexvar-init" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: initialize local variables for yylex by %lexvar-init or %lvar-init
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
%}
			<</lvar_decl>>

			<<lvar_init>>
%lvar-init%{ ic = 0; rc = 0; oc = 0; mc = 0; dc = 0; %}
			<</lvar_init>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-init----------------->>>

<<<----------case: /basic/declare/yywrap-action----------------->>>
	<<case "yywrap-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare yywrap action by %yywrap
*/
			<</desc>>
			<<init_code>>
// integer counter
int ic = 0;
// real(excluding integer) counter
int rc = 0;
// operator counter
int oc = 0;
// number of matched pattern
int mc = 0;
// discarded symbols;
int dc = 0;
			<</init_code>>
			<<yywrap>>
%yywrap%{
	fprintf(stdout, "file switching ...\n");
	return false;
%}
			<</yywrap>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
file switching ...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
file switching ...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/yywrap-action----------------->>>

<<<----------case: /basic/declare/lexical-actions----------------->>>
	<<case "lexical-actions" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: using %lex-init %pre-match
			%lexvar-decl %lexvar-init %yywrap
*/
			<</desc>>
<<lvar_decl>>
%lvar-decl%{
// integer counter
int ic;
// real(excluding integer) counter
int rc;
// operator counter
int oc;
// number of matched pattern
int mc;
// discarded symbols;
int dc;
%}
<</lvar_decl>>

<<lvar_init>>
%lvar-init%{ ic = 0; rc = 0; oc = 0; mc = 0; dc = 0; %}
<</lvar_init>>

<<lex_init>>
%lex-init%{ fprintf(stdout, "start scanning...\n");%}
<</lex_init>>

<<pre_match>>
%pre-match%{ if(yyleng > 0) {++mc;} %}
<</pre_match>>

<<yywrap>>
%yywrap%{
	if(yy_has_buffer()) {
		fprintf(stdout, "file switching ...\n");
		return 0;
	}
	return 1;
%}
<</yywrap>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
start scanning...
file switching ...
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 30
start scanning...
file switching ...
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 29
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexical-actions----------------->>>


<<<----------case: /basic/declare/token-decl-01----------------->>>
	<<case "token-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 1
*/
			<</desc>>
			<<token_decl>>
%token '+' '-'
%token '*' '/'
%token '^'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-01----------------->>>

<<<----------case: /basic/declare/token-decl-02----------------->>>
	<<case "token-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 2
*/
			<</desc>>
			<<token_decl>>
%token '\+' '\-'
%token '\*' '\/'
%token '\^'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-02----------------->>>

<<<----------case: /basic/declare/token-decl-03----------------->>>
	<<case "token-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2b' '\x2d'
/* '*' '/' */
%token '\x2a' '\x2f'
/* '^' */
%token '\x5e'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-03----------------->>>

<<<----------case: /basic/declare/token-decl-04----------------->>>
	<<case "token-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\X2B' '\X2D'
/* '*' '/' */
%token '\X2A' '\X2F'
/* '^' */
%token '\X5E'
			<</token_decl>>
		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-04----------------->>>


<<<----------case: /basic/declare/token-decl-05----------------->>>
	<<case "token-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2B' '\X2d'
/* '*' '/' */
%token '\X2a' '\x2F'
/* '^' */
%token '\X5E'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-05----------------->>>


<<<----------case: /basic/declare/token-decl-06----------------->>>
	<<case "token-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\053' '\055'
/* '*' '/' */
%token '\052' '\057'
/* '^' */
%token '\136'
			<</token_decl>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		-64[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-06----------------->>>


<<<----------case: /basic/declare/type-decl----------------->>>
	<<case "type-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare types(also called non-terminals) in grammar
			by %type
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<type_decl>>
%type<nVal> Lines Task
			<</type_decl>>

			<<other_decl>>
%destructor%{
	fprintf(stdout, "%ld lines included in this task.\n", $$);
%} Task
			<</other_decl>>

			<<type_action_0>>
$$ = $1;
			<</type_action_0>>
			<<type_action_1>>
$$ = $1 + 1;
			<</type_action_1>>
			<<type_action_2>>
$$ = 0;
			<</type_action_2>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
14 lines included in this task.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/type-decl----------------->>>


<<<----------case: /basic/declare/left-decl-01----------------->>>
	<<case "left-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 1
*/
			<</desc>>
			<<token_decl>>
%left '+' '-'
%left '*' '/'
%left '^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-01----------------->>>

<<<----------case: /basic/declare/left-decl-02----------------->>>
	<<case "left-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 2
*/
			<</desc>>
			<<token_decl>>
%left '\+' '\-'
%left '\*' '\/'
%left '\^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-02----------------->>>

<<<----------case: /basic/declare/left-decl-03----------------->>>
	<<case "left-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%left '\x5e'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-03----------------->>>

<<<----------case: /basic/declare/left-decl-04----------------->>>
	<<case "left-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-04----------------->>>


<<<----------case: /basic/declare/left-decl-05----------------->>>
	<<case "left-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-05----------------->>>


<<<----------case: /basic/declare/left-decl-06----------------->>>
	<<case "left-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%left '\136'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		0.523599[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-06----------------->>>


<<<----------case: /basic/declare/right-decl-01----------------->>>
	<<case "right-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 1
*/
			<</desc>>
			<<token_decl>>
%right '+' '-'
%right '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-01----------------->>>

<<<----------case: /basic/declare/right-decl-02----------------->>>
	<<case "right-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 2
*/
			<</desc>>
			<<token_decl>>
%right '\+' '\-'
%right '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-02----------------->>>

<<<----------case: /basic/declare/right-decl-03----------------->>>
	<<case "right-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2b' '\x2d'
/* '*' '/' */
%right '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-03----------------->>>

<<<----------case: /basic/declare/right-decl-04----------------->>>
	<<case "right-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\X2B' '\X2D'
/* '*' '/' */
%right '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-04----------------->>>


<<<----------case: /basic/declare/right-decl-05----------------->>>
	<<case "right-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2B' '\X2d'
/* '*' '/' */
%right '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-05----------------->>>


<<<----------case: /basic/declare/right-decl-06----------------->>>
	<<case "right-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\053' '\055'
/* '*' '/' */
%right '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-06----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>
	<<case "nonassoc-decl-01" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 1
*/
			<</desc>>
			<<token_decl>>
%nonassoc '+' '-'
%left '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>
	<<case "nonassoc-decl-02" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 2
*/
			<</desc>>
			<<token_decl>>
%nonassoc '\+' '\-'
%left '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>
	<<case "nonassoc-decl-03" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>
	<<case "nonassoc-decl-04" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>
	<<case "nonassoc-decl-05" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>
	<<case "nonassoc-decl-06" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>


<<<----------case: /basic/declare/parse-init-decl----------------->>>
	<<case "parse-init-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's initialization action by %parse-init,
			which is performed immediate before yyparse is ready to parsing 
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_init>>
%parse-init%{
	fprintf(stdout, "Let\'s get down to work.\n");
	errors = 0;
%}
			<</parse_init>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
Let's get down to work.
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-init-decl----------------->>>


<<<----------case: /basic/declare/parse-exit-decl----------------->>>
	<<case "parse-exit-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's exit action by %parse-exit,
			which is performed immediate before return from yyparse
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_exit>>
%parse-exit%{
	if(errors > 0) {
		fprintf(stdout, "%d errors occurred.\n", errors);
	}
	fprintf(stdout, "Well done! Thank you for your excellent work, Mr. Parser.\n");
%}
			<</parse_exit>>

		<</script>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
+16^-1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
+16^-1.5
		0.015625[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		1.31472e+06[REAL]
33 / 2.0
		16.5[REAL]
59.27 * 23.99
		1421.89[REAL]
+7 - 25
		-18[INT]
1 errors occurred.
Well done! Thank you for your excellent work, Mr. Parser.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-exit-decl----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/declare ---------------->>>


<<<----------sub-suite: /basic/interface -------------->>>
	<<suite  "interface" make="subdir-makefile-template">>


<<<----------case: /basic/interface/buffer-stack----------------->>>
	<<case "buffer-stack" make="basic-make-template">>
		<<script "interface-bstack-template">>
		<</script>>

		<<textfile "test.input">>
***************************************
test lcase number test1
lcase> open "cur?*************************
in lcase
abcdefg
close hijklm"
cur?
number> open 'cur?************************
in number
1234567
pop
89'
cur?
test1> open `test1.input`
pop
closing can not be executed, because of popping action
close
text ignored
		<</textfile>>

		<<textfile "test1.input">>
cur?**************************
in test1 test2 ucase
test2> open `test2.input`
cur?
ucase> open "cur?************************
ABCDEF
pop
XYZ"

******************test yy_push_buffer***********************
test2> push `test2.input`
******************test yy_push_buffer***********************
test3> push `test3.input`

pop
abortion can not executed, because of popping action
 
abort
		<</textfile>>

		<<textfile "test2.input">>
cur?**************************
in test2 chinese test3
chinese> open "
测试文本
close
此处文本应该看不见Over"
test3> open `test3.input`
close
test ignored
		<</textfile>>

		<<textfile "test3.input">>
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
***************************************
test lcase number test1
current buffer: lcase
*************************
in lcase
abcdefg
closing buffer lcase ...
switching to buffer test ...

current buffer: test

current buffer: number
************************
in number
1234567
popping buffer number ...
switching to buffer test ...

current buffer: test

current buffer: test1
**************************
in test1 test2 ucase
current buffer: test2
**************************
in test2 chinese test3

测试文本
closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

current buffer: test1

current buffer: ucase
************************
ABCDEF
popping buffer ucase ...
switching to buffer test1 ...


******************test yy_push_buffer***********************
current buffer: test2
**************************
in test2 chinese test3

测试文本
closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

******************test yy_push_buffer***********************
current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.


popping buffer test1 ...
switching to buffer test ...

popping buffer test ...
All buffers closed.
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/buffer-stack----------------->>>

<<<----------case: /basic/interface/ECHO----------------->>>
	<<case "ECHO" make="basic-make-template">>
		<<script "interface-echo-template">>
		<</script>>

		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/ECHO----------------->>>


<<<----------case: /basic/interface/get-bol----------------->>>
	<<case "get-bol" make="basic-make-template">>
		<<script "interface-getbol-template">>
		<</script>>

		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/get-bol----------------->>>


<<<----------case: /basic/interface/line-editor----------------->>>
	<<case "line-editor" make="basic-make-template">>
		<<script "interface-line-editor-template">>
		<</script>>

		<<textfile "test.input">>
Just e!01image!01ine, what is goning to be link!02ke if you are travelling in the outer space.!!no useful
Simply beatui!03utiful, yes that must &be very @-05good.
Hey&, wait a minute@01 it's simply &too good @02 be true. Please &stop, @04 dreaming&!&!&!
		<</textfile>>

		<<textfile "result.out">>
Just imagine, what is goning to be like if you are travelling in the outer space.
Simply beautiful, yes that must be very very good.
Hey, wait a minute, it's simply too good to be true. Please stop, stop dreaming!!!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/line-editor----------------->>>


<<<----------case: /basic/interface/loc2----------------->>>
	<<case "loc2" make="basic-make-template">>
		<<script "interface-loc2-template">>
		<</script>>

		<<textfile "test.input">>
#location_head
%$103
%%$$205
%%%$$$307
%%%%$$$$409
%%%%%$$$$$511
%%%%%%$$$$$$613
%%%%%%%$$$$$$$715
%%%%%%%%$$$$$$$$817

%a02%a06$a10
%%%%$$$$b09
%%%%$$$c08
%%%%$$d07
%%%%$$$$$%%%$%%%$$%%%$%%$$$$$$$e32
#location_tail


#location_head
%	109 %%		125 %%%			149 %%%%				189 %%%%%					1d7 %%%%%%						1j3 %%%%%%%							1p7 %%%%%%%%								1w9  %1x5%1x9	1y5 %%%%				1C5 %%%%			1F7 %%%%		1I1 %%%%	1J7
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#location_tail



tab=8

#tab_replace 0
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#tab_replace

tab?

#line_replace 1
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#line_replace




#orignal 2
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#orignal



#orignal 3
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#orignal

		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
after reseting, line: 1	col: 1
begin scanning tab_replace section by referrence 0
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning tab_replace section is over
begin comparing location(size 15) 0 and its referrence(size 15)
tabsize = 8
after reseting, line: 1	col: 1
begin scanning line_replace section by referrence 1
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning line_replace section is over
begin comparing location(size 15) 1 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 2
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 2 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 3
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 3 and its referrence(size 15)
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc2----------------->>>

<<<----------case: /basic/interface/loc1----------------->>>
	<<case "loc1" make="basic-make-template">>
		<<script "interface-location-template">>
		<</script>>

		<<textfile "test.input">>
tab=8
<test1.input>	217
301 305 309	317		333 337  342   348    355     363	373
tab=6
<test2.input>	519
601 605 609	613		625 629  634   640    647     655	661
		<</textfile>>

		<<textfile "test1.input">>
tab?
 202 206  211	217			229	233
tab=1	307
 402 406  411	415			421	425	
		<</textfile>>

		<<textfile "test2.input">>
tab=3
   204	210	216			228 232
tab?	307
		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
file `test1.input` is open.
tabsize = 4
tabsize is 1 now
file closed.
tabsize is 6 now
file `test2.input` is open.
tabsize is 3 now
tabsize = 3
file closed.
file closed.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc1----------------->>>


<<<----------case: /basic/interface/tinyfp----------------->>>
	<<case "tinyfp" make="basic-make-template">>
		<<script "interface-tinyfp-template">>
		<</script>>

		<<textfile "test.input">>
; scheme sample
#| test parsing expression of scheme
|#


(define (square x) (* x x))
(define (4times x) 
  (
    (lambda (a)
      (* a a))
    (square x)))

(define macro1 "(lambda (x) \'(Hi , x)
)")
;((lambda (x) '(Hi , x)) 3)
(eval macro1 3)
(ceval macro1 "world")

(define f1 "test1.input")
(load f1)


(define (sqrt y)
  
  (define (over? xm xn)
    (if
      (< (ceval m1 (- xm xn)) 0.00001)
      #t
      #f))
  (define (nextx xm)
    (/ (+ xm (/ y xm)) 2))
  (define (xsqrt xm)
    (if (over? xm (nextx xm))
      xm
      (xsqrt (nextx xm))))
  (xsqrt 1)
)

(sqrt 2.0)


(define f1 "test1.input")
(load f1)

(root dsqr 16.0 0.0001)
(root dcub 64.0 0.00001)

		<</textfile>>

		<<textfile "test1.input">>
(define m1 "(define (xabs a)
    (if
      (< a 0)
      (- 0 a)
      a))")

(define (root expr y e)
  (define (fabs n)
    (if (< n 0)
      (- 0 n)
      n))
  (define (ok? x xn)
    (< (fabs (- x xn)) e))
  (define (nextx x)
    (expr x y))
  (define (xroot x)
    (if (ok? x (nextx x))
      x
      (xroot (nextx x))))
  (xroot 1.0)
)

(define dsqr
  (lambda (x y)
    (/
      (+ x (/ y x))
    2.0)
  ))

(define dcub
  (lambda (x y)
   (/
     (+ (* x 2.0) (/ y (* x x)))
   3.0)
  ))
      
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
expand macro `macro1', its content is `(lambda (x) '(Hi , x)
)'
expand macro `macro1', its content is `(lambda (x) '(Hi , x)
)'
open file `f1', its content is `test1.input'
expand macro `m1', its content is `(define (xabs a)(if(< a 0)(- 0 a)a))'
open file `f1', its content is `test1.input'
parsing scheme program succeeded
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/tinyfp----------------->>>


<<<----------case: /basic/interface/yyerror----------------->>>
	<<case "yyerror" make="basic-make-template">>
		<<script "interface-yyerror-template">>
		<</script>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9

		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Redirect to my error-handler ---- Error: syntax error at 1:7.
Redirect to my error-handler ---- Error: syntax error at 2:1.
Redirect to my error-handler ---- Error: syntax error at 3:1.
Redirect to my error-handler ---- Error: syntax error at 4:1.
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/yyerror----------------->>>


<<<----------case: /basic/interface/esc-char-inaction----------------->>>
	<<case "esc-char-inaction" make="basic-make-template">>
		<<script "esc-char-inaction-template">>
		<</script>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9
end
well done!

		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
in parsevar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parsevar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$1 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 1
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 2
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 3
$$ is used to count number of numbers, and $$ is 3
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is begin
$$ is used to count number of numbers, and $$ is 3
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is add
$$ is used to count number of numbers, and $$ is 3
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 4
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 5
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is sub
$$ is used to count number of numbers, and $$ is 5
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 6
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 7
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is div
$$ is used to count number of numbers, and $$ is 7
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 8
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 9
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is end
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is well
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is done
$$ is used to count number of numbers, and $$ is 9
in lexvar-decl: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in yywrap: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-exit: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/esc-char-inaction----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/interface -------------->>>


<</suite>>
<<<----------sub-suite: /basic ---------------->>>


<</suites>>
<<<----------top-level suite: / ---------->>>

<<conf make="config-template">>
<<version>>0.50.101<</version>>
<<email>>upgen.tools@yahoo.com<</email>>
<<diff>>diff<</diff>>
<</conf>>

