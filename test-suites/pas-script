<<<< ------------------------------ global setting
<<settings>>


	<<group>>
<<<<<<<------------------ input from file
<<buffer_init>>lexfile(paramstr(1), false)<</buffer_init>>
<<buffer_init2>>lexfile(paramstr(1), false)<</buffer_init2>>
<<buffer_init3>>lexfile(paramstr(1), false)<</buffer_init3>>
<<inputed_file>> test.input <</inputed_file>>
<<before_myinput>>
	new(s_pfile);
	assignfile(s_pfile^, paramstr(1));
	reset(s_pfile^);
<</before_myinput>>
<<stream_type>>pas-file.log<</stream_type>>
>>>>>>>------------------ input from file
	<</group>>


	<<group>>
<<<<<<------------------ input from stdin
<<buffer_init>>lexfile('', true)<</buffer_init>>
<<buffer_init2>>lexfile('', true)<</buffer_init2>>
<<buffer_init3>>lexfile('', false)<</buffer_init3>>
<<inputed_file>> < test.input <</inputed_file>>
<<before_myinput>>s_pfile := @input;<</before_myinput>>
<<stream_type>>pas-stdin.log<</stream_type>>
>>>>>>------------------- input from stdin
	<</group>>

	
	<<group>>
<<<<<<<------------------ input from buffer
<<main_var_decl>>
var
	buffer_content: pchar;
	tt2: integer;
	f: file;
<</main_var_decl>>

<<before_buffer_init>>
	if paramcount < 1 then
	begin
		writeln('Error: file name expected.');
		exit;
	end;
	
	if not fileexists(paramstr(1)) then
	begin
		writeln('Error: failed to access file `', paramstr(1), '''.');
		exit;
	end;
	
	buffer_content := nil;
	tt2 := 0;
	
	assignfile(f, paramstr(1));
	reset(f, 1);
	try
		tt2 := filesize(f);
		getmem(buffer_content, tt2 + 1);
	except
	on e: EOutOfMemory do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to allocate memory for buffer');
			closefile(f);
			exit;
		end;
	end;
	
	try
		blockread(f, buffer_content^, tt2);
	except
	on e: EInOutError do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to read data from file');
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	end;
	
	closefile(f);
	buffer_content[tt2] := #0;
	tt2 := tt2 + 1;
	
<</before_buffer_init>>

<<after_buffer_usage>>
	if buffer_content <> nil then
		freemem(buffer_content);
<</after_buffer_usage>>

<<buffer_init>>lexstr(buffer_content, tt2)<</buffer_init>>
<<buffer_init2>>lexstr(buffer_content, tt2)<</buffer_init2>>
<<buffer_init3>>lexstr(buffer_content, tt2)<</buffer_init3>>
<<inputed_file>> test.input <</inputed_file>>
<<before_myinput>>
	new(s_pfile);
	assignfile(s_pfile^, paramstr(1));
	reset(s_pfile^);
<</before_myinput>>
<<stream_type>>pas-buffer.log<</stream_type>>
>>>>>>>------------------ input from buffer
	<</group>>


	<<group>>
<<<<<<<------------------ input from copied buffer
<<main_var_decl>>
var
	buffer_content: pchar;
	tt2: integer;
	f: file;
<</main_var_decl>>
<<before_buffer_init>>
	if paramcount < 1 then
	begin
		writeln('Error: file name expected.');
		exit;
	end;
	
	if not fileexists(paramstr(1)) then
	begin
		writeln('Error: failed to access file `', paramstr(1), '''.');
		exit;
	end;
	
	buffer_content := nil;
	tt2 := 0;
	
	assignfile(f, paramstr(1));
	reset(f, 1);
	try
		tt2 := filesize(f);
		getmem(buffer_content, tt2 + 1);
	except
	on e: EOutOfMemory do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to allocate memory for buffer');
			closefile(f);
			exit;
		end;
	end;
	
	try
		blockread(f, buffer_content^, tt2);
	except
	on e: EInOutError do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to read data from file');
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	end;
	
	closefile(f);
	buffer_content[tt2] := #0;
	tt2 := tt2 + 1;
	
<</before_buffer_init>>

<<after_buffer_usage>>
	if buffer_content <> nil then
		freemem(buffer_content);
<</after_buffer_usage>>

<<buffer_init>>lexcstr(buffer_content, tt2)<</buffer_init>>
<<buffer_init2>>lexcstr(buffer_content, tt2)<</buffer_init2>>
<<buffer_init3>>lexcstr(buffer_content, tt2)<</buffer_init3>>
<<inputed_file>> test.input <</inputed_file>>
<<before_myinput>>
	new(s_pfile);
	assignfile(s_pfile^, paramstr(1));
	reset(s_pfile^);
<</before_myinput>>
<<stream_type>>pas-cbuffer.log<</stream_type>>
>>>>>>>------------------ input from copied buffer
	<</group>>


<<prefix>>yy<</prefix>>
<<option_prefix>>%option prefix=yy<</option_prefix>>

<<s2i_map_define>>
{
s2i_map_t: string to integer map class, using red-black tree
	insert string & integer pair
	delete pair corresponding to a given string
	find value corresponding to a given string

    
The book INTRODUCTION TO ALGORITHMS by
	Thomas H. Cormen,
	Charles E. Leiserson,
	Ronald L. Rivest
	Clifford Stein
cover the details of algorithms of red-black tree.
}

type
	key_type = string;
	value_type = integer;
	elem_type  = record
		first: key_type;
		second: value_type;
	end;	  
   	pelem_type = ^elem_type;
   	
	pnode_type = ^node_type;
	node_type  = record
		key: key_type;
		value: value_type;
		parent: pnode_type;
		left: pnode_type;
		right: pnode_type;
		black: boolean;
	end;
	
	rbtree_t = class
	private
		root: pnode_type;
		xzero: pnode_type;
	public
		constructor create;
		destructor destroy; override;
		procedure clear;
		function zero: pnode_type;
		function locate(k: key_type): pnode_type;
		function find(k: key_type; var v: value_type): boolean;
		function insert(e: elem_type): boolean; overload;
		function insert(k: key_type; v: value_type): boolean; overload;
		function delete(k: key_type): boolean;
		function start: pnode_type; overload;
		function start(p: pnode_type): pnode_type; overload;
		function finish: pnode_type;
		function next(p: pnode_type): pnode_type;
	private
		procedure left_rotate(var x: pnode_type);
		procedure right_rotate(var x: pnode_type);
		procedure insert_fixup(var x: pnode_type);
		procedure delete_fixup(var x: pnode_type);
	end;
	
	s2i_pair_t = elem_type;
	s2i_it_t = pnode_type;
	s2i_cit_t = pnode_type;
	
	s2i_map_t = class
	private
		rbt: rbtree_t;
	public
		constructor create;
		destructor destroy; override;
		procedure clear;
		function find(k: key_type; var v: value_type): boolean;
		function value(k: key_type): value_type;
		procedure setvalue(e: elem_type); overload;
		procedure setvalue(k: key_type; v: value_type); overload;
		function insert(e: elem_type): boolean; overload;
		function insert(k: key_type; v: value_type): boolean; overload;
		function delete(k: key_type): boolean;
		function start: pnode_type;
		function finish: pnode_type;
		function next(p: pnode_type): pnode_type;
	end;

constructor rbtree_t.create;
begin
	inherited;
	new(xzero);
	xzero^.left := nil;
	xzero^.right := nil;
	xzero^.parent := nil;
	xzero^.key := '^';
	xzero^.value := -1;
	xzero^.black := true;
	root := xzero;
end;

destructor rbtree_t.destroy;
begin
	clear;
	dispose(xzero);
	inherited;
end;

procedure rbtree_t.clear;
var
	p, q: pnode_type;
begin
	
	xzero^.left := nil;
	xzero^.right := nil;
	xzero^.parent := nil;
	xzero^.key := '^';
	xzero^.value := -1;
	xzero^.black := true;
	p := root;
	
	while p <> xzero do
	begin
		while true do
		begin
			if p^.left <> xzero then
			begin
				q := p;
				p := p^.left;
				q^.left := xzero;
			end
			else if p^.right <> xzero then
			begin
				q := p;
				p := p^.right;
				q^.right := xzero;
			end
			else
				break;
		end;
		
		q := p^.parent;
				
		dispose(p);
		p := q;
	end;
	
	root := xzero;
end;

function rbtree_t.zero: pnode_type;
begin
	zero := xzero;
end;

function rbtree_t.start: pnode_type;
begin
	start := start(root);
end;

function rbtree_t.start(p: pnode_type): pnode_type;
begin
	while (p <> xzero) and (p^.left <> xzero) do
		p := p^.left;
	start := p;
end;

function rbtree_t.finish: pnode_type;
begin
	finish := xzero;
end;

function rbtree_t.next(p: pnode_type): pnode_type;
var
	q: pnode_type;
begin
	if p^.right <> xzero then
		next := start(p^.right)
	else
	begin
		q := p^.parent;
		while (q <> xzero) and (p = q^.right) do
		begin
			p := q;
			q := q^.parent;
		end;
		
		next := q;
	end;
end;


procedure rbtree_t.left_rotate(var x: pnode_type);
var
	p, r: pnode_type;
begin
	r := x^.right;
	x^.right := r^.left;
	if r^.left <> xzero then
		r^.left^.parent := x;
	r^.left := x;
	
	p := x^.parent;
	if p = xzero then
		root := r
	else
	begin
		if x = p^.left then
			p^.left := r
		else
			p^.right := r;	
	end;
	r^.parent := p;
	x^.parent := r;
end;


procedure rbtree_t.right_rotate(var x: pnode_type);
var
	p, lft: pnode_type;
begin
	lft := x^.left;
	x^.left := lft^.right;
	if lft^.right <> xzero then
		lft^.right^.parent := x;
	lft^.right := x;
	
	p := x^.parent;
	if p = xzero then
		root := lft
	else
	begin
		if x = p^.left then
			p^.left := lft
		else
			p^.right := lft;
	end;
	lft^.parent := p;
	x^.parent := lft;
end;


function rbtree_t.locate(k: key_type): pnode_type;
var
	p: pnode_type;
begin
	p := root;
	while p <> xzero do
	begin
		if p^.key > k then
			p := p^.left
		else if p^.key < k then
			p := p^.right
		else break;
	end;
	locate := p;
end;

function rbtree_t.find(k: key_type; var v: value_type): boolean;
var
	p: pnode_type;
begin
	p := locate(k);
	if p <> xzero then begin
		v := p^.value;
		find := true;
	end
	else find := false;
end;

function rbtree_t.insert(e: elem_type): boolean;
begin
	insert := insert(e.first, e.second);
end;

function rbtree_t.insert(k: key_type; v: value_type): boolean;
var
	p, q: pnode_type;
begin
	if root = xzero then
	begin
		new(root);
		root^.key := k;
		root^.value := v;
		root^.black := true;
		root^.left := xzero;
		root^.right := xzero;
		root^.parent := xzero;
		insert := true;
	end
	else
	begin
		q := xzero;
		p := root;
		while (p <> xzero) and (p^.key <> k) do
		begin
			q := p;
			if p^.key > k then
				p := p^.left
			else
				p := p^.right;
		end;
		
		if p <> xzero then
		begin
			insert := false;
			exit;
		end;
		
		new(p);
		p^.key := k;
		p^.value := v;
		p^.parent := q;
		p^.left := xzero;
		p^.right := xzero;
		p^.black := false;
		
		if q^.key > k then
			q^.left := p
		else
			q^.right := p;
		insert_fixup(p);
		
		insert := true;	
	end;
end;

procedure rbtree_t.insert_fixup(var x: pnode_type);
var
	p, b, pp: pnode_type;
begin
	while (x^.parent <> xzero) and (not x^.parent^.black) do
	begin
		p := x^.parent;
		pp := p^.parent;
		if p = pp^.left then
		begin
			b := pp^.right;
			
			if (b <> xzero) and (not b^.black) then
			begin
				p^.black := true;
				b^.black := true;
				pp^.black := false;
				x := pp;
			end
			else
			begin
				if x = p^.right then
				begin
					x := p;
					left_rotate(x);
					p := x^.parent;
				end;
				
				p^.black := true;
				pp^.black := false;
				right_rotate(pp);
			end
		end
		else
		begin
			b := pp^.left;
			if (b <> xzero) and (not b^.black) then
			begin
				p^.black := true;
				b^.black := true;
				pp^.black := false;
				x := pp;
			end
			else
			begin
				if x = p^.left then
				begin
					x := p;
					right_rotate(x);
					p := x^.parent;
				end;
				
				p^.black := true;
				pp^.black := false;
				left_rotate(pp);
			end;
		end;			
	end;
	
	root^.black := true;
end;

function rbtree_t.delete(k: key_type): boolean;
var
	p, x, y: pnode_type;
begin
	
	p := locate(k);

	if p = xzero then
	begin
		delete := false;
		exit;
	end;

	if (p^.left = xzero) or (p^.right = xzero) then
		y := p
	else
		y := next(p);
	
	if y^.left <> xzero then
		x := y^.left
	else
		x := y^.right;

	x^.parent := y^.parent;
	if y^.parent = xzero then
		root := x
	else begin
		if y = y^.parent^.left then
			y^.parent^.left := x
		else
			y^.parent^.right := x;
	end;
	
	if y <> p then
	begin
		p^.key := y^.key;
		p^.value := y^.value;
	end;
	
	if y^.black then delete_fixup(x);
	
	dispose(y);
	
	delete := true;
end;

procedure rbtree_t.delete_fixup(var x: pnode_type);
var
	w, p: pnode_type;
begin
	while (x <> root) and x^.black do
	begin
		if x = x^.parent^.left then
		begin
			p := x^.parent;
			w := p^.right;
			if not w^.black then
			begin
				w^.black := true;
				p^.black := false;
				left_rotate(p);
				w := p^.right;
			end;
			if w^.left^.black and w^.right^.black then
			begin
				w^.black := false;
				x := p;
			end
			else
			begin
				if w^.right^.black then
				begin
					w^.left^.black := true;
					w^.black := false;
					right_rotate(w);
					w := p^.right;
				end;
				w^.black := p^.black;
				p^.black := true;
				w^.right^.black := true;
				left_rotate(p);
				x := root;
			end;
		end
		else
		begin
			p := x^.parent;
			w := p^.left;
			if not w^.black then
			begin
				w^.black := true;
				p^.black := false;
				right_rotate(p);
				w := p^.left;
			end;
			if w^.left^.black and w^.right^.black then
			begin
				w^.black := false;
				x := p;
			end
			else
			begin
				if w^.left^.black then
				begin
					w^.right^.black := true;
					w^.black := false;
					left_rotate(w);
					w := p^.left;
				end;
				w^.black := p^.black;
				p^.black := true;
				w^.left^.black := true;
				right_rotate(p);
				x := root;
			end;
		end;
	end;
	
	x^.black := true;
end;


constructor s2i_map_t.create;
begin
	rbt := rbtree_t.create;
end;

destructor s2i_map_t.destroy;
begin
	rbt.destroy;
	inherited;
end;

procedure s2i_map_t.clear;
begin
	rbt.clear;
end;

function s2i_map_t.find(k: key_type; var v: value_type): boolean;
begin
	find := rbt.find(k, v);
end;

function s2i_map_t.value(k: key_type): value_type;
var
	val: value_type;
begin
	rbt.find(k, val);
	value := val;
end;

procedure s2i_map_t.setvalue(e: elem_type);
begin
	setvalue(e.first, e.second);
end;

procedure s2i_map_t.setvalue(k: key_type; v: value_type);
var
	p: pnode_type;
begin
	p := rbt.locate(k);
	if p = rbt.zero then
		rbt.insert(k, v)
	else
		p^.value := v;
end;

function s2i_map_t.insert(e: elem_type): boolean;
begin
	insert := rbt.insert(e);
end;

function s2i_map_t.insert(k: key_type; v: value_type): boolean;
begin
	insert := rbt.insert(k, v);
end;

function s2i_map_t.delete(k: key_type): boolean;
begin
	delete := rbt.delete(k);
end;

function s2i_map_t.start: pnode_type;
begin
	start := rbt.start;
end;

function s2i_map_t.finish: pnode_type;
begin
	finish := rbt.finish;
end;

function s2i_map_t.next(p: pnode_type): pnode_type;
begin
	next := rbt.next(p);
end;

<</s2i_map_define>>

<<char_handling_routines>>
function isblank(c: char): boolean;
begin
	isblank := ((c = #9) or (c = #32));
end;
function isspace(c: char): boolean;
begin
	isspace := ((c >= #9) and (c <= #13));
end;

function iscntrl(c: char): boolean;
begin
	iscntrl := ((c >=#0) and (c <= #31));
end;

function islower(c: char): boolean;
begin
	islower := ((c >= #97) and (c <= #122));
end;

function isupper(c: char): boolean;
begin
	isupper := ((c >= #65) and (c <= #90));
end;

function isdigit(c: char): boolean;
begin
	isdigit := ((c >= #48) and (c <= #57));
end;
function isxdigit(c: char): boolean;
begin
	isxdigit := ((c >= #48) and (c <= #57))
		or ((c >= #65) and (c <= #70))
		or ((c >= #97) and (c <= #102));
end;

function isalpha(c: char): boolean;
begin
	isalpha := islower(c) or isupper(c);
end;

function isalnum(c: char): boolean;
begin
	isalnum := isalpha(c) or isdigit(c);
end;

function ispunct(c: char): boolean;
begin
	ispunct := ((c >= #33) and (c <= #47))
		or ((c >= #58) and (c <= #64))
		or ((c >= #91) and (c <= #96))
		or ((c >= #123) and (c <= #126));
end;

function isgraph(c: char): boolean;
begin
	isgraph := ((c >= #33) and (c <= #126));
end;

function isprint(c: char): boolean;
begin
	isprint := ((c >= #32) and (c <= #126));
end;

<</char_handling_routines>>

<<generic_vector_decl>>

{
	generic vector class, the only obstacle to use is that
	you cannot push_back a constant, but a variable
}

type
	vector_t = class
	private
		base: pchar;
		sz_unit: integer;
		sz_used: integer;
		sz_total: integer;
	public
		constructor create(esz: integer);
		destructor destroy; override;
		procedure push_back(const e);
		procedure pop_back(out e);
		procedure getat(idx: integer; out e);
		procedure setat(idx: integer; const e);
		function size: integer;
		procedure clear;
	end;
<</generic_vector_decl>>

<<generic_vector_def>>
	constructor vector_t.create(esz: integer);
	begin
		inherited create;
		sz_unit := esz;
		sz_used := 0;
		sz_total := 0;
		base := nil;
	end;

	destructor vector_t.destroy;
	begin
		if base <> nil then
			freemem(base);
		inherited;
	end;

	procedure vector_t.push_back(const e);
	var
		p: pchar;
	begin
		if sz_used >= sz_total then
		begin
			sz_total := sz_total + 4;
			reallocmem(base, sz_total * sz_unit);
		end;
		
		p := pchar(base + sz_used * sz_unit);
		move(e, p^, sz_unit);
		sz_used := sz_used + 1;
	end;
	
	procedure vector_t.pop_back(out e);
	var
		p: pchar;
	begin
		if sz_used > 0 then
		begin
			sz_used := sz_used - 1;
			p := base + sz_used * sz_unit;
			move(p, e, sz_unit);
		end
		else raise ERangeError.create('Out of range');
	end;

	procedure vector_t.getat(idx: integer; out e);
	var
		p: pchar;
	begin
		if (idx >= 0) and (idx < sz_used) then
		begin
			p := base + idx * sz_unit;
			move(p^, e, sz_unit);
		end
		else
			raise ERangeError.create('Out of range');
	end;

	procedure vector_t.setat(idx: integer; const e);
	var
		p: pchar;
	begin
		if (idx >= 0) and (idx < sz_used) then
		begin
			p := base + idx * sz_unit;
			move(e, p^, sz_unit);
		end
		else
			raise ERangeError.create('Out of range');
	end;

	function vector_t.size: integer;
	begin
		size := sz_used;
	end;

	procedure vector_t.clear;
	begin
		sz_used := 0;
	end;
	
<</generic_vector_def>>


<</settings>>
>>>> ------------------------------------ global setting

<<templs>>

<<<----------template for configure.ac-------------->>>
<<templ "config-template">>AC_INIT([the pattern-matching and parsing program generator], [<<version/>>], [<<email/>>], [upgen])
AC_PREREQ([1.00])
AM_INIT_AUTOMAKE([])
UDIFF=<<diff/>>

UDIFF=<<diff/>>
LOGFILE=../../upgen_test_log/<<stream_type/>>
AC_SUBST([UPGEN_BINDIR])
AC_SUBST([UDIFF])
AC_SUBST([LOGFILE])
AC_SUBST([PASCC])
AC_SUBST([PASFLAG])

AC_CONFIG_FILES(<<makefiles/>>
)
AC_OUTPUT
<</templ>>

<<<----------template for Makefile.am of directories---------->>>
<<templ "subdir-makefile-template">>## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE
SUBDIRS = <<subdirs/>>
DIST_SUBDIRS = <<subdirs/>>

test-suites: clean
	NOK=;\
	NFAIL=;\
	for subdir in $(SUBDIRS) ; do \
		echo Enter "$$subdir" "..." >> $(top_srcdir)/$(LOGFILE) ; \
		( cd "$$subdir" && $(MAKE) test-suites --quiet) ; \
		case $$? in \
			0 ) NOK=0$$NOK;\
				;; \
			* ) NFAIL=0$$NFAIL; \
				;; \
		esac; \
	done ; \
	echo Results: >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NOK@ECHO_C@"|wc -c` succeeded >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NFAIL@ECHO_C@"|wc -c` FAILED >> $(top_srcdir)/$(LOGFILE) ; \
	test "$$NFAIL" = ""

<</templ>>


<<<----------template for Makefile.am of cases---------->>>
<<templ "lex-only-makefile-template">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) <<upgen_options/>> -s pas -clLp -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;

$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "make-no-exec">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err
CLEANFILES = test.out test.err

test-suites: script.upg
	$(UPGEN) <<upgen_options/>> -s pas -o script.pas $< 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "invoke-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>

CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -cL <<upgen_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1

test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "invoke-make-stdout-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>

CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -cL <<upgen_options/>> -s pas -t $< >$@ 2>> $(top_srcdir)/$(LOGFILE) ;

$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1

test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "invoke-make-lex-parse-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas scanner.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg scanner.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.pas scanner.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -clL <<parser_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
scanner.pas: scanner.upg
	@rm -f scanner.pas
	$(UPGEN) <<scanner_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
$(TESTEXE): script.pas scanner.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "basic-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>

CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -clL <<upgen_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1

test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<<----------template for testexe.pas of cases -------->>>
<<templ "testexe-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	<<before_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then
	begin
		halt(1);
	end;
	<<prefix/>>parse;
	<<after_init/>>
	<<after_buffer_usage/>>
end.

<</templ>>
<<<----------template for testexe.pas of cases -------->>>


<<<----------template for script.upg of cases---------->>>
<<templ "lex-only-script-template">><<desc/>>

%header%{
uses SysUtils, StrUtils;

{$H+}
function testmain: integer;

%}

%{
<<char_handling_routines/>>
<<global_decl_code/>>
%}

<<declare_section/>>
%%
<<lex_section/>>
%%
<<parse_section/>>
%%
<<code_section/>>

function testmain: integer;
<<main_var_decl/>>
<<local_var_decl/>>
<<local_decl_code/>>
begin

<<init_code/>>

<<before_buffer_init/>>
<<before_init/>>

	if <<prefix/>><<buffer_init/>> <> 0 then
	begin
		testmain := 1;
		exit;
	end;
	<<after_init/>>
	<<after_buffer_usage/>>
	testmain := 0;
	
end;
	
<</templ>>


<<templ "testexe-lex-only-script-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	testmain;
end.

<</templ>>

<<templ "invoke-full-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
// to avoid copy yytext
	s_strVarName: string;
%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';

%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

[0-9]+		begin
				<<prefix/>>lval.nVal := strtoint(yytext);
				result := NUM;
				exit;
				end;
"quit"		begin
				result := QUIT;
				exit;
			end;
"clear"		begin
				result := CLEAR;
				exit;
			end;
"list"		begin
				result := LIST;
				exit;
			end;
{var}		begin
				s_strVarName := yytext;
				result := VARI;
				exit;
			end;
			
[\+\-\*\/\%\^\=\(\)\?\n]	begin
				result := ord(yytext[0]);
				exit;
			end;

<<default_action/>>

%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			write('Error: at ', @1.firstLine, ':', @1.firstColumn);
			writeln('; description: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		write('Error: at ', @1.firstLine, ': ', @1.firstColumn);
		writeln('; description: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				write('Error: at ', @1.firstLine, ':', @1.firstColumn);
				writeln('; description: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

<</templ>>

<<templ "invoke-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
// to avoid copy yytext
	s_strVarName: string;
%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

[0-9]+		begin
				<<prefix/>>lval.nVal := strtoint(yytext);
				result := NUM;
				exit;
				end;
"quit"		begin
				result := QUIT;
				exit;
			end;
"clear"		begin
				result := CLEAR;
				exit;
			end;
"list"		begin
				result := LIST;
				exit;
			end;
{var}		begin
				s_strVarName := yytext;
				result := VARI;
				exit;
			end;
			
[\+\-\*\/\%\^\=\(\)\?\n]	begin
				result := ord(yytext[0]);
				exit;
			end;

<<default_action/>>

%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			writeln('Error: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		writeln('Error: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				writeln('Error: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

<</templ>>


<<<----------template for testexe.pas with user-defined scanner -------->>>
<<templ "testexe-invoke-myscanner-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_myinput/>>
	<<prefix/>>setlex(myscanner);

	<<prefix/>>parse;
	if (s_pfile <> nil) and (s_pfile <> @input) then
	begin
		closefile(s_pfile^);
		dispose(s_pfile);
	end;
end.

<</templ>>
<<<----------template for testexe.pas with user-defined scanner -------->>>



<<templ "invoke-myscanner-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
	s_pfile: ^text;
	yytext: string;
	s_strVarName: string;
	
function myscanner: integer;

%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';

%}

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%


%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			write('Error: at ', @1.firstLine, ':', @1.firstColumn);
			writeln('; description: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		write('Error: at ', @1.firstLine, ': ', @1.firstColumn);
		writeln('; description: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				write('Error: at ', @1.firstLine, ':', @1.firstColumn);
				writeln('; description: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

var
	savechar: boolean = false;
	lastc: char = PAS_EOF__;
	
function myscanner: integer;
var
	c: char;
	to_be_var: boolean;
begin

	myscanner := 0;
	c := PAS_EOF__;
	if s_pfile = nil then exit;
	
	repeat
		to_be_var := false;
		yytext := '';
		
		if savechar then
			c := lastc
		else
			read(s_pfile^, c);
		savechar := false;
		if c = PAS_EOF__ then exit;
		
		if isdigit(c) then
		begin
			repeat
				yytext := yytext + c;
				read(s_pfile^, c);
			until not isdigit(c);
			
			lastc := c;
			savechar := true;
			<<prefix/>>lval.nVal := strtoint(yytext);
			myscanner := NUM;
			exit;
		end;
		
		case c of
		'+', '-', '*', '/', '%',
		'^', '=', '(', ')', '?',
		#10:
			begin
				yytext := yytext + c;
				myscanner := ord(c);
				exit;
			end;
		'q':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'u' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'i' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := QUIT;
								exit;
							end;
						end;
					end;
				end;
			end;
		'c':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'l' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'e' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 'a' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if c = 'r' then begin
								yytext := yytext + c;
								read(s_pfile^, c);
								if (not isalnum(c)) and (c <> '_') then begin
									lastc := c;
									savechar := true;
									myscanner := CLEAR;
									exit;
								end;
							end;
						end;
					end;
				end;
			end;
		'l':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'i' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 's' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := LIST;
								exit;
							end;
						end;
					end;
				end;
			end;
		else
			begin
				if isalpha(c) or (c = '_') then begin
					to_be_var := true;
				end
				else begin
					if c <> PAS_EOF__ then begin
						if (c <> #9) and (c <> #11) and (c <> #32) then
							writeln('undefined symbol `', c, '''');
					end;
				end;
			end;
		end;
		
		if to_be_var then begin
			while isalnum(c) or (c = '_') do
			begin
				yytext := yytext + c;
				read(s_pfile^, c);
			end;
			
			lastc := c;
			savechar := true;
			s_strVarName := yytext;
			myscanner := VARI;
			exit;
		end;
		
	until c = PAS_EOF__;
	
	myscanner := 0;
end;

<</templ>>

<<templ "invoke-myscanner-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
	s_pfile: ^text;
	yytext: string;
	s_strVarName: string;
function myscanner: integer;
%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';

%}


/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%


%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			writeln('Error: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		writeln('Error: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				writeln('Error: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%


var
	savechar: boolean = false;
	lastc: char = PAS_EOF__;
	
function myscanner: integer;
var
	c: char;
	to_be_var: boolean;
begin

	myscanner := 0;
	c := PAS_EOF__;
	if s_pfile = nil then exit;
	
	repeat
		to_be_var := false;
		yytext := '';
		
		if savechar then
			c := lastc
		else
			read(s_pfile^, c);
		savechar := false;
		if c = PAS_EOF__ then exit;
		
		if isdigit(c) then
		begin
			repeat
				yytext := yytext + c;
				read(s_pfile^, c);
			until not isdigit(c);
			
			lastc := c;
			savechar := true;
			<<prefix/>>lval.nVal := strtoint(yytext);
			myscanner := NUM;
			exit;
		end;
		
		case c of
		'+', '-', '*', '/', '%',
		'^', '=', '(', ')', '?',
		#10:
			begin
				yytext := yytext + c;
				myscanner := ord(c);
				exit;
			end;
		'q':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'u' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'i' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := QUIT;
								exit;
							end;
						end;
					end;
				end;
			end;
		'c':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'l' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'e' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 'a' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if c = 'r' then begin
								yytext := yytext + c;
								read(s_pfile^, c);
								if (not isalnum(c)) and (c <> '_') then begin
									lastc := c;
									savechar := true;
									myscanner := CLEAR;
									exit;
								end;
							end;
						end;
					end;
				end;
			end;
		'l':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'i' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 's' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := LIST;
								exit;
							end;
						end;
					end;
				end;
			end;
		else
			begin
				if isalpha(c) or (c = '_') then begin
					to_be_var := true;
				end
				else begin
					if c <> PAS_EOF__ then begin
						if (c <> #9) and (c <> #11) and (c <> #32) then
							writeln('undefined symbol `', c, '''');
					end;
				end;
			end;
		end;
		
		if to_be_var then begin
			while isalnum(c) or (c = '_') do
			begin
				yytext := yytext + c;
				read(s_pfile^, c);
			end;
			
			lastc := c;
			savechar := true;
			s_strVarName := yytext;
			myscanner := VARI;
			exit;
		end;
		
	until c = PAS_EOF__;
	
	myscanner := 0;
end;

<</templ>>


<<<----------template for testexe.pas with another scanner generated -------->>>
<<templ "testexe-myscanner-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	scanner in 'scanner.pas', { scanning classes and routines}
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if zz<<buffer_init2/>> <> 0 then begin
		writeln('Error: initialization failed.');
		halt(1);
	end;
	<<prefix/>>setlex(zzlex);

	<<prefix/>>parse;
	<<after_buffer_usage/>>
end.

<</templ>>
<<<----------template for testexe.pas with another scanner generated -------->>>

<<templ "invoke-parser-only-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
	s_strVarName: string;
%}

%{

<<s2i_map_define/>>

const
	LBLANS = 'ans';

%}

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%


%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			write('Error: at ', @1.firstLine, ':', @1.firstColumn);
			writeln('; description: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		write('Error: at ', @1.firstLine, ': ', @1.firstColumn);
		writeln('; description: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				write('Error: at ', @1.firstLine, ':', @1.firstColumn);
				writeln('; description: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

<</templ>>


<<templ "testexe-invoke-noparser-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	<<before_init/>>
	if <<prefix/>><<buffer_init2/>> <> 0 then
	begin
		writeln('Error: initialization failed.');
		halt(1);
	end;
	<<after_init/>>
	<<prefix/>>lex;
	<<after_buffer_usage/>>
end.

<</templ>>

<<templ "invoke-noparser-template">>
<<desc/>>
/***********************************************************************
	program sample : extract keywords, identifiers, and numbers
************************************************************************/
<<option_prefix/>>

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*
			
%%

[0-9]+				writeln('number: ', yytext);
"quit"				writeln('keyword: ', yytext);
"clear"				writeln('keyword: ', yytext);
"list"				writeln('keyword: ', yytext);
{var}				writeln('identifier: ', yytext);

[\+\-\*\/\%\^\=\(\)\?]		writeln('operator: ', yytext[0]);
\n				writeln('new line encountered.');
<<default_action/>>
<<EOF>>				writeln('Good-bye!');
			
%%

%%

<</templ>>


<<templ "basic-parentheses-template">>
<<desc/>>
/**********************************************************************
	program sample: extract parentheses from expression,
			and convert them to brackets
***********************************************************************/

<<declare_section/>>
%%

[\(\)]		<<parent_lex_action/>>
			result := ord(yytext[0]);
			exit;
\n			writeln;
.

%%

Program: PExpr %{
<<accept_action/>>
		YYACCEPT();
	%}
	;

PExpr: PExpr PItem	%{

	%}
	|
	;
PItem: '('		%{
		write('[');
	%}
	PExpr ')'	%{
		write(']');
	%}
	;
%%
<<code_section/>>

<</templ>>

<<templ "basic-sentinfo-template">>
<<desc/>>
/****************************************************************
	program sample: count information of sentences in text
*****************************************************************/

%header%{

<<union_code/>>
<<location_code/>>
var
	sentenceCounter: integer = 1;
%}

<<union_decl/>>
<<location_decl/>>

%parsevar-decl%{
var
	lineCounter: integer;
	wordCounter: integer;
	charCounter: integer;
%}

%parsevar-init%{
lineCounter := 0;
wordCounter := 0;
charCounter := 0;
%}

ws	[ \t]
nows	[^ \t\n\.\?\!]

%token<nVal> TK_WORD TK_WS
%token	TK_ES

%type<nPair> Block Blocks

%%

[\.\?\!]		begin
		yylloc.sentenceNo := sentenceCounter;
		sentenceCounter := sentenceCounter + 1;
		result := TK_ES;
		exit;
	end;

{nows}+	begin
		yylloc.sentenceNo := sentenceCounter;
		yylval.nVal := yyleng;
		result := TK_WORD;
		exit;
	end;

{ws}+		begin
		yylloc.sentenceNo := sentenceCounter;
		yylval.nVal := yyleng;
		result := TK_WS;
		exit;
	end;
\n		begin
		yylloc.sentenceNo := sentenceCounter;
		result := 10;
		exit;
	end;

%%


SText: Blocks	%{
		writeln('Words: ', wordCounter);
		writeln('Chars: ', charCounter);
		writeln('Sents: ', @1.sentenceNo);
		writeln('Lines: ', lineCounter);
		YYACCEPT;
	%}
	;

Blocks:	Blocks Block	%{
		@$.sentenceNo := @2.sentenceNo;
		if $2.charCounter = -1 then begin
			$1.charCounter := $1.charCounter + 1;
			writeln('S', @1.sentenceNo, #9, $1.wordCounter, ' words;',
				#9, $1.charCounter, ' characters.');

			charCounter := charCounter + 1;

			$$.wordCounter := 0;
			$$.charCounter := 0;
		end
		else begin
			$$.wordCounter := $1.wordCounter + $2.wordCounter;
			$$.charCounter := $1.charCounter + $2.charCounter;

			wordCounter := wordCounter + $2.wordCounter;
			charCounter := charCounter + $2.charCounter;
		end;
	%}
	| Block		%{
		@$.sentenceNo := @1.sentenceNo;
		if $1.charCounter = -1 then begin
			writeln('S', @1.sentenceNo, #9, $1.wordCounter,
				' words;'#9'1 characters.');
			charCounter := charCounter + 1;

			$$.wordCounter := 0;
			$$.charCounter := 0;
		end
		else begin
			$$.wordCounter := $1.wordCounter;
			$$.charCounter := $1.charCounter;

			wordCounter := wordCounter + $1.wordCounter;
			charCounter := charCounter + $1.charCounter;
		end;
	%}
	;

Block: TK_WORD	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 1;
		$$.charCounter := $1;
	%}
	| TK_WS	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 0;
		$$.charCounter := $1;
	%}
	| '\n'	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 0;
		$$.charCounter := 1;
		lineCounter := lineCounter + 1;
	%}
	| TK_ES	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 0;
		$$.charCounter := -1;
	%}
	;

%%

<</templ>>

<<templ "testexe-basic-sentinfo-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	<<prefix/>>parse;
<<after_buffer_usage/>>
end.
<</templ>>

<<templ "basic-tagchecker-template">>
<<desc/>>
/**************************************************************
	sample program: tag checker, which determines if
			tag head has corresponding tag tail
***************************************************************/

%header%{

uses SysUtils, StrUtils;

{ push tag into stack }
procedure stack_push(plbl: pchar);
{ pop tag from stack }
function stack_pop: pchar;
{ get most recently pushed tag }
function stack_top: pchar;
{ free all nodes(not incuding their contents) in stack }
procedure stack_clear;
{ allocate a string }
function alloc_string(nlen: integer): pchar;
{ free all allocated string }
procedure free_string;

%}

%header%{
type
 	triple_t = record
		{ max of depth }
		maxdep: integer;
		{ current depth }
		curdep: integer;
		{ number of parentheses }
		pairnum: integer;
	end;

	tag_link_t = ^tag_node_t;
	tag_node_t = record

		plabel: pchar;
		pnext: tag_link_t;
	end;
%}

%{
var
	{ top of tag stack }
	sttop: tag_link_t = nil;
	{ top of allocation stack }
	stravail: tag_link_t = nil;

	{ temporary variable }
	{ @tempi used as counter in loops }
	tempi: integer;

<<init_code/>>
%}

/* legal name of tag excludes and string containing
	 ( ) [ ] { } < > , / " ' ; :
*/
tag	[A-Za-z0-9\!\@\#\$\%\^\&\*\+\-\_\~\`\?\.]+

/* semantic value type definition */
%union%{
	pchval: pchar;
	level: integer;
%}

%token<pchval> '(' ')'
%type<pchval> TagHead
%type<level> TagItem TagExpr
<<parse_param/>>
<<parsevar_decl/>>
<<parsevar_init/>>
<<destructor/>>
<<start_symbol/>>

%%

"<"{tag}">"	begin
		yylval.pchval := alloc_string(yyleng - 1);
		strlcopy(yylval.pchval, pchar(yytext + sizeof(char)), yyleng - 2);
		yylval.pchval[yyleng - 2] := #0;

		result := ord('(');
		exit;
	end;

"</"{tag}">"	begin
		yylval.pchval := stack_top;
		yytext[yyleng - 1] := #0;
		if (yylval.pchval = nil) or
			(strcomp(yylval.pchval, pchar(yytext + 2 * sizeof(char))) <> 0) then
			result := ord(']')
		else result := ord(')');
		exit;
	end;

.|\n		<<deflex_action/>>

%%

Exprs: TagExpr %{
		writeln('Tag checking passed.');
		<<exprs_action/>>
	%}
	;

SText: Exprs %{
		writeln('Input text is accepted by tag-check grammar.');
		YYACCEPT;
	%}
	;

TagExpr: TagExpr TagItem %{
		$$ := $2;
	%}
	|		%{
		$$ := tpl.curdep;
	%}
	;
TagItem: TagHead TagExpr ')'	%{
		tpl.curdep := tpl.curdep - 1;
		tpl.pairnum := tpl.pairnum + 1;
		stack_pop;

		for tempi := 0 to tpl.curdep - 1 do
			write(#9);
		
		writeln('</', $3, '>');

		$$ := tpl.curdep;
	%}
	| TagHead error ')'	%{
		tpl.curdep := tpl.curdep - 1;
		tpl.pairnum := tpl.pairnum + 1;
		stack_pop;

		for tempi := 0 to tpl.curdep - 1 do
			write(#9);

		writeln('</', $3, '>');

		$$ := tpl.curdep;

		yyerrok;
	%}
	;
TagHead: '('	%{

		for tempi := 0 to tpl.curdep - 1 do
			write(#9);

		writeln('<', $1, '>');

		tpl.curdep := tpl.curdep + 1;
		if tpl.curdep > tpl.maxdep  then tpl.maxdep := tpl.curdep;

		stack_push($1);
		$$ := $1;
	%}
	;
%%

{ push tag into stack }
procedure stack_push(plbl: pchar);
var
	p: tag_link_t;
begin

	new(p);
	p^.plabel := plbl;
	p^.pnext := sttop;
	sttop := p;
end;

{ pop tag from stack }
function stack_pop: pchar;
var
	pch: pchar;
	p: tag_link_t;
begin

	p := sttop;
	if p <> nil then begin
		pch := p^.plabel;
		sttop := sttop^.pnext;
		dispose(p);
	end
	else pch := nil;
	
	stack_pop := pch;
end;

{ get most recently pushed tag }
function stack_top: pchar;
begin
	if sttop = nil then stack_top := nil
	else
		stack_top := sttop^.plabel;
end;

{ free all nodes(not incuding their contents) in stack }
procedure stack_clear;
var
	p: tag_link_t;
begin
	while sttop <> nil do begin
		p := sttop^.pnext;
		dispose(sttop);
		sttop := p;	
	end;
	sttop := nil;
end;

{ allocate a string }
function alloc_string(nlen: integer): pchar;
var
	p: tag_link_t;
begin

	if nlen <= 0 then begin
		alloc_string := nil;
		exit;
	end;

	new(p);
	getmem(p^.plabel, sizeof(char) * nlen);
	p^.pnext := stravail;
	stravail := p;

	alloc_string := p^.plabel;

end;

{ free all allocated string }
procedure free_string;
var
	p: tag_link_t;
begin
	while stravail <> nil do begin
		p := stravail^.pnext;
		freemem(stravail^.plabel);
		dispose(stravail);
		stravail := p;	
	end;
	stravail := nil;
end;

<</templ>>

<<templ "testexe-basic-tagchecker-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<before_yyparse/>>
	
	<<prefix/>>parse(<<yyparse_param/>>);

	<<after_yyparse/>>

	stack_clear;
	free_string;
<<after_buffer_usage/>>

end.

<</templ>>

<<templ "basic-extr-numopr-template">>
<<desc/>>
/****************************************************************************
*	sample program: number(including integer and float),
*			arithmetic operator(+ - * / % ^ =)
*			extracter
*****************************************************************************/

%{

<<init_code/>>

var
	i: integer;
	pbuf: YYPBUFFER;
%}


udec	[0-9]+
sdec	[\-\+]?{udec}
frct	\.{udec}
num	{sdec}{frct}?
opr	[\+\-\*\/\%\^\=]

<<lvar_decl/>>
<<lvar_init/>>
<<lex_init/>>
<<pre_match/>>
<<yywrap/>>

%token FEOF

%%

"#open"[ \t]*\"[^\"\'\n]+\"	begin
		dc := dc + 1;
		yytext[yyleng - 1] := #0;

		i := 5;
		while yytext[i] <> '"' do
			i := i + 1;
		i := i + 1;
		pbuf := yy_new_filebuf(pchar(yytext + sizeof(char) * i));
		if pbuf = nil then 
			writeln('Error: failed to open file `',
				pchar(yytext + i * sizeof(char)), '''')
		else 
			yy_switch_buffer(pbuf);
		
	end;
{sdec}		ic := ic + 1;
{num}		rc := rc + 1;
{opr}		oc := oc + 1;
<<EOF>>		begin
		yy_delete_buffer();
		writeln('number of integers: ', ic);
		writeln('number of reals: ', rc);
		writeln('number of operators: ', oc);
		writeln('number of discarded symbols: ', dc);
		writeln('number of matched patterns: ', mc);
		result := FEOF;
		exit;
	end;

.|\n		dc := dc + 1;
%%

Start: Start FEOF 
	| FEOF
	;

%%

<</templ>>

<<templ "testexe-basic-extr-numopr-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;

	<<prefix/>>parse();
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "basic-fdc-template">>
<<desc/>>
/****************************************************************************
*	sample program: calculator for integers and reals
*	the purpose of this is to show how to use following features of upgen
*			%left %right %nonassoc %type
*			%prec %parse-init %parse-exit
*****************************************************************************/

%header%{

uses Math, SysUtils, StrUtils;

type
	xnum_t = record
		case nType: integer of
		0: (nVal: integer);
		1: (dVal: real);
	end;	
%}

%{

const
	NT_INT = 0;
	NT_REAL = 1;
%}

%union%{
	case byte of
	0: (nVal: integer);
	1: (dVal: real);
	2: (xNum: xnum_t);
%}
%yywrap%{
	yy_delete_buffer();
	result := false;
%}

%lvar-decl%{
	i: integer;
	pbuf: YYPBUFFER;
%}
%pvar-decl%{
	berror: boolean;
	errors: integer;
	str_fmt: string;
%}
%pvar-init%{
	berror := false;
	errors := 0;
%}


udec	[0-9]+
frct	\.{udec}
ureal	{udec}{frct}
opr	[\+\-\*\/\^\(\)]

%token<nVal> TK_INT
%token<dVal> TK_REAL

<<token_decl/>>
<<parse_init/>>
<<parse_exit/>>

%type<xNum> Expr

<<type_decl/>>

<<other_decl/>>

%%

"#open"[ \t]*\"[^\"\'\n]+\"	begin

		repeat
			i := yyinput;
		until (i = 10) or (i = END_OF_FILE);
		
		yy_set_bol(true);

		yytext[yyleng - 1] := #0;

		i := 5;
		while yytext[i] <> '"' do
			i := i + 1;
		i := i + 1;
		pbuf := yy_new_filebuf(pchar(yytext + sizeof(char) * i));
		
		if pbuf = nil then 
			writeln('Error: failed to open file `', pchar(yytext + i * sizeof(char)), '''')
		else
			yy_switch_buffer(pbuf);

	end;
{udec}		yylval.nVal := strtoint(yytext);

			write(yytext);
			result := TK_INT;
			exit;

{ureal}		yylval.dVal := strtofloat(yytext);
			write(yytext);
			result := TK_REAL;
			exit;
		
{opr}		write(yytext[0]);
			result := ord(yytext[0]);
			exit;

\n			writeln;		
			result := 10;
			exit;
[ \t]		write(yytext[0]);

.

%%

Task: Lines		%{
<<type_action_0/>>
	%}
	;

Lines: Lines Line	%{
<<type_action_1/>>
	%}
	|		%{
<<type_action_2/>>
	%}
	;
Line: Expr '\n'		%{
		if not berror then begin
			if $1.nType = NT_INT then begin
				str_fmt := format(#9#9'%d[INT]', [$1.nVal]);
				writeln(str_fmt);
			end
			else begin
				str_fmt := format(#9#9'%15.4f[REAL]', [$1.dVal]);
				writeln(str_fmt);
			end;
		end
		else errors := errors + 1;

		berror := false;
	%}
	| error '\n'	%{

		if berror then errors := errors + 1;

		berror := false;
		yyerrok;
	%}
	| '\n'		%{
		berror := false;
	%}
	;

Expr: Expr '+' Expr	%{
		if not berror then begin

			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				$$.nVal := $1.nVal + $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then 
					$$.dVal := $1.nVal + $3.dVal
				else if $3.nType = NT_INT then
					$$.dVal := $1.dVal + $3.nVal
				else
					$$.dVal := $1.dVal + $3.dVal;
			end;
		end;
	%}
	| Expr '-' Expr	%{
		if not berror then begin
			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				$$.nVal := $1.nVal - $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then
					$$.dVal := $1.nVal - $3.dVal
				else if $3.nType = NT_INT then
					$$.dVal := $1.dVal - $3.nVal
				else
					$$.dVal := $1.dVal - $3.dVal;
			end;
		end;
	%}
	| Expr '*' Expr	%{

		if not berror then begin
			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				$$.nVal := $1.nVal * $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then
					$$.dVal := $1.nVal * $3.dVal
				else if $3.nType = NT_INT then
					$$.dVal := $1.dVal * $3.nVal
				else
					$$.dVal := $1.dVal * $3.dVal;
			end;
		end;
	%}
	| Expr '/' Expr	%{

		if not berror then begin
			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				if $3.nVal = 0 then begin
					writeln('Error: divided by zero!');
					berror := true;
				end
				else
					$$.nVal := $1.nVal div $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then
					$$.dVal := $1.nVal / $3.dVal
				else if $3.nType = NT_INT then begin
					if $3.nVal = 0 then begin
						writeln('Error: divided by zero!');
						berror := true;
					end
					else
						$$.dVal := $1.dVal / $3.nVal;
				end
				else
					$$.dVal := $1.dVal / $3.dVal;
			end;
		end;
	%}
	| Expr '^' Expr %{

		if not berror then begin
			$$.nType := NT_REAL;
			try
				if $1.nType = NT_INT then begin
					if $3.nType = NT_INT then
						$$.dVal := power($1.nVal, $3.nVal)
					else
						$$.dVal := power($1.nVal, $3.dVal);
				end
				else begin
					if $3.nType = NT_INT then
						$$.dVal := power($1.dVal, $3.nVal)
					else
						$$.dVal := power($1.dVal, $3.dVal);
				end;
			except
			on EOverFlow do
				begin
					writeln('Error: number is out of range.');
					berror := true;
				end;
			else begin
					writeln('Error: domain error, x is negative while y is non-integer.');
					berror := true;
				end;
			end;
		end;
	%}
	| '(' Expr ')'	%{

		if not berror then begin
			$$.nType := $2.nType;
			if $2.nType = NT_INT then
				$$.nVal := $2.nVal
			else
				$$.dVal := $2.dVal;
		end;
	%}
	| '+' <<prec_refer/>> Expr	%{

		if not berror then begin
			$$.nType := $2.nType;
			if $2.nType = NT_INT then
				$$.nVal := $2.nVal
			else
				$$.dVal := $2.dVal;
		end;
	%}
	| '-' <<prec_refer/>> Expr	%{

		if not berror then begin
			$$.nType := $2.nType;
			if $2.nType = NT_INT then
				$$.nVal := 0 - $2.nVal
			else
				$$.dVal := 0 - $2.dVal;
		end;
	%}
	| TK_INT		%{
		$$.nType := NT_INT;
		$$.nVal := $1;
	%}
	| TK_REAL		%{
		$$.nType := NT_REAL;
		$$.dVal := $1;
	%}
	;
%%

<</templ>>


<<templ "testexe-basic-fdc-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;

	<<prefix/>>parse();
<<after_buffer_usage/>>

end.

<</templ>>



<<templ "interface-scanner-template">><<desc/>>
%{
<<init_code/>>
%}
<<declare_section/>>
%%
<<lex_section/>>
%%

Start: /* empty */

%%
<<code_section/>>

<</templ>>


<<templ "testexe-interface-scanner-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
<<before_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;

	<<after_init/>>
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-bstack-template">>
/*
	sample program: test buffer operations
	feature to test:
		yy_current_buffer, yy_has_buffer, yy_push_buffer, yy_pop_buffer,
		yy_new_filebuf, yy_new_cstrbuf, yy_new_strbuf, yy_switch_buffer,
		yy_delete_buffer
*/


%{

uses SysUtils, StrUtils;

<<generic_vector_decl/>>
<<generic_vector_def/>>

procedure initregistry; forward;
procedure regbuffer(pbuf: YYPBUFFER; pbname: pchar; sz: integer); forward;
function buffername(pbuf: YYPBUFFER): pchar; forward;
procedure clearregistry; forward;

var
	pbn: pchar;
	vbufname: vector_t;
	temp_buffer: pchar = nil;
%}

%lvar-decl%{
	i, j, d: integer;
	pbuf: YYPBUFFER;
%}

%yywrap%{
	pbn := buffername(yy_current_buffer);
	if pbn <> nil then
		writeln('buffer `', pbn, ''' is coming.');
	result := false;
%}

%x	RSTRT

fname	\`[^\"\'\`\n\r]+\`
str	\"[^\"\'\`]+\"
cstr	\'[^\"\'\`]+\'
bname	[[:cidf:]][[:cids:]]*


%parse-init%{

	initregistry;
	temp_buffer := nil;
	regbuffer(yy_current_buffer(), 'test', 4);
	
%}

%parse-exit%{

	clearregistry;
	if temp_buffer <> nil then
		freemem(temp_buffer);
	
%}

%token FEOF

%%

{bname}">"[ \t]*"open"[ \t]+{fname}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '`' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_filebuf(pchar(yytext + i * sizeof(char)), false);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for file `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"push"[ \t]+{fname}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '`' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_filebuf(pchar(yytext + sizeof(char) * i), false);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for file `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		end;
	end;
		
{bname}">"[ \t]*"open"[ \t]+{str}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '"' do
			i := i - 1;
		i := i + 1;

		d := yyleng - i;
		if temp_buffer <> nil then
			freemem(temp_buffer);

		getmem(temp_buffer, d * sizeof(char));
		
		d := d - 1;
		move(pchar(yytext + sizeof(char) * i)^, temp_buffer^, d);
		temp_buffer[d] := #0;
		

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_strbuf(temp_buffer, d);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"push"[ \t]+{str}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '"' do
			i := i - 1;
		i := i + 1;

		d := yyleng - i;
		if temp_buffer <> nil then
			freemem(temp_buffer);

		getmem(temp_buffer, d * sizeof(char));
		
		d := d - 1;
		move(pchar(yytext + sizeof(char) * i)^, temp_buffer^, d);
		temp_buffer[d] := #0;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_strbuf(temp_buffer, sizeof(char) * d);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"open"[ \t]+{cstr}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '''' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_cstrbuf(pchar(yytext + sizeof(char) * i), yyleng - i);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for constant string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"push"[ \t]+{cstr}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '''' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_cstrbuf(pchar(yytext + i * sizeof(char)), yyleng - i);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for constant string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		end;
	end;

"has?"		begin
		if yy_has_buffer then
			writeln('Yes, there are buffers!')
		else begin
			writeln('Oh, no! It''s impossible!!!');
			YYABORT;
		end;
	end;

"cur?"		begin
		pbn := buffername(yy_current_buffer);
		if pbn <> nil then
			writeln('current buffer: ', pbn)
		else begin
			writeln('Oh, no name for current buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;

"close"		begin
		pbn := buffername(yy_current_buffer);
		if pbn <> nil then begin
			writeln('closing buffer ', pbn, ' ...');
			yy_delete_buffer;
			if yy_has_buffer then begin
				pbn := buffername(yy_current_buffer);
				if pbn <> nil then
					writeln('switching to buffer ', pbn, ' ...')
				else begin
					writeln('Oh, no name for to-be-switched buffer! It''s impossible!!!');
					YYABORT;
				end;
			end;
		end
		else begin
			writeln('Oh, no name for to-be-deleted buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;
"abort"		begin
		writeln('program exit abnormal ...');
		YYABORT;
	end;
"pop"		begin
		pbn := buffername(yy_current_buffer());
		if pbn <> nil then begin
			writeln('popping buffer ', pbn, ' ...');
			yy_pop_buffer;
			if yy_has_buffer then begin
				pbn := buffername(yy_current_buffer);
				if pbn <> nil then
					writeln('switching to buffer ', pbn, ' ...')
				else begin
					writeln('Oh, no name for to-be-switched buffer! It''s impossible!!!');
					YYABORT;
				end;
			end;
		end
		else begin
			writeln('Oh, no name for to-be-popped buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;

"restart"	begin

			pbn := buffername(yy_current_buffer);
		if pbn <> nil then begin
			writeln('restarting buffer ', pbn, ' ...');
			
			yyrestart();
			YYBEGIN(RSTRT);
		end
		else begin
			writeln('Oh, no name for to-be-restarted buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;

<*>.|\n		write(yytext);

<RSTRT><<EOF>>	begin
		pbn := buffername(yy_current_buffer());
		if pbn <> nil then
			writeln('buffer `', pbn, ''' is abort to leave.');
		YYBEGIN(INITIAL);
		yy_delete_buffer();
		result := FEOF;
		exit;
	end;

<*><<EOF>>	begin
		pbn := buffername(yy_current_buffer());
		if pbn <> nil then
			writeln('buffer `', pbn, ''' is abort to leave.');
		yy_delete_buffer();
		result := FEOF;
		exit;
	end;

%%

Start: Texts %{
		if yy_has_buffer then begin
			writeln('There are still buffers!');
			YYABORT;
		end
		else
			writeln('All buffers closed.');
	%}
	;

Texts: Texts FEOF
	|
	;

%%

procedure initregistry;
begin
	vbufname := vector_t.create(sizeof(pchar));
	
end;

procedure regbuffer(pbuf: YYPBUFFER; pbname: pchar; sz: integer);
var
	pc: pchar;
begin

	if pbuf <> nil then begin
		getmem(pc, (sz + 1) * sizeof(char));
		move(pbname^, pc^, sz);
		pc[sz] := #0;

		vbufname.push_back(pc);
		
		pbuf.setdata(pointer(vbufname.size - 1));
	end;
end;

function buffername(pbuf: YYPBUFFER): pchar;
var
	n: integer;
	p: pchar;
begin
	
	if pbuf <> nil then begin
		n := integer(pbuf.getdata());
		if n < vbufname.size then begin
			vbufname.getat(n, p);
			buffername := p;
		end;
	end
	else buffername := nil;
end;

procedure clearregistry;
var
	i: integer;
	p: pchar;
begin
	for i := 0 to vbufname.size - 1 do
	begin
		p := nil;
		vbufname.getat(i, p);
		if p <> nil then
			freemem(p);
	end;
	vbufname.destroy;
end;

<</templ>>


<<templ "testexe-interface-bstack-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
<<before_init/>>
	if <<prefix/>><<buffer_init3/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;

<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-echo-template">>
/*
 *	sample program: test ECHO
 */

num	[0-9]+
xnum	0x[0-9]{2}

%%

^{num}	YYECHO;

{xnum}	YYECHO;
\n		YYECHO;
.		YYECHO;

%%

Start:
	;
%%

<</templ>>

<<templ "testexe-interface-echo-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-getbol-template">>
/*
 *	sample program: test yy_get_bol
 */
 
%{
uses SysUtils, StrUtils;
%}

num	[0-9]+
xnum	0x[0-9]{2}

%lvar-decl{
	n: integer;
%}

%%

^{num}		n := strtoint(yytext);
		if n <> yylloc.firstLine then
			writeln('Error: at ', yylloc.firstLine, ':', yylloc.firstColumn, ' failed to verify line number.');

{xnum}		n := strtoint(yytext + 2 * sizeof(char));
		if n <> yylloc.firstLine then
			writeln('Error: at ', yylloc.firstLine, ':', yylloc.firstColumn, ' failed to verify line number.');

\n		if not yy_get_bol then
			writeln('Error: at ', yylloc.firstLine, ':', yylloc.firstColumn, ' failed to verify value of bol.');

.

%%

Start:
	;
%%

<</templ>>

<<templ "testexe-interface-getbol-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-line-editor-template">>
/*
	sample program: special line editor
	feature to test: yymore yyless  yyinput yyterminate /
*/

%{
uses SysUtils, StrUtils;
%}

%lvar-decl%{
	c, n: integer;
%}

%%

"&"		yyleng := yyleng - 1;
		if yyleng > 0 then begin
			yytext[yyleng] := #0;
			write(yytext);
		end;
		
"&&"	yyleng := yyleng - 1;
		yytext[yyleng] := #0;
		yymore;
		
"&!"	yyleng := yyleng - 1;
		yytext[yyleng - 1] := '!';
		yytext[yyleng] := #0;
		yymore;
		
"&@"	yyleng := yyleng - 1;
		yytext[yyleng - 1] := '@';
		yytext[yyleng] := #0;
		yymore;
		
"!!"	yyleng := yyleng - 2;
		yytext[yyleng] := #0;
		if yyleng > 0 then
			write(yytext);

		repeat
			c := yyinput;
		until (c = 10) or (c = END_OF_FILE);
		
		if c = 10 then begin
			writeln;
			yy_set_bol(true);
		end;
		
"!!!"	yyleng := yyleng - 3;
		yytext[yyleng] := #0;
		if yyleng > 0 then
			write(yytext);
		yyterminate;


[^\@\&\!\n]+/"@"[0-9][0-9]

		yytext[yyleng] := #0;
		write(yytext);
		
		n := strtoint(pchar(yytext + sizeof(char)* (yyleng + 1)));

		if n > 0 then begin
			if n > yyleng then
				n := yyleng;
			yytext[n] := #0;
			write(yytext);
		end;
		// throw away 3 chars followed: @##
		yyinput;
		yyinput;
		yyinput;

[^\@\&\!\n]+/"@-"[0-9][0-9]

		yytext[yyleng] := #0;
		yylaleng := yyleng;
		
		n := strtoint(pchar(yytext + sizeof(char) * (yyleng + 2)));

		write(yytext);

		n := yyleng - n;
		if (n > 0) and (n < yyleng) then
			yyless(n);
			
[^\@\&\!\n]+/"!"[0-9][0-9]

		n := strtoint(pchar(yytext + sizeof(char) * (yyleng + 1)));

		if n > yyleng then
			n := yyleng;

		yyleng := yyleng - n;
		yytext[yyleng] := #0;

		if yyleng > 0 then 
			write(yytext);
		// throw away 3 chars followed: @##
		yyinput;
		yyinput;
		yyinput;

"@-"[0-9][0-9]
		yyleng := yyleng - 4;
		yytext[yyleng] := #0;
		yymore;			

.		yymore;

\n		write(yytext);
		

<<EOF>>
		if yyleng > 0 then
			write(yytext);
		flush(output);
%%

Start: /* empty */
	;

%%

<</templ>>


<<templ "testexe-interface-line-editor-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-loc2-template">>
/*
	sample program: location counter 2
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
		yyinput yyunput yyunget
*/

%header%{

{$H+}

uses SysUtils, StrUtils;

type

	loc_pair_t = record
		line: integer;
		col: integer;
	end;
<<generic_vector_decl/>>

type
	vlpair_t = vector_t;
	vpvlp_t = vector_t;
%}

%{
<<char_handling_routines/>>
<<generic_vector_def/>>


%}



%union%{
	case byte of
	0: (locVal: loc_pair_t);
	1: (nVal: integer);
	2: (pvpVal: vlpair_t);
%}

%lvar-decl%{
var
	i: integer;
	n: integer;
%}

%pvar-decl%{
var
	pLoc: vlpair_t;
	pr1, pr2: loc_pair_t;
	i: integer;
%}

%parse-init%{
	vvprLocs := vector_t.create(sizeof(vlpair_t));
%}

%parse-exit%{
	for i := 0 to vvprLocs.size - 1 do
	begin
		vvprLocs.getat(i, pLoc);
		pLoc.destroy;
	end;
	vvprLocs.destroy;		
%}

%formal-param%{var vvprLocs: vpvlp_t; var strBuf: string; var nLastLoc: integer %}
%actual-param%{ vvprLocs, strBuf, nLastLoc %}

locn	[[:alnum:]]{2}[[:digit:]]
num	[[:digit:]]+

%x	LOC_SC
%x	TOL_SC
%x	PUT_SC

%token LOC_HEAD LOC_TAIL PUT_TAIL
%token TR_TAIL LR_TAIL OR_TAIL
%token<nVal> TR_HEAD LR_HEAD OR_HEAD
%token<locVal> LOCN

%type<pvpVal> TabLine
%%

"#location_head"[ \t]*\r?\n		begin

		YYBEGIN(LOC_SC);
		result := LOC_HEAD;
		exit;
	end;

<LOC_SC>"#location_tail"[ \t]*\r?\n	begin

		YYBEGIN(INITIAL);
		result := LOC_TAIL;
		exit;
	end;

"#line_replace"[ \t]+{num}[ \t]*\r?\n	|
"#orignal"[ \t]+{num}[ \t]*\r?\n	|
"#tab_replace"[ \t]+{num}[ \t]*\r?\n	begin

		yyset_lineno(1);
		yyset_colno(1);
		writeln('after reseting, line: ', yyget_lineno, #9'col: ', yyget_colno);

		i := yyleng - 2;
		while not isdigit(yytext[i]) do
			i := i - 1;
		yytext[i + 1] := #0;
		
		while isdigit(yytext[i]) do
			i := i - 1;
		i := i + 1;

		yylval.nVal := strtoint(pchar(yytext + sizeof(char) * i));
		
		strBuf := '';

		YYBEGIN(TOL_SC);

		case yytext[1] of
		'l': begin
				result := LR_HEAD;
				exit;
			end;
		'o': begin
				result := OR_HEAD;
				exit;
			end;
		else begin
				result := TR_HEAD;
				exit;
			end;
		end;
	end;

<TOL_SC>"#line_replace"[ \t]*\r?\n	|
<TOL_SC>"#orignal"[ \t]*\r?\n		|
<TOL_SC>"#tab_replace"[ \t]*\r?\n	begin

		strBuf := strBuf + string(yytext);

		YYBEGIN(INITIAL);

		case yytext[1] of
		'l': begin
				result := LR_TAIL;
				exit;
			end;
		'o': begin
				result := OR_TAIL;
				exit;
			end;
		else begin
				result := TR_TAIL;
				exit;
			end;
		end;
	end;

<PUT_SC>"#line_replace"			|
<PUT_SC>"#orignal"			|
<PUT_SC>"#tab_replace"		begin

		YYBEGIN(INITIAL);
		result := PUT_TAIL;
		exit;
	end;

"tab?"				begin
		writeln('tabsize = ', yyget_tabsize());
	end;

"tab="[[:digit:]]		begin

		n := ord(yytext[4]) - 48;
		yyset_tabsize(n);
		writeln('tabsize is ', yyget_tabsize(), ' now');
	end;

<*>{locn}		begin
		if isdigit(yytext[0]) then  begin
			yylval.locVal.line := ord(yytext[0]) - 48;
		end
		else  if islower(yytext[0]) then begin
			yylval.locVal.line := ord(yytext[0]) - 87;
		end
		else begin
			yylval.locVal.line := ord(yytext[0]) - 29;
		end;


		if isdigit(yytext[1]) then begin
			yylval.locVal.col := (ord(yytext[1]) - 48) * 10 + ord(yytext[2]) - 48;
		end
		else if islower(yytext[1]) then begin
			yylval.locVal.col := (ord(yytext[1]) - 97) * 10 + 100 + ord(yytext[2]) - 48;
		end
		else begin
			yylval.locVal.col := (ord(yytext[1]) - 65) * 10 + 360 + ord(yytext[2]) - 48;
		end;

		if YYSTART = TOL_SC then
			strBuf := strBuf + string(yytext);

		result := LOCN;
		exit;
	end;

<*>.|\n		begin
		if YYSTART = TOL_SC then
			strBuf := strBuf + string(yytext);
	end;

%%

File:	File Section
	| Section
	;

Section: LocSect
	| RLSect
	| RTSect
	| OrgSect
	| TabLine PUT_TAIL	%{
		if nLastLoc < 0 then begin
			writeln('Error: OOPS!!!');
		end
		else begin
			vvprLocs.getat(nLastLoc, pLoc);
			writeln('begin comparing location(size ', pLoc.size, 
				') ', nLastLoc, ' and its referrence(size ', $1.size, ')');
			i := 0;
			while (i < $1.size) and (i < pLoc.size) do
			begin
				pLoc.getat(i, pr1);
				$1.getat(i, pr2);
				if (pr1.line <> pr2.line) or (pr1.col <> pr2.col) then
					writeln('refer.line = ', pr2.line, #9'refer.col = ', pr2.col,
						#9'Loc.line = ', pr1.line, #9'Loc.col = ', pr1.col);
				i := i + 1;
			end;
		end;
		$1.destroy;
	%}
	;

LocSect: LOC_HEAD
	 %{ nLastLoc := -1; %}
	 TabLine LOC_TAIL	%{
		vvprLocs.push_back($3);
	%}
	;
RLSect: LR_HEAD
	 %{
		nLastLoc := -2;
		writeln('begin scanning line_replace section by referrence ', $1);
	 %}
	 TabLine LR_TAIL		%{
		nLastLoc := $1;
		writeln('before putback, line: ', yyget_lineno, #9'col: ', yyget_colno);
		if length(strBuf) > 0 then begin
			for i := length(strBuf) downto 1 do
			begin
				if strBuf[i] <> #10 then
					yyunget()
				else
					yyunput('*');
			end;
		end;
		
		strBuf := '';
		writeln('after putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		writeln('scanning line_replace section is over');
		YYBEGIN(PUT_SC);
	%}
	;
RTSect: TR_HEAD
	 %{
		nLastLoc := -3;
		writeln('begin scanning tab_replace section by referrence ', $1);
	 %}
	 TabLine TR_TAIL		%{
		nLastLoc := $1;
		writeln('before putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());

		if length(strBuf) > 0 then begin
			for  i := length(strBuf) downto 1 do begin
				if strBuf[i] <> #9 then
					yyunget()
				else
					yyunput('*');
			end;
		end;
		strBuf := '';

		writeln('after putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		writeln('scanning tab_replace section is over');

		YYBEGIN(PUT_SC);
	%}
	;
OrgSect: OR_HEAD
	 %{
		nLastLoc := -4;
		writeln('begin scanning orignal section by referrence ', $1);
	 %}
	 TabLine OR_TAIL 	%{
	 
		nLastLoc := $1;
		writeln('before putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		if length(strBuf) > 0 then begin
			for i := length(strBuf) downto 1 do
				yyunget();
		end;
		strBuf := '';
		writeln('after putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		writeln('scanning orignal section is over');

		YYBEGIN(PUT_SC);
	%}
	;

TabLine: TabLine LOCN	%{
		if nLastLoc >= -1 then begin
			$$ := $1;
			if nLastLoc > -1 then
			begin
				pr1.line := @2.firstLine;
				pr1.col := @2.firstColumn;
				$$.push_back(pr1);
			end
			else begin
				$$.push_back($2);
			end;
		end
		else begin
			if (@2.firstLine <> $2.line) or (@2.firstColumn <> $2.col) then
				writeln('`@2.firstLine = ', @2.firstLine, #9'`@2.firstColumn = ', @2.firstColumn,
						#9'Loc.line = ', $2.line, #9'Loc.col = ', $2.col);
		end;
	%}
	| LOCN		%{
		if nLastLoc >= -1 then begin
			$$ := vector_t.create(sizeof(loc_pair_t));
			if nLastLoc > -1 then begin
				pr1.line := @1.firstLine;
				pr1.col := @1.firstColumn;
				$$.push_back(pr1);
			end
			else begin
				$$.push_back($1);
			end
		end
		else begin
			if (@1.firstLine <> $1.line) or (@1.firstColumn <> $1.col) then begin
				
				writeln('`@1.firstLine = ', @1.firstLine, #9'`@1.firstColumn = ', @1.firstColumn, 
						#9'Loc.line = ', $1.line, #9'Loc.col = ', $1.col);
			end;
		end;
	%}
	;
%%


<</templ>>

<<templ "testexe-interface-loc2-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

var
	vpvlp: vpvlp_t;
	strBuf: string = '';
	nLoc: integer = -1;

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse(vpvlp, strBuf, nLoc);
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-location-template">>
/*
	sample program: location counter
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
*/
%header%{
{$H+}
uses SysUtils;

type
	locVal_t = record
		line: integer;
		col: integer;
	end;
	

%}

%lvar-decl%{
	n: integer;
	pbuf: YYPBUFFER;
%}

fname	"<"[^\<\>\n\*\/\\\?]+">"
locn	[[:digit:]]{3}

%yywrap%{ result := false; %}

%union%{
	case boolean of
	true: (locVal: locVal_t);
	false: (nVal: integer);
%}

%token TABGET TABSET FOPENED FCLOSED
%token<locVal> LOCN

%%

"tab?"		writeln('tabsize = ', yyget_tabsize);
			result := TABGET;
			exit;

"tab="[[:digit:]]	n := ord(yytext[4]) - 48;
			yyset_tabsize(n);
			writeln('tabsize is ', yyget_tabsize(), ' now');
			result := TABSET;
			exit;

{fname}		yytext[yyleng - 1] := #0;
			pbuf := yy_new_filebuf(pchar(yytext + sizeof(char)));
			if pbuf = nil then begin
				writeln('Error: failed to open file `', pchar(yytext + 1), '`');
				result := -1;
				exit;
			end
			else begin
				writeln('file `', pchar(yytext + sizeof(char)), '` is open.');
			end;
		
			yy_switch_buffer(pbuf);
			result := FOPENED;
			exit;

{locn}			yylval.locVal.line := ord(yytext[0]) - 48;
			yylval.locVal.col := (ord(yytext[1]) - 48) * 10 + ord(yytext[2]) - 48;
			result := LOCN;
			exit;

\n			result := 10;
			exit;

.

<<EOF>>			yy_delete_buffer();
				writeln('file closed.');
				result := FCLOSED;
				exit;

%%

Files:	Files File FCLOSED
	| File FCLOSED
	;

File:	File Line
	| Line
	;

Line:	FOPENED
	| TabLine '\n'
	;
TabLine: TabLine TLItem
	| TLItem
	;

TLItem: TABGET
	| TABSET
	| LOCN	%{
		if (@1.firstLine <> $1.line) or (@1.firstColumn <> $1.col) then begin
			writeln('Error: failed to verify location information. `@1.firstLine = ', @1.firstLine,
				#9'`@1.firstColumn = ', @1.firstColumn,
				#9'Loc.line = ', $1.line, #9'Loc.col = ', $1.col);
		end;
	%}
	;

%%

<</templ>>


<<templ "testexe-interface-location-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-yyerror-template">>
/*
 *	sample program: test yyerror
 */

%header%{
uses SysUtils, StrUtils;
procedure myerror(msg: string);

%}

num	[[:digit:]]+
cid	[A-Za-z_][A-Za-z_0-9]*

%token NUM CID

%%

{num}	result := NUM;
		exit;
{cid}	result := CID;
		exit;

[ \t]
\r?\n	result := 10;
		exit;
.

%%

Lines: Lines Line
	|
	;
Line: Numbers '\n'
	;
Numbers: Numbers Unit
	|
	;
Unit: NUM
	| error '\n' %{
		yyerrok();
	%}
	;
%%

procedure myerror(msg: string);
begin
	
	writeln('Redirect to my error-handler ---- ', msg);
end;


<</templ>>

<<templ "testexe-interface-yyerror-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	yyseterror(myerror);
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.
<</templ>>

<<templ "esc-char-inaction-template">>
/*
	feature to test: using escape char, transform meta-symbols such as
		 $$, $n, @$, @n, %}, $<..>$, $<...>n
		to literal text in %{ %} embraced actions
*/

%header%{
uses SysUtils, StrUtils;
//in declaration header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}

%{

//in definition header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}

%lex-init%{
	writeln('in lex-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%pre-match%{
	writeln('in pre-match: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%lvar-decl%{
	//writeln('in lexvar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}
%lvar-init%{
	writeln('in lexvar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%yywrap%{
	writeln('in yywrap: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%destructor%{
	writeln('in destruct<>: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%} <>

%parse-init%{
	writeln('in parse-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%parse-exit%{
	writeln('in parse-exit: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%union%{
	//in SVT defintion: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
	nVal: integer;
	pchVal: pchar;
%}

%location%{
	//in location type definiton: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
	firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
%}

%pvar-decl%{
	//writeln('in parsevar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}
%pvar-init%{
	writeln('in parsevar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%formal-param%{var n: integer
//in formal-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}
%actual-param%{n
//in actual-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}

%token<pchVal> NUM
%token<pchVal> CID

%type<nVal> Symbols

%%

[[:digit:]]+	begin
		getmem(yylval.pchVal, yyleng + 1);
		strlcopy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] := #0;

		result := NUM;
		exit;
	end;
	
[[:cidf:]][[:cids:]]*	begin
		getmem(yylval.pchVal, yyleng + 1);
		strlcopy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] := #0;

		result := CID;
		exit;
	end;
.|\n

%%

Start: Symbols
	;
Symbols: Symbols CID	%{
		n := n + 1;
		writeln('`$2 is a C-style ID, its value is ', $2);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	| Symbols NUM	%{
		$$ := $$ + 1;
		writeln('`$2 is a number, its value is ', $2);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	| CID		%{
		n := 1;
		writeln('`$1 is a C-style ID, its value is ', $1);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	| NUM		%{
		$$ := 1;
		writeln('`$1 is a number, its value is ', $1);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	;

%%

<</templ>>

<<templ "testexe-esc-char-inaction-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

var
	ncnt: integer;

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	ncnt := 0;
	<<prefix/>>parse(ncnt);
	
<<after_buffer_usage/>>

end.
<</templ>>


<<templ "script-empty-sect-2">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/

%header%{

{$H-}

uses SysUtils, StrUtils;
var
	s_pfile: ^text = nil;
function myinput: integer;
%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ writeln(#9#9, $1); %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ := $1; %}
	| Number Digit	%{ $$ := $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ := 0; %}
	| '1'		%{ $$ := 1; %}
	| '2'		%{ $$ := 2; %}
	| '3'		%{ $$ := 3; %}
	| '4'		%{ $$ := 4; %}
	| '5'		%{ $$ := 5; %}
	| '6'		%{ $$ := 6; %}
	| '7'		%{ $$ := 7; %}
	| '8'		%{ $$ := 8; %}
	| '9'		%{ $$ := 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
%%

function myinput: integer;
var
	c: char;
begin

	if s_pfile = nil then begin
		myinput := 0;
		exit;
	end;

	read(s_pfile^, c);

	if c = PAS_EOF__ then myinput := 0
	else myinput := ord(c);

end;

<</templ>>

<<templ "testexe-script-empty-sect-2">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_myinput/>>
	<<prefix/>>setlex(myinput);
	<<prefix/>>parse();
	
	if (s_pfile <> nil ) and (s_pfile <> @input) then
	begin
		closefile(s_pfile^);
		dispose(s_pfile);
	end;
end.

<</templ>>

<<templ "script-only-3-sections">>

/*************************************************************************
feature to test: scannerless parser (section 2 of script is empty)
	 	 without user-code section
**************************************************************************/
%header%{

{$H-}

uses SysUtils, StrUtils;
var
	s_pfile: ^text = nil;

function myinput: integer;
%}

%{


function myinput: integer;
var
	c: char;
begin

	if s_pfile = nil then begin
		myinput := 0;
		exit;
	end;

	read(s_pfile^, c);

	if c = PAS_EOF then myinput := 0
	else myinput := ord(c);

end;

%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ writeln(#9#9, $1); %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ := $1; %}
	| Number Digit	%{ $$ := $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ := 0; %}
	| '1'		%{ $$ := 1; %}
	| '2'		%{ $$ := 2; %}
	| '3'		%{ $$ := 3; %}
	| '4'		%{ $$ := 4; %}
	| '5'		%{ $$ := 5; %}
	| '6'		%{ $$ := 6; %}
	| '7'		%{ $$ := 7; %}
	| '8'		%{ $$ := 8; %}
	| '9'		%{ $$ := 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
<</templ>>

<<templ "testexe-script-only-3-sections">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_myinput/>>
	<<prefix/>>setlex(myinput);
	<<prefix/>>parse();
	
	if (s_pfile <> nil ) and (s_pfile <> @input) then
	begin
		closefile(s_pfile^);
		dispose(s_pfile);
	end;
end.

<</templ>>


<<templ "script-empty-sect-3">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{

%}

%%
.|\n	write(yytext);
%%

<</templ>>

<<templ "testexe-script-empty-sect-3">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>lex;
	<<after_buffer_usage/>>
end.

<</templ>>

<<templ "script-dprec-rrc">>
/*
testing program: extract parentheses from expression, and convert them to brackets
	the purpose of this program is to show how to resolve reduce-reduce conflicts
	by %dprec
*/

%left '(' ')'
%%

[\(\)]		begin 
				result := ord(yytext[0]);
				exit;
			end;
			
\n			writeln;
.			write(yytext[0]);
%%

Program: PExpr %dprec 2 %{
		writeln('Done!');
		YYACCEPT;
	%}
	;
PExpr: PExpr PExpr %dprec 3
	| '(' 
	%{ write('['); %}
	PExpr ')' %{ write(']'); %}
	| %dprec 1
	;
%%

<</templ>>

<<templ "testexe-script-dprec-rrc">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	<<after_buffer_usage/>>
end.

<</templ>>


<</templs>>

<<<----------top-level suite: / ---------->>>
<<suites make="subdir-makefile-template">>


<<<----------sub-suite: /lex-alone ---------->>>
<<suite "lex-alone" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/begin---------->>>
	<<suite "begin" make="subdir-makefile-template">>

<<<----case: /lex-alone/begin/case-insensitive---->>>
		<<case "case-insensitive" make="lex-only-makefile-template">>
			<<upgen_options>>-i<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: case-insensitive
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
	XYZs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
	XYZs := 0;
				<</init_code>>
				<<lex_section>>
abc		writeln(yytext, ' ---> `abc''');
		abcs := abcs + 1;
XYZ		writeln(yytext, ' ---> `XYZ''');
		XYZs := XYZs + 1;
.|\n	{ do nothing}
				<</lex_section>>
				<<after_init>>
	yylex;
	writeln('abc''s = ', abcs);
	writeln('XYZ''s = ', XYZs);
				<</after_init>>
			<</script>>
			
			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
ABCD
xyz1232
abcd
XYZJFSLK
			<</textfile>>
			<<textfile "result.out">>
ABC ---> `abc'
xyz ---> `XYZ'
abc ---> `abc'
XYZ ---> `XYZ'
abc's = 2
XYZ's = 2
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/case-insensitive---->>>


<<<----case: /lex-alone/begin/debug-option---->>>
		<<case "debug-option" make="lex-only-makefile-template">>
			<<upgen_options>>-d<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%x	SC1
				<</declare_section>>
				<<lex_section>>
\{	YYBEGIN(SC1);
<SC1>\}	YYBEGIN(INITIAL);

<*>abc	abcs := abcs + 1;
<*>.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
acde
ABCabc
{
aabc
cccabc

			<</textfile>>
			<<textfile "result.out">>
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`a'}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`d'}, rule at line: 95
.................... accept {`e'}, rule at line: 95
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`A'}, rule at line: 95
.................... accept {`B'}, rule at line: 95
.................... accept {`C'}, rule at line: 95
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`{'}, rule at line: 91
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`a'}, rule at line: 95
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept unprintable-char{10}, rule at line: 95
.................... EOF reached
.................... EOS reached
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/debug-option---->>>


<<<----case: /lex-alone/begin/entry-param---->>>
		<<case "entry-param" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%formal-param%{abc: integer; def: char %}
%actual-param%{abc, def %}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				
				<<local_decl_code>>
var
	nret: integer;
				<</local_decl_code>>
				<<after_init>>
	nret := yylex(0, #0);
	if nret = 0 then begin
		result := 0;
		exit;
	end;
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/entry-param---->>>

<<<----case: /lex-alone/begin/eol-lookahead---->>>
		<<case "eol-lookahead" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/* test operator '$' */
				<</desc>>

				<<lex_section>>
.+$		writeln('whole-text = "', yytext, '".');
		writeln('lookahead-text = "', pchar(yytext + sizeof(char) * yyleng), '".');
		yytext[yyleng] := #0;
		writeln('matched-text = "', yytext, '".');

\n		writeln('a newline is matched.');
				<</lex_section>>
				<<local_decl_code>>
var
	nret: integer;
				<</local_decl_code>>

				<<after_init>>
	nret := yylex;
	if nret = 0 then begin
		result := 0;
		exit;
	end;
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
/* test operator '$' */

%%

.+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
		yytext[yyleng] = '\0';
		fprintf(stdout, "matched-text = \"%s\".\n", yytext);

\n		fprintf(stdout, "a newline is matched.\n");

%%

/* empty */

%%

int main(int argc, char **argv) {

	if(argc < 2) {
		yylexfile(NULL, true);
	}
	else {
		if(yylexfile(argv[1], false)) {
			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
			return -1;
		}
	}

	return yylex();
}
			<</textfile>>
			<<textfile "result.out">>
whole-text = "/* test operator '$' */
".
lookahead-text = "
".
matched-text = "/* test operator '$' */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);".
a newline is matched.
whole-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);".
a newline is matched.
whole-text = "		yytext[yyleng] = '\0';
".
lookahead-text = "
".
matched-text = "		yytext[yyleng] = '\0';".
a newline is matched.
whole-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);".
a newline is matched.
a newline is matched.
whole-text = "\n		fprintf(stdout, "a newline is matched.\n");
".
lookahead-text = "
".
matched-text = "\n		fprintf(stdout, "a newline is matched.\n");".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "/* empty */
".
lookahead-text = "
".
matched-text = "/* empty */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "int main(int argc, char **argv) {
".
lookahead-text = "
".
matched-text = "int main(int argc, char **argv) {".
a newline is matched.
a newline is matched.
whole-text = "	if(argc < 2) {
".
lookahead-text = "
".
matched-text = "	if(argc < 2) {".
a newline is matched.
whole-text = "		yylexfile(NULL, true);
".
lookahead-text = "
".
matched-text = "		yylexfile(NULL, true);".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
whole-text = "	else {
".
lookahead-text = "
".
matched-text = "	else {".
a newline is matched.
whole-text = "		if(yylexfile(argv[1], false)) {
".
lookahead-text = "
".
matched-text = "		if(yylexfile(argv[1], false)) {".
a newline is matched.
whole-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
".
lookahead-text = "
".
matched-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);".
a newline is matched.
whole-text = "			return -1;
".
lookahead-text = "
".
matched-text = "			return -1;".
a newline is matched.
whole-text = "		}
".
lookahead-text = "
".
matched-text = "		}".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
a newline is matched.
whole-text = "	return yylex();
".
lookahead-text = "
".
matched-text = "	return yylex();".
a newline is matched.
whole-text = "}
".
lookahead-text = "
".
matched-text = "}".
a newline is matched.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eol-lookahead---->>>


<<<----case: /lex-alone/begin/eos-action---->>>
		<<case "eos-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined END-OF-FILE action
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%yywrap%{

	writeln('YYSTART = ', YYSTART());
	result := false;
%}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
YYSTART = 0
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eos-action---->>>


<<<----case: /lex-alone/begin/lex-init-action---->>>
		<<case "lex-init-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined lex-init action, which is executed
	before pattern-matching
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%lex-init{

	writeln('Let''s get started');
%}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
Let's get started
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/lex-init-action---->>>


<<<----case: /lex-alone/begin/prematch-action---->>>
		<<case "prematch-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined prematch action, which is executed just before
	action corresponding matched pattern
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
	matches: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
	matches := 0;
				<</init_code>>

				<<declare_section>>
%pre-match{

	if strcomp(yytext, 'abc') = 0 then
		matches := matches + 1;

%}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	
	writeln('number of "abc" is ', abcs);
	writeln('number of matches is ', matches);
				<</lex_section>>
				<<after_init>>
	yylex();
	if abcs = matches then
		writeln('abcs equals matches')
	else
		writeln('abcs is different from matches');
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
number of matches is 4
abcs equals matches
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/prematch-action---->>>


<<<----case: /lex-alone/begin/simplest---->>>
		<<case "simplest" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test simplest case to check basic features
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/simplest---->>>


<<<----case: /lex-alone/begin/yyterminate---->>>
		<<case "yyterminate" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-interface: yyterminate
*/
				<</desc>>
				<<lex_section>>
q|Q		writeln;
		writeln('It is time to say goodbye.');	
		yyterminate();

.|\n	write(yytext);

<<EOF>>	writeln('Something wrong happened.');
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
hello, yyterminate
no more to say
q
			<</textfile>>
			<<textfile "result.out">>
hello, yyterminate
no more to say

It is time to say goodbye.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/yyterminate---->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/begin---------->>>


<<<----------sub-suite: /lex-alone/basic---------->>>
	<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/basic/action---->>>
		<<suite "action" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/action/ECHO---->>>
			<<case "ECHO" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: ECHO
*/
					<</desc>>
					<<declare_section>>
cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	writeln('Start scanning upgen script ...');
%}
					<</declare_section>>
					<<lex_section>>
int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); writeln('... keyword.');

{cid}		ECHO(); writeln('... identifier.');
{digit}		ECHO(); writeln('... number');
{punct}
.|\n
					<</lex_section>>
					<<after_init>>
		yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test built-in routines: ECHO
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	cout << "Start scanning upgen script ..." << endl;
%}

%%

int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); cout << "... keyword." << endl;

{cid}		ECHO(); cout << "... identifier." << endl;
{digit}		ECHO(); cout << "... number" << endl;
{punct}
.|\n

%%
				<</textfile>>
				<<textfile "result.out">>
Start scanning upgen script ...
test... identifier.
built... identifier.
in... identifier.
routines... identifier.
ECHO... identifier.
#include... keyword.
iostream... identifier.
using... keyword.
std... identifier.
cout... identifier.
using... keyword.
std... identifier.
endl... identifier.
cid... identifier.
cidf... identifier.
cids... identifier.
digit... identifier.
digit... identifier.
punct... identifier.
punct... identifier.
lex... identifier.
init... identifier.
cout... identifier.
Start... identifier.
scanning... identifier.
upgen... identifier.
script... identifier.
endl... identifier.
int... keyword.
void... keyword.
if... keyword.
return... keyword.
NULL... keyword.
using... keyword.
#include... keyword.
ECHO... identifier.
cout... identifier.
keyword... identifier.
endl... identifier.
cid... identifier.
ECHO... identifier.
cout... identifier.
identifier... identifier.
endl... identifier.
digit... identifier.
ECHO... identifier.
cout... identifier.
number... identifier.
endl... identifier.
punct... identifier.
n... identifier.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/ECHO---->>>


<<<----------case: /lex-alone/basic/action/yy_buffer---->>>
			<<case "yy_buffer" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yy_new_filebuf(file-name): buffer-object
	yy_push_buffer(buffer-object)
	yy_pop_buffer(): buffer-object
	yy_delete_buffer()
	yy_switch_buffer(buffer-object)
	yy_has_buffer(): false/true
	yy_current_buffer(): buffer-object
	yy_set_bol(false/true)
	yyinput(): char
*/
					<</desc>>
					<<global_decl_code>>
const
	MAX_BUF_NUM = 10;
	
var
	fnlist: array[0..MAX_BUF_NUM - 1] of pchar;
	cur_size: integer;
					<</global_decl_code>>
					<<init_code>>
	cur_size := 0;
					<</init_code>>
					<<declare_section>>
%lexvar-decl%{
var
	c, beg: integer;
	poldbuf, pnewbuf: YYPBUFFER;
	pch: pchar;
%}

fn	[^\\\/\*\r\n\t ]+
					<</declare_section>>
					<<lex_section>>
#include[ \t]*\<{fn}\>	begin

		repeat
			c := yyinput;
		until (c = END_OF_FILE) or (c = 10);

		yy_set_bol(true);

		if cur_size <  MAX_BUF_NUM then begin

			beg := 8;
			while yytext[beg] <> '<' do beg := beg + 1;
			beg := beg + 1;
			
			getmem(pch, (yyleng - beg) * sizeof(char));
			
			strlcopy(pch, pchar(yytext + sizeof(char) *beg), yyleng - beg - 1);
			beg := yyleng - beg - 1;
			pch[beg] := #0;

			pnewbuf := yy_new_filebuf(pch);
			if pnewbuf <> nil then begin
				poldbuf := yy_current_buffer();
				yy_push_buffer(pnewbuf);
				yy_push_buffer(poldbuf);
				fnlist[cur_size] := pch;
				cur_size := cur_size + 1;
			end
			else begin
				writeln('Warning: failed to open file `', pch, '''');
				freemem(pch);
				
			end;		
		end;
	end;

#open[ \t]*\<{fn}\>	begin

		repeat
			c := yyinput;
		until (c = END_OF_FILE) or (c = 10);
		if cur_size <  MAX_BUF_NUM then begin

			beg := 5;
			while yytext[beg] <> '<' do beg := beg + 1;
			beg := beg + 1;
			
			getmem(pch, (yyleng - beg) * sizeof(char));
			
			strlcopy(pch, pchar(yytext + sizeof(char) *beg), yyleng - beg - 1);
			beg := yyleng - beg - 1;
			pch[beg] := #0;
	
			pnewbuf := yy_new_filebuf(pch);
			if pnewbuf <> nil then begin
				yy_push_buffer(pnewbuf);
				fnlist[cur_size] := pch;
				cur_size := cur_size + 1;
				yy_set_bol(true);
			end
			else begin
				writeln('Warning: failed to open file `', pch, '''');
				freemem(pch);
			end;
				
		end;
   	end;

#overwrite[ \t]*\<{fn}\>	begin

		repeat
			c := yyinput;
		until (c = END_OF_FILE) or (c = 10);

		if cur_size <  MAX_BUF_NUM then begin

			beg := 5;
			while yytext[beg] <> '<' do beg := beg + 1;
			beg := beg + 1;
			
			getmem(pch, (yyleng - beg) * sizeof(char));
			
			strlcopy(pch, pchar(yytext + sizeof(char) *beg), yyleng - beg - 1);
			beg := yyleng - beg - 1;
			pch[beg] := #0;
	
			yy_delete_buffer();

			pnewbuf := yy_new_filebuf(pch);
			if pnewbuf <> nil then begin

				yy_push_buffer(pnewbuf);
				fnlist[cur_size] := pch;
				cur_size := cur_size + 1;
				yy_set_bol(true);
			end
			else begin
				writeln('Warning: failed to open file `', pch, '''');
				freemem(pch);;

			end;		
		end;
    end;
    
<<EOF>>		begin

		writeln;
		if yy_has_buffer() then begin

			yy_pop_buffer();
			yy_set_bol(true);
		end;
    end;
.|\n		write(yytext);
					<</lex_section>>
				
					<<local_decl_code>>
var
	i: integer;
					<</local_decl_code>>
					<<after_init>>
	yylex();
	for i := 0 to cur_size - 1 do

		freemem(fnlist[i]);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
******** test.input begin **********
#include<test1.input>
aaa
aaa
#open <test2.input>
aaa
******** test.input over ***********
				<</textfile>>
				<<textfile "test1.input">>
******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********
				<</textfile>>
				<<textfile "test2.input">>
******** test2.input begin **********
ccc
ccc
#overwrite<test3.input>
ccc
******** test2.input over ***********
				<</textfile>>
				<<textfile "test3.input">>
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********
				<</textfile>>
				<<textfile "result.out">>
******** test.input begin **********
aaa
aaa
******** test2.input begin **********
ccc
ccc
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********

aaa
******** test.input over ***********

******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yy_buffer---->>>


<<<----------case: /lex-alone/basic/action/yyinput---->>>
			<<case "yyinput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyinput(): char
	yyunput(char)
	yy_set_bol(false/true)
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%lvar-decl%{
var
	c: integer;
%}
					<</declare_section>>
					<<lex_section>>
"/*"	repeat
			c := yyinput;
			if c = END_OF_FILE then break;
			if chr(c) = '*' then begin
				c := yyinput;
				if (chr(c) = '/') or ( c = END_OF_FILE) then
					break;
				yyunput(chr(c));
			end;	
		until c = END_OF_FILE;

"//"	repeat
			c := yyinput;
		until (c = 10) or (c = END_OF_FILE);

		yy_set_bol(true);

^[ \t]+.*\n	write(yytext);
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
 just test for yyinput & yyunput
*/show me
 you can see me
 if there is not `beautiful life', then life is awful
//something wrong must be happened
/*
 
*************
/
Oops!
************/
 beautiful life
//***********************/
I am Prince of Darkness, so you can't see me
//************/**************/**********/
 and God will always be with you.
				<</textfile>>
				<<textfile "result.out">>
 you can see me
 if there is not `beautiful life', then life is awful
 beautiful life
 and God will always be with you.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyinput---->>>


<<<----------case: /lex-alone/basic/action/yyless---->>>
			<<case "yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyless(number-of-chars)
*/
					<</desc>>
					<<lex_section>>
"hello, world"	write(yytext); yyless(7);
"world"		write(yytext);
"Hi, guys"	write(yytext); yyless(4);
"guys"		write(yytext);
\n		writeln;
.

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
104 101 108 108 111 44 32 119 111 114 108 100 10 72 105 44 
32 103 117 121 115 10 10 -43 -116 58 -98 -119 88 -127 -96 15 
-47 82 -73 -50 -100 -62 -49 -8 79 -68 108 90 -112 -90 -3 124 
-80 37 32 -48 -52 -84 -93 64 -107 10 -110 66 -82 85 51 -42 
74 -72 36 38 -67 -123 92 119 -94 80 -40 -36 16 101 97 103 
47 12 -115 -113 105 114 -75 22 -57 -2 30 -12 3 -65 102 -121 
44 -22 -60 -44 -64 33 99 107 120 115 -104 55 28 77 -109 57 
83 69 98 42 -91 96 87 -106 65 11 41 94 126 8 29 -66 
-111 7 0 -39 95 113 48 61 -46 40 -18 100 123 -53 -99 -74 
49 1 -30 86 -5 45 -37 -85 89 34 -114 -10 24 116 -79 -89 
54 -23 60 62 76 -9 59 -117 -76 -95 31 127 -35 -17 68 -15 
84 -38 26 53 -54 -16 56 -105 78 110 -124 81 17 -19 -6 93 
-4 -78 -13 67 109 -83 117 122 91 -41 52 2 125 -97 -126 -25 
6 -24 70 -77 13 104 20 72 -1 -70 43 -103 46 -7 -108 -21 
-45 121 35 -31 39 -20 -26 25 -125 106 27 -81 -55 -92 19 -88 
-102 -61 -128 -120 -101 71 14 -51 -11 -59 -29 -28 -122 5 -71 -34 
73 4 -14 -69 -32 75 -87 18 -27 63 112 -58 23 -63 -56 111 
21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
hello, worldworld
Hi, guysguys


				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyless---->>>


<<<----------case: /lex-alone/basic/action/yymore--->>>
			<<case "yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>
/*
test built-in routines:
	yymore()
*/
					<</desc>>
					<<lex_section>>
"It\'s"		writeln(yytext); yymore();
"nice to"	writeln(yytext); yymore();
"see you!"	writeln(yytext); yymore();
" "		writeln('*'); yymore();
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
It's nice to see you!
None of these are available.
				<</textfile>>
				<<textfile "result.out">>
It's
*
It's nice to
*
It's nice to see you!
*
*
*
*
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yymore---->>>


<<<----------case: /lex-alone/basic/action/yyrestart--->>>
			<<case "yyrestart" make="lex-only-makefile-template">>
				<<EXTRA_DIST>>test1.input<</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyrestart()
*/
					<</desc>>
					<<global_decl_code>>
const
	MAX_OPEN_TIMES = 8;
var
	useFile: boolean;
	reopen_times: integer;
	pbuf: YYPBUFFER;
					<</global_decl_code>>
					<<init_code>>
	useFile := false;
	reopen_times := 0;
					<</init_code>>
					<<declare_section>>
%yywrap%{

	if not useFile then begin
		pbuf := yy_new_filebuf('test1.input');
		if pbuf = nil then begin
			writeln('failed to open `test1.input''');
			yyterminate();
		end
		else
			yy_switch_buffer(pbuf);
	end;
	useFile := true;
	result := false;
%}

%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
	
a	write(yytext); ncnt := ncnt + 1;

<<EOF>>	begin
		writeln;
		if useFile and (reopen_times < MAX_OPEN_TIMES) then begin

			reopen_times := reopen_times + 1;
			yyrestart();
			yy_set_bol(true);
		end;
	end;

.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln; writeln('a''s occurrences: ', ncnt);
	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
aa
				<</textfile>>
				<<textfile "test1.input">>
aa
				<</textfile>>
				<<textfile "result.out">>
aa
aa
aa
aa
aa
aa
aa
aa
aa

a's occurrences: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyrestart---->>>



<<<----------case: /lex-alone/basic/action/yysc_state--->>>
			<<case "yysc_state" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	YYSTART()
	yy_push_state(DFA-begin-state)
 	yy_pop_state()
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%x	sc1
%x	sc2
%x	sc3
%x	sc4
					<</declare_section>>
					<<lex_section>>
<INITIAL,sc1,sc2,sc3>"("	begin
		
		case YYSTART of
		INITIAL:	yy_push_state(sc1);
		sc1:	yy_push_state(sc2);
		sc2:	yy_push_state(sc3);
		sc3:	yy_push_state(sc4);
		end;
	end;

<sc1,sc2,sc3,sc4>")"	yy_pop_state();

<*>[[:space:]]+

<sc1>[^\(\)\r\n \t]+	
		writeln(#9, yytext);

<sc2>[^\(\)\r\n \t]+
		writeln(#9#9, yytext);

<sc3>[^\(\)\r\n \t]+
		writeln(#9#9#9, yytext);

<sc4>[^\(\)\r\n \t]+
		writeln(#9#9#9#9, yytext);

[^\(\)\n\r \t]+	
		writeln(yytext);

<*>.|\r?\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
	(define
		(right-branch
		tree)
		(cadr
		tree))
	(define
		(symbols
		tree)
		(if
			(leaf?
			tree)
			(list
				(symbol-leaf
				tree))
			(caddr tree)))
	(define
		(weight
		tree)
		(if
			(leaf?
			tree)
			(weight-leaf
			tree)
			(cadddr tree)))
				<</textfile>>
				<<textfile "result.out">>
	define
		right-branch
		tree
		cadr
		tree
	define
		symbols
		tree
		if
			leaf?
			tree
			list
				symbol-leaf
				tree
			caddr
			tree
	define
		weight
		tree
		if
			leaf?
			tree
			weight-leaf
			tree
			cadddr
			tree
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yysc_state---->>>


<<<----------case: /lex-alone/basic/action/yyunput--->>>
			<<case "yyunput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyunput(char-to-put)
*/
					<</desc>>
					<<declare_section>>
%lex-init%{
	writeln('Play game of `Change Word''');
%}
					<</declare_section>>
					<<lex_section>>
bad	yyunput('d');
	yyunput('o');
	yyunput('o');
	yyunput('g');

ugly	yyunput('e');
	yyunput('t');
	yyunput('u');
	yyunput('c');

cruel	yyunput('d');
	yyunput('n');
	yyunput('i');
	yyunput('k');

lie	yyunput('h');
	yyunput('t');
	yyunput('u');
	yyunput('r');
	yyunput('t');

proud	yyunput('e');
	yyunput('l');
	yyunput('b');
	yyunput('m');
	yyunput('u');
	yyunput('h');

.|\n	write(yytext);

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
Once upon a time, there is very bad, ugly guy. He is alway very cruel to people around him, and force himself to tell at leat a lie everyday. What's more, he is a very proud man.
				<</textfile>>
				<<textfile "result.out">>
Play game of `Change Word'
Once upon a time, there is very good, cute guy. He is alway very kind to people around him, and force himself to tell at leat a truth everyday. What's more, he is a very humble man.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyunput---->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/action---->>>



<<<----------sub-suite: /lex-alone/basic/charset---->>>
		<<suite "charset" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/charset/charset-blank--->>>
			<<case "charset-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
[ \t]		ncnt := ncnt + 1;
[ \t]{5}	ncnt := ncnt + 10;
[ \t]+		ncnt := ncnt + yyleng * 3;

.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
 a a a a
					b
          c
				<</textfile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>
			<<case "charset-cesc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
	escape char in C language
*/
					<</desc>>
					<<global_decl_code>>
var
	ncnt: integer;
					<</global_decl_code>>
					<<init_code>>
	ncnt := 0;
					<</init_code>>
					<<declare_section>>
cesc1	[\0\?\\\"\'\a\b\f\n\r\t\v]
cesc2	\0|\?|\\|\"|\'|\a|\b|\f|\n|\r|\t|\v
cesc3	"\0"|"\?"|"\\"|"\""|"\'"|"\a"|"\b"|"\f"|"\n"|"\r"|"\t"|"\v"

					<</declare_section>>
					<<lex_section>>
{cesc1}		ncnt := ncnt + 1;
{cesc2}{5}	ncnt := ncnt + 10;
{cesc3}+	ncnt := ncnt + yyleng * 3;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	writeln(ncnt);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
7 65 0 65 9 65 10 65 63 34 39 63 39 65 11 13 
11 13 92 92 92 92 13 34
				<</bytefile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>


<<<----------case: /lex-alone/basic/charset/charset-concat--->>>
			<<case "charset-concat" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation:
	concat
*/
					<</desc>>
					<<declare_section>>
int	[\+\-]?([1-9][0-9]*|0)
hex	\\[Xx][0-9A-Fa-f][0-9A-Fa-f]
oct	\\[0-3][0-7][0-7]
real	{int}|{int}"\."[0-9]+
					<</declare_section>>
					<<lex_section>>
{int}	|
{hex}	|
{oct}	|
{real}	writeln(yytext);
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/+100 c-999 a7777
\xffe wiof\X33kis \\x4232 \XDCE
dd\001\777\888\999\aaa
43.90a 48.23b1233204.738429sfsj4332
				<</textfile>>
				<<textfile "result.out">>
+100
-999
7777
\xff
\X33
\x42
32
\XDC
\001
777
888
999
43.90
48.23
1233204.738429
4332
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-concat--->>>


<<<----------case: /lex-alone/basic/charset/charset-email--->>>
			<<case "charset-email" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze email address 
*/
					<</desc>>
					<<global_decl_code>>
var
	ncnt: integer;
					<</global_decl_code>>
					<<init_code>>
	ncnt := 0;
					<</init_code>>
					<<declare_section>>
/* name section */
nsect	[0-9A-Za-z\_\-]{1,}
/* name */
name	{nsect}("."{nsect})*
emaddr	{name}\@{name}
					<</declare_section>>
					<<lex_section>>
{emaddr}	writeln(yytext); ncnt := ncnt + 1;

.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	writeln(ncnt);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
somebody.upgen@robot.com
somebody.upgen@r@obot.com
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
				<</textfile>>
				<<textfile "result.out">>
somebody.upgen@robot.com
somebody.upgen@r
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
3
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-email--->>>


<<<----------case: /lex-alone/basic/charset/charset-hex--->>>
			<<case "charset-hex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning hexadecimal numbers
*/
					<</desc>>
					<<global_decl_code>>
var
	blanks: integer;
	spaces: integer;
	digits: integer;
	uppers: integer;
	lowers: integer;
	eofs: integer;
	nansis: integer;
					<</global_decl_code>>
					
					<<init_code>>
	blanks := 0;
	spaces := 0;
	digits := 0;
	uppers := 0;
	lowers := 0;
	eofs := 0;
	nansis := 0;
					<</init_code>>
					<<declare_section>>
blank	[\x09\x20]
space	[\x09-\x0D]
digit	[\x30-\x39]
upper	[\X41-\X5a]
lower	[\x61-\X7A]
eof	[\XFf]
nansi	[\X80-\xff]
					<</declare_section>>
					<<lex_section>>
{blank}		blanks := blanks + 1;
{space}		spaces := spaces + 1;
{digit}		digits := digits + 1;
{upper}		uppers := uppers + 1;
{lower}		lowers := lowers + 1;
{eof}		eofs := eofs + 1;
{nansi}		nansis := nansis + 1;
.|\n
					<</lex_section>>
					<<after_init>>
			yylex();
			writeln('blanks: ', blanks);
			writeln('spaces: ', spaces);
			writeln('digits: ', digits);
			writeln('uppers: ', uppers);
			writeln('lowers: ', lowers);
			writeln('eofs: ', eofs);
			writeln('nansis: ', nansis);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-43 -116 58 -98 -119 88 -127 -96 15 -47 82 -73 -50 -100 -62 -49 
-8 79 -68 108 90 -112 -90 -3 124 -80 37 32 -48 -52 -84 -93 
64 -107 10 -110 66 -82 85 51 -42 74 -72 36 38 -67 -123 92 
119 -94 80 -40 -36 16 101 97 103 47 12 -115 -113 105 114 -75 
22 -57 -2 30 -12 3 -65 102 -121 44 -22 -60 -44 -64 33 99 
107 120 115 -104 55 28 77 -109 57 83 69 98 42 -91 96 87 
-106 65 11 41 94 126 8 29 -66 -111 7 0 -39 95 113 48 
61 -46 40 -18 100 123 -53 -99 -74 49 1 -30 86 -5 45 -37 
-85 89 34 -114 -10 24 116 -79 -89 54 -23 60 62 76 -9 59 
-117 -76 -95 31 127 -35 -17 68 -15 84 -38 27 53 -54 -16 56 
-105 78 110 -124 81 17 -19 -6 93 -4 -78 -13 67 109 -83 117 
122 91 -41 52 2 125 -97 -126 -25 6 -24 70 -77 13 104 20 
72 -1 -70 43 -103 46 -7 -108 -21 -45 121 35 -31 39 -20 -26 
25 -125 106 27 -81 -55 -92 19 -88 -102 -61 -128 -120 -101 71 14 
-51 -11 -59 -29 -28 -122 5 -71 -34 73 4 -14 -69 -32 75 -87 
18 -27 63 112 -58 23 -63 -56 111 21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
blanks: 2
spaces: 4
digits: 10
uppers: 26
lowers: 26
eofs: 1
nansis: 127
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-hex--->>>


<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>
			<<case "charset-ipaddress" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze ip address 
*/
					<</desc>>
					
					<<global_decl_code>>
var
	selfs: integer;
	ipaddrs: integer;
					<</global_decl_code>>
					
					<<init_code>>
	selfs := 0;
	ipaddrs := 0;
					<</init_code>>

					<<declare_section>>
self	"127"\.0{1,3}\.0{1,3}\.(0?0)?1
ipsect	[01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5]
ipaddr	({ipsect})(\.({ipsect})){3}
					<</declare_section>>
					<<lex_section>>
{self}		selfs := selfs + 1;
			writeln('localhost ', selfs, ': ', yytext);
{ipaddr}	ipaddrs := ipaddrs + 1;
			writeln('ip ', ipaddrs, ': ', yytext);
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	writeln('localhosts: ', selfs);
	writeln('others: ', ipaddrs);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
localhost1: 127.0.0.1
localhost2: 127.000.000.001
localhost3: 127.0.00.001
ip1: 192.156.173.115
ip3: 0.0.0.1
ip4: 0.0.0.0
ip5: 255.255.255.255
ip6: 256.001.002.003
ip7: 128.a.9.3
ip8: 116.119.121.34
ip2: 99.77.88.10
				<</textfile>>
				<<textfile "result.out">>
localhost 1: 127.0.0.1
localhost 2: 127.000.000.001
localhost 3: 127.0.00.001
ip 1: 192.156.173.115
ip 2: 0.0.0.1
ip 3: 0.0.0.0
ip 4: 255.255.255.255
ip 5: 56.001.002.003
ip 6: 116.119.121.34
ip 7: 99.77.88.10
localhosts: 3
others: 7
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>


<<<----------case: /lex-alone/basic/charset/charset-meta--->>>
			<<case "charset-meta" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
meta-char as escape char
*/
					<</desc>>
					<<global_decl_code>>
var
	meta1s, meta2s: integer;
	meta3s, meta4s: integer;
					<</global_decl_code>>
					<<init_code>>
	meta1s := 0;
 	meta2s := 0;
 	meta3s := 0;
 	meta4s := 0;
					<</init_code>>
					<<declare_section>>
meta1	[\%\(\)\[\]\{\}\<\>\|\<\>\:\$\^\/\*\+\,\;\.\?\-]
meta2	\%|\(|\)|\[|\]|\{|\}|\<|\>|\||\<|\>|\:|\$|\^|\/|\*|\+|\,|\;|\.|\?|\-
meta3	"\%"|"\("|"\)"|"\["|"\]"|"\{"|"\}"|"\<"|"\>"|"\|"|"\<"|"\>"|"\:"|"\$"|"\^"|"\/"|"\*"|"\+"|"\,"|"\;"|"\."|"\?"|"\-"
meta4	"%"|"("|")"|"["|"]"|"{"|"}"|"<"|">"|"|"|"<"|">"|":"|"$"|"^"|"/"|"*"|"+"|","|";"|"."|"?"|"-"

					<</declare_section>>
					<<lex_section>>
{meta1}		meta1s:= meta1s + 1; write(yytext);
{meta2}		meta2s:= meta2s + 1; write(yytext);
{meta3}		meta3s:= meta3s + 1; write(yytext);
{meta4}		meta4s:= meta4s + 1; write(yytext);
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	writeln;
	writeln('meta1s = ', meta1s);
	writeln('meta2s = ', meta2s);
	writeln('meta3s = ', meta3s);
	writeln('meta4s = ', meta4s);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
				<</textfile>>
				<<textfile "result.out">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
meta1s = 41
meta2s = 0
meta3s = 0
meta4s = 0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-meta--->>>



<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>
			<<case "charset-normal-esc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
normal char as escape char
*/
					<</desc>>
					<<global_decl_code>>
var
	norm2: integer;
	norm3: integer;
	norm4: integer;
	norm5: integer;
					<</global_decl_code>>
					<<init_code>>
	norm2 := 0;
	norm3 := 0;
	norm4 := 0;
	norm5 := 0;	
					<</init_code>>
					<<declare_section>>

norm1	\\[A-Zc-eg-mo-qsuw-z_\#\&\=\@\`\~]
norm2	"\A"|"\B"|"\C"|"\D"|"\E"|"\F"|"\G"|"\H"|"\I"|"\J"|"\K"|"\L"|"\M"|"\N"|"\O"|"\P"|"\Q"|"\R"|"\S"|"\T"|"\U"|"\V"|"\W"|"\X"|"\Y"|"\Z"|"\c"|"\d"|"\e"|"\g"|"\h"|"\i"|"\j"|"\k"|"\l"|"\m"|"\o"|"\p"|"\q"|"\s"|"\u"|"\w"|"\x"|"\y"|"\z"|"\_"|"\#"|"\&"|"\="|"\@"|"\`"|"\~"
norm3	"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"|"c"|"d"|"e"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"o"|"p"|"q"|"s"|"u"|"w"|"x"|"y"|"z"|"_"|"#"|"&"|"="|"@"|"`"|"~"
norm4	\A|\B|\C|\D|\E|\F|\G|\H|\I|\J|\K|\L|\M|\N|\O|\P|\Q|\R|\S|\T|\U|\V|\W|\X|\Y|\Z|\c|\d|\e|\g|\h|\i|\j|\k|\l|\m|\o|\p|\q|\s|\u|\w|\x|\y|\z|\_|\#|\&|\=|\@|\`|\~
norm5	A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|c|d|e|g|h|i|j|k|l|m|o|p|q|s|u|w|x|y|z|_|#|&|=|@|`|~

					<</declare_section>>
					<<lex_section>>
{norm2}		norm2 := norm2 + 1; write(yytext);
{norm3}		norm3 := norm3 + 1; write(yytext);
{norm4}		norm4 := norm4 + 1; write(yytext);
{norm5}		norm5 := norm5 + 1; write(yytext);
.|\n
					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	yylex();
	writeln;
	writeln('norm2:', norm2);
	writeln('norm3:', norm3);
	writeln('norm4:', norm4);
	writeln('norm5:', norm5);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
8 -43 -30 120 -90 29 110 54 120 -14 -67 8 -80 -94 97 23 
105 -21 -111 8 65 -77 98 125 0 22 -102 27 71 -77 -10 80 
-120 -40 -56 46 -11 54 100 109 40 33 118 -40 -61 -41 -17 45 
-62 -128 53 3 51 -104 -127 52 -82 27 79 -11 -50 69 69 86 
29 13 -123 19 67 -23 -128 107 11 -10 67 -50 -50 50 -5 -112 
-78 49 -108 -26 -55 21 27 119 48 105 108 -2 -82 -78 84 -53 
-65 -39 -34 3 -61 95 110 -50 85 -78 -100 35 -28 -104 -76 -105 
-55 72 125 -110 93 -105 9 -115 0 117 -117 -82 39 -33 121 -25 
-71 88 -22 124 -73 88 74 12 10 -26 48 -17 126 -28 -122 71 
44 3 -39 -119 -102 -30 22 -102 88 -95 72 127 -128 -63 102 57 
25 80 -75 -48 -87
				<</bytefile>>
				<<textfile "result.out">>
xxiAGPdmOEEVCkCwilT_U#HuyXXJ~GXHP
norm2:33
norm3:0
norm4:0
norm5:0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>


<<<----------case: /lex-alone/basic/charset/charset-oct--->>>
			<<case "charset-oct" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning octal numbers
*/
					<</desc>>
					
					<<global_decl_code>>
var
	digits: integer;
	uppers: integer;
	lowers: integer;
	eofs: integer;
	nansis: integer;
	
	strd: string;
	stru: string;
	strl: string;
					<</global_decl_code>>
					<<init_code>>
					
	digits := 0;
	uppers := 0;
	lowers := 0;
	eofs := 0;
	nansis := 0;
	strd := '';
	stru := '';
	strl := '';
					<</init_code>>
					<<declare_section>>
digit	[\060-\071]
upper	[\101-\132]
lower	[\141-\172]
eof		[\377]
nansi	[\200-\377]
					<</declare_section>>
					<<lex_section>>
{digit}		digits := digits + 1; strd := strd + yytext;
{upper}		uppers := uppers + 1; stru := stru + yytext;
{lower}		lowers := lowers + 1; strl := strl + yytext;
{eof}		eofs := eofs + 1;
{nansi}		nansis := nansis + 1;
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	yylex();
	writeln;
	writeln('digits: ', strd, ' ', digits, ' in total.');
	writeln('uppers: ', stru, ' ', uppers, ' in total.');
	writeln('lowers: ', strl, ' ', lowers, ' in total.');
	writeln('eofs: ', eofs);
	writeln('nansis: ', nansis);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
127 120 -93 -30 32 116 -64 2 -87 120 62 116 95 68 68 83 
-51 88 9 -21 -77 25 65 0 -69 -42 -115 -29 -74 127 -34 53 
-9 -127 24 23 -10 -40 25 -97 81 87 19 -80 -100 87 4 105 
-81 13 84 98 39 -106 98 -30 108 -16 -59 34 111 -92 88 102 
37 112 125 27 72 -105 -69 -103 -18 -50 74 -118 38 78 -12 -43 
91 72 56 -126 -34 -102 100 74 -118 42 109 -7 -50 -59 95 -13 
53 -35 15 125 116 -54 23 98 -104 97 -19 -66 -81 -31 -108 10 
41 -52 -115 8 102 -15 82 -15 27 -65 -22 -23 -124 74 -35 -71 
39 -20 55 -101 -74 78 -3 78 -81 -22 13 94 -53 -95 104 -11 
109 -11 -3 -45 -25 79 -60 2 15 -81 -20 -109 -7 -55 77 32 
-75 -124 -69 107 -46 -72 -71 -127 -93 -58 -33 110 103 71 99 -44 
61 96 -88 36 -80 108 38 -65 27 18 82 20 -37 -97 52 -112 
35 -17 -5 -11 -88 -75 118 75 123 85 -71 -29 -99 29 -73 -38 
125 95 -2 45 -52 36 -20 -25 55 63 -4 18 -34 48 -93 2 
32 -98 -9 -56 83 110 19 -49 -61 -52 -78 96 -23 105 58 103 
-55 56 -108 -107 93 -127 124 -108 -64 120 -90 -98 -87 73 -96 -55 
-24 -104 -111 59 6 -92 10 -55 112 -68 42 90 38 100 -63 -17 
-99 85 -124 -6 -42 0 -114 -106 121 52 53 34 126 -43 -21 102 
109 124 -95 115 32 -84 61 -112 104 103 -22 -114 -53 -85 125 104 
1 1 98 -41 2 -16 110 123 37 -93 -99 -93 120 -120 9 -26 
4 -86 89 36 86 -106 -76 -65 -3 -97 77 -55 74 -53 49 75 
-52 -108 35 -50 -124 -111 73 -87 52 -26 76 -84 110 85 -110 114 
0 -20 -106 86 -126 75 21 -128 -22 99 73 52 46 122 -128 -6 
14 -93 -55 -109 52 18 60 104 -7 -119 20 103 -34 -89 -38 -34 
-109 112 53 21 -69 74 -107 -91 -83 -34 -38 -37 89 90 -42 103 
-3 -97 -6 49 -79 55 -103 -86 -64 -83 18 -98 84 -20 125 -25 
92 -78 -3 24 -4 -110 -67 -86 113 -105 -123 -54 -15 91 49 -18 
-6 44 31 -84 99 -72 86 35 102 104 -63 -70 84 62 -94 -79 
-16 -97 -55 -19 49 -122 -105 -94 30 28 108 15 120 -98 -2 114 
-54 29 30 45 -42 117 80 60 -35 17 -10 50 80 -104 -29 64 
55 -84 45 105 50 -60 11 80 -31 120 96 89 22 94 -53 -32 
123 -22 13 81 95 93 -115 60 110 -124 110 -66 28 81 
				<</bytefile>>
				<<textfile "result.out">>

digits: 5857470845144451711272 22 in total.
uppers: DDSXAQWWTXHJNHJRJNNOMGRKUSIZUYVMJKILUVKIJYZTVTPPPYQQ 52 in total.
lowers: xtxtibblofpdmtbafhmkngclvnigxpdyfmshghbnxnrczhgpgqcfhlxruixnn 61 in total.
eofs: 0
nansis: 257
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-oct--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>
			<<case "charset-posix-alnum" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alnum
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

alnum	[[:alnum:]]

					<</declare_section>>
					<<lex_section>>
{alnum}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{alnum}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{alnum}+	ncnt := ncnt + yyleng * 3; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-37 -96 60 -108 -49 -92 47 -81 -7 75 -102 -11 50 -112 -35 6 
104 -75 -88 109 -98 34 -54 49 -114 102 97 -67 -20 -46 56 -100 
118 64 24 -13 -128 36 -79 120 -59 89 42 51 -66 18 -47 68 
-60 43 -70 127 57 -74 -34 53 -50 -68 22 115 29 76 17 -40 
15 112 -76 96 -87 0 122 -12 -9 -17 65 -124 -15 -110 8 41 
114 78 46 98 -39 -83 86 119 -14 -78 -5 101 -57 -71 38 -89 
-27 -52 -117 87 -120 63 117 13 25 100 -122 69 83 27 40 -44 
59 -62 -73 91 80 31 -106 -103 -21 -51 -82 -94 -36 99 -25 -1 
-104 58 -126 55 -4 -109 14 -63 33 -18 11 -118 -64 -41 -99 72 
-33 -16 27 -84 110 113 45 -90 10 48 -72 37 92 93 1 77 
-45 -121 62 -86 -95 -6 -42 -125 -69 -65 -113 52 -111 16 -31 -107 
-38 70 121 81 106 108 103 85 123 90 82 54 73 -3 -115 -26 
-55 105 -8 88 -85 107 94 -2 124 74 -127 -105 12 116 -80 44 
23 -43 -32 67 -28 19 -24 -97 95 -119 30 21 126 79 -48 -53 
39 71 125 2 -77 4 9 20 35 -10 -22 5 -23 32 7 -29 
-30 -61 -93 61 -56 111 -58 -91 3 -19 84 66 -116 -123 -101 28
				<</bytefile>>
				<<textfile "result.out">>
K +1
2 +1
h +1
m +1
1 +1
fa +4
8 +1
v +1
x +1
Y +1
3 +1
D +1
9 +1
5 +1
s +1
L +1
p +1
z +1
A +1
rN +4
b +1
Vw +4
e +1
W +1
u +1
d +1
ES +4
P +1
c +1
7 +1
H +1
nq +4
0 +1
M +1
4 +1
FyQjlgU +21
ZR6I +12
i +1
X +1
k +1
J +1
t +1
C +1
O +1
G +1
o +1
TB +4
96
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>
			<<case "charset-posix-alpha" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alpha
*/
					<</desc>>
					<<declare_section>>
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]

%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
{alpha}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{alpha}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{alpha}+	ncnt := ncnt + yyleng * 3; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>


					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
96 -34 -73 -66 -14 56 39 -45 -43 111 120 -56 67 -86 6 89 
106 -94 13 87 -28 84 45 16 110 36 117 15 102 -122 -78 -109 
-20 22 -72 58 94 23 -59 12 126 66 -62 28 -19 -26 -91 -67 
107 -89 59 -44 -92 -93 52 103 -83 -33 -75 -104 -102 7 63 55 
74 79 -16 -63 -12 35 100 40 121 71 70 -127 -90 -55 61 -23 
3 0 -96 5 80 57 43 -70 -69 -9 -111 -52 34 77 24 69 
-11 90 14 91 33 -21 41 27 92 29 -82 47 -58 -35 73 86 
46 98 37 -107 95 -37 118 119 10 72 122 123 124 125 25 127 
-128 75 -126 -125 -124 -123 105 -121 -120 -119 -118 -117 -116 -115 -114 -113 
-112 97 -110 31 -108 115 -106 -105 50 -103 60 -101 -100 -99 -98 -97 
82 -95 17 53 54 112 76 49 -88 -87 18 -85 -84 83 114 -81 
-80 -79 30 -77 -76 116 -74 2 104 -71 19 88 -68 48 21 -65 
-64 113 42 -61 -60 38 108 -57 11 93 -54 -53 99 -51 -50 -49 
-48 -47 -46 78 51 8 -42 -41 -40 -39 -38 27 -36 109 1 85 
-32 -31 -30 -29 20 -27 64 -25 -24 65 -22 101 32 44 -18 -17 
9 -15 4 -13 68 81 -10 62 -8 -7 -6 -5 -4 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
ox +4
C +1
Yj +4
W +1
T +1
n +1
u +1
f +1
B +1
k +1
g +1
JO +4
d +1
yGF +9
P +1
M +1
E +1
Z +1
IV +4
b +1
vw +4
Hz +4
K +1
i +1
a +1
s +1
R +1
pL +4
Sr +4
t +1
h +1
X +1
q +1
l +1
c +1
N +1
m +1
U +1
A +1
e +1
DQ +4
76
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>
			<<case "charset-posix-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - blank
*/

					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
blank	[[:blank:]]
					<</declare_section>>
					<<lex_section>>
{blank}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{blank}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{blank}+	ncnt := ncnt + yyleng * 3; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
80 -104 -125 -100 -42 84 120 -57 -58 40 -114 6 -1 115 10 -28 
16 -74 -62 -12 -7 -75 65 47 -90 -76 2 -67 54 -65 -69 88 
-96 -95 34 17 -101 68 15 -18 0 46 -91 -36 -107 96 -120 -92 
123 -97 -127 75 126 43 -117 116 111 71 -21 -20 94 41 -38 86 
95 30 44 124 11 39 114 -43 102 19 -13 -121 106 28 98 -32 
-17 105 69 63 1 13 -25 -31 -30 -82 77 -81 74 -24 90 85 
49 -109 -94 103 55 27 -79 -122 -16 83 -23 7 127 -88 -11 42 
-80 -68 76 -110 93 -2 -48 51 104 25 -106 -85 59 61 67 -59 
-70 8 -34 73 -124 60 -33 112 -78 -14 18 64 -123 -54 -93 35 
122 113 5 -66 -51 101 78 -9 107 -113 20 27 -84 57 92 -47 
-8 -116 -45 -98 50 22 33 -22 -72 -118 4 -126 -44 87 -87 -111 
56 -71 66 14 81 -37 125 -29 29 32 -52 -61 -99 23 9 89 
3 -40 -49 -119 -39 119 58 -102 31 121 100 -50 -63 52 72 62 
79 24 -77 -56 -103 -83 -108 108 37 53 -89 -64 97 91 -46 -26 
-19 -112 -86 99 -35 38 118 109 48 -27 -15 -128 36 70 -115 -105 
82 -55 -41 45 21 110 -10 -60 -53 -73 -6 -5 -4 -3 117 12 
				<</bytefile>>
				<<textfile "result.out">>
  +1
	 +1
2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>
			<<case "charset-posix-cid" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - cid
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{cidf}{cids}*		writeln(yytext); ncnt := ncnt + 1;
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test posix charset - cid
*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]

%%

{cidf}{cids}*		cout << yytext << endl; ++ncnt;
.|\n

%%

int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
posix
charset
cid
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
cidf
cidf
cids
cids
cidf
cids
cout
yytext
endl
ncnt
n
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
48
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>




<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>
			<<case "charset-posix-digit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - digit
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

digit	[[:digit:]]
xdigt	[[:xdigit:]]
lower	[[:lower:]]
upper	[[:upper:]]
alnum	[[:alnum:]]
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{digit}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{digit}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{digit}+	ncnt := ncnt + 3 * yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
105 -64 -121 -114 -94 -25 -51 16 54 -50 33 28 -75 -58 84 -61 
-14 -91 123 -69 86 93 22 110 -74 65 14 85 -6 -78 9 55 
114 94 29 42 64 -92 -48 -49 90 60 -77 -100 -111 111 -102 8 
49 -2 126 -47 -79 122 -19 124 40 70 -43 -30 98 20 -93 -105 
-104 -83 3 27 -82 45 127 -10 51 -36 -117 27 -76 -26 7 79 
32 56 -95 -97 -120 102 74 -106 5 88 66 -20 -66 91 53 -41 
6 25 106 118 121 41 17 -88 -57 96 -23 43 -12 -67 -54 -60 
83 30 -112 -70 67 0 39 44 -42 -98 -17 68 -34 1 -128 -16 
-55 -52 97 -53 35 -56 -81 -5 -37 -115 -119 -90 107 -18 81 61 
47 -87 58 13 72 -35 -96 104 -109 -116 -38 34 117 31 108 69 
-80 2 -108 95 -32 115 36 -28 -84 -118 -8 -1 -24 -113 82 -124 
120 -11 52 -73 18 113 -39 87 -68 92 -123 80 -62 -107 -33 -9 
-71 -63 24 -21 77 -45 -13 100 -27 -7 -72 112 -29 89 76 59 
-122 99 -127 116 109 -89 -85 62 57 15 -110 63 10 38 -3 4 
119 -59 21 -40 73 125 78 -65 12 19 -4 -103 -125 37 -101 103 
-126 -86 11 23 75 101 46 -22 50 -44 -15 -31 48 -46 71 -99
				<</bytefile>>
				<<textfile "result.out">>
6 +1
7 +1
1 +1
3 +1
8 +1
5 +1
4 +1
9 +1
2 +1
0 +1
10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>
			<<case "charset-posix-graph" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - graph
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{graph}		ncnt := ncnt + 1;
			nchars := nchars + 1;
			writeln(yytext, ' +1');
{graph}{2}	ncnt := ncnt + 4;
			nchars := nchars + 2;
			writeln(yytext, ' +4');
{graph}+	ncnt := ncnt + 3 * yyleng;
			nchars := nchars + yyleng;
			writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-100 -54 -41 127 91 -15 40 -14 -78 -22 95 -102 -111 -52 -43 -88 
-89 -12 99 103 94 48 -44 74 -29 -113 -36 -94 -103 71 -55 -83 
72 77 114 -116 -26 3 -71 38 -39 -120 -118 98 52 23 -4 -73 
-80 -31 -87 56 2 106 109 -99 89 -112 -59 -70 -119 29 90 -1 
66 115 -33 19 79 104 -79 -86 9 82 69 -96 33 119 17 51 
-34 -121 -25 -35 101 -75 121 5 -108 -17 -24 108 -127 -47 -48 120 
-122 84 105 -93 -64 43 -37 -62 -60 -77 -13 -11 50 68 -38 86 
73 -72 122 -61 -65 -23 41 123 14 62 25 12 10 -95 -82 18 
57 -51 -30 111 53 -97 110 15 -49 83 -2 67 64 31 -3 45 
-85 -28 92 -42 -101 30 -27 55 42 -92 118 -128 -91 16 60 -90 
96 59 -66 39 -18 -21 28 7 4 -32 -63 80 -67 -123 37 -76 
-40 -74 21 27 -7 -6 -126 107 102 -117 -109 -115 81 76 27 113 
32 88 1 -53 -125 -58 -9 -110 0 -68 -19 6 -69 -57 54 124 
70 -114 -105 -10 44 -8 126 63 8 75 20 49 -124 11 22 125 
-5 61 -45 58 87 78 -50 -84 46 93 -16 85 -46 97 24 47 
117 116 65 -20 100 13 34 36 -98 -81 112 35 -107 -106 -104 -56 
				<</bytefile>>
				<<textfile "result.out">>
[ +1
( +1
_ +1
cg^0 +12
J +1
G +1
HMr +9
& +1
b4 +4
8 +1
jm +4
Y +1
Z +1
Bs +4
Oh +4
RE +4
!w +4
3 +1
e +1
y +1
l +1
x +1
Ti +4
+ +1
2D +4
VI +4
z +1
){ +4
> +1
9 +1
o5 +4
n +1
S +1
C@ +4
- +1
\ +1
7* +4
v +1
< +1
`; +4
' +1
P +1
% +1
kf +4
QL +4
q +1
X +1
6|F +9
, +1
~? +4
K +1
1 +1
} +1
= +1
:WN +9
.] +4
U +1
a +1
/utA +12
d +1
"$ +4
p# +4
168 94
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>
			<<case "charset-posix-lower" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - lower
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
lower	[[:lower:]]

%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}
					<</declare_section>>
					<<lex_section>>
{lower}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{lower}{2}	ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{lower}+	ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-81 -95 86 58 -122 -116 -14 -27 110 -63 0 -105 19 16 -69 -39 
49 -60 -79 14 -15 -33 8 43 112 -128 -88 -62 -89 -67 88 -20 
62 -46 -2 -23 74 -101 -10 10 -28 40 -55 18 -61 106 -85 126 
-92 101 -47 -26 -48 -34 -86 -87 -3 66 123 47 118 -64 117 56 
-16 57 3 73 79 99 -125 82 59 6 -51 17 55 -112 68 -19 
32 28 11 67 36 115 -83 69 13 127 -74 -107 -96 98 -66 -77 
24 2 90 -108 114 -102 -73 7 -98 9 64 -12 29 72 -41 -40 
52 -123 -113 -109 -49 21 89 38 -1 108 -118 92 33 95 -6 105 
-24 -5 -13 -103 12 65 -94 -22 -35 54 -4 103 100 -38 -59 -111 
25 -21 35 34 -84 -18 -93 27 63 -32 -68 -78 84 5 -100 -58 
30 -25 85 -117 27 75 87 22 20 31 122 125 -124 4 94 -8 
-57 -50 -110 -104 83 78 -99 1 -75 -17 -56 51 -71 91 53 -80 
-127 -42 -29 111 -106 -31 61 107 -11 71 46 23 77 15 -44 -7 
-114 42 -65 119 48 -90 -30 -126 80 81 41 -9 -43 93 97 104 
50 39 116 -120 102 -76 121 120 -52 -97 -119 44 -121 -70 -82 96 
70 -53 -91 -72 37 -36 45 113 -115 109 -37 60 -54 76 124 -45 
				<</bytefile>>
				<<textfile "result.out">>
n +1
p +1
j +1
e +1
v +1
u +1
c +1
s +1
b +1
r +1
l +1
i +1
gd +4
z +1
o +1
k +1
w +1
ah +4
t +1
f +1
yx +4
q +1
m +1
32 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>
			<<case "charset-posix-print" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - print
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

print	[[:print:]]
					<</declare_section>>
					<<lex_section>>

{print}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{print}{2}	ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{print}+	ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
45 -115 61 96 -10 -11 -86 -118 -92 -2 62 114 -70 52 53 58 
124 -28 27 -45 21 -105 95 -44 -25 123 46 79 54 -93 -124 -89 
31 51 -3 -22 -24 110 -94 -74 -12 36 19 -23 4 -59 -56 102 
10 -119 70 72 -96 -110 -5 68 -36 -127 0 -98 126 -112 -123 90 
108 35 -6 60 -34 -126 38 -68 -15 127 44 -82 -72 -9 94 -35 
105 -16 100 -113 -32 -27 103 48 -63 32 -4 -17 91 -47 -54 -128 
65 -95 -29 37 -40 -26 101 -99 13 97 -21 -43 116 -53 -57 49 
-90 1 14 88 -71 -33 16 -73 104 3 80 93 -108 -101 -78 84 
-8 89 111 20 122 98 29 28 -42 85 -61 117 -31 -116 18 22 
119 30 33 -103 -81 12 9 42 47 -121 27 -13 74 -100 -107 -97 
-49 78 -39 -18 -76 -104 67 120 77 109 -83 -120 17 -60 -41 15 
-65 -19 -102 107 -20 -7 -88 -1 81 63 -62 -77 -80 34 -106 -87 
83 -69 -111 -14 75 8 -64 71 64 -50 106 -55 -38 -91 -46 25 
-52 2 -85 121 -51 39 87 -79 57 125 24 -114 -58 -66 -30 41 
86 7 118 -125 -122 23 55 92 -75 40 43 113 -67 -109 -84 56 
11 59 99 76 112 73 -48 82 5 6 50 66 -117 69 -37 115 
				<</bytefile>>
				<<textfile "result.out">>
- +1
=` +4
>r +4
45:| +12
_ +1
{.O6 +12
3 +1
n +1
$ +1
f +1
FH +4
D +1
~ +1
Zl# +9
< +1
& +1
, +1
^ +1
i +1
d +1
g0 +4
  +1
[ +1
A +1
% +1
e +1
a +1
t +1
1 +1
X +1
h +1
P] +4
T +1
Yo +4
zb +4
U +1
u +1
w +1
! +1
*/ +4
J +1
N +1
CxMm +12
k +1
Q? +4
" +1
S +1
K +1
G@ +4
j +1
y +1
'W +4
9} +4
)V +4
v +1
7\ +4
(+q +9
8 +1
;cLpI +15
R +1
2B +4
E +1
s +1
171 95
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>




<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>
			<<case "charset-posix-space" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - space
*/
					<</desc>>
					<<declare_section>>

%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

space	[[:space:]]
					<</declare_section>>
					<<lex_section>>
{space}			ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{space}{2}		ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{space}+		ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
111 -113 11 107 -106 2 -51 76 -112 -119 102 -121 -122 27 -47 77 
-109 32 3 -64 44 25 -9 -31 33 17 69 51 31 -99 67 1 
-1 97 -44 -85 -3 61 -62 78 -65 -111 -83 112 -38 -126 -21 43 
-84 84 56 48 -63 113 -79 68 16 6 -29 39 -59 123 71 41 
-37 4 42 -34 95 86 14 91 19 85 -8 45 -71 -90 -98 89 
10 -32 62 -58 -80 23 74 -43 118 98 -86 126 63 -35 -10 66 
109 -13 -127 72 46 -94 -19 58 -102 -81 122 -11 -55 121 83 117 
-72 116 -114 101 -16 9 53 -5 -69 -15 -95 -50 52 -117 -33 -66 
-49 -92 124 -115 99 28 -7 108 -110 0 -2 -107 -77 55 -18 94 
-78 88 12 7 -4 37 -74 -24 22 -46 -52 64 15 -89 8 103 
-30 -45 -97 114 -101 -96 -20 -26 -128 -36 -57 18 5 -48 -40 79 
-22 -91 13 29 -104 100 73 -108 -88 70 75 -6 -53 57 -73 93 
-76 92 -123 80 105 -75 21 81 -67 -103 -42 82 -125 -68 -17 -120 
115 59 87 -124 120 90 -28 -27 106 24 96 -14 119 30 26 60 
-118 47 -82 -25 110 104 -70 49 65 -56 20 34 -61 -105 50 -23 
-93 -60 40 35 54 38 125 127 -100 -41 -87 36 -39 -54 -12 -116 
				<</bytefile>>
				<<bytefile "result.out">>
11 32 43 49 10 32 32 43 49 10 10 32 43 49 10 9 
32 43 49 10 12 32 43 49 10 13 32 43 49 10 54 32 
54 10
				<</bytefile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>
			<<case "charset-posix-upper" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - upper
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

upper	[[:upper:]]
					<</declare_section>>
					<<lex_section>>
{upper}			ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{upper}{2}		ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{upper}+		ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-34 -84 -47 -124 91 80 -37 87 -104 48 74 -16 -126 -61 1 -62 
-67 58 102 34 32 -33 110 65 -102 85 75 124 -77 -125 122 -25 
7 -118 28 -13 70 -15 107 83 104 13 -65 27 49 42 46 10 
-23 69 90 101 -4 -80 5 -95 -49 120 119 62 15 23 66 67 
44 45 -53 20 -127 12 24 60 76 99 -20 57 59 -121 30 -123 
93 -103 29 -5 -31 -113 -41 118 72 21 0 -98 -22 54 73 -101 
-63 100 43 -6 -99 113 97 -10 38 -97 -40 17 11 -71 71 36 
-17 82 -26 -35 86 121 4 64 98 -114 -78 -46 -105 -30 94 -57 
117 63 25 22 -94 39 -119 -11 40 78 -106 -86 -54 111 95 18 
123 77 -39 89 52 -91 -115 -109 127 -48 50 33 -120 -100 79 68 
126 55 -9 2 -68 -107 -90 -89 -88 -87 -117 -85 14 -83 -82 -81 
53 -79 -122 19 -76 -75 -74 -73 -72 109 -70 -69 -92 16 -66 61 
-64 96 51 41 -60 -59 -58 8 -56 -55 -116 88 -52 -51 -50 56 
81 -93 -112 -45 -44 -43 -42 116 106 -110 -38 6 -36 115 -128 27 
-32 84 125 -29 -28 -27 114 31 -24 9 92 -21 47 -19 -18 112 
108 37 -14 35 -12 -111 103 3 -8 -7 -96 105 -108 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
P +1
W +1
J +1
A +1
UK +4
F +1
S +1
EZ +4
BC +4
L +1
H +1
I +1
G +1
R +1
V +1
N +1
M +1
Y +1
OD +4
X +1
Q +1
T +1
34 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>
			<<case "charset-posix-xdigit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - xdigit
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

xdigt	[[:xdigit:]]
					<</declare_section>>
					<<lex_section>>

{xdigt}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{xdigt}{2}	ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{xdigt}+	ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
121 -78 -90 74 45 -59 -107 80 -96 112 78 -54 -113 -84 56 -63 
-73 9 -79 10 8 -8 42 69 111 104 118 57 -88 117 95 -87 
-81 38 -40 70 85 54 -67 -121 -37 -45 32 44 127 -60 -19 22 
40 -46 109 -122 3 -68 29 43 99 90 -98 -76 -117 -125 -4 61 
-111 53 -62 31 123 2 -39 68 -126 103 86 -118 11 -24 114 -72 
50 115 27 -14 18 -53 94 -77 -103 126 13 -31 -23 72 -22 -42 
89 -16 -34 -94 63 -70 -66 75 -12 -51 -100 -85 -35 60 5 28 
-115 -120 65 -30 79 98 -128 -97 -92 -1 6 113 -36 -102 -29 15 
119 37 -6 105 27 -61 36 19 25 21 39 -91 -114 110 -21 91 
-112 30 24 67 34 35 -38 1 -9 58 -11 -93 -26 -17 -3 -20 
4 73 17 66 -104 -7 -47 -32 -127 0 -2 64 -65 -50 -74 -110 
-123 106 -105 -124 83 33 52 122 -15 -108 102 100 -75 88 125 107 
-95 -10 -5 51 -58 93 97 49 71 -116 108 -44 23 -71 124 -101 
82 62 46 -82 -86 14 55 -41 47 76 12 77 101 48 -64 59 
-55 116 87 -13 7 -119 -52 20 81 -28 92 -99 -33 -56 -49 -69 
-48 -109 -106 -89 41 -80 -27 120 -25 96 -57 -83 84 16 -43 -18 
				<</bytefile>>
				<<textfile "result.out">>
8 +1
E +1
9 +1
F +1
6 +1
c +1
5 +1
D +1
2 +1
A +1
b +1
C +1
B +1
4 +1
fd +4
3 +1
a1 +4
7 +1
e0 +4
28 22
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>


<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>
			<<case "charset-single-a" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
Test charset set has only a single char
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

aset	[a]
					<</declare_section>>
					<<lex_section>>
{aset}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{aset}{2,5}	ncnt := ncnt + 2 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 2);
{aset}+		ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abbbbbbaaaaaaaaaabbaaaaaaaaabbbbbbaaaaaaaabaaaaaaaaaaaaaaabbbaaaaaaaabbaaaaabbbaaabaabbaaaabbbaaabbabbbaabbbbb
				<</textfile>>
				<<textfile "result.out">>
a +1
aaaaaaaaaa +30
aaaaaaaaa +27
aaaaaaaa +24
aaaaaaaaaaaaaaa +45
aaaaaaaa +24
aaaaa +10
aaa +6
aa +4
aaaa +8
aaa +6
a +1
aa +4
190 71
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/charset---------->>>



<<<----------sub-suite: /lex-alone/basic/lookahead---->>>
		<<suite "lookahead" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>
			<<case "lookahead-mixture" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore, yyless, yyunput
*/
					<</desc>>
					<<lex_section>>
"hell"			
"hello"(\,?" ")?	writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);
			yymore();

"seat"			writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);
			yyless(1);
			yyunput('b');

"beat"			writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);

"seat"/tle		writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);
			yyless(1);
			yyunput('b');

"beat"/tle		writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);

.|\n			write(yytext);
					<</lex_section>>

					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
seat-eh, hello, seattle
				<</textfile>>
				<<textfile "result.out">>

whole-text = seat
lookahead-text = 
valid-text = seat

whole-text = beat
lookahead-text = 
valid-text = beat
-eh, 
whole-text = hello, 
lookahead-text = 
valid-text = hello, 

whole-text = hello, seattle
lookahead-text = tle
valid-text = hello, seattle
bello, 
whole-text = seattle
lookahead-text = tle
valid-text = seattle

whole-text = beattle
lookahead-text = tle
valid-text = beattle
tle
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>
			<<case "lookahead-multiple" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/
					<</desc>>

					<<global_decl_code>>
var
	lineno: integer;
	bla: boolean;
					<</global_decl_code>>
					<<init_code>>
	lineno := 1;
	bla := false;
					<</init_code>>
					<<declare_section>>

cid	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	yyleng := yyleng - 1;
			while (yytext[yyleng] = #32) or (yytext[yyleng] = #9) do
				yyleng := yyleng - 1;

			yyleng := yyleng + 1;
			yytext[yyleng] := #0;
			bla := true;
			writeln('k', lineno, ':', yytext);	
if		|
else		|
return		|
#include		writeln('t', lineno, ':', yytext); 
.			if bla then	writeln(yytext);
			bla := false;
\n			lineno := lineno + 1;
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/

%{

#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*

%%
	int lineno = 1;
	bool bla = false;

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	for(--yyleng; yytext[yyleng] == ' ' || yytext[yyleng] == '\t'; --yyleng) {
				
			}
			++yyleng;
			yytext[yyleng] = '\0';
			bla = true;
			cout << "k" << lineno << ":" << yytext << endl;	
if		|
else		|
return		|
#include		cout << "t" << lineno << ":" << yytext << endl; 
.			if(bla) {
				cout << yytext << endl;
			}
			bla = false;
\n			++lineno;
%%
/*do nothing */

int main(int argc, char **argv) {

	if(0 != yylex(NULL)) {
		
		return -1;
	}
	else {
		return 0;
	}
}
				<</textfile>>
				<<textfile "result.out">>
k7:#include
<
t18:if
t19:else
t20:return
t21:#include
t28:if
t29:else
k30:return
	
t31:#include
k32:if
(
k42:if
(
k44:return
 
k46:else
{
k47:return
 
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>
			<<case "lookahead-single" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test basic functionality of lookahead feature
*/
					<</desc>>

					<<global_decl_code>>
var
	abcs: integer;
					<</global_decl_code>>
					<<init_code>>
	abcs := 0;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
abc/d	abcs := abcs + 1;
	writeln('whole-text = ', yytext);	
	writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
	yytext[yyleng] := #0;
	writeln('valid-text = ', yytext);

abc
.|\n	write(yytext);

<<EOF>>	writeln('number of "abc/d" is ', abcs);
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abcd
abc
babcd
babc
				<</textfile>>
				<<textfile "result.out">>
whole-text = abcd
lookahead-text = d
valid-text = abc
d

bwhole-text = abcd
lookahead-text = d
valid-text = abc
d
b
number of "abc/d" is 2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>
			<<case "lookahead-yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yyless
*/
					<</desc>>

					<<global_decl_code>>
var
	bla: boolean;
					<</global_decl_code>>
					<<init_code>>
	bla := false;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
gabcde/f	writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		yyless(1);
		bla := true;

abc/d		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		yyless(1);
		bla := true;

b/c		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;

abc		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := false;

.|\n	if bla then	writeln(yytext);
		bla := false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
gabcdefg
				<</textfile>>
				<<textfile "result.out">>
whole-text = gabcdef
lookahead-text = f
valid-text = gabcde
whole-text = abcd
lookahead-text = d
valid-text = abc
whole-text = bc
lookahead-text = c
valid-text = b
c
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>
			<<case "lookahead-yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore
*/
					<</desc>>

					<<global_decl_code>>
var
	bla: boolean;
					<</global_decl_code>>
					<<init_code>>
	bla := false;
					<</init_code>>

					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
Hello\,\040/world\!	begin	
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;
		yymore();
	end;
world\!			begin	
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := false;
	end;
Michael/" "Jodan	begin	
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;
		yymore();
	end;
" "Jodan		begin
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := false;
	end;

Jackson"--"/King" of "R"&"R	begin
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;
	end;

.|\n	if bla then writeln(yytext);
		bla := false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
Hello, world!
Michael Jodan
Jackson--King of R&R
abc
				<</textfile>>
				<<textfile "result.out">>
whole-text = Hello, world!
lookahead-text = world!
valid-text = Hello, 
whole-text = Hello, world!
lookahead-text = 
valid-text = Hello, world!
whole-text = Michael Jodan
lookahead-text =  Jodan
valid-text = Michael
whole-text = Michael Jodan
lookahead-text = 
valid-text = Michael Jodan
whole-text = Jackson--King of R&R
lookahead-text = King of R&R
valid-text = Jackson--
K
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/lookahead---->>>


<<<----------sub-suite: /lex-alone/basic/option---->>>
		<<suite "option" make="subdir-makefile-template">>


<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>
			<<case "lex-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: duplicated option

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%option debug=1
%option debug=yes
%option debug="yes"
					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				
			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>
				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>


<<<----------case: /lex-alone/basic/option/lex-option1--->>>
			<<case "lex-option1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test option setting
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	begin
		writeln(yytext);
		ncnt := ncnt + 1;
	end;
.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test option setting
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*

%%
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	{
		cout << yytext << endl;
		++ncnt;
	}
.|\n

%%
int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
option
setting
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
option
debug
option
debug1
option
verbose
off
option
detail
on
option
just
test
yes
option
you
are
joking
true
option
file
path
upgen
option
file
name
no
title
c
cpp
id
cidf
cids
Aa
Dd
Ss
Uu
Bb
Mm
Uu
Ll
Dd
Ii
Vv
id
cout
yytext
endl
ncnt
n
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
86
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-option1--->>>


<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>
			<<case "lex-unsupported" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: unsupported options
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%array
%pointer
%8bit
%case-insentitive

					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/option---->>>


<<<----------sub-suite: /lex-alone/basic/reop---->>>
		<<suite "reop" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>
			<<case "charset-plus" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexical analyse float number in C
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var ints, floats: integer %}
%actual-param%{ ints, floats %}

int		[\+\-]?[0-9]+
basic		{int}(\.[0-9]+)?
float		{basic}([EFef]{int})?
					<</declare_section>>
					<<lex_section>>
{int}
		writeln(yytext);
		ints := ints + 1;
{float}

		writeln(yytext);

		floats := floats + 1;
.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ni: integer;
	nf: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ni := 0;
	nf := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ni, nf);
	writeln('number of integer: ', ni);
	writeln('number of float: ', nf);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
123
39999999900000000000E
234.5Fa3423
23f4.5
566666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
39999999900000000000
234.5
3423
23f4
5
566666
3
45e0
3
4.5
6E8
4E34
5
6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9
7F3
4
number of integer: 10
number of float: 11
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>

<<<----------case: /lex-alone/basic/reop/charset-range--->>>
			<<case "charset-range" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: range

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var cnt1, cnt2, cnt3, cnt4: integer %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

eq4a	a{4}
lt3b	b{,3}
gt2c	c{2,}
d2t5	d{2,5}
					<</declare_section>>
					<<lex_section>>

{eq4a}		cnt1 := cnt1 + 1; writeln(yytext, ' --> match {eq4a}');
{lt3b}		cnt2 := cnt2 + 1; writeln(yytext, ' --> match {lt3b}');
{gt2c}		cnt3 := cnt3 + 1; writeln(yytext, ' --> match {gt2c}');
{d2t5}		cnt4 := cnt4 + 1; writeln(yytext, ' --> match {d2t5}');
.|\n
<<EOF>>		writeln('end of file reached.');
					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt1: integer;
	ncnt2: integer;
	ncnt3: integer;
	ncnt4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt1 := 0;
	ncnt2 :=0;
	ncnt3 := 0;
	ncnt4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex( ncnt1, ncnt2, ncnt3, ncnt4);
	writeln('aaa: ', ncnt1);
	writeln('-bbb: ', ncnt2);
	writeln('cc-: ', ncnt3);
	writeln('dd-ddddd: ', ncnt4);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
.aaaddd.........aaaadddddddd.......aaaaaabbabbbbbbbbbbbbbbbaaaaaaaaabdddddddddd.......................................ddd................ccccccccccddddddddddddddddddddddddddddddaaaaaaabbbbbbbbbbbbbbbbdddd..ddddddd...............ddddd...ccccdddddddddddddddddddddddcccccccdbbbbbbbbbbcccccccccccccccccccccccdddd...aaaaaaaaaacccccccccddddddddddddbbbbbbbbbcccccc........aaaaaaaaa.........aaaddd......ddd......bbbbbbbbbbcccccccccccddd......aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadddddddddd.ccccccdddddddddddddddddddddddcccccccccddddddddddddaabbbbbbbbbbbbbbbbbbbbbbdddddd........................ccccccddddd
				<</textfile>>
				<<textfile "result.out">>
ddd --> match {d2t5}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddd --> match {d2t5}
aaaa --> match {eq4a}
bb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
b --> match {lt3b}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
cccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
aaaa --> match {eq4a}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
dddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
ddddd --> match {d2t5}
cccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccc --> match {gt2c}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccccccccccccccc --> match {gt2c}
dddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
cccccc --> match {gt2c}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddd --> match {d2t5}
ddd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccc --> match {gt2c}
ddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
end of file reached.
aaa: 22
-bbb: 32
cc-: 10
dd-ddddd: 40
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-range--->>>

<<<----------case: /lex-alone/basic/reop/charset-star--->>>
			<<case "charset-star" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexically analyse real number in PASCAL
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

/* unsigned positve integer */
nonzero		[1-9][0-9]*
/* natural number */
natural		0|{nonzero}
/* mantissa */
mant		[0-9]*[1-9]
/* basic representation of real number*/
basic		[\+\-]?{natural}(\.{mant})?
/* scientific representatio of real number */
/*scient		{basic}[Ee][\+\-]{nonzero}*/
/* pascal real number */
preal		{basic}([Ee][\+\-]?{nonzero})?
					<</declare_section>>
					<<lex_section>>

{preal}		begin
		writeln(yytext);
		ncnt := ncnt + 1;
		end;

.|\n
					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
123
234.5ea3423
23e4.5
566a666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
234.5
3423
23e4
5
566
666
3
45
0.3
4.5
6E8
4E34
5
6E8
9.7
34
9
7
3
4
21
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-star--->>>

<<<----------case: /lex-alone/basic/reop/charset-union--->>>
			<<case "charset-union" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: union
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var cnt1, cnt2, cnt3, cnt4: integer %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

int	(\+|\-)?((0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*|0)
hex	\\(X|x)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)
oct	\\(0|1|2|3)(0|1|2|3|4|5|6|7)(0|1|2|3|4|5|6|7)
real	{int}(\.(0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*)?
					<</declare_section>>
					<<lex_section>>

{int}		cnt1 := cnt1 + 1;
		writeln(yytext);
{hex}		cnt2 := cnt2 + 1;
		writeln(yytext);
{oct}		cnt3 := cnt3 + 1;
		writeln(yytext);
{real}		cnt4 := cnt4 + 1;
		writeln(yytext);
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt1: integer;
	ncnt2: integer;
	ncnt3: integer;
	ncnt4: integer;
	nret: integer;
					<</local_decl_code>>
					
					<<before_init>>
	ncnt1 := 0;
	ncnt2 := 0;
	ncnt3 := 0;
	ncnt4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt1, ncnt2, ncnt3, ncnt4);
	writeln('int: ', ncnt1);
	writeln('hex: ', ncnt2);
	writeln('oct: ', ncnt3);
	writeln('real: ', ncnt4);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
\X3289f
434.3300.342.43423.9324.4320
\580523
\2347843
tfghui90ioik568io
00.00.00.00.00.00.090000
00x9000

				<</textfile>>
				<<textfile "result.out">>
\X32
89
434.33
0
0.342
43423.9324
432
0
58
0523
\234
7843
9
0
568
0
0.0
0.0
0.0
0.0
0.0
0.09
0
0
0
0
0
0
9
0
0
0
int: 21
hex: 1
oct: 1
real: 9
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-union--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/reop---->>>


<<<----------sub-suite: /lex-alone/basic/rule---->>>
		<<suite "rule" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>
			<<case "rule-bol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test bol(beginning of line) flag
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{var bols, nbols: integer%}
%actual-param%{bols, nbols%}
					<</declare_section>>
					<<lex_section>>
^"#include"	
		writeln(yytext, ' => matched ^"#include"');
		bols := bols + 1;
	
"#include"	
		writeln(yytext, ' => matched "#include"');
		nbols := nbols + 1;
	
"#import"	
		writeln(yytext, ' => matched "#import"');
		nbols := nbols + 1;
	
^"#if"		
		writeln(yytext, ' => matched ^"#if"');
		bols := bols + 1;
	
"#if"		
		writeln(yytext, ' => matched "#if"');
		nbols := nbols + 1;
	
"#cond"		
		writeln(yytext, ' => matched "#cond"');
		nbols := nbols + 1;
	
.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('at_bol: ', n1);
	writeln('not_at_bol: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test regular expression: bol flag is set

Sample:
#include
 #include
#import
	#import
#if #if
#cond
#cond

*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{int &bols, int &nbols%}
%actual-param%{bols, nbols%}

%%
^"#include"	{
		cout << yytext << " => matched ^\"#include\"" << endl;
		++bols;
	}
"#include"	{
		cout << yytext << " => matched \"#include\"" << endl;
		++nbols;
	}
"#import"	{
		cout << yytext << " => matched \"#import\"" << endl;
		++nbols;
	}
^"#if"		{
		cout << yytext << " => matched ^\"#if\"" << endl;
		++bols;
	}
"#if"		{
		cout << yytext << " => matched \"#if\"" << endl;
		++nbols;
	}
"#cond"		{
		cout << yytext << " => matched \"#cond\"" << endl;
		++nbols;
	}
.|\n

%%

int main(int argc, char **argv) {

	int n1 = 0, n2 = 0;
	int nret = yylex(NULL, n1, n2);
	
	cout << "at_bol: " << n1 << endl 
	     << "not_at_bol: " << n2 << endl;
	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
#include => matched ^"#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched ^"#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
#include => matched ^"#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
at_bol: 3
not_at_bol: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>
			<<case "rule-bol-sc-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 1
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var _as, bs: integer%}
%actual-param%{ _as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	_as := _as +  2; writeln(yytext, ' => matched `^a''');
a	_as := _as + 1; writeln(yytext, ' => matched `a''');
^b	bs := bs + 2; writeln(yytext, ' => matched `^b''');
b	bs := bs + 1; writeln(yytext, ' => matched `b''');

.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abc		2	1
actual bonus	5	2
beta		6	4
beattles	7	6
business man	8	8
blog address	9	10
as useful tool	11	10

				<</textfile>>
				<<textfile "result.out">>
a => matched `^a'
b => matched `b'
a => matched `^a'
a => matched `a'
b => matched `b'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
a => matched `^a'
a's: 11
b's: 10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>
			<<case "rule-bol-sc-2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 2
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var _as, bs: integer%}
%actual-param%{ _as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	_as := _as +  2; writeln(yytext, ' => matched `^a''');
a	_as := _as + 1; writeln(yytext, ' => matched `a''');
b	bs := bs + 1; writeln(yytext, ' => matched `b''');
^bb	bs := bs + 4; writeln(yytext, ' => matched `^bb''');

.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('a''s: ', n1);
	     writeln('b''s: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
bbcc...aaa	3	4
aa		6	4
bbbbbb		6	12
cccaacccc	8	12
aaaaaaaa	17	12
...bbcbbb	17	17
ccaaa		20	17
aaax		24	17
xaaa		27	17
...aa		29	17
bbabjjabaa	33	23
bababa		36	26
a......aa	40	26
aa		43	26
aaabbb		47	29
				<</textfile>>
				<<textfile "result.out">>
bb => matched `^bb'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
bb => matched `^bb'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
bb => matched `^bb'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
a's: 47
b's: 29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>
			<<case "rule-bol-sc-3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, bs, cs, ds, es, fs, gs: integer%}
%actual-param%{ _as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>

a|b		if yytext[0] = 'a' then begin

			_as := _as + 1;
			yy_push_state(asc);
		end
		else begin
			bs := bs + 1;
			yy_push_state(bsc);
		end;
		
<*>[cd]		case yytext[0] of
				'c': cs := cs +  2;
				else  ds := ds + 2;
			end;

<asc,bsc>[abce]	case yytext[0] of
					'a': _as := _as +  3;
					'b': bs := bs + 3;
					'c': cs := cs +  3;
					else  es := es + 3;
				end;
				
<asc>f		fs := fs + 4;
<bsc>[fg]	if yytext[0] = 'f' then
				fs := fs + 5
			else begin
				gs := gs + 5;
			end;
			
<asc>aa		yy_pop_state(); _as := _as +  6;
<bsc>bb		yy_pop_state(); bs := bs + 6;
<*>.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	n5: integer;
	n6: integer;
	n7: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
	n5 := 0;
	n6 := 0;
	n7 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n2, n3, n4, n5, n6, n7);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);
	writeln('c''s: ', n3);
	writeln('d''s: ', n4);
	writeln('e''s: ', n5);
	writeln('f''s: ', n6);
	writeln('g''s: ', n7);

	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			7	0	0	0	0	0	0
a			8	0	0	0	0	0	0
	ggggg		8	0	0	0	0	0	0
	cccc		8	0	8	0	0	0	0
	ddddd		8	0	8	10	0	0	0
	fffff		8	0	8	10	0	20	0
aa			14	0	8	10	0	20	0
a			15	0	8	10	0	20	0
aa			21	0	8	10	0	20	0
a			22	0	8	10	0	20	0
	bbbbbbb		22	21	8	10	0	20	0
	ddddddddd	22	21	8	28	0	20	0
	ee		22	21	8	28	6	20	0
aa			28	21	8	28	6	20	0
a			29	21	8	28	6	20	0
aa			35	21	8	28	6	20	0
a			36	21	8	28	6	20	0
aa			42	21	8	28	6	20	0
b			42	22	8	28	6	20	0
bb			42	28	8	28	6	20	0
b			42	29	8	28	6	20	0
bb			42	35	8	28	6	20	0
b			42	36	8	28	6	20	0
bb			42	42	8	28	6	20	0
b			42	43	8	28	6	20	0
bb			42	49	8	28	6	20	0
b			42	50	8	28	6	20	0
bb			42	56	8	28	6	20	0
b			42	57	8	28	6	20	0
	ggggg..........	42	57	8	28	6	20	25
	g		42	57	8	28	6	20	30
	a		45	57	8	28	6	20	30
	ddddddd		45	57	8	42	6	20	30
	eeeee		45	57	8	42	21	20	30
	f		45	57	8	42	21	25	30
	eeeeeeeee	45	57	8	42	48	25	30
	ffff		45	57	8	42	48	45	30
	aaaaaaa		66	57	8	42	48	45	30
bb			66	63	8	42	48	45	30
b			66	64	8	42	48	45	30
bb			66	70	8	42	48	45	30
b			66	71	8	42	48	45	30
	cccccccc	66	71	24	42	48	45	30
	ddddd....	66	71	24	52	48	45	30
bb			66	77	24	52	48	45	30
a			67	77	24	52	48	45	30
	a		70	77	24	52	48	45	30
	cccc		70	77	32	52	48	45	30
	ddddd		70	77	32	62	48	45	30
	ffffff		70	77	32	62	48	69	30
	gggggg		70	77	32	62	48	69	30
	ddddd		70	77	32	72	48	69	30
	e		70	77	32	72	51	69	30
	ffggggg		70	77	32	72	51	77	30
	ee		70	77	32	72	57	77	30
	b		70	80	32	72	57	77	30
	dddd		70	80	32	80	57	77	30
	eeee		70	80	32	80	69	77	30
				<</textfile>>
				<<textfile "result.out">>
a's: 70
b's: 80
c's: 32
d's: 80
e's: 69
f's: 77
g's: 30
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>
			<<case "rule-bol-sc-4" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 4
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, bs, cs, ds, es, fs, gs: integer%}
%actual-param%{ _as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc

					<</declare_section>>
					<<lex_section>>

\{|\[		case yytext[0] of
				'{': YYBEGIN(asc);
				else  YYBEGIN(bsc);
			end;

<asc>^[abcdefg]	case yytext[0] of
		'a': _as := _as - 1;
		'b': bs := bs - 1;
		'c': cs := cs - 1;
		'd': ds := ds - 1;
		'e': es := es - 1;
		'f': fs := fs - 1;
		else gs := gs - 1;
		end;

<asc>[abcdefg]	case yytext[0] of
		'a': _as := _as + 1;
		'b': bs := bs + 1;
		'c': cs := cs + 1;
		'd': ds := ds + 1;
		'e': es := es + 1;
		'f': fs := fs + 1;
		else gs := gs + 1;
		end;

<bsc>^[abcdefg]	case yytext[0] of
		'a': _as := _as - 2;
		'b': bs := bs - 2;
		'c': cs := cs - 2;
		'd': ds := ds - 2;
		'e': es := es - 2;
		'f': fs := fs - 2;
		else  gs := gs - 2;
		end;
<bsc>[abcdefg]	case yytext[0] of
		'a': _as := _as +  2;
		'b': bs := bs + 2;
		'c': cs := cs + 2;
		'd': ds := ds + 2;
		'e': es := es + 2;
		'f': fs := fs + 2;
		else  gs := gs + 2;
		end;
<asc>\}		YYBEGIN(INITIAL);
<bsc>\]		YYBEGIN(INITIAL);

<*>^[abcdefg]	case yytext[0] of
		'a': _as := _as - 3;
		'b': bs := bs - 3;
		'c': cs := cs - 3;
		'd': ds := ds - 3;
		'e': es := es - 3;
		'f': fs := fs - 3;
		else  gs := gs - 3;
		end;
<*>[abcdefg]	case yytext[0] of
		'a': _as := _as +  3;
		'b': bs := bs + 3;
		'c': cs := cs +  3;
		'd': ds := ds + 3;
		'e': es := es + 3;
		'f': fs := fs + 3;
		else  gs := gs + 3;
		end;

^[abcdefg]	case yytext[0] of
		'a': _as := _as - 1000;
		'b': bs := bs - 1000;
		'c': cs := cs - 1000;
		'd': ds := ds - 1000;
		'e': es := es - 1000;
		'f': fs := fs - 1000;
		else  gs := gs - 1000;
		end;
[abcdefg]	case yytext[0] of
		'a': _as := _as +  1000;
		'b': bs := bs + 1000;
		'c': cs := cs +  1000;
		'd': ds := ds + 1000;
		'e': es := es + 1000;
		'f': fs := fs + 1000;
		else  gs := gs + 1000;
		end;
<*>.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	n5: integer;
	n6: integer;
	n7: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
	n5 := 0;
	n6 := 0;
	n7 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3, n4, n5, n6, n7);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);
	writeln('c''s: ', n3);
	writeln('d''s: ', n4);
	writeln('e''s: ', n5);
	writeln('f''s: ', n6);
	writeln('g''s: ', n7);

	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			1	0	0	0	0	0	0
a			0	0	0	0	0	0	0
	ggggg		0	0	0	0	0	0	5
cccc			0	0	2	0	0	0	5
	ddddd		0	0	2	5	0	0	5
	fffff		0	0	2	5	0	5	5
aa			0	0	2	5	0	5	5
a	aaa		2	0	2	5	0	5	5
aa	aaa		5	0	2	5	0	5	5
aa			5	0	2	5	0	5	5
bbb	bbb		5	4	2	5	0	5	5
ddd	dddd		5	4	2	10	0	5	5
ee	ee		5	4	2	10	2	5	5
aa	a		6	4	2	10	2	5	5
a			5	4	2	10	2	5	5
aa	aaa		8	4	2	10	2	5	5
a	a		8	4	2	10	2	5	5
}
[
aa			8	4	2	10	2	5	5
b			8	2	2	10	2	5	5
bb			8	2	2	10	2	5	5
b			8	0	2	10	2	5	5
bb			8	0	2	10	2	5	5
b			8	-2	2	10	2	5	5
bb			8	-2	2	10	2	5	5
b			8	-4	2	10	2	5	5
bb			8	-4	2	10	2	5	5
b			8	-6	2	10	2	5	5
bb			8	-6	2	10	2	5	5
b			8	-8	2	10	2	5	5
	ggggg..........	8	-8	2	10	2	5	15		
	a		10	-8	2	10	2	5	15
a			8	-8	2	16	2	5	15
	ddd		8	-8	2	16	2	5	15
	eeeee		8	-8	2	16	12	5	15
	f		8	-8	2	16	12	7	15
	ee		8	-8	2	16	16	7	15
	ffff		8	-8	2	16	16	15	15
	aaaaaaa		22	-8	2	16	16	15	15
bb			22	-8	2	16	16	15	15
b			22	-10	2	16	16	15	15
bb			22	-10	2	16	16	15	15
b			22	-12	2	16	16	15	15
	cccccccc	22	-12	18	16	16	15	15
	ddddd....	22	-12	18	26	16	15	15
bb			22	-12	18	26	16	15	15
a			20	-12	18	26	16	15	15
	a		22	-12	18	26	16	15	15
	cccc		22	-12	26	26	16	15	15
	ddddd		22	-12	26	36	16	15	15
	ffffff		22	-12	26	36	16	27	15
	ggg		22	-12	26	36	16	27	21
	ddddd		22	-12	26	46	16	27	21
	e		22	-12	26	46	18	27	21
	ffggggg		22	-12	26	46	18	31	31
	ee		22	-12	26	46	22	31	31
	b		22	-10	26	46	22	31	31
	dddd		22	-10	26	54	22	31	31
	eeee		22	-10	26	54	30	31	31
]

	eeeeeeeeee	22	-10	26	54	60	31	31
	eeeeeeeeee	22	-10	26	54	90	31	31
	eeeeeeeeee	22	-10	26	54	120	31	31
b			22	-13	26	54	120	31	31
b			22	-16	26	54	120	31	31
b			22	-19	26	54	120	31	31
b			22	-22	26	54	120	31	31
b			22	-25	26	54	120	31	31
b			22	-28	26	54	120	31	31
bgggggggggggggggggggg	22	-31	26	54	120	31	91
bgggggggggggggggggggg	22	-34	26	54	120	31	151
bgggggggggggggggggggg	22	-37	26	54	120	31	211
				<</textfile>>
				<<textfile "result.out">>
a's: 22
b's: -37
c's: 26
d's: 54
e's: 120
f's: 31
g's: 211
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>

<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>
			<<case "rule-eof-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE <<EOF>>
*/
					<</desc>>
					<<global_decl_code>>
var
	current_sc: integer;
					<</global_decl_code>>
					
					<<init_code>>
	current_sc := 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, bs, cs, eofs: integer%}
%actual-param%{ _as, bs, cs, eofs %}

%x	asc
%s	bsc
%x	csc

					<</declare_section>>
					<<lex_section>>
<*><<EOF>>		eofs := eofs + 1;
a			YYBEGIN(asc); current_sc := 1;
b			YYBEGIN(bsc); current_sc := 2;
c			YYBEGIN(csc); current_sc := 3;
<asc,bsc,csc>[abc]	case yytext[0] of
			'a': begin
				if current_sc = 1 then begin
					YYBEGIN(INITIAL);
					current_sc := 0;
				end
				else
					_as := _as +  2;
				end;
			'b': begin
				if current_sc = 2 then begin
					YYBEGIN(INITIAL);
					current_sc := 0;
				end
				else
					bs := bs + 2;
				end;
			else begin
				if current_sc = 3 then begin
					YYBEGIN(INITIAL);
					current_sc := 0;
				end
				else
					cs := cs +  2;
				end;
			end;
			
<*>.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	eofs: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	eofs := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n2, n3, eofs);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);
	writeln('c''s: ', n3);
	writeln('eof''s: ', eofs);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abba	 0 2 0
accca    0 2 3
baaaaaab 6 2 3
cbbbc    6 5 3
bccb     6 5 5
baaaab   105 5
accca    105 8
cccbbbbc 109 8
bccb     10910
aba      101010
				<</textfile>>
				<<textfile "result.out">>
a's: 20
b's: 20
c's: 20
eof's: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>
			<<case "rule-eol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE $
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var lines: integer%}
%actual-param%{ lines %}
					<</declare_section>>
					<<lex_section>>
\.$	lines := lines + 1;
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1);
	writeln('lines: ', n1);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
In the time since the 1986 edition of this book, the world of compiler design
has changed significantly. Programming languages have evolved to present new
compilation problems. Computer architectures offer a variety of resources of
which the compiler designer must take advantage. Perhaps most interestingly,
the venerable technology of code optimization has found use outside compilers.
It is now used in tools that find bugs in software, and most importantly, find		1
security holes in existing code. And much of the "front-end" technology -
grammars, regular expressions, parsers, and syntax-directed translators - are
still in wide use.
Thus, our philosophy from previous versions of the book has not changed.
We recognize that few readers will build, or even maintain, a compiler for a		2/3
major programming language. Yet the models, theory, and algorithms associated
with a compiler can be applied to a wide range of problems in software
design and software development . We therefore emphasize problems that are
most commonly encountered in designing a language processor, regardless of
the source language or target machine.
Use of the Book										4
It takes at least two quarters or even two semesters to cover all or most of the
material in this book. It is common to cover the first half in an undergraduate
course and the second half of the book - stressing code optimization - in
a second course at the graduate or mezzanine level. Here is an outline of the
chapters:
Chapter 1 contains motivational material and also presents some background
issues in computer architecture and programming-language principles.
Chapter 2 develops a miniature compiler and introduces many of the important		5
concepts, which are then developed in later chapters. The compiler itself
appears in the appendix.
Chapter 3 covers lexical analysis, regular expressions, finite-state machines, and	6
scanner-generator tools. This material is fundamental to text-processing of all
sorts.
											7
Chapter 4 covers the major parsing methods, top-down (recursive-descent , LL)
and bottom-up (LR and its variant s) .
Chapter 5 introduces the principal ideas in syntax-directed definitions and		8
syntax-directed translations.
Chapter 6 takes the theory of Chapter 5 and shows how to use it to generate		9
intermediate code for a typical programming language.
Chapter 7 covers run-time environment s, especially management of the run-time		10
stack and garbage collection.
Chapter 8 is on object-code generation. It covers construction of basic blocks,		11
generation of code from expressions and basic blocks, and register-allocation
techniques.
Chapter 9 introduces the technology of code optimization, including flow graphs,	12
data-flow frameworks, and iterative algorithms for solving these fr ameworks .
Chapter 10 covers instruction-level optimization. The emphasis is on the extraction	13
of parallelism from small sequences of instructions and scheduling them
on single processors that can do more than one thing at once.
Chapter 11 talks about larger-scale parallelism detection and exploitation. Here,	14
the emphasis is on numeric codes that have many tight loops that range over
multidimensional arrays.
Chapter 12 is on interprocedural analysis. It covers pointer analy sis, aliasing,	15
and data-flow analysis that takes into account the sequence of procedure calls
that reach a given point in the code.
Courses fr om material in this book have been taught at Columbia, Harvard,		16
and Stanford. At Columbia, a senior/first-year graduate course on programming
languages and translators has been regularly offered using material fr om
the first eight chapters. A highlight of this course is a semester-long project
in which students work in small teams to create and implement a little language
of their own design. The student-created languages have covered diverse
application domains including quantum computation, music synthesis, computer
graphics, gaming, matrix operations and many other areas. Students use
compiler-comp onent generators such as ANTLR, Lex, and Yacc and the syntaxdirected
translation techniques discussed in chapters two and five to build their
compilers. A follow-on graduate course has fo cused on material in Chapters 9
through 12, emphasizing code generation and optimization for contemporary
machines including network processors and multiprocessor architectures.
At Stanford, a one-quarter introductory course covers roughly the material		17
in Chapters 1 through 8, although there is an introduction to global code
optimization fr om Chapter 9. The second compiler course covers Chapters 9
through 12, plus the more advanced material on garbage collection from Chapter
7. Students use a locally developed , Java- based system called Joeq for
implementing data-flow analysis algorithms.
											18
The reader should possess some "computer-science sophistication," including
at least a second course on programming, and courses in data structures and
discrete mathematics. Knowledge of several different programming languages
is useful.
Exercises										19
The book contains extensive exercises, with some for almost every section. We
indicate harder exercises or parts of exercises with an exclamation point. The
hardest exercises have a double exclamation point.
Gradiance. On-Line Homeworks								20
A feature of the new edition is that there is an accompanying set of on-line
homeworks using a technology developed by Gradiance Corp. Instructors may
assign these homeworks to their class, or students not enrolled in a class may
enroll in an "omnibus class" that allows them to do the homeworks as a tutorial
(without an instructor-created class) . Gradiance questions look like ordinary
questions, but your solutions are sampled. If you make an incorrect choice you
are given specific advice or feedback to help you correct your solution. If your
instructor permits, you are allowed to try again, until you get a perfect score.
A subscription to the Gradiance service is offered with all new copies of this		21
text sold in North America. For more information, visit the Addison-Wesley
web site www . aw . com/gradiance or send email tocomput ing@aw . com.
Support on the World Wide Web								22
The book's home page is
dragonbook . stanford . edu
Here, you will find errata as we learn of them, and backup materials. We hope
to make available the notes for each offering of compiler-related courses as we
teach them, including homeworks, solutions, and exams. We also plan to post
descriptions of important compilers written by their implementers.
											23
				<</textfile>>
				<<textfile "result.out">>
lines: 23
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>
			<<case "rule-mcall-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: macro call
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
dec	[0-9]
hex	[0-9A-Fa-f]
sign	[\+\-]

%formal-param%{ var decs, hexes, signs: integer%}
%actual-param%{ decs, hexes, signs%}

					<</declare_section>>
					<<lex_section>>
{dec}+			decs := decs + 1;	writeln(yytext, ' [dec]');
{hex}+			hexes := hexes + 1; writeln(yytext, ' [hex]');
{sign}?({dec}+|{hex}+)	signs := signs + 1; writeln(yytext, ' [sign]');
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln('dec''s: ', n1);
	writeln('hex''s: ', n2);
	writeln('sign''s: ', n3);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
b7809
+-45fb
date: 1999.12.31
date: 2010.01.01
time: 23:59:59
time: 01:00:00
money: $999,999.99
phone: 0086-010-12345678
zip-code: 100233
sample text1
.0000-9990*&*$*&@%&ghf892efs
hello world on the earth
hi world in the universe
no more sample

				<</textfile>>
				<<textfile "result.out">>
b7809 [hex]
-45fb [sign]
da [hex]
e [hex]
1999 [dec]
12 [dec]
31 [dec]
da [hex]
e [hex]
2010 [dec]
01 [dec]
01 [dec]
e [hex]
23 [dec]
59 [dec]
59 [dec]
e [hex]
01 [dec]
00 [dec]
00 [dec]
e [hex]
999 [dec]
999 [dec]
99 [dec]
e [hex]
0086 [dec]
-010 [sign]
-12345678 [sign]
-c [sign]
de [hex]
100233 [dec]
a [hex]
e [hex]
e [hex]
1 [dec]
0000 [dec]
-9990 [sign]
f892ef [hex]
e [hex]
d [hex]
e [hex]
ea [hex]
d [hex]
e [hex]
e [hex]
e [hex]
e [hex]
a [hex]
e [hex]
dec's: 19
hex's: 25
sign's: 5
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>
			<<case "rule-multipattern-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: multi REs share same action
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var goods, bads: integer%}
%actual-param%{ goods, bads %}
					<</declare_section>>
					<<lex_section>>
"good"		|
"great"		|
"terrific"	|
"nice"		|
"awesome"	goods := goods + 1;

"horrible"	|
"terrible"	|
"nightmare"	|
"disastrous"	bads := bads + 1;
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('good-words: ', n1);
	writeln('bad-words: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
<--- XDICT --->
good
[gud]
n. ,,
a. ,,,,,,
<--- 5.0 --->
good
*[gud]
n. , , 
a. , , , , , , , 
 ; 
:
  for good
  for good or for evil
  good and
  good for
  hold good for
  in good time
  make good
  to the good
  good-bye
  say good-bye to sb
  as good as
<--- stardict1.3 --->
good
[gud]
n. ,;
a. ,,;
<---  --->
good
/ gUd; ^Jd/ adj (better / 5betE(r); `bZtL/, best /best; bZst/)  1 of high quality; of an acceptable standard; satisfactory ; ; ; : a good lecture, performance, harvest    * good pronunciation, behaviour, eyesight    * a good (eg sharp) knife  * Is the light good enough to take photographs? ? * The car has very good brakes. . * Her English is very good. .  2 (a) ~ (at sth) (often used with names of occupations or with ns derived from vs ) able to perform satisfactorily; competent ; : a good teacher, hairdresser, poet, etc    * good at mathematics, languages, describing things    * a good loser, ie one who doesn't complain when he loses . (b) [pred ] ~ with sth/sb capable when using, dealing with, etc sth/sb   : good with one's hands, eg able to draw, make things, etc   * He's very good with children, ie can look after them well, amuse them, etc. .  3 (a) morally acceptable; virtuous ; : a good deed  * try to lead a good life . (b) (esp of a child) well-behaved , : Try to be a good girl. .  4 ~ (to sb) willing to help others; kind ; ; : You were a good girl to help in the shop. , . * He was very good to me when I was ill. . * Would you be good enough to carry this for me? ?  5 pleasant; agreeable; welcome ; ; ; : The firm has had good times and bad times. . * What good weather we're having! ! * Have you heard the good news about my award? ? * It's good to be home again. , .  6 (of food) fit to be eaten; not yet rotting or rotten , : good eggs, fruit, etc   * Separate the good meat from the bad. .  7 [usu attrib ] not diseased; healthy; strong ; ; : good teeth and bones  * Would you speak into my good ear, I can't hear in the other one. , .  8 (of money) not fake or false; genuine , : This note is counterfeit, but that one's good. , . * (fig ) I gave good money for that camera, and it turned out to be worthless. , .  9 [attrib ] (of clothes, etc) used only for more formal or important occasions : My one good suit is at the cleaner's. . * Wear your good clothes to go to church. .  10 [attrib ] thorough; complete; sound ; ; : give sb a good beating, scolding, telling-off, etc    * go for a good long walk  * We had a good laugh at that. .  11 [usu attrib ] amusing ; : a good story, joke, etc   * `That's a good one!' she said, laughing loudly. !.  12 ~ (for sb/sth) beneficial; wholesome ; : the good (ie clean, refreshing) mountain air  * Is this kind of food good for me? ? * Sunshine is good for your plants. . * This cream is good for (ie soothes and heals) burns. .  13 ~ (for sth/to do sth) suitable; appropriate ; : a good time for buying a house/to buy a house  * This beach is good for swimming but bad for surfing. . * She would be good for the job. .  14 ~ for sth (a) (of a person or his credit) such that he will be able to repay (a sum lent) : He/His credit is good for 5000. []5000. (b) having the necessary energy, fitness, durability, etc   : You're good for (ie will live) a few years yet. . * This car's good for many more miles. . (c) valid for sth : The return half of the ticket is good for three months. .  15 (used in greetings ): Good morning/afternoon/evening! !  16 (fml ) (used as a polite, but more often patronizing, form of address or description , ): my good sir, man, friend, etc    * How is your good lady (ie your wife) ? ?  17 [attrib ] (used as a form of praise ): Good old Fred! ! * Good man! That's just what I wanted. ! .  18 [attrib ] (used in exclamations ): Good Heavens! ! * Good God! !  19 (with aa) [attrib ] (a) great in number, quantity, etc  , : a good many people  * We've come a good (ie long) way/distance. . (b) (used with expressions of measurement, quantity, etc  ) not less than; rather more than ; : We waited for a good hour. . * It's a good three miles to the station. . * She ate a good half of the cake. .  20 (idm ) as good as almost; practically ; : He as good as said I'm a liar, ie suggested that I was a liar without actually using the word `liar'. . * The matter is as good as settled. . good and... (infml ) completely ; : I won't go until I'm good and ready. . a good `few a considerable number (of); several ; : `How many came?' `A good few.' ?. * There are still a good few empty seats. . ,good for `sb, `you, `them, etc (infml ) (used when congratulating sb ) sb, etc did well : She passed the exam? Good for her! ? ! (For other idioms containing good, see entries for other major words in each idiom good, ,  (as) good as gold => gold; in good time => time1.)

adv (US infml ) well : Now, you listen to me good! , !

/ gUd; ^Jd/ n  1 [U] that which is morally right or acceptable ; : the difference between good and evil  * Is religion always a force for good? ?  2 [U] that which gives benefit, profit, advantage, etc   : work for the good of one's country  * I'm giving you this advice for your own good. . * Do social workers do a lot of good? ? Cf  do-gooder (do1).  3 the good [pl v] virtuous people : a gathering of the good and the great .  4 (idm ) be no/not much/any/some `good (doing sth) be of no, not much, etc value  ...: It's no good (my) talking to him. . * Was his advice ever any good? ? * This gadget isn't much good. . * What good is it asking her? ? do (sb) `good benefit sb : Eat more fruit: it will do you good. , . * This cough medicine tastes nice but it doesn't do much good, ie isn't very effective. , . * (usu ironic ) Much good may it do you, ie You won't get much benefit from it. . for `good (and `all) permanently; finally ; ; : She says that she's leaving the country for good, ie intending never to return to it. . to the `good (used to describe sb's financial state) in credit : We are 500 to the good, ie We have 500 more than we had. 500. up to no `good (infml ) doing sth wrong, mischievous, etc ; ; : Where's that naughty child now? I'm sure he'll be up to no good wherever he is. ? , .
<--- WordNet --->
good
good
     adj 1: having desirable or positive qualities especially those
            suitable for a thing specified; "good news from the
            hospital"; "a good report card"; "when she was good
            she was very very good"; "a good knife is one good for
            cutting"; "this stump will make a good picnic table";
            "a good check"; "a good joke"; "a good exterior
            paint"; "a good secretary"; "a good dress for the
            office" [ant: {bad}]
     2: having the normally expected amount; "gives full measure";
        "gives good measure"; "a good mile from here" [syn: {full}]
     3: morally admirable [ant: {evil}]
     4: deserving of esteem and respect; "all respectable companies
        give guarantees"; "ruined the family's good name" [syn: {estimable},
         {honorable}, {respectable}]
     5: promoting or enhancing well-being; "an arms limitation
        agreement beneficial to all countries"; "the beneficial
        effects of a temperate climate"; "the experience was good
        for her" [syn: {beneficial}]
     6: superior to the average; "in fine spirits"; "a fine
        student"; "made good grades"; "morale was good"; "had good
        weather for the parade" [syn: {fine}]
     7: agreeable or pleasing; "we all had a good time"; "good
        manners"
     8: of moral excellence; "a genuinely good person"; "a just
        cause"; "an upright and respectable man"; "the life of the
        nation is secure only while the nation is honest,
        truthful, and virtuous"- Frederick Douglass [syn: {just},
        {upright}, {virtuous}]
     9: having or showing knowledge and skill and aptitude; "adept
        in handicrafts"; "an adept juggler"; "an expert job"; "a
        good mechanic"; "a practiced marksman"; "a proficient
        engineer"; "a lesser-known but no less skillful composer";
        "the effect was achieved by skillful retouching" [syn: {adept},
         {expert}, {practiced}, {proficient}, {skillful}, {skilful}]
     10: thorough; "had a good workout"; "gave the house a good
         cleaning"
     11: with or in a close or intimate relationship; "a good
         friend"; "my sisters and brothers are near and dear"
         [syn: {dear}, {near}]
     12: having or showing or arising from a desire to promote the
         welfare or happiness of others; "his benevolent smile";
         "a benevolent nature" [syn: {benevolent}] [ant: {malevolent}]
     13: financially sound; "a good investment"; "a secure
         investment" [syn: {dependable}, {safe}, {secure}]
     14: most suitable or right for a particular purpose; "a good
         time to plant tomatoes"; "the right time to act"; "the
         time is ripe for great sociological changes" [syn: {right},
          {ripe}]
     15: resulting favorably; "its a good thing that I wasn't there";
         "it is good that you stayed"; "it is well that no one saw
         you"; "all's well that ends well" [syn: {well(p)}]
     16: exerting force or influence; "the law is effective
         immediately"; "a warranty good for two years"; "the law
         is already in effect (or in force)" [syn: {effective}, {in
         effect(p)}, {in force(p)}]
     17: feeling healthy and free of aches and pains; "I feel good"
         [syn: {good(p)}]
     18: capable of pleasing; "good looks"
     19: appealing to the mind; "good music"; "a serious book" [syn:
         {serious}]
     20: in excellent physical condition; "good teeth"; "I still have
         one good leg"; "a sound mind in a sound body" [syn: {sound}]
     21: tending to promote physical well-being; beneficial to
         health; "beneficial effects of a balanced diet"; "a good
         night's sleep"; "the salutary influence of pure air"
         [syn: {beneficial}, {salutary}]
     22: not forged; "a good dollar bill"
     23: not left to spoil; "the meat is still good" [syn: {unspoiled},
          {unspoilt}]
     24: generally admired; "good taste"
     [also: {better}, {best}]

good
     n 1: benefit; "for your own good"; "what's the good of worrying?"
     2: moral excellence or admirableness; "there is much good to be
        found in people" [syn: {goodness}] [ant: {evil}, {evil}]
     3: that which is good or valuable or useful; "weigh the good
        against the bad"; "among the highest goods of all are
        happiness and self-realization" [syn: {goodness}] [ant: {bad},
         {bad}]
     [also: {better}, {best}]

good
     adv 1: (often used as a combining form) in a good or proper or
            satisfactory manner or to a high standard (`good' is a
            nonstandard dialectal variant for `well'); "the
            children behaved well"; "a task well done"; "the party
            went well"; "he slept well"; "a well-argued thesis";
            "a well-planned party"; "the baby can walk pretty
            good" [syn: {well}] [ant: {ill}]
     2: in a complete and thorough manner (`good' is sometimes used
        informally for `thoroughly'); "he was soundly defeated";
        "we beat him good" [syn: {thoroughly}, {soundly}]
     [also: {better}, {best}]
<--- CDICT5 --->
good
[gUd;ud]
< good >
[]
(()) gd., G, G.
<<>>
bet.ter, best
1 
  a good experience 
  good news from the hospital 
2 a. 
     a good exterior paint 
     a good joke 
  b. ; 
     Is this a good dress for the party? ?
3 a. 
     The milk is still good. 
  b. ; 
     a good tooth 
4 a. 
     a good student 
  b. ()  ()
5 a. () 
     a good books 
  b. 
     good taste 
6 ; 
  ruined the family's good name 
7 ; 
  good looks 
8 
  a good night's rest 
9 ; 
  a good machinist 
10 ; 
   a good workout 
11 a. 
     a good investment 
   b. 
     a good reason 
   c. ; 
     a good dollar bill 
12 a. 
     a warranty good for two years 
     a driver's license that is still good 
   b. 
     I'm good for another round of golf. 
13 a. ; 
     Is she good for the money that you lent her? ?
   b. 
     He is always good for a laugh. 
14 a. ; 
     a good income 
   b. 
     a good table 
15 
   It is a good mile from here. 
16 a. ; 
     had a good time at the party 
   b. ; 
     good weather 
     a good omen 
17 a. ; 
     a good person 
   b. ; 
     a good soul 
     a good heart 
   c. ; 
     a good Republican 
18 a. ; 
     a good child 
   b. ; 
     good manners 
19
   The first serve was wide, but the second was good. , 
20 (, )
   Good heavens! !
   Good grief! !
<<>>
1 a. 
  b. ; 
2 ; 
  for the common good 
3 ; ; 
  There is much good to be found in people. 
4 ( goods)
  a. ; 
     frozen goods 
  b. ; 
  c. () 
5 ( goods)
  (()) 
  tried to get the goods on the crook 
<<>>
(()) ; 
<<>>
as good as
; 
as good as new  
for good
; 
I'm moving to Europe for good. 
good and
(()) ; 
I'll do it when I am good and ready. , 
no good
(())
1 
2 ; 
  It's no good arguing with them. 
to the good
1 ; 
2 
  ended up to the good 


<--- XDICT --->
great
[greit]
a. ,,,,,,,
ad. 
<--- 5.0 --->
great
*[greit]
a. , , , , , 
ad. , 
n. , , 
:
  in great detail
  great at
  great on
  great with
  a great many
  a great deal
<--- stardict1.3 --->
great
[greit]
a. ,,;
ad. ,;
<---  --->
great
/ greIt; ^ret/ adj (-er, -est)  1 (a) [attrib ] well above average in size, extent or quantity ; ; ; : The great ship sank below the waves. . * a great expanse of forest  * dive to a great depth  * all creatures great and small  * A great crowd had turned up. . * People had turned up in great numbers. . * The great majority (of people) (ie Most people) approve. . (b) far away in space or time ; : He lives a great distance away. . * That was a great while ago. . (c) [usu attrib ] exceptional in degree or intensity; considerable ; ; : of great value, importance, relevance, significance, etc     * He described it in great detail. . * Take great care to do it properly. . * You have my greatest (ie very great) sympathy. . * be in great demand, ie much wanted . (d) in a very good state of health, morale or well-being; fine ; ; ; ; : I feel great today! ! * in great form, ie very fit and active  * in great spirits, ie very cheerful . (e) [attrib ] with very good or bad effects : It's a great relief to know you're safe. . * You've been a great help. . * the greatest disaster that has ever befallen us. . =>Usage at big big.  2 (a) of remarkable ability or quality; outstanding ; : a great man, artist, musician, etc    * her great deeds  * No one would deny that Beethoven's symphonies are great masterpieces. . * the world's greatest novelist . (b) [attrib ] of high rank or status ; : a great lady  * the great powers, ie important and powerful countries  * Alexander the Great . (c) (infml ) very remarkable; splendid ; ; ; ; : He's great! ! * She's the greatest! ! * It's great that you can come! ! * What a great party! ! * He scored a great goal. . (d) (infml ) ~ (to do sth) very enjoyable or satisfactory ; : We had a great time in Majorca. . * It's great to know you! ! * It's great to have met you! !  3 (a) ~ for sth (infml ) very suitable for sth; ideal or useful for sth ; : This little gadget's great for opening tins. . * These are great shoes for muddy weather. . (b) [pred ] ~ at sth (infml ) clever or skilful at sth ; : She's great at tennis, chess, etc.  . (c) (ironic ) (used to express exasperation, scorn, etc    ): Oh great, I've missed the bus again! , ! * You've been a great help, you have! , !  4 [attrib ] (a) important; noteworthy; ; : The princess was getting married, and everyone was in town for the great occasion. , . * As the great moment approached, she grew more and more nervous. . (b) unequalled; excellent ; ; : She had a great chance/opportunity, but she let it slip. , . (c) the great the most important : The great advantage of this metal is that it doesn't rust. .  5 [attrib ] fully deserving the name of; beyond the ordinary ; ; ; : We are great friends. . * I've never been a great reader, ie I do not read much. . * He's a great one for complaining, ie He constantly complains. .  6 [attrib ] (infml ) (used to intensify another adj of size, etc ) very ; : What a great big idiot! ! * You great fat pig! ! * That's a great thick slice of cake! !  7 [attrib ] (used to name the larger of two types, species, etc  ): the great auk, ie contrasted with the little auk .  8 (added to words for relatives beginning with grand- to show a further stage in relationship grand-, ): one's ,great-`grandfather, ie one's father's or mother's grandfather  * one's ,great-`grandson, ie the grandson of one's son or daughter . =>App 8 8.  9 (dated infml , ) (in exclamations of surprise ): Great Scott! ! * Great heavens! !  10 (idm ) be no great shakes (infml ) not be very good, efficient, suitable, etc ; ; ; : She's no great shakes as an actress. . going great guns (infml ) proceeding vigorously and successfully ; . a good/great deal => deal2. great and small rich and poor, powerful and weak, etc  : Everyone, great and small, is affected by these changes. , . make great/rapid strides => stride. of great price very valuable ; . your need is greater than mine => need.

n  1 (usu pl ) (infml ) person of outstanding ability ; : one of boxing's all-time greats .  2 the great [pl v] great(2) people ; ; : a fashionable affair attended by all the great and the good, ie important and influential people .

NOTE ON USAGE : Britain or Great Britain (GB)consists of the geographical areas of England, Scotland and Wales. GB . It is often also used to refer to the political state, officially called the United Kingdom of Great Britain and Northern Ireland and usually abbreviated to the United Kingdom or the UK. , , UK. *The British Isles are the islands of Britain and Ireland. . There is no noun in British English commonly used to refer to the nationality of the people of Britain; instead the adjective is used : She's British. . * The British are said to have an unusual sense of humour. . Britisher is used in American English. *Britisher . Briton is found in newspaper, etc reports of incidents concerning British people and in statistical information. *Briton . It is also used of the early inhabitants of Britain *Briton: 10 Britons in hijacked plane 10 * According to the latest surveys many Britons suffer from heart disease. , . *  the ancient Britons .
<--- WordNet --->
great
great
     adj 1: relatively large in size or number or extent; larger than
            others of its kind; "a great juicy steak"; "a great
            multitude"; "the great auk"; "a great old oak"; "a
            great ocean liner"; "a great delay"
     2: more than usual; "great expectations"; "great worry"
     3: (used of persons) standing above others in character or
        attainment or reputation; "our distinguished professor";
        "an eminent scholar"; "a great statesman" [syn: {distinguished},
         {eminent}]
     4: of major significance or importance; "a great work of art";
        "Einstein was one of the outstanding figures of the 20th
        century" [syn: {outstanding}]
     5: remarkable or out of the ordinary in degree or magnitude or
        effect; "a great crisis"; "had a great stake in the
        outcome"
     6: very good; "he did a bully job"; "a neat sports car"; "had a
        great time at the party"; "you look simply smashing" [syn:
         {bang-up}, {bully}, {corking}, {cracking}, {dandy}, {groovy},
         {keen}, {neat}, {nifty}, {not bad(p)}, {peachy}, {slap-up},
         {swell}, {smashing}]
     7: uppercase; "capital A"; "great A"; "many medieval
        manuscripts are in majuscule script" [syn: {capital}, {majuscule}]
     8: marked by active interest and enthusiasm; "an avid sports
        fan"; "a great walker"; "an eager beaver" [syn: {avid}, {eager},
         {zealous}]
     9: in an advanced stage of pregnancy; "was big with child";
        "was great with child" [syn: {big(p)}, {enceinte}, {expectant},
         {gravid}, {great(p)}, {large(p)}, {heavy(p)}, {with
        child(p)}]
<--- CDICT5 --->
great
[gret;reit]
< great >
[]
<<>>
great.er, great.est
1 () 
2 
3 () 
  A great throng awaited us. 
4 () 
  a great delay 
5 () 
  a great crisis 
6 ; 
  a great work of art 
7 
  the great house on the estate 
8 () , , 
  "For he was great, ere foutune made him so." (John Dryden)
9 ; 
  one of the great nations of the West 
10 ; 
   a great leader 
11 ; 
12 (()) 
   a great lover of music 
13 (()) 
   great at algebra 
14 (()) ; 
   We had a great time at the dance. 
15 () ()
   a great-granddaughter 
16 (()) 
<<>>
1 (pl. greats, great) 
  a composer considered among the greats 
2
  a. () 
  b. () 
<<>>
(()) 
got along great with the teacher 
<<>>
greatly
<<>>
greatness


<--- XDICT --->
terrific
[trifik]
a. ,,
<--- 5.0 --->
terrific
*[t'rifik]
a. , , 
:
  at a terrific speed
<--- stardict1.3 --->
terrific
[trifik]
a. ,,;
<---  --->
terrific
/ tE5rIfIk; tE`rIfIk/ adj (infml )  1 very great; extreme ; : a terrific storm  *driving at a terrific speed .  2 excellent; wonderful ; : doing a terrific job  * The view was terrific. .
<--- WordNet --->
terrific
terrific
     adj 1: very great or intense; "a terrific noise"; "a terrific
            thunderstorm storm"; "fought a terrific battle"
     2: extraordinarily good; used especially as intensifiers; "a
        fantastic trip to the Orient"; "the film was fantastic!";
        "a howling success"; "a marvelous collection of rare
        books"; "had a rattling conversation about politics"; "a
        tremendous achievement" [syn: {fantastic}, {howling(a)}, {marvelous},
         {marvellous}, {rattling(a)}, {tremendous}, {wonderful}, {wondrous}]
     3: causing extreme terror; "a terrifying wail" [syn: {terrifying}]
<--- CDICT5 --->
terrific
[trIfIk;trifik]
< ter.rif.ic >
<<>>
more ter.rif.ic ; most ter.rif.ic
1 , , 
2 , , 
2 , ; 
<<>>
ter.rif.ic.ness
<<>>
ter.rif.i.cal.ly


<--- XDICT --->
nice
[nais]
a. ,,,,,,,
<--- 5.0 --->
nice
*[nais]
a. , , , , , , , 
:
  be nice to sb
<--- stardict1.3 --->
nice
[nais]
a. ,,;
<---  --->
nice
/ naIs; naIs/ adj (-r, -st)  1 (a) pleasant; agreeable ; ; : a nice person, smile, taste, remark     * a nice day  * nice weather  * a nice little girl  * That tastes nice! ! * We had a nice time at the beach. . * It's not nice to pick your nose. . (b) ~ (to sb) kind; friendly ; : Try to be nice to my father when he visits. . Cf  nasty.  2 (ironic ) bad; unpleasant ; : This is a nice mess you've got us into! ! * That's a nice thing to say! !  3 needing precision and care; fine; subtle ; ; : a nice distinction  * a nice point of law, ie one that may be difficult to decide  * nice (ie very slight) shades of meaning .  4 (a) hard to please; having refined tastes ; : too nice in one's dress . (b) (usu in negative expressions ) respectable; scrupulous ; ; ; : She's not too nice in her business methods. .  5 (idm ) nice and (used before adjs ) (infml approv , ) agreeably : nice and warm by the fire  * nice and cool in the woods . good/nice work => work1. nice work if you can get it (saying ) (used to express envy of what sb has been lucky or clever enough to get or do , ).
<--- WordNet --->
nice
nice
     adj 1: pleasant or pleasing or agreeable in nature or appearance;
            "what a nice fellow you are and we all thought you so
            nasty"- George Meredith; "nice manners"; "a nice
            dress"; "a nice face"; "a nice day"; "had a nice time
            at the party"; "the corn and tomatoes are nice today"
            [ant: {nasty}]
     2: socially or conventionally correct; refined or virtuous;
        "from a decent family"; "a nice girl" [syn: {decent}]
     3: done with delicacy and skill; "a nice bit of craft"; "a job
        requiring nice measurements with a micrometer"; "a nice
        shot" [syn: {skillful}]
     4: excessively fastidious and easily disgusted; "too nice about
        his food to take to camp cooking"; "so squeamish he would
        only touch the toilet handle with his elbow" [syn: {dainty},
         {overnice}, {prissy}, {squeamish}]
     5: noting distinctions with nicety; "a discriminating interior
        designer"; "a nice sense of color"; "a nice point in the
        argument" [syn: {discriminate}]
     6: exhibiting courtesy and politeness; "a nice gesture" [syn: {courteous},
         {gracious}]
<--- CDICT5 --->
nice
[naIs;nais | nis;nis]
< nice >
[]
<<>>
nic.er, nic.est
1 ; 
  had a nice time 
2 ; 
  a nice dress 
  a nice face 
3 
  a nice gesture 
4 ; 
5 ; 
6 ; 
  a nice distinction 
  a nice sense of style 
7 
  a nice bit of craft 
8 ( and , )
  nice and warm 
9
  a. ; 
  b. ; 
     "Ere... / The nice Morn on th' Indian steep, / From her cabin'd loop-hole peep." (John Milton)  / , / 
<<>>
nicely
<<>>
niceness

< Nice >
<<>>


<--- XDICT --->
awesome
[sm]
a. ,
<--- 5.0 --->
awesome
*[':sm]
a. , 
<--- stardict1.3 --->
awesome

a. ,;
<---  --->
awesome
/ -sEm; -sEm/ adj causing awe ; : His strength was awesome. .
<--- WordNet --->
awesome
awesome
     adj : inspiring awe or admiration or wonder; "New York is an
           amazing city"; "the Grand Canyon is an awe-inspiring
           sight"; "the awesome complexity of the universe"; "this
           sea, whose gently awful stirrings seem to speak of some
           hidden soul beneath"- Melville; "Westminster Hall's
           awing majesty, so vast, so high, so silent" [syn: {amazing},
            {awe-inspiring}, {awful}, {awing}]
<--- CDICT5 --->
awesome
[sm;sm]
< awe.some >
<<>>
1 , , 
2 , 
<<>>
awe.some.ly
<<>>
awe.some.ness

<--- XDICT --->
horrible
[hbl]
a. ,,
<--- 5.0 --->
horrible
*['hrbl]
a. , , 
<--- stardict1.3 --->
horrible
[hrbl]
a. ,,;
<---  --->
horrible
/ 5hCrEbl; ?@ 5hR:r-; `hRrEbl/ adj  1 causing horror ; : a horrible crime, nightmare, death   .  2 (infml ) very unpleasant : horrible weather, food, people    * It tastes horrible. . * Don't be so horrible (to me). . 
<--- WordNet --->
horrible
horrible
     adj : provoking horror; "an atrocious automobile accident"; "a
           frightful crime of decapitation"; "an alarming, even
           horrifying, picture"; "war is beyond all words
           horrible"- Winston Churchill; "an ugly wound" [syn: {atrocious},
            {frightful}, {horrifying}, {ugly}]
<--- CDICT5 --->
horrible
[hrbL,hr-;hrbl]
< hor.ri.ble >
<<>>
1 ; 
  "War is beyond all words horrible." (Winston S. Churchill)
2 ; 
<<>>
horri.ble.ness
<<>>
horri.bly


<--- XDICT --->
terrible
[terbl]
a. ,,,;;,;
<--- 5.0 --->
terrible
*['terbl]
a. , , 
<--- stardict1.3 --->
terrible
[terbl]
a. ,,;
<---  --->
terrible
/ 5terEbl; `tZrEbl/ adj  1 causing great fear ordistress; appalling ; ; : a terriblewar, accident, murder   .  2 hard to bear; extreme ; : terrible toothache  * The heat was terrible. .  3 (infml ) very bad ; : I'm terrible at tennis. . * What a terrible meal! ! * He's a terrible bore. .
<--- WordNet --->
terrible
terrible
     adj 1: causing fear or dread or terror; "the awful war"; "an awful
            risk"; "dire news"; "a career or vengeance so direful
            that London was shocked"; "the dread presence of the
            headmaster"; "polio is no longer the dreaded disease
            it once was"; "a dreadful storm"; "a fearful howling";
            "horrendous explosions shook the city"; "a terrible
            curse" [syn: {awful}, {dire}, {direful}, {dread(a)}, {dreaded},
             {dreadful}, {fearful}, {fearsome}, {frightening}, {horrendous},
             {horrific}]
     2: exceptionally bad or displeasing; "atrocious taste";
        "abominable workmanship"; "an awful voice"; "dreadful
        manners"; "a painful performance"; "terrible handwriting";
        "an unspeakable odor came sweeping into the room" [syn: {atrocious},
         {abominable}, {awful}, {dreadful}, {painful}, {unspeakable}]
     3: intensely or extremely bad or unpleasant in degree or
        quality; "severe pain"; "a severe case of flu"; "a
        terrible cough"; "under wicked fire from the enemy's
        guns"; "a wicked cough" [syn: {severe}, {wicked}]
     4: extremely distressing; "fearful slum conditions"; "a
        frightful mistake"; "suffered terrible thirst" [syn: {fearful},
         {frightful}]
<--- CDICT5 --->
terrible
[trbL;terbl]
< ter.ri.ble >
[]
<<>>
1 ; 
  a terrible bolt of lightning 
  a terrible curse 
2 
  terrible responsibilities 
3 ; 
  "the life for which he had paid so terrible a price" (Leslie Fiedler)
4 a. 
     had a terrible time at the party 
  b.
     terrible hypocrisy 
<<>>
terri.ble.ness
<<>>
terri.bly


<--- XDICT --->
nightmare
[naitm]
n. ,,
<--- 5.0 --->
nightmare
*['naitm]
n. , , ()
 , 
<--- stardict1.3 --->
nightmare
[naitm]
n. ,,;
<---  --->
nightmare
n  1 frightening dream ; : I have nightmares about falling off a cliff. .  2 (infml ) very frightening or unpleasantexperience : Driving during the blizzard was a nightmare. . 
<--- WordNet --->
nightmare
nightmare
     n 1: a situation resembling a terrifying dream [syn: {incubus}]
     2: a terrifying or deeply upsetting dream
<--- CDICT5 --->
nightmare
[naItmr;naitm]
< night.mare >
<<>>
1 ; 
2  ()
3 
  
<<>>
nightmar.ish
<<>>
nightmarish.ly
<<>>
nightmarish.ness


<--- XDICT --->
disastrous
[dizstrs]
a. ,
<--- 5.0 --->
disastrous
*[di'z:strs]
a. , 
<--- stardict1.3 --->
disastrous
[dizstrs]
a. ,;
<---  --->
disastrous
/ dI5zB:strEs; ?@ -z5As-; dIz`AstrEs/ adj being or causing a disaster ; ; : disastrous floods  * a defeat that was disastrous to the country  * Buying this house was a disastrous step: it's going to have a main road built behind it. , . 
<--- WordNet --->
disastrous
disastrous
     adj : (of events) having extremely unfortunate or dire
           consequences; bringing ruin; "the stock market crashed
           on Black Friday"; "a calamitous defeat"; "the battle
           was a disastrous end to a disastrous campaign"; "such
           doctrines, if true, would be absolutely fatal to my
           theory"- Charles Darwin; "it is fatal to enter any war
           without the will to win it"- Douglas MacArthur; "a
           fateful error" [syn: {black}, {calamitous}, {fatal}, {fateful}]
<--- CDICT5 --->
disastrous
[dIzstrs;dizstrs]
< dis.as.trous >
<<>>
1 ; 
2 , 
  a disastrous report card 
<<>>
dis.astrous.ly
<<>>
dis.astrous.ness

good: 225
great: 125
terrific: 16
nice: 59
awesome: 10

horrible: 14
terrible: 24
nightmare: 11
disastrous: 14

436/63
				<</textfile>>
				<<textfile "result.out">>
good-words: 435
bad-words: 63
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-useless--->>>
			<<case "rule-useless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: useless expression
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var lowers, uppers, digits: integer %}
%actual-param%{ lowers, uppers, digits %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			lowers := lowers + 1;
B			uppers := uppers + 1;
<*>[[:alnum:]]		if isdigit(yytext[0]) then
				digits := digits + 1
			else if islower(yytext[0]) then
				lowers := lowers + 1
			else
				uppers := uppers + 1;
<asc>[[:upper:]]	uppers := uppers + 2;
<bsc>[[:lower:]]	lowers := lowers + 2;
<asc>[[:digit:]]	digits := digits + 2;
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex( n1, n2, n3);
	writeln('lower''s: ', n1);
	writeln('upper''s: ', n2);
	writeln('digit''s: ', n3);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
eeeeeeeeee8888hh22222222hh5555555FFFF..........hhh.hhheeeh55555555hffffffffGG..........FFFFFhDDDDDDDDDhCCCCCfffffccchhhhhddddddddddddhhGGGGGGGGGGh222hh......hhhbbbbh2222hheeeeehhhhhfaaaaaeeeeeecccccc....haaaaaaaaaaaah2222222333333333hhGGGGGGGGhh3333333333hffff888888888hhddddddd000000000heeebbbbbbbbb8888888hhhhCCCCCCCCCBBBBhBBBBBBBBBBhhccccchhhhhhbbbb00333333ggghDaaaaa00000CCCCCCCCCChhhhhBBCCCCCCCfh3555555555eeehbbbbbbbbbbhccccchhFFFFFFFFhh333hh00000hFFFFFFFFFF44444dddDDDDDDDh55554444444444hhhhDD00000fBBBBhfffffbbhEEEEhhhhhh3333hhh..5555555555h000bbbbbbbbb...EEEEEEEEddh5558h........CCCCCCChhh.......hhBBBBBBhaaahCCCCCCCCCGGGGGGGG00000000000000022222h5555hh..........heeeeeeeeeehhaaaaaaaaahgggggggggaaaaaaaggggh000h222ffffffheeeeeeeeeh55555555h..hh0000000
332/159/215
				<</textfile>>
				<<textfile "result.out">>
lower's: 332
upper's: 159
digit's: 215
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-useless--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/rule---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond---------->>>
		<<suite "startcond" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>
			<<case "startcond-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition: duplicated SC

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

%x asc
%s asc

					<</declare_section>>
					<<lex_section>>
"{"			YYBEGIN(asc);
<asc>"}"	YYBEGIN(INITIAL);
<asc>a		ncnt := ncnt + 1; write(yytext);
a		ncnt := ncnt + 2; write(yytext);
<*>\n		writeln;
<asc>.		write('_');
.

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln; writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{sfkiwegfsafa;adska
9348ejfsdjfklaeijofsedaiojdfasijoafiajoiwafo9ijwef320ewfokSAlL
349aew0ifjofl;Sao9pjgvdsnAO9WFMDSOPAAEGDASSODPL;AOPAalaomfaopfkd;klasdfjkfeiwjofkdscmx ,        P2309824390EDWPKOCSMLZX,. D
OPAKFPOAOPAF[al;pafkasdflergjvkldmldsfa[pw4e-=3240r5i0=-ew]pdsv;l  /.CX v,psidjkiewroas[dlc;fmkioopwer[]al;aerpwdsl
}
ajfdslowpef
oepwfasfl;sdfwepfas'
				<</textfile>>
				<<textfile "result.out">>
_________a_a_a___a
_____________a________a_____a____a__a____a____________________
___a___________a____________________________________a_a___a________a_______________________________________________________
_____________a___a__a_________________a______________________________________________a__________________a__a_______

a
aa

29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>
			<<case "startcond-exclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, _as2, bs, bs2: integer%}
%actual-param%{ _as, _as2, bs, bs2 %}

%x isc

					<</declare_section>>
					<<lex_section>>
\{		YYBEGIN(isc); write(yytext);
<isc>\}		YYBEGIN(INITIAL); write(yytext);
a		_as := _as + 1; write(yytext);
<isc>b		bs2 := bs2 + 1; write(yytext);
b		bs := bs + 1; write(yytext);
<*>a		_as2 := _as2 + 1; write(yytext);
<isc>.		write('_');
<*>\n		writeln;
.		write('*');
					<</lex_section>>

					<<local_decl_code>>
var
	n1: integer;
	n11: integer;
	n2: integer;
	n21: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n11 := 0;
	n2 := 0;
	n21 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n11, n2, n21);
	writeln('a''s: ', n1, ' at INITIAL');
	writeln('a''s: ', n11, ' at isc');
	writeln('b''s: ', n2, ' at INITIAL');
	writeln('b''s: ', n21, ' at isc');

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
bb~~bbbbbb~aa~aaaaaaaaaaa~~}}}}}}}}}~cccccaaa}}}}~bbbbbb~}~~aaaaabbbbbbbb~~~~cccccccccaaa{{{{{{{{{{aaaaaa~cccccccccc~..........~....bbb~~.~~ccccccc~aaaaaaaaacccccc~~{{{{{{{~~~ccccccc~{{{{{{}}}}}}}}}}~~~~bb~{{{{{cccccccccc}}}}}}{{{aaaaa~{{{{{{}}}}c~cccc~bbbaaaaaaa..........~aaaaaaa~~}}}}}}}}}}~~
.: 25
a: 58
b: 30
{: 37
}: 44
c: 59
~: 42

				<</textfile>>
				<<textfile "result.out">>
bb**bbbbbb*aa*aaaaaaaaaaa*****************aaa*****bbbbbb****aaaaabbbbbbbb*************aaa{_________aaaaaa___________________________bbb_____________aaaaaaaaa________________________________}*************bb*{______________}*****{__aaaaa_______}**********bbbaaaaaaa***********aaaaaaa**************
*****
a****
b****
{____
}****
*****
*****

a's: 39 at INITIAL
a's: 20 at isc
b's: 28 at INITIAL
b's: 3 at isc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>
			<<case "startcond-exclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var n1, n2, n3: integer %}
%actual-param%{ n1, n2, n3 %}

%x bsc
%x csc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		write(yytext);
<INITIAL,csc>\{		yy_push_state(bsc); write(yytext);
<INITIAL,bsc>\[		yy_push_state(csc); write(yytext);
<bsc>\}			yy_pop_state(); write(yytext);
<csc>\]			yy_pop_state(); write(yytext);
<bsc,csc>[\}\]]		write(yytext);
a				n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
.				write('*');
<bsc>.			write('-');
<csc>.			write('_');
<*>\n			writeln;

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln('a''s: ', n1, ' at INITIAL');
	writeln('a''s: ', n2, ' at bsc');
	writeln('a''s: ', n3, ' at csc');


	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
************aaaaaaaaaa*************************[_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]*{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

a's: 10 at INITIAL
a's: 18 at bsc
a's: 1 at csc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>
			<<case "startcond-exclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3, n4: integer %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%x csc
%x dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		write(yytext);
\{		YYBEGIN(bsc); write(yytext);
<bsc>\{		YYBEGIN(csc); write(yytext);
<csc>\{		YYBEGIN(dsc); write(yytext);
<dsc>\}		YYBEGIN(csc); write(yytext);
<csc>\}		YYBEGIN(bsc); write(yytext);
<bsc>\}		YYBEGIN(INITIAL); write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
<dsc>a			n4 := n4 + 1; write(yytext);
.				write('*');
<bsc>.			write('-');
<csc>.			write('_');
<dsc>.			write('+');
<*>\n			writeln;
					<</lex_section>>

					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n2, n3, n4);
	writeln('SC0: ', n1);
	writeln('SC1: ', n2);
	writeln('SC2: ', n3);
	writeln('SC3: ', n4);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}***********{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}**{{{+aaaaaaaa+aa+++++}}}***{{{++aaaaa}}}******************{{{++++++++++++++}}}******{{{++++++++++++++}}}*************************aaaaaaa*****{{{++}}}************aaaaaaaa***********aaaaaaa{{{+++++++++++++++++++++++++}}}***{{{+++++++++++++++++++++++++}}}**{{{++++++++++++}}}*****aa*********aa******************{{{++++++++++++++}}}*********************aaaaaaa**************aaaaa*aaaaaaaa**a{{{+++++aa+++++++++}}}********
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 49
SC1: 10
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>
			<<case "startcond-inclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, _as2, bs, bs2: integer%}
%actual-param%{ _as, _as2, bs, bs2 %}

%s isc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+	write(yytext);
\{		YYBEGIN(isc); write(yytext);
<isc>\}		YYBEGIN(INITIAL); write(yytext);
a		_as := _as + 1; write(yytext);
b		bs := bs + 1; write(yytext);
<isc>b		bs2 := bs2 + 1; write(yytext);
<*>a		_as2 := _as2 + 1; write(yytext);
.		write('*');
<isc>.		write('_');
<*>\n		writeln;
					<</lex_section>>


					<<local_decl_code>>
var
	n1: integer;
	n11: integer;
	n2: integer;
	n21: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n11 := 0;
	n2 := 0;
	n21 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n11, n2, n21);
	writeln('SC0-a: ', n1);
	writeln('SC1-a: ', n11);
	writeln('SC0-b: ', n2);
	writeln('SC1-b: ', n21);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
aaaaa}}}}}}}}~bbbbbbbbbb{{{~{{{{{{{{~~~aaaaaaaaaa}}}}}}}}}}}}}}~~~~~~........~{{{{{{{{{~bbbbaaaaaaaaa~{{bbbbbb~b~~~~{c~~}}}~~~{{{~}}}}b~aaaaaaaaa{{{{{{{{bbbbbbbbc~}}}}}}~}}}}}}.~~aaaaaaaaaa{{{{{{{{{{~}}}}}}~~cccccc~~}}}}}}}a
.: 9
a: 19
a: 25
{: 18
}: 16
{: 26
}: 38
b: 10
b: 20
c: 8
~: 35

				<</textfile>>
				<<textfile "result.out">>
aaaaa}}}}}}}}*bbbbbbbbbb{______________aaaaaaaaaa}}}}}}}}}}}}}}***************{_________bbbbaaaaaaaaa___bbbbbb_b________}}}***{___}}}}b*aaaaaaaaa{_______bbbbbbbb__}}}}}}*}}}}}}***aaaaaaaaaa{__________}}}}}}**********}}}}}}}a
***9
a**19
a**25
{__18
}**16
{__26
}**38
b**10
b**20
***8
***35

SC0-a: 27
SC1-a: 19
SC0-b: 13
SC1-b: 19
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>
			<<case "startcond-inclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3: integer%}
%actual-param%{ n1, n2, n3 %}

%s bsc
%s csc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		write(yytext);
[\}\]]			write(yytext);
<INITIAL,csc>\{		yy_push_state(bsc); write(yytext);
<INITIAL,bsc>\[		yy_push_state(csc); write(yytext);
<bsc>\}			yy_pop_state(); write(yytext);
<csc>\]			yy_pop_state(); write(yytext);
<bsc,csc>[\}\]]		write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
.			write('*');
<bsc>.			write('-');
<csc>.			write('_');
<*>\n			writeln;
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln('SC0-a: ', n1);
	writeln('SC1-a: ', n2);
	writeln('SC2-a: ', n3);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
*********]]*aaaaaaaaaa******************]]]]]]][_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]]{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

SC0-a: 10
SC1-a: 18
SC2-a: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>
			<<case "startcond-inclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3, n4: integer %}
%actual-param%{ n1, n2, n3, n4 %}


%s bsc
%s csc
%s dsc
					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		write(yytext);
[\{\}]		YYBEGIN(bsc); write(yytext);
<bsc>\{		YYBEGIN(csc); write(yytext);
<csc>\{		YYBEGIN(dsc); write(yytext);
<dsc>\}		YYBEGIN(csc); write(yytext);
<csc>\}		YYBEGIN(bsc); write(yytext);
<bsc>\}		YYBEGIN(INITIAL); write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
<dsc>a			n4 := n4 + 1; write(yytext);
.			write('*');
<bsc>.			write('-');
<csc>.			write('_');
<dsc>.			write('+');
<*>\n			writeln;
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3, n4);
	writeln('SC0: ', n1);
	writeln('SC1: ', n2);
	writeln('SC2: ', n3);
	writeln('SC3: ', n4);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>
			<<case "startcond-inex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive & exclusive start-condition

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3, n4: integer %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%s csc
%s dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		write(yytext);
[\{\}]		YYBEGIN(bsc); write(yytext);
<bsc>\{		YYBEGIN(csc); write(yytext);
<csc>\{		YYBEGIN(dsc); write(yytext);
<dsc>\}		YYBEGIN(csc); write(yytext);
<csc>\}		YYBEGIN(bsc); write(yytext);
<bsc>\}		YYBEGIN(INITIAL); write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
<dsc>a			n4 := n4 + 1; write(yytext);
.			write('*');
<bsc>.		write('-');
<csc>.		write('_');
<dsc>.		write('+');
<*>\n		writeln;
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3, n4);
	writeln('SC0: ', n1);
	writeln('SC1: ', n2);
	writeln('SC2: ', n3);
	writeln('SC3: ', n4);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>
		<<suite "startcond-refer" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-alleof--->>>
			<<case "startcond-refer-alleof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
every start-condition has its own EOF-rule
*/
					<</desc>>
					
					<<global_decl_code>>
var
	pcchFileName: array[0..2] of pchar = (
		'test1.input',
		'test2.input',
		nil);
	fIndex: integer = 0;
	pbuf: YYPBUFFER;
					<</global_decl_code>>
					<<init_code>>
	fIndex := 0;
					<</init_code>>
					<<declare_section>>
%x	asc
%x	bsc
%x	csc
					<</declare_section>>
					<<lex_section>>
a		YYBEGIN(asc);
b		YYBEGIN(bsc);
c		YYBEGIN(csc);
<asc>a		YYBEGIN(INITIAL);
<bsc>b		YYBEGIN(INITIAL);
<csc>c		YYBEGIN(INITIAL);
<<EOF>>
			writeln('File end at SC-INITIAL: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<asc><<EOF>>
			writeln('File end at SC-asc: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<bsc><<EOF>>
			writeln('File end at SC-bsc: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<csc><<EOF>>
			writeln('File end at SC-csc: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<*>.|\n

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
dddddddddeccccccccccc...aaaaaadbbbbbbbbbaaaaaaaccccccceeeebbbbbbbbbeeeeccaaaaaaaecccccccceeeeeeeeeeeeeccccaaaaaaaaaaeeedddaaaaaaaddddeedddddddeddddddddebbbbbbb...dddde...aaaaaaaaaaeeeaaaaaaaaaeddddddddbbbbbbbbbbee.....bbbbbbbbbeeaaaaaaa
.: 14
a: 63
b: 44
c: 32
d: 44
e: 39

				<</textfile>>
				<<textfile "test1.input">>
aaaaaadddddddddeeeee..eeedddddddeeddddddddbbbbbdddddddeddddbbbddeeeebbaaaaaaaaeeacccccebbbbbbcccccccccbbbbbbbeccceaaaaaaaa
.: 2
a: 23
b: 23
c: 17
d: 37
e: 20

				<</textfile>>
				<<textfile "test2.input">>
aaaaaaaee..a.........bbbbbedddddddddedddeeeaaaaddeeeeedddecccccaaeeeebbbbbeccccceeebbbddddcccceddbdee..........ddccccccccccebbbbbbaaaaaaaaaaeeddddddcccccebbbbbbedddedccccccccccccccccdddddddddd........eee....dddddeeeeeeeeee......ebbbbeeeedddddddddebbbbbbbbbbaaaaaaabbbbbbcccccceee
.: 39
a: 31
b: 46
c: 51
d: 60
e: 52

				<</textfile>>
				<<textfile "result.out">>
File end at SC-asc: 2
File end at SC-bsc: 4
File end at SC-bsc: 4
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-alleof--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-allsc--->>>
			<<case "startcond-refer-allsc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
special start-condition <*>
*/
					<</desc>>
					<<global_decl_code>>
var
	c1: integer;
	c2: integer;
					<</global_decl_code>>
					<<init_code>>
	c1 := 0;
	c2 := 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ var beta, betb, others: integer %}
%actual-param%{ beta, betb, others %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			YYBEGIN(asc);
			write('{');
			c1 := 0;
			others := others + 1;
			
b			YYBEGIN(bsc);
			write('[');
			c2 := 0;
			others := others + 1;
			
<asc>a		YYBEGIN(INITIAL);
			write('}');
			beta := beta + c1;
			others := others + 1;
			
<bsc>b		YYBEGIN(INITIAL);
			write(']');
			beta := beta + c2;
			others := others + 1;

<asc>[[:graph:]] 	c1 := c1 + 1;
					write(yytext);
			
<bsc>[[:graph:]]	c2 := c2 + 1;
					write(yytext);
<*>.			write('_');
				others := others + 1;
				
<*>\n			writeln;

<*><<EOF>>		others := others + c1;
				others := others + c2;
				
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln;
	writeln('chars between a''s: ', n1);
	writeln('chars between b''s: ', n2);
	writeln('others: ', n3);
	writeln('total: ', n1 + n2 + n3);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
bbedddcccccccecccccccccccccceaeeddddddddeeedddddddddd.ddde.......eeeaaebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142

				<</textfile>>
				<<textfile "result.out">>
[]___________________________{eeddddddddeeedddddddddd.ddde.......eee}{ebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142


chars between a's: 38
chars between b's: 0
others: 104
total: 142
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-allsc--->>>

<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-multisc--->>>
			<<case "startcond-refer-multisc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
refer multi start-condition
*/

					<</desc>>
					<<init_code>>
					<</init_code>>
					<<declare_section>>

%formal-param%{ var qstr, mstr: string; var bexpr: boolean %}
%actual-param%{ qstr, mstr, bexpr %}

%x	qstr_sc
%x	expr_sc
					<</declare_section>>
					<<lex_section>>

\"						yy_push_state(qstr_sc); bexpr := false;
<qstr_sc>\`					yy_push_state(expr_sc); bexpr := true;
<expr_sc,qstr_sc>\$[[:cidf:]][[:cids:]]*	if bexpr then mstr := mstr + yytext else qstr := qstr + yytext;			 
<expr_sc,qstr_sc>[\+\-\*\/\(\)\[\]\{\}]		if bexpr then mstr := mstr + yytext else qstr := qstr + yytext;
<expr_sc>\`					yy_pop_state(); bexpr := false; mstr := mstr + #10;
<qstr_sc>\"					yy_pop_state(); qstr := qstr + #10;
<expr_sc,qstr_sc,expr_sc>.			if bexpr then mstr := mstr + yytext else qstr := qstr + yytext;

<*>.|\n
					<</lex_section>>
					
					<<local_decl_code>>
var
	qstr: string;
	mstr: string;
	b: boolean;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	qstr := '';
	mstr := '';
	b := false;
					<</before_init>>
					<<after_init>>
	nret := yylex(qstr, mstr, b);

	writeln('qstr: ', qstr);
	writeln('mstr: ', mstr);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
"if test `expr n1 * n2` != 0 then both n1 and n2 are not zero else either n1 or n2 are zero"
print_msg("for your information `echo $msg`")    
print "done"

				<</textfile>>
				<<textfile "result.out">>
qstr: if test  != 0 then both n1 and n2 are not zero else either n1 or n2 are zero
for your information 
done

mstr: expr n1 * n2
echo $msg

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-multisc--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-someeof--->>>
			<<case "startcond-refer-someeof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
some start-conditions have own EOF-rule
*/

					<</desc>>
					<<global_decl_code>>
const
	IDX_ASC = 0;
	IDX_BSC = 1;
	IDX_CSC = 2;
	IDX_DSC = 3;
var
	ppchFileName: array[0..3] of pchar = (
		'test1.input',
		'test2.input',
		'test3.input',
		nil);
					<</global_decl_code>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%lvar-decl%{
	i: integer;
	pbuf: YYPBUFFER;
%}

%yywrap%{
	result := false; 
%}

%x	asc
%x	bsc
%x	csc
%x	dsc
					<</declare_section>>
					<<lex_section>>

a	YYBEGIN(asc); writeln(yytext);
b	YYBEGIN(bsc); writeln(yytext);
c	YYBEGIN(csc); writeln(yytext);
d	YYBEGIN(dsc); writeln(yytext);
<asc>a	YYBEGIN(INITIAL);
<bsc>b	YYBEGIN(INITIAL);
<csc>c	YYBEGIN(INITIAL);
<dsc>d	YYBEGIN(INITIAL);
<asc><<EOF>>	begin
			writeln('File end at SC-asc: ', YYSTART());
			yy_delete_buffer();
			for i := 2 downto 0 do begin
				pbuf := yy_new_filebuf(ppchFileName[i]);
				if pbuf = nil then begin

					writeln('failed to open buffer');
					yyterminate();
					break;
				end
				else begin
					yy_push_buffer(pbuf);
				end;
			end;
			YYBEGIN(INITIAL);
		end;
<*><<EOF>>		begin
			case YYSTART() of
			bsc: writeln('File end at SC-bsc: ', YYSTART());
			csc: writeln('File end at SC-csc: ', YYSTART());
			dsc: writeln('File end at SC-dsc: ', YYSTART());
			end;
			yy_delete_buffer();
			YYBEGIN(INITIAL);
		end;

<*>.|\n
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
a
				<</textfile>>
				<<textfile "test1.input">>
b
				<</textfile>>
				<<textfile "test2.input">>
c
				<</textfile>>
				<<textfile "test3.input">>
d
				<</textfile>>
				<<textfile "result.out">>
a
File end at SC-asc: 2
b
File end at SC-bsc: 4
c
File end at SC-csc: 6
d
File end at SC-dsc: 8
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-someeof--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/basic---------->>>

<</suite>>
<<<----------sub-suite: /lex-alone ---------->>>



<<<----------sub-suite: /invoke ---------------->>>
<<suite "invoke" make="subdir-makefile-template">>
<<<----------case: /invoke/default----------------->>>
	<<case "default" make="invoke-make-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	default options
		-o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
ans = 		0
ans = 		1024
ans = 		1024
Error: at 25:1; description: yy is unset variable.
yy = 		1024
yy = 		1024
Error: at 28:1; description: goodbye is unset variable.
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
	<<<----------case: /invoke/default----------------->>>

<<<----------case: /invoke/option-t----------------->>>
	<<case "option-t" make="invoke-make-stdout-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -t to redirect code output to stdout
		-t
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
ans = 		0
ans = 		1024
ans = 		1024
Error: at 25:1; description: yy is unset variable.
yy = 		1024
yy = 		1024
Error: at 28:1; description: goodbye is unset variable.
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-t----------------->>>


<<<----------case: /invoke/option-a----------------->>>
	<<case "option-a" make="invoke-make-template">>
		<<upgen_options>>-al<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -a
		-a -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-a----------------->>>


<<<----------case: /invoke/option-d1----------------->>>
	<<case "option-d1" make="invoke-make-template">>
		<<upgen_options>>-d -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d to enable producing diagnosis information
	for pattern-matching
		-d -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
.................... accept {`sub'}, rule at line: 744
.................... accept {`='}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`-'}, rule at line: 750
.................... accept {`-'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`-'}, rule at line: 750
.................... accept {`+'}, rule at line: 750
.................... accept {`4'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`4'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`-'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`4'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept unprintable-char{10}, rule at line: 750
sub = 		-7748934
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`%'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`1011'}, rule at line: 727
.................... accept unprintable-char{10}, rule at line: 750
ans = 		-630
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept unprintable-char{10}, rule at line: 750
sub = 		-620
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`9'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`216'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`24'}, rule at line: 727
.................... accept unprintable-char{10}, rule at line: 750
sub = 		-600
.................... accept {`sup'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`('}, rule at line: 750
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`^'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`3'}, rule at line: 727
.................... accept {`)'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
.................... accept unprintable-char{10}, rule at line: 750
sup = 		342857
.................... accept {`list'}, rule at line: 740
.................... accept unprintable-char{10}, rule at line: 750
ans = 		-630
sub = 		-600
sup = 		342857
.................... accept {`clear'}, rule at line: 736
.................... accept unprintable-char{10}, rule at line: 750
.................... accept {`sup'}, rule at line: 744
.................... accept {`?'}, rule at line: 750
Error: at 8:1; description: sup is unset variable.
.................... accept unprintable-char{10}, rule at line: 750
.................... accept {`quit'}, rule at line: 732
.................... accept unprintable-char{10}, rule at line: 750
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1----------------->>>

<<<----------case: /invoke/option-D2----------------->>>
	<<case "option-D2" make="invoke-make-template">>
		<<upgen_options>>-D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -D to enable producing diagnosis information
	for parsing
		-D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 759.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 862.
Next symbol is -
Shift -, go to state 28
Next symbol is -
Shift -, go to state 12
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 862.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 895.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
Next symbol is +
Shift +, go to state 11
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 862.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 900.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 911.
Next symbol is %
Shift %, go to state 31
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 847.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 769.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is (
Shift (, go to state 14
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 911.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 862.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 904.
Next symbol is /
Shift /, go to state 30
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 911.
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is LIST
Shift LIST, go to state 9
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 803.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is CLEAR
Shift CLEAR, go to state 8
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 799.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 786.
Next symbol is ?
Shift ?, go to state 34
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 786.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is QUIT
Shift QUIT, go to state 10
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 811.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-D2----------------->>>

<<<----------case: /invoke/option-d1D2----------------->>>
	<<case "option-d1D2" make="invoke-make-template">>
		<<upgen_options>>-d -D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d[debug-level] -D[debug-level] to enable producing diagnosis information
	for pattern-matching and parsing
		-d -D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 759.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`-'}, rule at line: 750
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 862.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 750
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`-'}, rule at line: 750
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 862.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 895.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 750
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`-'}, rule at line: 750
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 862.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 900.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`%'}, rule at line: 750
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 911.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 755
.................... accept {`1011'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 908.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 847.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 769.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 755
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 755
.................... accept {`9'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 755
.................... accept {`216'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 755
.................... accept {`24'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sup'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 755
.................... accept {`('}, rule at line: 750
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 911.
.................... accept {` '}, rule at line: 755
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 755
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`)'}, rule at line: 750
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 862.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 904.
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 911.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`list'}, rule at line: 740
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 803.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`clear'}, rule at line: 736
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 799.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sup'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 750
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 786.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 786.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`quit'}, rule at line: 732
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 811.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1D2----------------->>>

<<<----------case: /invoke/option-i----------------->>>
	<<case "option-i" make="invoke-make-template">>
		<<upgen_options>>-il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -i so that pattern will be matched case-insensitively
		-i -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-i----------------->>>

<<<----------case: /invoke/option-l----------------->>>
	<<case "option-l" make="invoke-make-template">>
<<<<-------<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using option -l to disable location computation
		-l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-l----------------->>>


<<<----------case: /invoke/option-m----------------->>>
	<<case "option-m" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using option -m to disable generating pattern-matching program
		-m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-m----------------->>>

<<<----------case: /invoke/option-p----------------->>>
	<<case "option-p" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using option -p to disable generating pattern-matching program
		-p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
<<prefix>>yy<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-p----------------->>>

<<<----------case: /invoke/option-decl-file----------------->>>
	<<case "option-decl-file" make="invoke-make-template">>
		<<upgen_options>>-Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		-H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-decl-file----------------->>>


<<<----------case: /invoke/option-sspec----------------->>>
	<<case "option-sspec" make="invoke-make-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -s to specify language SPEC to generate code
		-s pas -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-sspec----------------->>>


<<<----------case: /invoke/option-S----------------->>>
	<<case "option-S" make="invoke-make-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -S to enable default action in pattern-matching
		-S -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-S----------------->>>


<<<----------case: /invoke/option-v----------------->>>
	<<case "option-v" make="invoke-make-template">>
		<<upgen_options>>-lv<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -v to report details on automations
		-v -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-v----------------->>>


<<<----------case: /invoke/option-cmp-d1m----------------->>>
	<<case "option-cmp-d1m" make="invoke-make-template">>
		<<upgen_options>>-d -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>

		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1m----------------->>>


<<<----------case: /invoke/option-cmp-d1p----------------->>>
	<<case "option-cmp-d1p" make="invoke-make-template">>
		<<upgen_options>>-d -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
.................... accept {`EOF'}, rule at line: 22
identifier: EOF
.................... accept {`['}, rule at line: 26
undefined symbol `['
.................... accept {`0'}, rule at line: 18
number: 0
.................... accept {`-'}, rule at line: 24
operator: -
.................... accept {`9'}, rule at line: 18
number: 9
.................... accept {`]'}, rule at line: 26
undefined symbol `]'
.................... accept {`+'}, rule at line: 24
operator: +
.................... accept {`quit'}, rule at line: 19
keyword: quit
.................... accept {`-'}, rule at line: 24
operator: -
.................... accept {`clear'}, rule at line: 20
keyword: clear
.................... accept {`{'}, rule at line: 26
undefined symbol `{'
.................... accept {`var'}, rule at line: 22
identifier: var
.................... accept {`}'}, rule at line: 26
undefined symbol `}'
.................... accept {`list'}, rule at line: 21
keyword: list
.................... accept {`+'}, rule at line: 24
operator: +
.................... accept {`-'}, rule at line: 24
operator: -
.................... accept {`*'}, rule at line: 24
operator: *
.................... accept {`/'}, rule at line: 24
operator: /
.................... accept {`%'}, rule at line: 24
operator: %
.................... accept {`^'}, rule at line: 24
operator: ^
.................... accept {`='}, rule at line: 24
operator: =
.................... accept {`('}, rule at line: 24
operator: (
.................... accept {`)'}, rule at line: 24
operator: )
.................... accept {`?'}, rule at line: 24
operator: ?
.................... accept unprintable-char{10}, rule at line: 25
new line encountered.
.................... accept {`\'}, rule at line: 26
undefined symbol `\'
.................... accept {`n'}, rule at line: 22
identifier: n
.................... accept unprintable-char{10}, rule at line: 25
new line encountered.
.................... accept {`.'}, rule at line: 26
undefined symbol `.'
.................... accept unprintable-char{10}, rule at line: 25
new line encountered.
.................... accept {EOF}, rule at line: 28
Good-bye!
.................... EOS reached
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>

	<</case>>
<<<----------case: /invoke/option-cmp-d1p----------------->>>


<<<----------case: /invoke/option-cmp-D2p----------------->>>
	<<case "option-cmp-D2p" make="invoke-make-template">>
		<<upgen_options>>-D -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-D -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-D2p----------------->>>


<<<----------case: /invoke/option-cmp-d1D2H----------------->>>
	<<case "option-cmp-d1D2H" make="invoke-make-template">>
		<<upgen_options>>-d -D -Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 758.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 861.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 749
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 861.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 894.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 749
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 861.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 899.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`%'}, rule at line: 749
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 910.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 754
.................... accept {`1011'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 846.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 768.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 754
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {` '}, rule at line: 754
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 754
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 754
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 754
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {` '}, rule at line: 754
.................... accept {`*'}, rule at line: 749
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 754
.................... accept {`9'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept {`/'}, rule at line: 749
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 754
.................... accept {`216'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 754
.................... accept {`24'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 754
.................... accept {`('}, rule at line: 749
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 910.
.................... accept {` '}, rule at line: 754
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 754
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`)'}, rule at line: 749
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 861.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 903.
.................... accept {` '}, rule at line: 754
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 754
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 910.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`list'}, rule at line: 739
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 802.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`clear'}, rule at line: 735
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 798.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 749
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 785.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 785.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`quit'}, rule at line: 731
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 810.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2H----------------->>>

<<<----------case: /invoke/option-cmp-d1D2l----------------->>>
	<<case "option-cmp-d1D2l" make="invoke-make-template">>
		<<upgen_options>>-d -D<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 757.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`-'}, rule at line: 748
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 856.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 748
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`-'}, rule at line: 748
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 856.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 889.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 822.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 748
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`-'}, rule at line: 748
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 856.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 894.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 822.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 856.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 822.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`%'}, rule at line: 748
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 905.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 753
.................... accept {`1011'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 902.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 842.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 767.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 753
.................... accept {`ans'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 905.
.................... accept {` '}, rule at line: 753
.................... accept {`/'}, rule at line: 748
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 753
.................... accept {`31'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept {`*'}, rule at line: 748
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 830.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 753
.................... accept {`31'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 753
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 905.
.................... accept {` '}, rule at line: 753
.................... accept {`*'}, rule at line: 748
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 753
.................... accept {`9'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept {`/'}, rule at line: 748
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 826.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 753
.................... accept {`216'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept {`*'}, rule at line: 748
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 830.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 753
.................... accept {`24'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 902.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sup'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 753
.................... accept {`('}, rule at line: 748
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 905.
.................... accept {` '}, rule at line: 753
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 753
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`)'}, rule at line: 748
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 856.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 898.
.................... accept {` '}, rule at line: 753
.................... accept {`/'}, rule at line: 748
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 753
.................... accept {`ans'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 905.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`list'}, rule at line: 738
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 800.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`clear'}, rule at line: 734
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 796.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sup'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 748
Next symbol is ?
Error: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 784.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 784.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`quit'}, rule at line: 730
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 808.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2l----------------->>>

<<<----------case: /invoke/option-cmp-d1D2S----------------->>>
	<<case "option-cmp-d1D2S" make="invoke-make-template">>
		<<upgen_options>>-d -D -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -S -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 758.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 861.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 749
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 861.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 894.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 749
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 861.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 899.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`%'}, rule at line: 749
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 910.
Next symbol is %
Shift %, go to state 31
.................... accept {`1011'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 846.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 768.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {`*'}, rule at line: 749
Next symbol is *
Shift *, go to state 29
.................... accept {`9'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept {`/'}, rule at line: 749
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is /
Shift /, go to state 30
.................... accept {`216'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {`24'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`('}, rule at line: 749
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 910.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`)'}, rule at line: 749
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 861.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 903.
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 910.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`list'}, rule at line: 739
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 802.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`clear'}, rule at line: 735
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 798.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 749
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 785.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 785.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`quit'}, rule at line: 731
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 810.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2S----------------->>>

<<<----------case: /invoke/option-cmp-lS----------------->>>
	<<case "option-cmp-lS" make="invoke-make-template">>
		<<upgen_options>>-S<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -l -o FILE
*/
			<</desc>>

		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lS----------------->>>


<<<----------case: /invoke/option-cmp-St----------------->>>
	<<case "option-cmp-St" make="invoke-make-stdout-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -t
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
ans = 		0
ans = 		1024
ans = 		1024
Error: at 25:1; description: yy is unset variable.
yy = 		1024
yy = 		1024
Error: at 28:1; description: goodbye is unset variable.
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-St----------------->>>


<<<----------case: /invoke/option-cmp-aS----------------->>>
	<<case "option-cmp-aS" make="invoke-make-template">>
		<<upgen_options>>-a -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-a -S -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-aS----------------->>>


<<<----------case: /invoke/option-cmp-pS----------------->>>
	<<case "option-cmp-pS" make="invoke-make-template">>
		<<upgen_options>>-S -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -p -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-pS----------------->>>


<<<----------case: /invoke/option-cmp-mS----------------->>>
	<<case "option-cmp-mS" make="invoke-make-template">>
		<<upgen_options>>-S -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mS----------------->>>


<<<----------case: /invoke/option-cmp-HS----------------->>>
	<<case "option-cmp-HS" make="invoke-make-template">>
		<<upgen_options>>-S -Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -H -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HS----------------->>>

<<<----------case: /invoke/option-cmp-iS----------------->>>
	<<case "option-cmp-iS" make="invoke-make-template">>
		<<upgen_options>>-S -il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -i -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iS----------------->>>

<<<----------case: /invoke/option-cmp-HsC++----------------->>>
	<<case "option-cmp-HsC++" make="invoke-make-template">>
		<<upgen_options>>-lH<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		and option -s to specify the programming language to generate code
		-H -s pas -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HsC++----------------->>>


<<<----------case: /invoke/option-cmp-Hm----------------->>>
	<<case "option-cmp-Hm" make="invoke-make-template">>
		<<upgen_options>>-Hlm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hm----------------->>>

<<<----------case: /invoke/option-cmp-lm----------------->>>
	<<case "option-cmp-lm" make="invoke-make-template">>
		<<upgen_options>>-m<</upgen_options>>
		<<script "invoke-myscanner-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lm----------------->>>

<<<----------case: /invoke/option-cmp-mp----------------->>>
	<<case "option-cmp-mp" make="make-no-exec">>
		<<upgen_options>>-p -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-p -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Warning: No code generated for script `script.upg',
since both pattern-matching and parsing program generation disabled.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mp----------------->>>

<<<----------case: /invoke/option-cmp-msC++----------------->>>
	<<case "option-cmp-msC++" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s pas -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++----------------->>>

<<<----------case: /invoke/option-cmp-msC++t----------------->>>
	<<case "option-cmp-msC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s pas -m -t
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++t----------------->>>

<<<----------case: /invoke/option-cmp-Hp----------------->>>
	<<case "option-cmp-Hp" make="invoke-make-template">>
		<<upgen_options>>-Hlp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hp----------------->>>

<<<----------case: /invoke/option-cmp-Hlp----------------->>>
	<<case "option-cmp-Hlp" make="invoke-make-template">>
		<<upgen_options>>-Hp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -l -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hlp----------------->>>

<<<----------case: /invoke/option-cmp-Hip----------------->>>
	<<case "option-cmp-Hip" make="invoke-make-template">>
		<<upgen_options>>-Hilp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quIT
operator: -
keyword: CLEar
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hip----------------->>>

<<<----------case: /invoke/option-cmp-ipt----------------->>>
	<<case "option-cmp-ipt" make="invoke-make-stdout-template">>
		<<upgen_options>>-ilp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -t
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quIT
operator: -
keyword: CLEar
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-ipt----------------->>>

<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>
	<<case "option-cmp-HPzzCMD" make="invoke-make-template">>
		<<upgen_options>>-HlP zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>

<<<----------case: /invoke/option-cmp-HPzz----------------->>>
	<<case "option-cmp-HPzz" make="invoke-make-template">>
		<<upgen_options>>-Hl -P xx<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzz----------------->>>

<<<----------case: /invoke/option-cmp-iPzz----------------->>>
	<<case "option-cmp-iPzz" make="invoke-make-template">>
		<<upgen_options>>-il -P xx<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-i -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sUb = Sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
lISt
CLEAR
CLear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
Error: at 4:7; description: Sub is unset variable.
sup = 		378298
ans = 		-630
sub = 		-620
sup = 		378298
Error: at 9:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iPzz----------------->>>

<<<----------case: /invoke/option-cmp-lPzz----------------->>>
	<<case "option-cmp-lPzz" make="invoke-make-template">>
		<<upgen_options>>-P xx<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lPzz----------------->>>

<<<----------case: /invoke/option-cmp-mPzz----------------->>>
	<<case "option-cmp-mPzz" make="invoke-make-template">>
		<<upgen_options>>-lm -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-m -P zz FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzz----------------->>>

<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>
	<<case "option-cmp-PzzsC++" make="invoke-make-template">>
		<<upgen_options>>-l -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-s pas -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>

<<<----------case: /invoke/option-cmp-PzzS----------------->>>
	<<case "option-cmp-PzzS" make="invoke-make-template">>
		<<upgen_options>>-lS -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-S-P zz -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzS----------------->>>

<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>
	<<case "option-cmp-mPzzsC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-lm -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s pas -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>

<<<----------case: /invoke/option-cmp-mPzztv----------------->>>
	<<case "option-cmp-mPzztv" make="invoke-make-stdout-template">>
		<<upgen_options>>-lmv -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-v -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzztv----------------->>>

<<<----------case: /invoke/option-cmp-lex+parse----------------->>>
	<<case "option-cmp-lex+parse" make="invoke-make-lex-parse-template">>
		<<parser_options>>-H -m<</parser_options>>
		<<scanner_options>>-p -P zz<</scanner_options>>
		<<script "invoke-parser-only-template">>
			<<desc>>/*
features to test: put scanner generated by upgen and parser generated by upgen together
this is parser part.
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-myscanner-template">>
		<</ufile>>
		<<textfile "scanner.upg">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/
%{
uses SysUtils, StrUtils,
	script { parsing classes and routines };

%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*


%%

[0-9]+				yylval.nVal := strtoint(yytext);
					result := NUM;
					exit;
"quit"				result := QUIT;
					exit;
"clear"				result := CLEAR;
					exit;
"list"				result := LIST;
					exit;
{var}				s_strVarName := string(yytext);
					result := VARI;
					exit;
[\+\-\*\/\%\^\=\(\)\?\n]	result := ord(yytext[0]);
					 exit;

.				writeln('undefined symbol `', yytext[0], '''');

%%

%%

		<</textfile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
undefined symbol ` '
undefined symbol ` '
ans = 		-630
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
sub = 		-620
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
sub = 		-600
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lex+parse----------------->>>

<</suite>>
<<<----------sub-suite: /invoke ---------------->>>

<<<----------sub-suite: /empty ---------------->>>
<<suite "empty" make="subdir-makefile-template">>

<<<----------case: /invoke/empty/empty-file----------------->>>
	<<case "empty-file" make="make-no-exec">>
		<<textfile "script.upg">>
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 1:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-file----------------->>>

<<<----------sub-suite: /empty ---------------->>>

<<<----------case: /invoke/empty/only-comments----------------->>>
	<<case "only-comments" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: content of script is empty except comments
*/
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 4:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-comments----------------->>>

<<<----------case: /invoke/empty/empty-sect-2----------------->>>
	<<case "empty-sect-2" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-empty-sect-2">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-empty-sect-2">>
		<</ufile>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
Error: syntax error at 0:0.
		900001
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-2----------------->>>


<<<----------case: /invoke/empty/only-2-sections----------------->>>
	<<case "only-2-sections" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: script contains only 2 sections
*/
%%
.		/* do nothing */
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 6:0.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-2-sections----------------->>>

<<<----------case: /invoke/empty/only-3-sections----------------->>>
	<<case "only-3-sections" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-only-3-sections">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-only-3-sections">>
		<</ufile>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
Error: syntax error at 0:0.
		900001
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-3-sections----------------->>>

<<<----------case: /invoke/empty/empty-sect-3----------------->>>
	<<case "empty-sect-3" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "script-empty-sect-3">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-empty-sect-3">>
		<</ufile>>
		<<textfile "test.input">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner.');
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	write(yytext);
%%

		<</textfile>>
		<<textfile "result.out">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner.');
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	write(yytext);
%%

		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-3----------------->>>

<</suite>>
<<<----------sub-suite: /empty ---------------->>>

<<<----------sub-suite: /basic ---------------->>>
<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /basic/declare ---------------->>>
	<<suite "declare" make="subdir-makefile-template">>

<<<----------case: /basic/declare/def-header----------------->>>
	<<case "def-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple definition headers
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/def-header----------------->>>


<<<----------case: /basic/declare/decl-header----------------->>>
	<<case "decl-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple declaration headers
*/
			<</desc>>
			<<declare_section>>

%header%{
{ declaration header 1 }
<<filebuf_decl/>>
%}

%header%{
{ declaration header 2}
procedure showAccept;
%}

%{
{ definition header }
procedure showAccept;
begin
	writeln('This text is accepted by parenthese extracter.');
end;
%}

			<</declare_section>>
			<<accept_action>>
showAccept;
			<</accept_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
This text is accepted by parenthese extracter.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/decl-header----------------->>>


<<<----------case: /basic/declare/svt-decl-01----------------->>>
	<<case "svt-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: using %union to declare semantic value type
*/
			<</desc>>

			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}

%union%{
	case boolean of
	true: (nVal: integer);
	false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
	sentenceNo: integer;
%}
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-01----------------->>>


<<<----------case: /basic/declare/svt-decl-02----------------->>>
	<<case "svt-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define svt-to-be union in definition header
			and declare it as semantic value type by %union 
*/
			<</desc>>

			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;

	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location%{
	firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
	sentenceNo: integer;
%}
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-02----------------->>>

<<<----------case: /basic/declare/svt-decl-03----------------->>>
	<<case "svt-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 1
*/
			<</desc>>

			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	

	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;
			<</location_code>>

			<<union_decl>>
%union mysvt_t
%union%{
	nVal: integer;
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-03----------------->>>

<<<----------case: /basic/declare/svt-decl-04----------------->>>
	<<case "svt-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 2
*/
			<</desc>>
			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;

type
	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>

			<<union_decl>>
%union%{
	case boolean of
	true: (nVal: integer);
	false: (nPair: npair_t);
%}

%union%{
	nVal: integer;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
%}

%union mysvt_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-04----------------->>>

<<<----------case: /basic/declare/loc-decl-01----------------->>>
	<<case "loc-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define location-to-be struct in definition header
			and declare it as location type by %location 
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}
%union%{
	case boolean of
	true: (nVal: integer);
	false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-01----------------->>>

<<<----------case: /basic/declare/loc-decl-02----------------->>>
	<<case "loc-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 1
*/
			<</desc>>

			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;

type
	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location myloc_t
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
%}
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-02----------------->>>

<<<----------case: /basic/declare/loc-decl-03----------------->>>
	<<case "loc-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 2
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;

	illegal_loc_t = record
		firstLine: integer;
		lastLine: integer;
	end;
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}

%union%{
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
%}

%location illegal_loc_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-03----------------->>>

<<<----------case: /basic/declare/loc-decl-04----------------->>>
	<<case "loc-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 3
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}

%union%{
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
%}
%location%{
	firstLine: integer;
	lastLine: integer;
%}
%location int

			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-04----------------->>>

<<<----------case: /basic/declare/parse-param-01----------------->>>
	<<case "parse-param-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param 
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-01----------------->>>

<<<----------case: /basic/declare/parse-param-02----------------->>>
	<<case "parse-param-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param,
			but declare more than once
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}

/* if it were to use this declaration, Pascal compiler would have complained */
%formal-param%{illegal_declaration: integer%}
%actual-param%{illegal_variable%}
			<</parse_param>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
		
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-02----------------->>>


<<<----------case: /basic/declare/destructor-01----------------->>>
	<<case "destructor-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 1: destructor specified by symbol
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard head: ', $$);
	stack_pop();
%} TagHead

%destructor%{
	writeln('discard head: ', $$);
%} '('

%destructor%{
	writeln('discard tail: ', $$);
%} ')'
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard head: tables
discard head: table
discard head: table
discard head: body
discard head: html
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-01----------------->>>


<<<----------case: /basic/declare/destructor-02----------------->>>
	<<case "destructor-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 2: destructor for untagged symbols
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard undefined symbol.');
%} <>
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-02----------------->>>

<<<----------case: /basic/declare/destructor-03----------------->>>
	<<case "destructor-03" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 3: destructor specified by semantic value type
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard tag: ', $$, '.');
%} <pchval>

%destructor%{
	writeln('discard at level: ', $$, '.');
%} <level>
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>

<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard tag: tables.
discard at level: 4.
discard tag: table.
discard at level: 3.
discard tag: table.
discard at level: 2.
discard tag: body.
discard at level: 1.
discard tag: html.
discard at level: 0.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-03----------------->>>


<<<----------case: /basic/declare/destructor-04----------------->>>
	<<case "destructor-04" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: different kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard head: ', $$, '.');
	stack_pop();
%} TagHead

%destructor%{
	writeln('discard head: ', $$, '.');
%} '('

%destructor%{
	writeln('discard tag: ', $$, '.');
%} <pchval>

%destructor%{
	writeln('discard at level: ', $$, '.');
%} <level>
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>

<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-04----------------->>>


<<<----------case: /basic/declare/destructor-05----------------->>>
	<<case "destructor-05" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: all kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard head: ', $$, '.');
	stack_pop();
%} TagHead

%destructor%{
	writeln('discard head: ', $$, '.');
%} '('

%destructor%{
	writeln('discard tag: ', $$, '.');
%} <pchval>

%destructor%{
	writeln('discard at level: ', $$, '.');
%} <level>

%destructor%{
	writeln('discard undefined symbol.');
%} <>
			<</destructor>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-05----------------->>>

<<<----------case: /basic/declare/parsevar-decl----------------->>>
	<<case "parsevar-decl" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare local variables in yyparse 
			by %parsevar-decl
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
var
	tpl: triple_t;
%}
%parsevar-init%{
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
%}
			<</parsevar_decl>>

			<<exprs_action>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-decl----------------->>>

<<<----------case: /basic/declare/parsevar-init----------------->>>
	<<case "parsevar-init" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: initialize local variables in yyparse 
			by %parsevar-init
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
	tpl: triple_t;
%}
			<</parsevar_decl>>

			<<parsevar_init>>
%parsevar-init%{
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
%}
			<</parsevar_init>>

			<<exprs_action>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-init----------------->>>

<<<----------case: /basic/declare/start-symbol----------------->>>
	<<case "start-symbol" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare start symbol by %start
*/
			<</desc>>
			<<start_symbol>>
%start SText
			<</start_symbol>>
			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
			
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
Input text is accepted by tag-check grammar.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/start-symbol----------------->>>

<<<----------case: /basic/declare/dprec-rrc----------------->>>
	<<case "dprec-rrc" make="basic-make-template">>
		<<script "script-dprec-rrc">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-dprec-rrc">>
		<</ufile>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[func a b [sub c d]]
[+ [* a [/ b [^ c [* [% d e] f]]]] [sin [cos [tan [exp x]]]]]
[define myfun [a b]
	[cond a] [[display a]]
	[else] [[display b]]
]
Done!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/dprec-rrc----------------->>>

<<<----------case: /basic/declare/lex-init-action----------------->>>
	<<case "lex-init-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare lex initialization action by %lex-init
*/
			<</desc>>
			<<init_code>>
var
// integer counter
	ic: integer = 0;
// real(excluding integer) counter
	rc: integer = 0;
// operator counter
	oc: integer = 0;
// number of matched pattern
	mc: integer = 0;
// discarded symbols;
	dc: integer = 0;
			<</init_code>>
			<<lex_init>>
%lex-init%{ writeln('start scanning...');%}
			<</lex_init>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
start scanning...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
start scanning...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lex-init-action----------------->>>


<<<----------case: /basic/declare/pre-match-action----------------->>>
	<<case "pre-match-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare pre-match action (just ahead of any lexical action)
			 by %pre-match
*/
			<</desc>>
			<<init_code>>
var
// integer counter
	ic: integer = 0;
// real(excluding integer) counter
	rc: integer = 0;
// operator counter
	oc: integer = 0;
// number of matched pattern
	mc: integer = 0;
// discarded symbols;
	dc: integer = 0;
			<</init_code>>
			<<pre_match>>
%pre-match%{ if yyleng > 0 then mc := mc + 1; %}
			<</pre_match>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 54
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 83
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/pre-match-action----------------->>>


<<<----------case: /basic/declare/lexvar-decl----------------->>>
	<<case "lexvar-decl" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare local variables for yylex by %lexvar-decl or %lvar-decl
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
var
// integer counter
	ic: integer;
// real(excluding integer) counter
	rc: integer;
// operator counter
	oc: integer;
// number of matched pattern
	mc: integer;
// discarded symbols;
	dc: integer;
%}
%lvar-init%{
		ic := 0;
		rc := 0;
		oc := 0;
		mc := 0;
		dc := 0;
%}
			<</lvar_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-decl----------------->>>


<<<----------case: /basic/declare/lexvar-init----------------->>>
	<<case "lexvar-init" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: initialize local variables for yylex by %lexvar-init or %lvar-init
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
var
// integer counter
	ic: integer;
// real(excluding integer) counter
	rc: integer;
// operator counter
	oc: integer;
// number of matched pattern
	mc: integer;
// discarded symbols;
	dc: integer;
%}
			<</lvar_decl>>

			<<lvar_init>>
%lvar-init%{ ic := 0; rc := 0; oc := 0; mc := 0; dc := 0; %}
			<</lvar_init>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-init----------------->>>

<<<----------case: /basic/declare/yywrap-action----------------->>>
	<<case "yywrap-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare yywrap action by %yywrap
*/
			<</desc>>
			<<init_code>>
var
// integer counter
	ic: integer = 0;
// real(excluding integer) counter
	rc: integer = 0;
// operator counter
	oc: integer = 0;
// number of matched pattern
	mc: integer = 0;
// discarded symbols;
	dc: integer = 0;
			<</init_code>>
			<<yywrap>>
%yywrap%{
	writeln('file switching ...');
	result := false;
%}
			<</yywrap>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
file switching ...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
file switching ...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/yywrap-action----------------->>>

<<<----------case: /basic/declare/lexical-actions----------------->>>
	<<case "lexical-actions" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: using %lex-init %pre-match
			%lexvar-decl %lexvar-init %yywrap
*/
			<</desc>>
<<lvar_decl>>
%lvar-decl%{
var
// integer counter
	ic: integer;
// real(excluding integer) counter
	rc: integer;
// operator counter
	oc: integer;
// number of matched pattern
	mc: integer;
// discarded symbols;
	dc: integer;
%}
<</lvar_decl>>

<<lvar_init>>
%lvar-init%{ ic := 0; rc := 0; oc := 0; mc := 0; dc := 0; %}
<</lvar_init>>

<<lex_init>>
%lex-init%{ writeln('start scanning...');%}
<</lex_init>>

<<pre_match>>
%pre-match%{ if yyleng > 0 then mc := mc + 1; %}
<</pre_match>>

<<yywrap>>
%yywrap%{
	if yy_has_buffer then begin
		writeln('file switching ...');
		result := false;
	end;
%}
<</yywrap>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
start scanning...
file switching ...
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 30
start scanning...
file switching ...
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 29
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexical-actions----------------->>>


<<<----------case: /basic/declare/token-decl-01----------------->>>
	<<case "token-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 1
*/
			<</desc>>
			<<token_decl>>
%token '+' '-'
%token '*' '/'
%token '^'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-01----------------->>>

<<<----------case: /basic/declare/token-decl-02----------------->>>
	<<case "token-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 2
*/
			<</desc>>
			<<token_decl>>
%token '\+' '\-'
%token '\*' '\/'
%token '\^'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-02----------------->>>

<<<----------case: /basic/declare/token-decl-03----------------->>>
	<<case "token-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2b' '\x2d'
/* '*' '/' */
%token '\x2a' '\x2f'
/* '^' */
%token '\x5e'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-03----------------->>>

<<<----------case: /basic/declare/token-decl-04----------------->>>
	<<case "token-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\X2B' '\X2D'
/* '*' '/' */
%token '\X2A' '\X2F'
/* '^' */
%token '\X5E'
			<</token_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-04----------------->>>


<<<----------case: /basic/declare/token-decl-05----------------->>>
	<<case "token-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2B' '\X2d'
/* '*' '/' */
%token '\X2a' '\x2F'
/* '^' */
%token '\X5E'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-05----------------->>>


<<<----------case: /basic/declare/token-decl-06----------------->>>
	<<case "token-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\053' '\055'
/* '*' '/' */
%token '\052' '\057'
/* '^' */
%token '\136'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-06----------------->>>


<<<----------case: /basic/declare/type-decl----------------->>>
	<<case "type-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare types(also called non-terminals) in grammar
			by %type
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<type_decl>>
%type<nVal> Lines Task
			<</type_decl>>

			<<other_decl>>
%destructor%{
	writeln($$, ' lines included in this task.');
%} Task
			<</other_decl>>

			<<type_action_0>>
$$ := $1;
			<</type_action_0>>
			<<type_action_1>>
$$ := $1 + 1;
			<</type_action_1>>
			<<type_action_2>>
$$ := 0;
			<</type_action_2>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
14 lines included in this task.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/type-decl----------------->>>


<<<----------case: /basic/declare/left-decl-01----------------->>>
	<<case "left-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 1
*/
			<</desc>>
			<<token_decl>>
%left '+' '-'
%left '*' '/'
%left '^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-01----------------->>>

<<<----------case: /basic/declare/left-decl-02----------------->>>
	<<case "left-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 2
*/
			<</desc>>
			<<token_decl>>
%left '\+' '\-'
%left '\*' '\/'
%left '\^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-02----------------->>>

<<<----------case: /basic/declare/left-decl-03----------------->>>
	<<case "left-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%left '\x5e'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-03----------------->>>

<<<----------case: /basic/declare/left-decl-04----------------->>>
	<<case "left-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-04----------------->>>


<<<----------case: /basic/declare/left-decl-05----------------->>>
	<<case "left-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-05----------------->>>


<<<----------case: /basic/declare/left-decl-06----------------->>>
	<<case "left-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%left '\136'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-06----------------->>>


<<<----------case: /basic/declare/right-decl-01----------------->>>
	<<case "right-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 1
*/
			<</desc>>
			<<token_decl>>
%right '+' '-'
%right '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-01----------------->>>

<<<----------case: /basic/declare/right-decl-02----------------->>>
	<<case "right-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 2
*/
			<</desc>>
			<<token_decl>>
%right '\+' '\-'
%right '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-02----------------->>>

<<<----------case: /basic/declare/right-decl-03----------------->>>
	<<case "right-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2b' '\x2d'
/* '*' '/' */
%right '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-03----------------->>>

<<<----------case: /basic/declare/right-decl-04----------------->>>
	<<case "right-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\X2B' '\X2D'
/* '*' '/' */
%right '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-04----------------->>>


<<<----------case: /basic/declare/right-decl-05----------------->>>
	<<case "right-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2B' '\X2d'
/* '*' '/' */
%right '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-05----------------->>>


<<<----------case: /basic/declare/right-decl-06----------------->>>
	<<case "right-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\053' '\055'
/* '*' '/' */
%right '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-06----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>
	<<case "nonassoc-decl-01" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 1
*/
			<</desc>>
			<<token_decl>>
%nonassoc '+' '-'
%left '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>
	<<case "nonassoc-decl-02" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 2
*/
			<</desc>>
			<<token_decl>>
%nonassoc '\+' '\-'
%left '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>
	<<case "nonassoc-decl-03" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>
	<<case "nonassoc-decl-04" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>
	<<case "nonassoc-decl-05" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>
	<<case "nonassoc-decl-06" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>


<<<----------case: /basic/declare/parse-init-decl----------------->>>
	<<case "parse-init-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's initialization action by %parse-init,
			which is performed immediate before yyparse is ready to parsing 
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_init>>
%parse-init%{
	writeln('Let''s get down to work.');
	errors := 0;
%}
			<</parse_init>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
Let's get down to work.
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-init-decl----------------->>>


<<<----------case: /basic/declare/parse-exit-decl----------------->>>
	<<case "parse-exit-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's exit action by %parse-exit,
			which is performed immediate before return from yyparse
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_exit>>
%parse-exit%{
	if errors > 0 then
		writeln(errors, ' errors occurred.');
	writeln('Well done! Thank you for your excellent work, Mr. Parser.');
%}
			<</parse_exit>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
2 errors occurred.
Well done! Thank you for your excellent work, Mr. Parser.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-exit-decl----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/declare ---------------->>>


<<<----------sub-suite: /basic/interface -------------->>>
	<<suite  "interface" make="subdir-makefile-template">>


<<<----------case: /basic/interface/buffer-stack----------------->>>
	<<case "buffer-stack" make="basic-make-template">>
		<<script "interface-bstack-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-bstack-template">>
		<</ufile>>

		<<textfile "test.input">>
***************************************
test lcase number test1
lcase> open "cur?*************************
in lcase
abcdefg
close hijklm"
cur?
number> open 'cur?************************
in number
1234567
pop
89'
cur?
test1> open `test1.input`
pop
closing can not be executed, because of popping action
close
text ignored
		<</textfile>>

		<<textfile "test1.input">>
cur?**************************
in test1 test2 ucase
test2> open `test2.input`
cur?
ucase> open "cur?************************
ABCDEF
pop
XYZ"

******************test yy_push_buffer***********************
test2> push `test2.input`
******************test yy_push_buffer***********************
test3> push `test3.input`

pop
abortion can not executed, because of popping action
 
abort
		<</textfile>>

		<<textfile "test2.input">>
cur?**************************
in test2 chinese test3
chinese> open "

close
Over"
test3> open `test3.input`
close
test ignored
		<</textfile>>

		<<textfile "test3.input">>
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
		<</textfile>>

		<<textfile "result.out">>
***************************************
test lcase number test1
current buffer: lcase
*************************
in lcase
abcdefg
closing buffer lcase ...
switching to buffer test ...

current buffer: test

current buffer: number
************************
in number
1234567
popping buffer number ...
switching to buffer test ...

current buffer: test

current buffer: test1
**************************
in test1 test2 ucase
current buffer: test2
**************************
in test2 chinese test3


closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

current buffer: test1

current buffer: ucase
************************
ABCDEF
popping buffer ucase ...
switching to buffer test1 ...


******************test yy_push_buffer***********************
current buffer: test2
**************************
in test2 chinese test3


closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

******************test yy_push_buffer***********************
current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.


popping buffer test1 ...
switching to buffer test ...

popping buffer test ...
All buffers closed.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/buffer-stack----------------->>>

<<<----------case: /basic/interface/ECHO----------------->>>
	<<case "ECHO" make="basic-make-template">>
		<<script "interface-echo-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-echo-template">>
		<</ufile>>

		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/ECHO----------------->>>


<<<----------case: /basic/interface/get-bol----------------->>>
	<<case "get-bol" make="basic-make-template">>
		<<script "interface-getbol-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-getbol-template">>
		<</ufile>>
		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/get-bol----------------->>>


<<<----------case: /basic/interface/line-editor----------------->>>
	<<case "line-editor" make="basic-make-template">>
		<<script "interface-line-editor-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-line-editor-template">>
		<</ufile>>

		<<textfile "test.input">>
Just e!01image!01ine, what is goning to be link!02ke if you are travelling in the outer space.!!no useful
Simply beatui!03utiful, yes that must &be very @-05good.
Hey&, wait a minute@01 it's simply &too good @02 be true. Please &stop, @04 dreaming&!&!&!
		<</textfile>>

		<<textfile "result.out">>
Just imagine, what is goning to be like if you are travelling in the outer space.
Simply beautiful, yes that must be very very good.
Hey, wait a minute, it's simply too good to be true. Please stop, stop dreaming!!!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/line-editor----------------->>>


<<<----------case: /basic/interface/loc2----------------->>>
	<<case "loc2" make="basic-make-template">>
		<<script "interface-loc2-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-loc2-template">>
		<</ufile>>

		<<textfile "test.input">>
#location_head
%$103
%%$$205
%%%$$$307
%%%%$$$$409
%%%%%$$$$$511
%%%%%%$$$$$$613
%%%%%%%$$$$$$$715
%%%%%%%%$$$$$$$$817

%a02%a06$a10
%%%%$$$$b09
%%%%$$$c08
%%%%$$d07
%%%%$$$$$%%%$%%%$$%%%$%%$$$$$$$e32
#location_tail


#location_head
%	109 %%		125 %%%			149 %%%%				189 %%%%%					1d7 %%%%%%						1j3 %%%%%%%							1p7 %%%%%%%%								1w9  %1x5%1x9	1y5 %%%%				1C5 %%%%			1F7 %%%%		1I1 %%%%	1J7
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#location_tail



tab=8

#tab_replace 0
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#tab_replace

tab?

#line_replace 1
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#line_replace




#orignal 2
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#orignal



#orignal 3
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#orignal

		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
after reseting, line: 1	col: 1
begin scanning tab_replace section by referrence 0
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning tab_replace section is over
begin comparing location(size 15) 0 and its referrence(size 15)
tabsize = 8
after reseting, line: 1	col: 1
begin scanning line_replace section by referrence 1
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning line_replace section is over
begin comparing location(size 15) 1 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 2
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 2 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 3
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 3 and its referrence(size 15)
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc2----------------->>>

<<<----------case: /basic/interface/loc1----------------->>>
	<<case "loc1" make="basic-make-template">>
		<<script "interface-location-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-location-template">>
		<</ufile>>
		
		<<textfile "test.input">>
tab=8
<test1.input>	217
301 305 309	317		333 337  342   348    355     363	373
tab=6
<test2.input>	519
601 605 609	613		625 629  634   640    647     655	661
		<</textfile>>

		<<textfile "test1.input">>
tab?
 202 206  211	217			229	233
tab=1	307
 402 406  411	415			421	425	
		<</textfile>>

		<<textfile "test2.input">>
tab=3
   204	210	216			228 232
tab?	307
		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
file `test1.input` is open.
tabsize = 4
tabsize is 1 now
file closed.
tabsize is 6 now
file `test2.input` is open.
tabsize is 3 now
tabsize = 3
file closed.
file closed.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc1----------------->>>



<<<----------case: /basic/interface/yyerror----------------->>>
	<<case "yyerror" make="basic-make-template">>
		<<script "interface-yyerror-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-yyerror-template">>
		<</ufile>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9

		<</textfile>>

		<<textfile "result.out">>
Redirect to my error-handler ---- Error: syntax error at 1:7.
Redirect to my error-handler ---- Error: syntax error at 2:1.
Redirect to my error-handler ---- Error: syntax error at 3:1.
Redirect to my error-handler ---- Error: syntax error at 4:1.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/yyerror----------------->>>


<<<----------case: /basic/interface/esc-char-inaction----------------->>>
	<<case "esc-char-inaction" make="basic-make-template">>
		<<script "esc-char-inaction-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-esc-char-inaction-template">>
		<</ufile>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9
end
well done!

		<</textfile>>

		<<textfile "result.out">>
in parsevar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$1 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 1
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 2
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 3
$$ is used to count number of numbers, and $$ is 3
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is begin
$$ is used to count number of numbers, and $$ is 3
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is add
$$ is used to count number of numbers, and $$ is 3
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 4
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 5
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is sub
$$ is used to count number of numbers, and $$ is 5
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 6
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 7
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is div
$$ is used to count number of numbers, and $$ is 7
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 8
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 9
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is end
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is well
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is done
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in yywrap: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-exit: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/esc-char-inaction----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/interface -------------->>>


<</suite>>
<<<----------sub-suite: /basic ---------------->>>


<</suites>>
<<<----------top-suite: /-------------------->>>

<<conf make="config-template">>
<<version>>0.50.101<</version>>
<<email>>upgen.tools@yahoo.com<</email>>
<<diff>>diff<</diff>>
<</conf>>

