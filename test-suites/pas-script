<<<< ------------------------------ global setting
<<settings>>


	<<group>>
<<<<<<<------------------ input from file
<<buffer_init>>lexfile(paramstr(1), false)<</buffer_init>>
<<buffer_init2>>lexfile(paramstr(1), false)<</buffer_init2>>
<<buffer_init3>>lexfile(paramstr(1), false)<</buffer_init3>>
<<inputed_file>> test.input <</inputed_file>>
<<before_myinput>>
	new(s_pfile);
	assignfile(s_pfile^, paramstr(1));
	reset(s_pfile^);
<</before_myinput>>
<<stream_type>>pas-file.log<</stream_type>>
>>>>>>>------------------ input from file
	<</group>>


	<<group>>
<<<<<<------------------ input from stdin
<<buffer_init>>lexfile('', true)<</buffer_init>>
<<buffer_init2>>lexfile('', true)<</buffer_init2>>
<<buffer_init3>>lexfile('', false)<</buffer_init3>>
<<inputed_file>> < test.input <</inputed_file>>
<<before_myinput>>s_pfile := @input;<</before_myinput>>
<<stream_type>>pas-stdin.log<</stream_type>>
>>>>>>------------------- input from stdin
	<</group>>

	
	<<group>>
<<<<<<<------------------ input from buffer
<<main_var_decl>>
var
	buffer_content: pchar;
	tt2: integer;
	f: file;
<</main_var_decl>>

<<before_buffer_init>>
	if paramcount < 1 then
	begin
		writeln('Error: file name expected.');
		exit;
	end;
	
	if not fileexists(paramstr(1)) then
	begin
		writeln('Error: failed to access file `', paramstr(1), '''.');
		exit;
	end;
	
	buffer_content := nil;
	tt2 := 0;
	
	assignfile(f, paramstr(1));
	reset(f, 1);
	try
		tt2 := filesize(f);
		getmem(buffer_content, tt2 + 1);
	except
	on e: EOutOfMemory do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to allocate memory for buffer');
			closefile(f);
			exit;
		end;
	end;
	
	try
		blockread(f, buffer_content^, tt2);
	except
	on e: EInOutError do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to read data from file');
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	end;
	
	closefile(f);
	buffer_content[tt2] := #0;
	tt2 := tt2 + 1;
	
<</before_buffer_init>>

<<after_buffer_usage>>
	if buffer_content <> nil then
		freemem(buffer_content);
<</after_buffer_usage>>

<<buffer_init>>lexstr(buffer_content, tt2)<</buffer_init>>
<<buffer_init2>>lexstr(buffer_content, tt2)<</buffer_init2>>
<<buffer_init3>>lexstr(buffer_content, tt2)<</buffer_init3>>
<<inputed_file>> test.input <</inputed_file>>
<<before_myinput>>
	new(s_pfile);
	assignfile(s_pfile^, paramstr(1));
	reset(s_pfile^);
<</before_myinput>>
<<stream_type>>pas-buffer.log<</stream_type>>
>>>>>>>------------------ input from buffer
	<</group>>


	<<group>>
<<<<<<<------------------ input from copied buffer
<<main_var_decl>>
var
	buffer_content: pchar;
	tt2: integer;
	f: file;
<</main_var_decl>>
<<before_buffer_init>>
	if paramcount < 1 then
	begin
		writeln('Error: file name expected.');
		exit;
	end;
	
	if not fileexists(paramstr(1)) then
	begin
		writeln('Error: failed to access file `', paramstr(1), '''.');
		exit;
	end;
	
	buffer_content := nil;
	tt2 := 0;
	
	assignfile(f, paramstr(1));
	reset(f, 1);
	try
		tt2 := filesize(f);
		getmem(buffer_content, tt2 + 1);
	except
	on e: EOutOfMemory do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to allocate memory for buffer');
			closefile(f);
			exit;
		end;
	end;
	
	try
		blockread(f, buffer_content^, tt2);
	except
	on e: EInOutError do
		begin
			writeln('Fatal Error: ', e.message);
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	else
		begin
			writeln('Error: error occurs when attempting to read data from file');
			closefile(f);
			freemem(buffer_content);
			exit;
		end;
	end;
	
	closefile(f);
	buffer_content[tt2] := #0;
	tt2 := tt2 + 1;
	
<</before_buffer_init>>

<<after_buffer_usage>>
	if buffer_content <> nil then
		freemem(buffer_content);
<</after_buffer_usage>>

<<buffer_init>>lexcstr(buffer_content, tt2)<</buffer_init>>
<<buffer_init2>>lexcstr(buffer_content, tt2)<</buffer_init2>>
<<buffer_init3>>lexcstr(buffer_content, tt2)<</buffer_init3>>
<<inputed_file>> test.input <</inputed_file>>
<<before_myinput>>
	new(s_pfile);
	assignfile(s_pfile^, paramstr(1));
	reset(s_pfile^);
<</before_myinput>>
<<stream_type>>pas-cbuffer.log<</stream_type>>
>>>>>>>------------------ input from copied buffer
	<</group>>


<<prefix>>yy<</prefix>>
<<option_prefix>>%option prefix=yy<</option_prefix>>

<<s2i_map_define>>
{
s2i_map_t: string to integer map class, using red-black tree
	insert string & integer pair
	delete pair corresponding to a given string
	find value corresponding to a given string

    
The book INTRODUCTION TO ALGORITHMS by
	Thomas H. Cormen,
	Charles E. Leiserson,
	Ronald L. Rivest
	Clifford Stein
cover the details of algorithms of red-black tree.
}

type
	key_type = string;
	value_type = integer;
	elem_type  = record
		first: key_type;
		second: value_type;
	end;	  
   	pelem_type = ^elem_type;
   	
	pnode_type = ^node_type;
	node_type  = record
		key: key_type;
		value: value_type;
		parent: pnode_type;
		left: pnode_type;
		right: pnode_type;
		black: boolean;
	end;
	
	rbtree_t = class
	private
		root: pnode_type;
		xzero: pnode_type;
	public
		constructor create;
		destructor destroy; override;
		procedure clear;
		function zero: pnode_type;
		function locate(k: key_type): pnode_type;
		function find(k: key_type; var v: value_type): boolean;
		function insert(e: elem_type): boolean; overload;
		function insert(k: key_type; v: value_type): boolean; overload;
		function delete(k: key_type): boolean;
		function start: pnode_type; overload;
		function start(p: pnode_type): pnode_type; overload;
		function finish: pnode_type;
		function next(p: pnode_type): pnode_type;
	private
		procedure left_rotate(var x: pnode_type);
		procedure right_rotate(var x: pnode_type);
		procedure insert_fixup(var x: pnode_type);
		procedure delete_fixup(var x: pnode_type);
	end;
	
	s2i_pair_t = elem_type;
	s2i_it_t = pnode_type;
	s2i_cit_t = pnode_type;
	
	s2i_map_t = class
	private
		rbt: rbtree_t;
	public
		constructor create;
		destructor destroy; override;
		procedure clear;
		function find(k: key_type; var v: value_type): boolean;
		function value(k: key_type): value_type;
		procedure setvalue(e: elem_type); overload;
		procedure setvalue(k: key_type; v: value_type); overload;
		function insert(e: elem_type): boolean; overload;
		function insert(k: key_type; v: value_type): boolean; overload;
		function delete(k: key_type): boolean;
		function start: pnode_type;
		function finish: pnode_type;
		function next(p: pnode_type): pnode_type;
	end;

constructor rbtree_t.create;
begin
	inherited;
	new(xzero);
	xzero^.left := nil;
	xzero^.right := nil;
	xzero^.parent := nil;
	xzero^.key := '^';
	xzero^.value := -1;
	xzero^.black := true;
	root := xzero;
end;

destructor rbtree_t.destroy;
begin
	clear;
	dispose(xzero);
	inherited;
end;

procedure rbtree_t.clear;
var
	p, q: pnode_type;
begin
	
	xzero^.left := nil;
	xzero^.right := nil;
	xzero^.parent := nil;
	xzero^.key := '^';
	xzero^.value := -1;
	xzero^.black := true;
	p := root;
	
	while p <> xzero do
	begin
		while true do
		begin
			if p^.left <> xzero then
			begin
				q := p;
				p := p^.left;
				q^.left := xzero;
			end
			else if p^.right <> xzero then
			begin
				q := p;
				p := p^.right;
				q^.right := xzero;
			end
			else
				break;
		end;
		
		q := p^.parent;
				
		dispose(p);
		p := q;
	end;
	
	root := xzero;
end;

function rbtree_t.zero: pnode_type;
begin
	zero := xzero;
end;

function rbtree_t.start: pnode_type;
begin
	start := start(root);
end;

function rbtree_t.start(p: pnode_type): pnode_type;
begin
	while (p <> xzero) and (p^.left <> xzero) do
		p := p^.left;
	start := p;
end;

function rbtree_t.finish: pnode_type;
begin
	finish := xzero;
end;

function rbtree_t.next(p: pnode_type): pnode_type;
var
	q: pnode_type;
begin
	if p^.right <> xzero then
		next := start(p^.right)
	else
	begin
		q := p^.parent;
		while (q <> xzero) and (p = q^.right) do
		begin
			p := q;
			q := q^.parent;
		end;
		
		next := q;
	end;
end;


procedure rbtree_t.left_rotate(var x: pnode_type);
var
	p, r: pnode_type;
begin
	r := x^.right;
	x^.right := r^.left;
	if r^.left <> xzero then
		r^.left^.parent := x;
	r^.left := x;
	
	p := x^.parent;
	if p = xzero then
		root := r
	else
	begin
		if x = p^.left then
			p^.left := r
		else
			p^.right := r;	
	end;
	r^.parent := p;
	x^.parent := r;
end;


procedure rbtree_t.right_rotate(var x: pnode_type);
var
	p, lft: pnode_type;
begin
	lft := x^.left;
	x^.left := lft^.right;
	if lft^.right <> xzero then
		lft^.right^.parent := x;
	lft^.right := x;
	
	p := x^.parent;
	if p = xzero then
		root := lft
	else
	begin
		if x = p^.left then
			p^.left := lft
		else
			p^.right := lft;
	end;
	lft^.parent := p;
	x^.parent := lft;
end;


function rbtree_t.locate(k: key_type): pnode_type;
var
	p: pnode_type;
begin
	p := root;
	while p <> xzero do
	begin
		if p^.key > k then
			p := p^.left
		else if p^.key < k then
			p := p^.right
		else break;
	end;
	locate := p;
end;

function rbtree_t.find(k: key_type; var v: value_type): boolean;
var
	p: pnode_type;
begin
	p := locate(k);
	if p <> xzero then begin
		v := p^.value;
		find := true;
	end
	else find := false;
end;

function rbtree_t.insert(e: elem_type): boolean;
begin
	insert := insert(e.first, e.second);
end;

function rbtree_t.insert(k: key_type; v: value_type): boolean;
var
	p, q: pnode_type;
begin
	if root = xzero then
	begin
		new(root);
		root^.key := k;
		root^.value := v;
		root^.black := true;
		root^.left := xzero;
		root^.right := xzero;
		root^.parent := xzero;
		insert := true;
	end
	else
	begin
		q := xzero;
		p := root;
		while (p <> xzero) and (p^.key <> k) do
		begin
			q := p;
			if p^.key > k then
				p := p^.left
			else
				p := p^.right;
		end;
		
		if p <> xzero then
		begin
			insert := false;
			exit;
		end;
		
		new(p);
		p^.key := k;
		p^.value := v;
		p^.parent := q;
		p^.left := xzero;
		p^.right := xzero;
		p^.black := false;
		
		if q^.key > k then
			q^.left := p
		else
			q^.right := p;
		insert_fixup(p);
		
		insert := true;	
	end;
end;

procedure rbtree_t.insert_fixup(var x: pnode_type);
var
	p, b, pp: pnode_type;
begin
	while (x^.parent <> xzero) and (not x^.parent^.black) do
	begin
		p := x^.parent;
		pp := p^.parent;
		if p = pp^.left then
		begin
			b := pp^.right;
			
			if (b <> xzero) and (not b^.black) then
			begin
				p^.black := true;
				b^.black := true;
				pp^.black := false;
				x := pp;
			end
			else
			begin
				if x = p^.right then
				begin
					x := p;
					left_rotate(x);
					p := x^.parent;
				end;
				
				p^.black := true;
				pp^.black := false;
				right_rotate(pp);
			end
		end
		else
		begin
			b := pp^.left;
			if (b <> xzero) and (not b^.black) then
			begin
				p^.black := true;
				b^.black := true;
				pp^.black := false;
				x := pp;
			end
			else
			begin
				if x = p^.left then
				begin
					x := p;
					right_rotate(x);
					p := x^.parent;
				end;
				
				p^.black := true;
				pp^.black := false;
				left_rotate(pp);
			end;
		end;			
	end;
	
	root^.black := true;
end;

function rbtree_t.delete(k: key_type): boolean;
var
	p, x, y: pnode_type;
begin
	
	p := locate(k);

	if p = xzero then
	begin
		delete := false;
		exit;
	end;

	if (p^.left = xzero) or (p^.right = xzero) then
		y := p
	else
		y := next(p);
	
	if y^.left <> xzero then
		x := y^.left
	else
		x := y^.right;

	x^.parent := y^.parent;
	if y^.parent = xzero then
		root := x
	else begin
		if y = y^.parent^.left then
			y^.parent^.left := x
		else
			y^.parent^.right := x;
	end;
	
	if y <> p then
	begin
		p^.key := y^.key;
		p^.value := y^.value;
	end;
	
	if y^.black then delete_fixup(x);
	
	dispose(y);
	
	delete := true;
end;

procedure rbtree_t.delete_fixup(var x: pnode_type);
var
	w, p: pnode_type;
begin
	while (x <> root) and x^.black do
	begin
		if x = x^.parent^.left then
		begin
			p := x^.parent;
			w := p^.right;
			if not w^.black then
			begin
				w^.black := true;
				p^.black := false;
				left_rotate(p);
				w := p^.right;
			end;
			if w^.left^.black and w^.right^.black then
			begin
				w^.black := false;
				x := p;
			end
			else
			begin
				if w^.right^.black then
				begin
					w^.left^.black := true;
					w^.black := false;
					right_rotate(w);
					w := p^.right;
				end;
				w^.black := p^.black;
				p^.black := true;
				w^.right^.black := true;
				left_rotate(p);
				x := root;
			end;
		end
		else
		begin
			p := x^.parent;
			w := p^.left;
			if not w^.black then
			begin
				w^.black := true;
				p^.black := false;
				right_rotate(p);
				w := p^.left;
			end;
			if w^.left^.black and w^.right^.black then
			begin
				w^.black := false;
				x := p;
			end
			else
			begin
				if w^.left^.black then
				begin
					w^.right^.black := true;
					w^.black := false;
					left_rotate(w);
					w := p^.left;
				end;
				w^.black := p^.black;
				p^.black := true;
				w^.left^.black := true;
				right_rotate(p);
				x := root;
			end;
		end;
	end;
	
	x^.black := true;
end;


constructor s2i_map_t.create;
begin
	rbt := rbtree_t.create;
end;

destructor s2i_map_t.destroy;
begin
	rbt.destroy;
	inherited;
end;

procedure s2i_map_t.clear;
begin
	rbt.clear;
end;

function s2i_map_t.find(k: key_type; var v: value_type): boolean;
begin
	find := rbt.find(k, v);
end;

function s2i_map_t.value(k: key_type): value_type;
var
	val: value_type;
begin
	rbt.find(k, val);
	value := val;
end;

procedure s2i_map_t.setvalue(e: elem_type);
begin
	setvalue(e.first, e.second);
end;

procedure s2i_map_t.setvalue(k: key_type; v: value_type);
var
	p: pnode_type;
begin
	p := rbt.locate(k);
	if p = rbt.zero then
		rbt.insert(k, v)
	else
		p^.value := v;
end;

function s2i_map_t.insert(e: elem_type): boolean;
begin
	insert := rbt.insert(e);
end;

function s2i_map_t.insert(k: key_type; v: value_type): boolean;
begin
	insert := rbt.insert(k, v);
end;

function s2i_map_t.delete(k: key_type): boolean;
begin
	delete := rbt.delete(k);
end;

function s2i_map_t.start: pnode_type;
begin
	start := rbt.start;
end;

function s2i_map_t.finish: pnode_type;
begin
	finish := rbt.finish;
end;

function s2i_map_t.next(p: pnode_type): pnode_type;
begin
	next := rbt.next(p);
end;

<</s2i_map_define>>

<<char_handling_routines>>
function isblank(c: char): boolean;
begin
	isblank := ((c = #9) or (c = #32));
end;
function isspace(c: char): boolean;
begin
	isspace := ((c >= #9) and (c <= #13));
end;

function iscntrl(c: char): boolean;
begin
	iscntrl := ((c >=#0) and (c <= #31));
end;

function islower(c: char): boolean;
begin
	islower := ((c >= #97) and (c <= #122));
end;

function isupper(c: char): boolean;
begin
	isupper := ((c >= #65) and (c <= #90));
end;

function isdigit(c: char): boolean;
begin
	isdigit := ((c >= #48) and (c <= #57));
end;
function isxdigit(c: char): boolean;
begin
	isxdigit := ((c >= #48) and (c <= #57))
		or ((c >= #65) and (c <= #70))
		or ((c >= #97) and (c <= #102));
end;

function isalpha(c: char): boolean;
begin
	isalpha := islower(c) or isupper(c);
end;

function isalnum(c: char): boolean;
begin
	isalnum := isalpha(c) or isdigit(c);
end;

function ispunct(c: char): boolean;
begin
	ispunct := ((c >= #33) and (c <= #47))
		or ((c >= #58) and (c <= #64))
		or ((c >= #91) and (c <= #96))
		or ((c >= #123) and (c <= #126));
end;

function isgraph(c: char): boolean;
begin
	isgraph := ((c >= #33) and (c <= #126));
end;

function isprint(c: char): boolean;
begin
	isprint := ((c >= #32) and (c <= #126));
end;

<</char_handling_routines>>

<<generic_vector_decl>>

{
	generic vector class, the only obstacle to use is that
	you cannot push_back a constant, but a variable
}

type
	vector_t = class
	private
		base: pchar;
		sz_unit: integer;
		sz_used: integer;
		sz_total: integer;
	public
		constructor create(esz: integer);
		destructor destroy; override;
		procedure push_back(const e);
		procedure pop_back(out e);
		procedure getat(idx: integer; out e);
		procedure setat(idx: integer; const e);
		function size: integer;
		procedure clear;
	end;
<</generic_vector_decl>>

<<generic_vector_def>>
	constructor vector_t.create(esz: integer);
	begin
		inherited create;
		sz_unit := esz;
		sz_used := 0;
		sz_total := 0;
		base := nil;
	end;

	destructor vector_t.destroy;
	begin
		if base <> nil then
			freemem(base);
		inherited;
	end;

	procedure vector_t.push_back(const e);
	var
		p: pchar;
	begin
		if sz_used >= sz_total then
		begin
			sz_total := sz_total + 4;
			reallocmem(base, sz_total * sz_unit);
		end;
		
		p := pchar(base + sz_used * sz_unit);
		move(e, p^, sz_unit);
		sz_used := sz_used + 1;
	end;
	
	procedure vector_t.pop_back(out e);
	var
		p: pchar;
	begin
		if sz_used > 0 then
		begin
			sz_used := sz_used - 1;
			p := base + sz_used * sz_unit;
			move(p, e, sz_unit);
		end
		else raise ERangeError.create('Out of range');
	end;

	procedure vector_t.getat(idx: integer; out e);
	var
		p: pchar;
	begin
		if (idx >= 0) and (idx < sz_used) then
		begin
			p := base + idx * sz_unit;
			move(p^, e, sz_unit);
		end
		else
			raise ERangeError.create('Out of range');
	end;

	procedure vector_t.setat(idx: integer; const e);
	var
		p: pchar;
	begin
		if (idx >= 0) and (idx < sz_used) then
		begin
			p := base + idx * sz_unit;
			move(e, p^, sz_unit);
		end
		else
			raise ERangeError.create('Out of range');
	end;

	function vector_t.size: integer;
	begin
		size := sz_used;
	end;

	procedure vector_t.clear;
	begin
		sz_used := 0;
	end;
	
<</generic_vector_def>>


<</settings>>
>>>> ------------------------------------ global setting

<<templs>>

<<<----------template for configure.ac-------------->>>
<<templ "config-template">>AC_INIT([the pattern-matching and parsing program generator], [<<version/>>], [<<email/>>], [upgen])
AC_PREREQ([1.00])
AM_INIT_AUTOMAKE([])
UDIFF=<<diff/>>

UDIFF=<<diff/>>
LOGFILE=../../upgen_test_log/<<stream_type/>>
AC_SUBST([UPGEN_BINDIR])
AC_SUBST([UDIFF])
AC_SUBST([LOGFILE])
AC_SUBST([PASCC])
AC_SUBST([PASFLAG])

AC_CONFIG_FILES(<<makefiles/>>
)
AC_OUTPUT
<</templ>>

<<<----------template for Makefile.am of directories---------->>>
<<templ "subdir-makefile-template">>## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE
SUBDIRS = <<subdirs/>>
DIST_SUBDIRS = <<subdirs/>>

test-suites: clean
	NOK=;\
	NFAIL=;\
	for subdir in $(SUBDIRS) ; do \
		echo Enter "$$subdir" "..." >> $(top_srcdir)/$(LOGFILE) ; \
		( cd "$$subdir" && $(MAKE) test-suites --quiet) ; \
		case $$? in \
			0 ) NOK=0$$NOK;\
				;; \
			* ) NFAIL=0$$NFAIL; \
				;; \
		esac; \
	done ; \
	echo Results: >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NOK@ECHO_C@"|wc -c` succeeded >> $(top_srcdir)/$(LOGFILE) ; \
	echo "		" `echo @ECHO_N@ "$$NFAIL@ECHO_C@"|wc -c` FAILED >> $(top_srcdir)/$(LOGFILE) ; \
	test "$$NFAIL" = ""

<</templ>>


<<<----------template for Makefile.am of cases---------->>>
<<templ "lex-only-makefile-template">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) <<upgen_options/>> -s pas -clLp -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;

$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1
	
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "make-no-exec">>
## This file is test script for upgen
## No copyright or copyleft reserved
## THIS SOFTWARE IS PROVIDED ``AS IS '' AND WITHOUT ANY EXPRESS
## OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITINESS FOR A
## PARTICULAR PURPOSE

UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err
CLEANFILES = test.out test.err

test-suites: script.upg
	$(UPGEN) <<upgen_options/>> -s pas -o script.pas $< 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "invoke-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>

CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -cL <<upgen_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1

test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "invoke-make-stdout-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>

CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -cL <<upgen_options/>> -s pas -t $< >$@ 2>> $(top_srcdir)/$(LOGFILE) ;

$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1

test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "invoke-make-lex-parse-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas scanner.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg scanner.upg test.input result.out result.err <<EXTRA_DIST/>>
CLEANFILES = test.out test.err script.pas scanner.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -clL <<parser_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
scanner.pas: scanner.upg
	@rm -f scanner.pas
	$(UPGEN) <<scanner_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
$(TESTEXE): script.pas scanner.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1
test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<templ "basic-make-template">>

bin_PROGRAMS = testexe
testexe_SOURCES = script.pas testexe.pas

TESTEXE = testexe$(EXEEXT)
UPGEN = $(UPGEN_BINDIR)/upgen

EXTRA_DIST = script.upg test.input result.out result.err <<EXTRA_DIST/>>

CLEANFILES = test.out test.err script.pas $(TESTEXE) $(OBJ)
OBJS = *.$(OBJEXT) *.dcu *.ppu

script.pas: script.upg
	@rm -f script.pas
	$(UPGEN) -clL <<upgen_options/>> -s pas -o $@ $< 2>> $(top_srcdir)/$(LOGFILE) ;
$(TESTEXE): script.pas
	@rm -f $(TESTEXE)
	$(PASCC) $(PASFLAG) -o$@ testexe.pas >/dev/null 2>&1

test-suites: $(TESTEXE)
	@rm -f test.out
	./$(TESTEXE) <<inputed_file/>> 1>test.out 2>test.err;	\
	messge=`$(UDIFF) -w  -q $(srcdir)/test.out $(srcdir)/result.out`;	\
	if test -z "$$messge" ; then	\
		messge=`$(UDIFF) -w -q $(srcdir)/test.err $(srcdir)/result.err`; \
	fi;	\
	if test -z "$$messge" ; then \
		echo ".............. succeeded" >> $(top_srcdir)/$(LOGFILE) ;	\
	else	\
		echo ".............. FAILED" >> $(top_srcdir)/$(LOGFILE) ;	\
	fi;	\
	test "$$messge" = ""
<</templ>>


<<<----------template for testexe.pas of cases -------->>>
<<templ "testexe-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	<<before_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then
	begin
		halt(1);
	end;
	<<prefix/>>parse;
	<<after_init/>>
	<<after_buffer_usage/>>
end.

<</templ>>
<<<----------template for testexe.pas of cases -------->>>


<<<----------template for script.upg of cases---------->>>
<<templ "lex-only-script-template">><<desc/>>

%header%{
uses SysUtils, StrUtils;

{$H+}
function testmain: integer;

%}

%{
<<char_handling_routines/>>
<<global_decl_code/>>
%}

<<declare_section/>>
%%
<<lex_section/>>
%%
<<parse_section/>>
%%
<<code_section/>>

function testmain: integer;
<<main_var_decl/>>
<<local_var_decl/>>
<<local_decl_code/>>
begin

<<init_code/>>

<<before_buffer_init/>>
<<before_init/>>

	if <<prefix/>><<buffer_init/>> <> 0 then
	begin
		testmain := 1;
		exit;
	end;
	<<after_init/>>
	<<after_buffer_usage/>>
	testmain := 0;
	
end;
	
<</templ>>


<<templ "testexe-lex-only-script-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	testmain;
end.

<</templ>>

<<templ "invoke-full-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
// to avoid copy yytext
	s_strVarName: string;
%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';

%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

[0-9]+		begin
				<<prefix/>>lval.nVal := strtoint(yytext);
				result := NUM;
				exit;
				end;
"quit"		begin
				result := QUIT;
				exit;
			end;
"clear"		begin
				result := CLEAR;
				exit;
			end;
"list"		begin
				result := LIST;
				exit;
			end;
{var}		begin
				s_strVarName := yytext;
				result := VARI;
				exit;
			end;
			
[\+\-\*\/\%\^\=\(\)\?\n]	begin
				result := ord(yytext[0]);
				exit;
			end;

<<default_action/>>

%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			write('Error: at ', @1.firstLine, ':', @1.firstColumn);
			writeln('; description: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		write('Error: at ', @1.firstLine, ': ', @1.firstColumn);
		writeln('; description: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				write('Error: at ', @1.firstLine, ':', @1.firstColumn);
				writeln('; description: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

<</templ>>

<<templ "invoke-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
// to avoid copy yytext
	s_strVarName: string;
%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';
%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%

[0-9]+		begin
				<<prefix/>>lval.nVal := strtoint(yytext);
				result := NUM;
				exit;
				end;
"quit"		begin
				result := QUIT;
				exit;
			end;
"clear"		begin
				result := CLEAR;
				exit;
			end;
"list"		begin
				result := LIST;
				exit;
			end;
{var}		begin
				s_strVarName := yytext;
				result := VARI;
				exit;
			end;
			
[\+\-\*\/\%\^\=\(\)\?\n]	begin
				result := ord(yytext[0]);
				exit;
			end;

<<default_action/>>

%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			writeln('Error: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		writeln('Error: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				writeln('Error: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

<</templ>>


<<<----------template for testexe.pas with user-defined scanner -------->>>
<<templ "testexe-invoke-myscanner-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_myinput/>>
	<<prefix/>>setlex(myscanner);

	<<prefix/>>parse;
	if (s_pfile <> nil) and (s_pfile <> @input) then
	begin
		closefile(s_pfile^);
		dispose(s_pfile);
	end;
end.

<</templ>>
<<<----------template for testexe.pas with user-defined scanner -------->>>



<<templ "invoke-myscanner-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
	s_pfile: ^text;
	yytext: string;
	s_strVarName: string;
	
function myscanner: integer;

%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';

%}

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%


%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			write('Error: at ', @1.firstLine, ':', @1.firstColumn);
			writeln('; description: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		write('Error: at ', @1.firstLine, ': ', @1.firstColumn);
		writeln('; description: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				write('Error: at ', @1.firstLine, ':', @1.firstColumn);
				writeln('; description: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

var
	savechar: boolean = false;
	lastc: char = PAS_EOF__;
	
function myscanner: integer;
var
	c: char;
	to_be_var: boolean;
begin

	myscanner := 0;
	c := PAS_EOF__;
	if s_pfile = nil then exit;
	
	repeat
		to_be_var := false;
		yytext := '';
		
		if savechar then
			c := lastc
		else
			read(s_pfile^, c);
		savechar := false;
		if c = PAS_EOF__ then exit;
		
		if isdigit(c) then
		begin
			repeat
				yytext := yytext + c;
				read(s_pfile^, c);
			until not isdigit(c);
			
			lastc := c;
			savechar := true;
			<<prefix/>>lval.nVal := strtoint(yytext);
			myscanner := NUM;
			exit;
		end;
		
		case c of
		'+', '-', '*', '/', '%',
		'^', '=', '(', ')', '?',
		#10:
			begin
				yytext := yytext + c;
				myscanner := ord(c);
				exit;
			end;
		'q':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'u' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'i' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := QUIT;
								exit;
							end;
						end;
					end;
				end;
			end;
		'c':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'l' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'e' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 'a' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if c = 'r' then begin
								yytext := yytext + c;
								read(s_pfile^, c);
								if (not isalnum(c)) and (c <> '_') then begin
									lastc := c;
									savechar := true;
									myscanner := CLEAR;
									exit;
								end;
							end;
						end;
					end;
				end;
			end;
		'l':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'i' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 's' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := LIST;
								exit;
							end;
						end;
					end;
				end;
			end;
		else
			begin
				if isalpha(c) or (c = '_') then begin
					to_be_var := true;
				end
				else begin
					if c <> PAS_EOF__ then begin
						if (c <> #9) and (c <> #11) and (c <> #32) then
							writeln('undefined symbol `', c, '''');
					end;
				end;
			end;
		end;
		
		if to_be_var then begin
			while isalnum(c) or (c = '_') do
			begin
				yytext := yytext + c;
				read(s_pfile^, c);
			end;
			
			lastc := c;
			savechar := true;
			s_strVarName := yytext;
			myscanner := VARI;
			exit;
		end;
		
	until c = PAS_EOF__;
	
	myscanner := 0;
end;

<</templ>>

<<templ "invoke-myscanner-noloc-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
	s_pfile: ^text;
	yytext: string;
	s_strVarName: string;
function myscanner: integer;
%}

%{

<<s2i_map_define/>>
<<char_handling_routines/>>

const
	LBLANS = 'ans';

%}


/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%


%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			writeln('Error: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		writeln('Error: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				writeln('Error: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				writeln('Error: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%


var
	savechar: boolean = false;
	lastc: char = PAS_EOF__;
	
function myscanner: integer;
var
	c: char;
	to_be_var: boolean;
begin

	myscanner := 0;
	c := PAS_EOF__;
	if s_pfile = nil then exit;
	
	repeat
		to_be_var := false;
		yytext := '';
		
		if savechar then
			c := lastc
		else
			read(s_pfile^, c);
		savechar := false;
		if c = PAS_EOF__ then exit;
		
		if isdigit(c) then
		begin
			repeat
				yytext := yytext + c;
				read(s_pfile^, c);
			until not isdigit(c);
			
			lastc := c;
			savechar := true;
			<<prefix/>>lval.nVal := strtoint(yytext);
			myscanner := NUM;
			exit;
		end;
		
		case c of
		'+', '-', '*', '/', '%',
		'^', '=', '(', ')', '?',
		#10:
			begin
				yytext := yytext + c;
				myscanner := ord(c);
				exit;
			end;
		'q':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'u' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'i' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := QUIT;
								exit;
							end;
						end;
					end;
				end;
			end;
		'c':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'l' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 'e' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 'a' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if c = 'r' then begin
								yytext := yytext + c;
								read(s_pfile^, c);
								if (not isalnum(c)) and (c <> '_') then begin
									lastc := c;
									savechar := true;
									myscanner := CLEAR;
									exit;
								end;
							end;
						end;
					end;
				end;
			end;
		'l':
			begin
				to_be_var := true;
				yytext := yytext + c;
				read(s_pfile^, c);
				if c = 'i' then begin
					yytext := yytext + c;
					read(s_pfile^, c);
					if c = 's' then begin
						yytext := yytext + c;
						read(s_pfile^, c);
						if c = 't' then begin
							yytext := yytext + c;
							read(s_pfile^, c);
							if (not isalnum(c)) and (c <> '_') then begin
								lastc := c;
								savechar := true;
								myscanner := LIST;
								exit;
							end;
						end;
					end;
				end;
			end;
		else
			begin
				if isalpha(c) or (c = '_') then begin
					to_be_var := true;
				end
				else begin
					if c <> PAS_EOF__ then begin
						if (c <> #9) and (c <> #11) and (c <> #32) then
							writeln('undefined symbol `', c, '''');
					end;
				end;
			end;
		end;
		
		if to_be_var then begin
			while isalnum(c) or (c = '_') do
			begin
				yytext := yytext + c;
				read(s_pfile^, c);
			end;
			
			lastc := c;
			savechar := true;
			s_strVarName := yytext;
			myscanner := VARI;
			exit;
		end;
		
	until c = PAS_EOF__;
	
	myscanner := 0;
end;

<</templ>>


<<<----------template for testexe.pas with another scanner generated -------->>>
<<templ "testexe-myscanner-template">><<desc/>>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	scanner in 'scanner.pas', { scanning classes and routines}
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if zz<<buffer_init2/>> <> 0 then begin
		writeln('Error: initialization failed.');
		halt(1);
	end;
	<<prefix/>>setlex(zzlex);

	<<prefix/>>parse;
	<<after_buffer_usage/>>
end.

<</templ>>
<<<----------template for testexe.pas with another scanner generated -------->>>

<<templ "invoke-parser-only-template">>
<<desc/>>
/**********************************************************************
 *
 * program sample -- integral desktop calculator
 *
 ***********************************************************************/

<<option_prefix/>>

%header%{
{$H+}
uses sysutils, strutils;

var
	s_strVarName: string;
%}

%{

<<s2i_map_define/>>

const
	LBLANS = 'ans';

%}

/* semantic value type declaration */
%union%{
	nVal: integer;
	pchVal: pchar;
%}

/* declaration of local varaibles used in <<prefix/>>parse */
%parsevar-decl%{
	iVal, expo, r: integer;
	mapVars: s2i_map_t;
	strVar: string;
	bNaN: boolean;
	cit: s2i_cit_t;
%}

%parsevar-init%{
	iVal := 0;
	mapVars := s2i_map_t.create;
	strVar := '';
	bNaN := false;
%}

%parse-exit%{
	mapVars.destroy;
%}

/* token(terminal) declarations */
%token<nVal> NUM
%token VARI CLEAR LIST QUIT

/* token(terminal) declarations with user-defined precedence and associativity */
%left '+' '-'
%left '*' '/' '%'
%right '^' MINUS

/* grammatic type(variable or non-terminal) declarations */
%type<nVal> Expr

/* start symbol of CFG(context-free grammar) */
%start Program

%%


%%

Program: %{
		mapVars.insert(LBLANS, 0);
	%}
	| Program Line		%{

		bNaN := false;
	%}
	;

Line: 	'\n'
	| Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(LBLANS, $1);
			writeln(LBLANS, ' = '#9#9, $1);
		end;
	%}
	| VARI 			%{
		strVar := s_strVarName;
	%}
	'=' Expr '\n'		%{
		if not bNaN then
		begin
			mapVars.setvalue(strVar, $4);
			writeln(strVar, ' = '#9#9, $4);
		end;
	%}
	| VARI %{
		if mapVars.find(s_strVarName, iVal) then
		begin
			writeln(s_strVarName, ' = '#9#9, iVal);
		end
		else
		begin
			write('Error: at ', @1.firstLine, ':', @1.firstColumn);
			writeln('; description: ', s_strVarName, ' is unset variable.');
		end;
		
	%}
	'?' '\n'
	| CLEAR	'\n'		%{
		mapVars.clear;
		mapVars.insert(LBLANS, 0);
	%}
	| LIST	'\n'		%{
		cit := mapVars.start;
		while cit <> mapVars.finish do
		begin
			writeln(cit^.key, ' = '#9#9, cit^.value);
			cit := mapVars.next(cit);
		end;
	%}
	| QUIT	'\n'		%{
		YYACCEPT;
	%}
	| error '\n'		%{
	
		write('Error: at ', @1.firstLine, ': ', @1.firstColumn);
		writeln('; description: undefined symbol.');
		yyerrok;
	%}
	;

Expr:	Expr '+' Expr		%{
		if not bNaN then
			$$ := $1 + $3;
	%}
	| Expr '-' Expr		%{
		if not bNaN then
			$$ := $1 - $3;
	%}
	| Expr '*' Expr		%{
		if not bNaN then
			$$ := $1 * $3;
	%}
	| Expr '/' Expr		%{
		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else 
				$$ := $1 div $3;
		end;
	%}
	| Expr '%' Expr		%{

		if not bNaN then
		begin
			if $3 = 0 then
			begin
				write('Error: at ', @3.firstLine, ': ', @3.firstColumn);
				writeln('; description: divided by zero!!');
				bNaN := true;
			end
			else
				$$ := $1 mod $3;
			
		end;
	%}
	| Expr '^' Expr		%{

		if not bNaN then
		begin

			if $3 = 0 then
				$$ := 1
			else if $1 = 0 then
				$$ := 0
			else
			begin
				expo := $3;

				if $3 < 0 then 
					expo := 0 - expo;
			
				$$ := $1;
				r := 1;
				while expo > 1 do
				begin
				
					if expo mod 2 = 1 then
						r := r * $$;
					$$ := $$ * $$;
					expo := expo shr 1;
				end;
				$$ := $$ * r;

				if $3 < 0 then
					$$ := 1 div $$;
			end;
		end;
	%}
	| '-' %prec MINUS Expr	%{

		if not bNaN then
			$$ := 0 - $2;
	%}
	| '+' %prec MINUS Expr	%{
		if not bNaN then
			$$ := $2;
	%}
	| '(' Expr ')'		%{
		if not bNaN then
			$$ := $2;
	%}
	| NUM			%{
		$$ := $1;
	%}
	| VARI			%{

		if not bNaN then
		begin
			if mapVars.find(s_strVarName, iVal) then
				$$ := iVal
			else
			begin
				write('Error: at ', @1.firstLine, ':', @1.firstColumn);
				writeln('; description: ', s_strVarName, ' is unset variable.');
				bNaN := true;
			end;
		end;
	%}
	;

%%

<</templ>>


<<templ "testexe-invoke-noparser-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	<<before_init/>>
	if <<prefix/>><<buffer_init2/>> <> 0 then
	begin
		writeln('Error: initialization failed.');
		halt(1);
	end;
	<<after_init/>>
	<<prefix/>>lex;
	<<after_buffer_usage/>>
end.

<</templ>>

<<templ "invoke-noparser-template">>
<<desc/>>
/***********************************************************************
	program sample : extract keywords, identifiers, and numbers
************************************************************************/
<<option_prefix/>>

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*
			
%%

[0-9]+				writeln('number: ', yytext);
"quit"				writeln('keyword: ', yytext);
"clear"				writeln('keyword: ', yytext);
"list"				writeln('keyword: ', yytext);
{var}				writeln('identifier: ', yytext);

[\+\-\*\/\%\^\=\(\)\?]		writeln('operator: ', yytext[0]);
\n				writeln('new line encountered.');
<<default_action/>>
<<EOF>>				writeln('Good-bye!');
			
%%

%%

<</templ>>


<<templ "basic-parentheses-template">>
<<desc/>>
/**********************************************************************
	program sample: extract parentheses from expression,
			and convert them to brackets
***********************************************************************/

<<declare_section/>>
%%

[\(\)]		<<parent_lex_action/>>
			result := ord(yytext[0]);
			exit;
\n			writeln;
.

%%

Program: PExpr %{
<<accept_action/>>
		YYACCEPT();
	%}
	;

PExpr: PExpr PItem	%{

	%}
	|
	;
PItem: '('		%{
		write('[');
	%}
	PExpr ')'	%{
		write(']');
	%}
	;
%%
<<code_section/>>

<</templ>>

<<templ "basic-sentinfo-template">>
<<desc/>>
/****************************************************************
	program sample: count information of sentences in text
*****************************************************************/

%header%{

<<union_code/>>
<<location_code/>>
var
	sentenceCounter: integer = 1;
%}

<<union_decl/>>
<<location_decl/>>

%parsevar-decl%{
var
	lineCounter: integer;
	wordCounter: integer;
	charCounter: integer;
%}

%parsevar-init%{
lineCounter := 0;
wordCounter := 0;
charCounter := 0;
%}

ws	[ \t]
nows	[^ \t\n\.\?\!]

%token<nVal> TK_WORD TK_WS
%token	TK_ES

%type<nPair> Block Blocks

%%

[\.\?\!]		begin
		yylloc.sentenceNo := sentenceCounter;
		sentenceCounter := sentenceCounter + 1;
		result := TK_ES;
		exit;
	end;

{nows}+	begin
		yylloc.sentenceNo := sentenceCounter;
		yylval.nVal := yyleng;
		result := TK_WORD;
		exit;
	end;

{ws}+		begin
		yylloc.sentenceNo := sentenceCounter;
		yylval.nVal := yyleng;
		result := TK_WS;
		exit;
	end;
\n		begin
		yylloc.sentenceNo := sentenceCounter;
		result := 10;
		exit;
	end;

%%


SText: Blocks	%{
		writeln('Words: ', wordCounter);
		writeln('Chars: ', charCounter);
		writeln('Sents: ', @1.sentenceNo);
		writeln('Lines: ', lineCounter);
		YYACCEPT;
	%}
	;

Blocks:	Blocks Block	%{
		@$.sentenceNo := @2.sentenceNo;
		if $2.charCounter = -1 then begin
			$1.charCounter := $1.charCounter + 1;
			writeln('S', @1.sentenceNo, #9, $1.wordCounter, ' words;',
				#9, $1.charCounter, ' characters.');

			charCounter := charCounter + 1;

			$$.wordCounter := 0;
			$$.charCounter := 0;
		end
		else begin
			$$.wordCounter := $1.wordCounter + $2.wordCounter;
			$$.charCounter := $1.charCounter + $2.charCounter;

			wordCounter := wordCounter + $2.wordCounter;
			charCounter := charCounter + $2.charCounter;
		end;
	%}
	| Block		%{
		@$.sentenceNo := @1.sentenceNo;
		if $1.charCounter = -1 then begin
			writeln('S', @1.sentenceNo, #9, $1.wordCounter,
				' words;'#9'1 characters.');
			charCounter := charCounter + 1;

			$$.wordCounter := 0;
			$$.charCounter := 0;
		end
		else begin
			$$.wordCounter := $1.wordCounter;
			$$.charCounter := $1.charCounter;

			wordCounter := wordCounter + $1.wordCounter;
			charCounter := charCounter + $1.charCounter;
		end;
	%}
	;

Block: TK_WORD	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 1;
		$$.charCounter := $1;
	%}
	| TK_WS	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 0;
		$$.charCounter := $1;
	%}
	| '\n'	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 0;
		$$.charCounter := 1;
		lineCounter := lineCounter + 1;
	%}
	| TK_ES	%{
		@$.sentenceNo := @1.sentenceNo;
		$$.wordCounter := 0;
		$$.charCounter := -1;
	%}
	;

%%

<</templ>>

<<templ "testexe-basic-sentinfo-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	<<prefix/>>parse;
<<after_buffer_usage/>>
end.
<</templ>>

<<templ "basic-tagchecker-template">>
<<desc/>>
/**************************************************************
	sample program: tag checker, which determines if
			tag head has corresponding tag tail
***************************************************************/

%header%{

uses SysUtils, StrUtils;

{ push tag into stack }
procedure stack_push(plbl: pchar);
{ pop tag from stack }
function stack_pop: pchar;
{ get most recently pushed tag }
function stack_top: pchar;
{ free all nodes(not incuding their contents) in stack }
procedure stack_clear;
{ allocate a string }
function alloc_string(nlen: integer): pchar;
{ free all allocated string }
procedure free_string;

%}

%header%{
type
 	triple_t = record
		{ max of depth }
		maxdep: integer;
		{ current depth }
		curdep: integer;
		{ number of parentheses }
		pairnum: integer;
	end;

	tag_link_t = ^tag_node_t;
	tag_node_t = record

		plabel: pchar;
		pnext: tag_link_t;
	end;
%}

%{
var
	{ top of tag stack }
	sttop: tag_link_t = nil;
	{ top of allocation stack }
	stravail: tag_link_t = nil;

	{ temporary variable }
	{ @tempi used as counter in loops }
	tempi: integer;

<<init_code/>>
%}

/* legal name of tag excludes and string containing
	 ( ) [ ] { } < > , / " ' ; :
*/
tag	[A-Za-z0-9\!\@\#\$\%\^\&\*\+\-\_\~\`\?\.]+

/* semantic value type definition */
%union%{
	pchval: pchar;
	level: integer;
%}

%token<pchval> '(' ')'
%type<pchval> TagHead
%type<level> TagItem TagExpr
<<parse_param/>>
<<parsevar_decl/>>
<<parsevar_init/>>
<<destructor/>>
<<start_symbol/>>

%%

"<"{tag}">"	begin
		yylval.pchval := alloc_string(yyleng - 1);
		strlcopy(yylval.pchval, pchar(yytext + sizeof(char)), yyleng - 2);
		yylval.pchval[yyleng - 2] := #0;

		result := ord('(');
		exit;
	end;

"</"{tag}">"	begin
		yylval.pchval := stack_top;
		yytext[yyleng - 1] := #0;
		if (yylval.pchval = nil) or
			(strcomp(yylval.pchval, pchar(yytext + 2 * sizeof(char))) <> 0) then
			result := ord(']')
		else result := ord(')');
		exit;
	end;

.|\n		<<deflex_action/>>

%%

Exprs: TagExpr %{
		writeln('Tag checking passed.');
		<<exprs_action/>>
	%}
	;

SText: Exprs %{
		writeln('Input text is accepted by tag-check grammar.');
		YYACCEPT;
	%}
	;

TagExpr: TagExpr TagItem %{
		$$ := $2;
	%}
	|		%{
		$$ := tpl.curdep;
	%}
	;
TagItem: TagHead TagExpr ')'	%{
		tpl.curdep := tpl.curdep - 1;
		tpl.pairnum := tpl.pairnum + 1;
		stack_pop;

		for tempi := 0 to tpl.curdep - 1 do
			write(#9);
		
		writeln('</', $3, '>');

		$$ := tpl.curdep;
	%}
	| TagHead error ')'	%{
		tpl.curdep := tpl.curdep - 1;
		tpl.pairnum := tpl.pairnum + 1;
		stack_pop;

		for tempi := 0 to tpl.curdep - 1 do
			write(#9);

		writeln('</', $3, '>');

		$$ := tpl.curdep;

		yyerrok;
	%}
	;
TagHead: '('	%{

		for tempi := 0 to tpl.curdep - 1 do
			write(#9);

		writeln('<', $1, '>');

		tpl.curdep := tpl.curdep + 1;
		if tpl.curdep > tpl.maxdep  then tpl.maxdep := tpl.curdep;

		stack_push($1);
		$$ := $1;
	%}
	;
%%

{ push tag into stack }
procedure stack_push(plbl: pchar);
var
	p: tag_link_t;
begin

	new(p);
	p^.plabel := plbl;
	p^.pnext := sttop;
	sttop := p;
end;

{ pop tag from stack }
function stack_pop: pchar;
var
	pch: pchar;
	p: tag_link_t;
begin

	p := sttop;
	if p <> nil then begin
		pch := p^.plabel;
		sttop := sttop^.pnext;
		dispose(p);
	end
	else pch := nil;
	
	stack_pop := pch;
end;

{ get most recently pushed tag }
function stack_top: pchar;
begin
	if sttop = nil then stack_top := nil
	else
		stack_top := sttop^.plabel;
end;

{ free all nodes(not incuding their contents) in stack }
procedure stack_clear;
var
	p: tag_link_t;
begin
	while sttop <> nil do begin
		p := sttop^.pnext;
		dispose(sttop);
		sttop := p;	
	end;
	sttop := nil;
end;

{ allocate a string }
function alloc_string(nlen: integer): pchar;
var
	p: tag_link_t;
begin

	if nlen <= 0 then begin
		alloc_string := nil;
		exit;
	end;

	new(p);
	getmem(p^.plabel, sizeof(char) * nlen);
	p^.pnext := stravail;
	stravail := p;

	alloc_string := p^.plabel;

end;

{ free all allocated string }
procedure free_string;
var
	p: tag_link_t;
begin
	while stravail <> nil do begin
		p := stravail^.pnext;
		freemem(stravail^.plabel);
		dispose(stravail);
		stravail := p;	
	end;
	stravail := nil;
end;

<</templ>>

<<templ "testexe-basic-tagchecker-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<before_yyparse/>>
	
	<<prefix/>>parse(<<yyparse_param/>>);

	<<after_yyparse/>>

	stack_clear;
	free_string;
<<after_buffer_usage/>>

end.

<</templ>>

<<templ "basic-extr-numopr-template">>
<<desc/>>
/****************************************************************************
*	sample program: number(including integer and float),
*			arithmetic operator(+ - * / % ^ =)
*			extracter
*****************************************************************************/

%{

<<init_code/>>

var
	i: integer;
	pbuf: YYPBUFFER;
%}


udec	[0-9]+
sdec	[\-\+]?{udec}
frct	\.{udec}
num	{sdec}{frct}?
opr	[\+\-\*\/\%\^\=]

<<lvar_decl/>>
<<lvar_init/>>
<<lex_init/>>
<<pre_match/>>
<<yywrap/>>

%token FEOF

%%

"#open"[ \t]*\"[^\"\'\n]+\"	begin
		dc := dc + 1;
		yytext[yyleng - 1] := #0;

		i := 5;
		while yytext[i] <> '"' do
			i := i + 1;
		i := i + 1;
		pbuf := yy_new_filebuf(pchar(yytext + sizeof(char) * i));
		if pbuf = nil then 
			writeln('Error: failed to open file `',
				pchar(yytext + i * sizeof(char)), '''')
		else 
			yy_switch_buffer(pbuf);
		
	end;
{sdec}		ic := ic + 1;
{num}		rc := rc + 1;
{opr}		oc := oc + 1;
<<EOF>>		begin
		yy_delete_buffer();
		writeln('number of integers: ', ic);
		writeln('number of reals: ', rc);
		writeln('number of operators: ', oc);
		writeln('number of discarded symbols: ', dc);
		writeln('number of matched patterns: ', mc);
		result := FEOF;
		exit;
	end;

.|\n		dc := dc + 1;
%%

Start: Start FEOF 
	| FEOF
	;

%%

<</templ>>

<<templ "testexe-basic-extr-numopr-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;

	<<prefix/>>parse();
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "basic-fdc-template">>
<<desc/>>
/****************************************************************************
*	sample program: calculator for integers and reals
*	the purpose of this is to show how to use following features of upgen
*			%left %right %nonassoc %type
*			%prec %parse-init %parse-exit
*****************************************************************************/

%header%{

uses Math, SysUtils, StrUtils;

type
	xnum_t = record
		case nType: integer of
		0: (nVal: integer);
		1: (dVal: real);
	end;	
%}

%{

const
	NT_INT = 0;
	NT_REAL = 1;
%}

%union%{
	case byte of
	0: (nVal: integer);
	1: (dVal: real);
	2: (xNum: xnum_t);
%}
%yywrap%{
	yy_delete_buffer();
	result := false;
%}

%lvar-decl%{
	i: integer;
	pbuf: YYPBUFFER;
%}
%pvar-decl%{
	berror: boolean;
	errors: integer;
	str_fmt: string;
%}
%pvar-init%{
	berror := false;
	errors := 0;
%}


udec	[0-9]+
frct	\.{udec}
ureal	{udec}{frct}
opr	[\+\-\*\/\^\(\)]

%token<nVal> TK_INT
%token<dVal> TK_REAL

<<token_decl/>>
<<parse_init/>>
<<parse_exit/>>

%type<xNum> Expr

<<type_decl/>>

<<other_decl/>>

%%

"#open"[ \t]*\"[^\"\'\n]+\"	begin

		repeat
			i := yyinput;
		until (i = 10) or (i = END_OF_FILE);
		
		yy_set_bol(true);

		yytext[yyleng - 1] := #0;

		i := 5;
		while yytext[i] <> '"' do
			i := i + 1;
		i := i + 1;
		pbuf := yy_new_filebuf(pchar(yytext + sizeof(char) * i));
		
		if pbuf = nil then 
			writeln('Error: failed to open file `', pchar(yytext + i * sizeof(char)), '''')
		else
			yy_switch_buffer(pbuf);

	end;
{udec}		yylval.nVal := strtoint(yytext);

			write(yytext);
			result := TK_INT;
			exit;

{ureal}		yylval.dVal := strtofloat(yytext);
			write(yytext);
			result := TK_REAL;
			exit;
		
{opr}		write(yytext[0]);
			result := ord(yytext[0]);
			exit;

\n			writeln;		
			result := 10;
			exit;
[ \t]		write(yytext[0]);

.

%%

Task: Lines		%{
<<type_action_0/>>
	%}
	;

Lines: Lines Line	%{
<<type_action_1/>>
	%}
	|		%{
<<type_action_2/>>
	%}
	;
Line: Expr '\n'		%{
		if not berror then begin
			if $1.nType = NT_INT then begin
				str_fmt := format(#9#9'%d[INT]', [$1.nVal]);
				writeln(str_fmt);
			end
			else begin
				str_fmt := format(#9#9'%15.4f[REAL]', [$1.dVal]);
				writeln(str_fmt);
			end;
		end
		else errors := errors + 1;

		berror := false;
	%}
	| error '\n'	%{

		if berror then errors := errors + 1;

		berror := false;
		yyerrok;
	%}
	| '\n'		%{
		berror := false;
	%}
	;

Expr: Expr '+' Expr	%{
		if not berror then begin

			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				$$.nVal := $1.nVal + $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then 
					$$.dVal := $1.nVal + $3.dVal
				else if $3.nType = NT_INT then
					$$.dVal := $1.dVal + $3.nVal
				else
					$$.dVal := $1.dVal + $3.dVal;
			end;
		end;
	%}
	| Expr '-' Expr	%{
		if not berror then begin
			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				$$.nVal := $1.nVal - $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then
					$$.dVal := $1.nVal - $3.dVal
				else if $3.nType = NT_INT then
					$$.dVal := $1.dVal - $3.nVal
				else
					$$.dVal := $1.dVal - $3.dVal;
			end;
		end;
	%}
	| Expr '*' Expr	%{

		if not berror then begin
			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				$$.nVal := $1.nVal * $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then
					$$.dVal := $1.nVal * $3.dVal
				else if $3.nType = NT_INT then
					$$.dVal := $1.dVal * $3.nVal
				else
					$$.dVal := $1.dVal * $3.dVal;
			end;
		end;
	%}
	| Expr '/' Expr	%{

		if not berror then begin
			if ($1.nType = NT_INT) and ($3.nType = NT_INT) then begin
				$$.nType := NT_INT;
				if $3.nVal = 0 then begin
					writeln('Error: divided by zero!');
					berror := true;
				end
				else
					$$.nVal := $1.nVal div $3.nVal;
			end
			else begin
				$$.nType := NT_REAL;
				if $1.nType = NT_INT then
					$$.dVal := $1.nVal / $3.dVal
				else if $3.nType = NT_INT then begin
					if $3.nVal = 0 then begin
						writeln('Error: divided by zero!');
						berror := true;
					end
					else
						$$.dVal := $1.dVal / $3.nVal;
				end
				else
					$$.dVal := $1.dVal / $3.dVal;
			end;
		end;
	%}
	| Expr '^' Expr %{

		if not berror then begin
			$$.nType := NT_REAL;
			try
				if $1.nType = NT_INT then begin
					if $3.nType = NT_INT then
						$$.dVal := power($1.nVal, $3.nVal)
					else
						$$.dVal := power($1.nVal, $3.dVal);
				end
				else begin
					if $3.nType = NT_INT then
						$$.dVal := power($1.dVal, $3.nVal)
					else
						$$.dVal := power($1.dVal, $3.dVal);
				end;
			except
			on EOverFlow do
				begin
					writeln('Error: number is out of range.');
					berror := true;
				end;
			else begin
					writeln('Error: domain error, x is negative while y is non-integer.');
					berror := true;
				end;
			end;
		end;
	%}
	| '(' Expr ')'	%{

		if not berror then begin
			$$.nType := $2.nType;
			if $2.nType = NT_INT then
				$$.nVal := $2.nVal
			else
				$$.dVal := $2.dVal;
		end;
	%}
	| '+' <<prec_refer/>> Expr	%{

		if not berror then begin
			$$.nType := $2.nType;
			if $2.nType = NT_INT then
				$$.nVal := $2.nVal
			else
				$$.dVal := $2.dVal;
		end;
	%}
	| '-' <<prec_refer/>> Expr	%{

		if not berror then begin
			$$.nType := $2.nType;
			if $2.nType = NT_INT then
				$$.nVal := 0 - $2.nVal
			else
				$$.dVal := 0 - $2.dVal;
		end;
	%}
	| TK_INT		%{
		$$.nType := NT_INT;
		$$.nVal := $1;
	%}
	| TK_REAL		%{
		$$.nType := NT_REAL;
		$$.dVal := $1;
	%}
	;
%%

<</templ>>


<<templ "testexe-basic-fdc-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;

	<<prefix/>>parse();
<<after_buffer_usage/>>

end.

<</templ>>



<<templ "interface-scanner-template">><<desc/>>
%{
<<init_code/>>
%}
<<declare_section/>>
%%
<<lex_section/>>
%%

Start: /* empty */

%%
<<code_section/>>

<</templ>>


<<templ "testexe-interface-scanner-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
<<before_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;

	<<after_init/>>
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-bstack-template">>
/*
	sample program: test buffer operations
	feature to test:
		yy_current_buffer, yy_has_buffer, yy_push_buffer, yy_pop_buffer,
		yy_new_filebuf, yy_new_cstrbuf, yy_new_strbuf, yy_switch_buffer,
		yy_delete_buffer
*/


%{

uses SysUtils, StrUtils;

<<generic_vector_decl/>>
<<generic_vector_def/>>

procedure initregistry; forward;
procedure regbuffer(pbuf: YYPBUFFER; pbname: pchar; sz: integer); forward;
function buffername(pbuf: YYPBUFFER): pchar; forward;
procedure clearregistry; forward;

var
	pbn: pchar;
	vbufname: vector_t;
	temp_buffer: pchar = nil;
%}

%lvar-decl%{
	i, j, d: integer;
	pbuf: YYPBUFFER;
%}

%yywrap%{
	pbn := buffername(yy_current_buffer);
	if pbn <> nil then
		writeln('buffer `', pbn, ''' is coming.');
	result := false;
%}

%x	RSTRT

fname	\`[^\"\'\`\n\r]+\`
str	\"[^\"\'\`]+\"
cstr	\'[^\"\'\`]+\'
bname	[[:cidf:]][[:cids:]]*


%parse-init%{

	initregistry;
	temp_buffer := nil;
	regbuffer(yy_current_buffer(), 'test', 4);
	
%}

%parse-exit%{

	clearregistry;
	if temp_buffer <> nil then
		freemem(temp_buffer);
	
%}

%token FEOF

%%

{bname}">"[ \t]*"open"[ \t]+{fname}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '`' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_filebuf(pchar(yytext + i * sizeof(char)), false);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for file `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"push"[ \t]+{fname}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '`' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_filebuf(pchar(yytext + sizeof(char) * i), false);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for file `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		end;
	end;
		
{bname}">"[ \t]*"open"[ \t]+{str}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '"' do
			i := i - 1;
		i := i + 1;

		d := yyleng - i;
		if temp_buffer <> nil then
			freemem(temp_buffer);

		getmem(temp_buffer, d * sizeof(char));
		
		d := d - 1;
		move(pchar(yytext + sizeof(char) * i)^, temp_buffer^, d);
		temp_buffer[d] := #0;
		

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_strbuf(temp_buffer, d);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"push"[ \t]+{str}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '"' do
			i := i - 1;
		i := i + 1;

		d := yyleng - i;
		if temp_buffer <> nil then
			freemem(temp_buffer);

		getmem(temp_buffer, d * sizeof(char));
		
		d := d - 1;
		move(pchar(yytext + sizeof(char) * i)^, temp_buffer^, d);
		temp_buffer[d] := #0;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_strbuf(temp_buffer, sizeof(char) * d);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"open"[ \t]+{cstr}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '''' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_cstrbuf(pchar(yytext + sizeof(char) * i), yyleng - i);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for constant string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_switch_buffer(pbuf);
		end;
	end;

{bname}">"[ \t]*"push"[ \t]+{cstr}	begin

		yytext[yyleng - 1] := #0;
		i := yyleng - 3;
		while yytext[i] <> '''' do
			i := i - 1;
		i := i + 1;

		j := 1;
		while yytext[j] <> '>' do
			j := j + 1;
		yytext[j] := #0;

		pbuf := yy_new_cstrbuf(pchar(yytext + i * sizeof(char)), yyleng - i);
		if pbuf = nil then begin
			writeln('Error: failed create buffer for constant string `', yytext, '''.');
			YYABORT;
		end
		else begin
			regbuffer(pbuf, yytext, j);
			yy_push_buffer(pbuf);
		end;
	end;

"has?"		begin
		if yy_has_buffer then
			writeln('Yes, there are buffers!')
		else begin
			writeln('Oh, no! It''s impossible!!!');
			YYABORT;
		end;
	end;

"cur?"		begin
		pbn := buffername(yy_current_buffer);
		if pbn <> nil then
			writeln('current buffer: ', pbn)
		else begin
			writeln('Oh, no name for current buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;

"close"		begin
		pbn := buffername(yy_current_buffer);
		if pbn <> nil then begin
			writeln('closing buffer ', pbn, ' ...');
			yy_delete_buffer;
			if yy_has_buffer then begin
				pbn := buffername(yy_current_buffer);
				if pbn <> nil then
					writeln('switching to buffer ', pbn, ' ...')
				else begin
					writeln('Oh, no name for to-be-switched buffer! It''s impossible!!!');
					YYABORT;
				end;
			end;
		end
		else begin
			writeln('Oh, no name for to-be-deleted buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;
"abort"		begin
		writeln('program exit abnormal ...');
		YYABORT;
	end;
"pop"		begin
		pbn := buffername(yy_current_buffer());
		if pbn <> nil then begin
			writeln('popping buffer ', pbn, ' ...');
			yy_pop_buffer;
			if yy_has_buffer then begin
				pbn := buffername(yy_current_buffer);
				if pbn <> nil then
					writeln('switching to buffer ', pbn, ' ...')
				else begin
					writeln('Oh, no name for to-be-switched buffer! It''s impossible!!!');
					YYABORT;
				end;
			end;
		end
		else begin
			writeln('Oh, no name for to-be-popped buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;

"restart"	begin

			pbn := buffername(yy_current_buffer);
		if pbn <> nil then begin
			writeln('restarting buffer ', pbn, ' ...');
			
			yyrestart();
			YYBEGIN(RSTRT);
		end
		else begin
			writeln('Oh, no name for to-be-restarted buffer! It''s impossible!!!');
			YYABORT;
		end;
	end;

<*>.|\n		write(yytext);

<RSTRT><<EOF>>	begin
		pbn := buffername(yy_current_buffer());
		if pbn <> nil then
			writeln('buffer `', pbn, ''' is abort to leave.');
		YYBEGIN(INITIAL);
		yy_delete_buffer();
		result := FEOF;
		exit;
	end;

<*><<EOF>>	begin
		pbn := buffername(yy_current_buffer());
		if pbn <> nil then
			writeln('buffer `', pbn, ''' is abort to leave.');
		yy_delete_buffer();
		result := FEOF;
		exit;
	end;

%%

Start: Texts %{
		if yy_has_buffer then begin
			writeln('There are still buffers!');
			YYABORT;
		end
		else
			writeln('All buffers closed.');
	%}
	;

Texts: Texts FEOF
	|
	;

%%

procedure initregistry;
begin
	vbufname := vector_t.create(sizeof(pchar));
	
end;

procedure regbuffer(pbuf: YYPBUFFER; pbname: pchar; sz: integer);
var
	pc: pchar;
begin

	if pbuf <> nil then begin
		getmem(pc, (sz + 1) * sizeof(char));
		move(pbname^, pc^, sz);
		pc[sz] := #0;

		vbufname.push_back(pc);
		
		pbuf.setdata(pointer(vbufname.size - 1));
	end;
end;

function buffername(pbuf: YYPBUFFER): pchar;
var
	n: integer;
	p: pchar;
begin
	
	if pbuf <> nil then begin
		n := integer(pbuf.getdata());
		if n < vbufname.size then begin
			vbufname.getat(n, p);
			buffername := p;
		end;
	end
	else buffername := nil;
end;

procedure clearregistry;
var
	i: integer;
	p: pchar;
begin
	for i := 0 to vbufname.size - 1 do
	begin
		p := nil;
		vbufname.getat(i, p);
		if p <> nil then
			freemem(p);
	end;
	vbufname.destroy;
end;

<</templ>>


<<templ "testexe-interface-bstack-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
<<before_init/>>
	if <<prefix/>><<buffer_init3/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;

<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-echo-template">>
/*
 *	sample program: test ECHO
 */

num	[0-9]+
xnum	0x[0-9]{2}

%%

^{num}	YYECHO;

{xnum}	YYECHO;
\n		YYECHO;
.		YYECHO;

%%

Start:
	;
%%

<</templ>>

<<templ "testexe-interface-echo-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-getbol-template">>
/*
 *	sample program: test yy_get_bol
 */
 
%{
uses SysUtils, StrUtils;
%}

num	[0-9]+
xnum	0x[0-9]{2}

%lvar-decl{
	n: integer;
%}

%%

^{num}		n := strtoint(yytext);
		if n <> yylloc.firstLine then
			writeln('Error: at ', yylloc.firstLine, ':', yylloc.firstColumn, ' failed to verify line number.');

{xnum}		n := strtoint(yytext + 2 * sizeof(char));
		if n <> yylloc.firstLine then
			writeln('Error: at ', yylloc.firstLine, ':', yylloc.firstColumn, ' failed to verify line number.');

\n		if not yy_get_bol then
			writeln('Error: at ', yylloc.firstLine, ':', yylloc.firstColumn, ' failed to verify value of bol.');

.

%%

Start:
	;
%%

<</templ>>

<<templ "testexe-interface-getbol-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-line-editor-template">>
/*
	sample program: special line editor
	feature to test: yymore yyless  yyinput yyterminate /
*/

%{
uses SysUtils, StrUtils;
%}

%lvar-decl%{
	c, n: integer;
%}

%%

"&"		yyleng := yyleng - 1;
		if yyleng > 0 then begin
			yytext[yyleng] := #0;
			write(yytext);
		end;
		
"&&"	yyleng := yyleng - 1;
		yytext[yyleng] := #0;
		yymore;
		
"&!"	yyleng := yyleng - 1;
		yytext[yyleng - 1] := '!';
		yytext[yyleng] := #0;
		yymore;
		
"&@"	yyleng := yyleng - 1;
		yytext[yyleng - 1] := '@';
		yytext[yyleng] := #0;
		yymore;
		
"!!"	yyleng := yyleng - 2;
		yytext[yyleng] := #0;
		if yyleng > 0 then
			write(yytext);

		repeat
			c := yyinput;
		until (c = 10) or (c = END_OF_FILE);
		
		if c = 10 then begin
			writeln;
			yy_set_bol(true);
		end;
		
"!!!"	yyleng := yyleng - 3;
		yytext[yyleng] := #0;
		if yyleng > 0 then
			write(yytext);
		yyterminate;


[^\@\&\!\n]+/"@"[0-9][0-9]

		yytext[yyleng] := #0;
		write(yytext);
		
		n := strtoint(pchar(yytext + sizeof(char)* (yyleng + 1)));

		if n > 0 then begin
			if n > yyleng then
				n := yyleng;
			yytext[n] := #0;
			write(yytext);
		end;
		// throw away 3 chars followed: @##
		yyinput;
		yyinput;
		yyinput;

[^\@\&\!\n]+/"@-"[0-9][0-9]

		yytext[yyleng] := #0;
		yylaleng := yyleng;
		
		n := strtoint(pchar(yytext + sizeof(char) * (yyleng + 2)));

		write(yytext);

		n := yyleng - n;
		if (n > 0) and (n < yyleng) then
			yyless(n);
			
[^\@\&\!\n]+/"!"[0-9][0-9]

		n := strtoint(pchar(yytext + sizeof(char) * (yyleng + 1)));

		if n > yyleng then
			n := yyleng;

		yyleng := yyleng - n;
		yytext[yyleng] := #0;

		if yyleng > 0 then 
			write(yytext);
		// throw away 3 chars followed: @##
		yyinput;
		yyinput;
		yyinput;

"@-"[0-9][0-9]
		yyleng := yyleng - 4;
		yytext[yyleng] := #0;
		yymore;			

.		yymore;

\n		write(yytext);
		

<<EOF>>
		if yyleng > 0 then
			write(yytext);
		flush(output);
%%

Start: /* empty */
	;

%%

<</templ>>


<<templ "testexe-interface-line-editor-template">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-loc2-template">>
/*
	sample program: location counter 2
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
		yyinput yyunput yyunget
*/

%header%{

{$H+}

uses SysUtils, StrUtils;

type

	loc_pair_t = record
		line: integer;
		col: integer;
	end;
<<generic_vector_decl/>>

type
	vlpair_t = vector_t;
	vpvlp_t = vector_t;
%}

%{
<<char_handling_routines/>>
<<generic_vector_def/>>


%}



%union%{
	case byte of
	0: (locVal: loc_pair_t);
	1: (nVal: integer);
	2: (pvpVal: vlpair_t);
%}

%lvar-decl%{
var
	i: integer;
	n: integer;
%}

%pvar-decl%{
var
	pLoc: vlpair_t;
	pr1, pr2: loc_pair_t;
	i: integer;
%}

%parse-init%{
	vvprLocs := vector_t.create(sizeof(vlpair_t));
%}

%parse-exit%{
	for i := 0 to vvprLocs.size - 1 do
	begin
		vvprLocs.getat(i, pLoc);
		pLoc.destroy;
	end;
	vvprLocs.destroy;		
%}

%formal-param%{var vvprLocs: vpvlp_t; var strBuf: string; var nLastLoc: integer %}
%actual-param%{ vvprLocs, strBuf, nLastLoc %}

locn	[[:alnum:]]{2}[[:digit:]]
num	[[:digit:]]+

%x	LOC_SC
%x	TOL_SC
%x	PUT_SC

%token LOC_HEAD LOC_TAIL PUT_TAIL
%token TR_TAIL LR_TAIL OR_TAIL
%token<nVal> TR_HEAD LR_HEAD OR_HEAD
%token<locVal> LOCN

%type<pvpVal> TabLine
%%

"#location_head"[ \t]*\r?\n		begin

		YYBEGIN(LOC_SC);
		result := LOC_HEAD;
		exit;
	end;

<LOC_SC>"#location_tail"[ \t]*\r?\n	begin

		YYBEGIN(INITIAL);
		result := LOC_TAIL;
		exit;
	end;

"#line_replace"[ \t]+{num}[ \t]*\r?\n	|
"#orignal"[ \t]+{num}[ \t]*\r?\n	|
"#tab_replace"[ \t]+{num}[ \t]*\r?\n	begin

		yyset_lineno(1);
		yyset_colno(1);
		writeln('after reseting, line: ', yyget_lineno, #9'col: ', yyget_colno);

		i := yyleng - 2;
		while not isdigit(yytext[i]) do
			i := i - 1;
		yytext[i + 1] := #0;
		
		while isdigit(yytext[i]) do
			i := i - 1;
		i := i + 1;

		yylval.nVal := strtoint(pchar(yytext + sizeof(char) * i));
		
		strBuf := '';

		YYBEGIN(TOL_SC);

		case yytext[1] of
		'l': begin
				result := LR_HEAD;
				exit;
			end;
		'o': begin
				result := OR_HEAD;
				exit;
			end;
		else begin
				result := TR_HEAD;
				exit;
			end;
		end;
	end;

<TOL_SC>"#line_replace"[ \t]*\r?\n	|
<TOL_SC>"#orignal"[ \t]*\r?\n		|
<TOL_SC>"#tab_replace"[ \t]*\r?\n	begin

		strBuf := strBuf + string(yytext);

		YYBEGIN(INITIAL);

		case yytext[1] of
		'l': begin
				result := LR_TAIL;
				exit;
			end;
		'o': begin
				result := OR_TAIL;
				exit;
			end;
		else begin
				result := TR_TAIL;
				exit;
			end;
		end;
	end;

<PUT_SC>"#line_replace"			|
<PUT_SC>"#orignal"			|
<PUT_SC>"#tab_replace"		begin

		YYBEGIN(INITIAL);
		result := PUT_TAIL;
		exit;
	end;

"tab?"				begin
		writeln('tabsize = ', yyget_tabsize());
	end;

"tab="[[:digit:]]		begin

		n := ord(yytext[4]) - 48;
		yyset_tabsize(n);
		writeln('tabsize is ', yyget_tabsize(), ' now');
	end;

<*>{locn}		begin
		if isdigit(yytext[0]) then  begin
			yylval.locVal.line := ord(yytext[0]) - 48;
		end
		else  if islower(yytext[0]) then begin
			yylval.locVal.line := ord(yytext[0]) - 87;
		end
		else begin
			yylval.locVal.line := ord(yytext[0]) - 29;
		end;


		if isdigit(yytext[1]) then begin
			yylval.locVal.col := (ord(yytext[1]) - 48) * 10 + ord(yytext[2]) - 48;
		end
		else if islower(yytext[1]) then begin
			yylval.locVal.col := (ord(yytext[1]) - 97) * 10 + 100 + ord(yytext[2]) - 48;
		end
		else begin
			yylval.locVal.col := (ord(yytext[1]) - 65) * 10 + 360 + ord(yytext[2]) - 48;
		end;

		if YYSTART = TOL_SC then
			strBuf := strBuf + string(yytext);

		result := LOCN;
		exit;
	end;

<*>.|\n		begin
		if YYSTART = TOL_SC then
			strBuf := strBuf + string(yytext);
	end;

%%

File:	File Section
	| Section
	;

Section: LocSect
	| RLSect
	| RTSect
	| OrgSect
	| TabLine PUT_TAIL	%{
		if nLastLoc < 0 then begin
			writeln('Error: OOPS!!!');
		end
		else begin
			vvprLocs.getat(nLastLoc, pLoc);
			writeln('begin comparing location(size ', pLoc.size, 
				') ', nLastLoc, ' and its referrence(size ', $1.size, ')');
			i := 0;
			while (i < $1.size) and (i < pLoc.size) do
			begin
				pLoc.getat(i, pr1);
				$1.getat(i, pr2);
				if (pr1.line <> pr2.line) or (pr1.col <> pr2.col) then
					writeln('refer.line = ', pr2.line, #9'refer.col = ', pr2.col,
						#9'Loc.line = ', pr1.line, #9'Loc.col = ', pr1.col);
				i := i + 1;
			end;
		end;
		$1.destroy;
	%}
	;

LocSect: LOC_HEAD
	 %{ nLastLoc := -1; %}
	 TabLine LOC_TAIL	%{
		vvprLocs.push_back($3);
	%}
	;
RLSect: LR_HEAD
	 %{
		nLastLoc := -2;
		writeln('begin scanning line_replace section by referrence ', $1);
	 %}
	 TabLine LR_TAIL		%{
		nLastLoc := $1;
		writeln('before putback, line: ', yyget_lineno, #9'col: ', yyget_colno);
		if length(strBuf) > 0 then begin
			for i := length(strBuf) downto 1 do
			begin
				if strBuf[i] <> #10 then
					yyunget()
				else
					yyunput('*');
			end;
		end;
		
		strBuf := '';
		writeln('after putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		writeln('scanning line_replace section is over');
		YYBEGIN(PUT_SC);
	%}
	;
RTSect: TR_HEAD
	 %{
		nLastLoc := -3;
		writeln('begin scanning tab_replace section by referrence ', $1);
	 %}
	 TabLine TR_TAIL		%{
		nLastLoc := $1;
		writeln('before putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());

		if length(strBuf) > 0 then begin
			for  i := length(strBuf) downto 1 do begin
				if strBuf[i] <> #9 then
					yyunget()
				else
					yyunput('*');
			end;
		end;
		strBuf := '';

		writeln('after putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		writeln('scanning tab_replace section is over');

		YYBEGIN(PUT_SC);
	%}
	;
OrgSect: OR_HEAD
	 %{
		nLastLoc := -4;
		writeln('begin scanning orignal section by referrence ', $1);
	 %}
	 TabLine OR_TAIL 	%{
	 
		nLastLoc := $1;
		writeln('before putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		if length(strBuf) > 0 then begin
			for i := length(strBuf) downto 1 do
				yyunget();
		end;
		strBuf := '';
		writeln('after putback, line: ', yyget_lineno(), #9'col: ', yyget_colno());
		writeln('scanning orignal section is over');

		YYBEGIN(PUT_SC);
	%}
	;

TabLine: TabLine LOCN	%{
		if nLastLoc >= -1 then begin
			$$ := $1;
			if nLastLoc > -1 then
			begin
				pr1.line := @2.firstLine;
				pr1.col := @2.firstColumn;
				$$.push_back(pr1);
			end
			else begin
				$$.push_back($2);
			end;
		end
		else begin
			if (@2.firstLine <> $2.line) or (@2.firstColumn <> $2.col) then
				writeln('`@2.firstLine = ', @2.firstLine, #9'`@2.firstColumn = ', @2.firstColumn,
						#9'Loc.line = ', $2.line, #9'Loc.col = ', $2.col);
		end;
	%}
	| LOCN		%{
		if nLastLoc >= -1 then begin
			$$ := vector_t.create(sizeof(loc_pair_t));
			if nLastLoc > -1 then begin
				pr1.line := @1.firstLine;
				pr1.col := @1.firstColumn;
				$$.push_back(pr1);
			end
			else begin
				$$.push_back($1);
			end
		end
		else begin
			if (@1.firstLine <> $1.line) or (@1.firstColumn <> $1.col) then begin
				
				writeln('`@1.firstLine = ', @1.firstLine, #9'`@1.firstColumn = ', @1.firstColumn, 
						#9'Loc.line = ', $1.line, #9'Loc.col = ', $1.col);
			end;
		end;
	%}
	;
%%


<</templ>>

<<templ "testexe-interface-loc2-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

var
	vpvlp: vpvlp_t;
	strBuf: string = '';
	nLoc: integer = -1;

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse(vpvlp, strBuf, nLoc);
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-location-template">>
/*
	sample program: location counter
	feature to test: yyget_lineno, yyset_lineno,
		yyget_columnno, yyset_columnno
		yyget_tabsize, yyset_tabsize
*/
%header%{
{$H+}
uses SysUtils;

type
	locVal_t = record
		line: integer;
		col: integer;
	end;
	

%}

%lvar-decl%{
	n: integer;
	pbuf: YYPBUFFER;
%}

fname	"<"[^\<\>\n\*\/\\\?]+">"
locn	[[:digit:]]{3}

%yywrap%{ result := false; %}

%union%{
	case boolean of
	true: (locVal: locVal_t);
	false: (nVal: integer);
%}

%token TABGET TABSET FOPENED FCLOSED
%token<locVal> LOCN

%%

"tab?"		writeln('tabsize = ', yyget_tabsize);
			result := TABGET;
			exit;

"tab="[[:digit:]]	n := ord(yytext[4]) - 48;
			yyset_tabsize(n);
			writeln('tabsize is ', yyget_tabsize(), ' now');
			result := TABSET;
			exit;

{fname}		yytext[yyleng - 1] := #0;
			pbuf := yy_new_filebuf(pchar(yytext + sizeof(char)));
			if pbuf = nil then begin
				writeln('Error: failed to open file `', pchar(yytext + 1), '`');
				result := -1;
				exit;
			end
			else begin
				writeln('file `', pchar(yytext + sizeof(char)), '` is open.');
			end;
		
			yy_switch_buffer(pbuf);
			result := FOPENED;
			exit;

{locn}			yylval.locVal.line := ord(yytext[0]) - 48;
			yylval.locVal.col := (ord(yytext[1]) - 48) * 10 + ord(yytext[2]) - 48;
			result := LOCN;
			exit;

\n			result := 10;
			exit;

.

<<EOF>>			yy_delete_buffer();
				writeln('file closed.');
				result := FCLOSED;
				exit;

%%

Files:	Files File FCLOSED
	| File FCLOSED
	;

File:	File Line
	| Line
	;

Line:	FOPENED
	| TabLine '\n'
	;
TabLine: TabLine TLItem
	| TLItem
	;

TLItem: TABGET
	| TABSET
	| LOCN	%{
		if (@1.firstLine <> $1.line) or (@1.firstColumn <> $1.col) then begin
			writeln('Error: failed to verify location information. `@1.firstLine = ', @1.firstLine,
				#9'`@1.firstColumn = ', @1.firstColumn,
				#9'Loc.line = ', $1.line, #9'Loc.col = ', $1.col);
		end;
	%}
	;

%%

<</templ>>


<<templ "testexe-interface-location-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.

<</templ>>


<<templ "interface-yyerror-template">>
/*
 *	sample program: test yyerror
 */

%header%{
uses SysUtils, StrUtils;
procedure myerror(msg: string);

%}

num	[[:digit:]]+
cid	[A-Za-z_][A-Za-z_0-9]*

%token NUM CID

%%

{num}	result := NUM;
		exit;
{cid}	result := CID;
		exit;

[ \t]
\r?\n	result := 10;
		exit;
.

%%

Lines: Lines Line
	|
	;
Line: Numbers '\n'
	;
Numbers: Numbers Unit
	|
	;
Unit: NUM
	| error '\n' %{
		yyerrok();
	%}
	;
%%

procedure myerror(msg: string);
begin
	
	writeln('Redirect to my error-handler ---- ', msg);
end;


<</templ>>

<<templ "testexe-interface-yyerror-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	yyseterror(myerror);
	<<prefix/>>parse;
	
<<after_buffer_usage/>>

end.
<</templ>>

<<templ "esc-char-inaction-template">>
/*
	feature to test: using escape char, transform meta-symbols such as
		 $$, $n, @$, @n, %}, $<..>$, $<...>n
		to literal text in %{ %} embraced actions
*/

%header%{
uses SysUtils, StrUtils;
//in declaration header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}

%{

//in definition header: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}

%lex-init%{
	writeln('in lex-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%pre-match%{
	writeln('in pre-match: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%lvar-decl%{
	//writeln('in lexvar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}
%lvar-init%{
	writeln('in lexvar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%yywrap%{
	writeln('in yywrap: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%destructor%{
	writeln('in destruct<>: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%} <>

%parse-init%{
	writeln('in parse-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%parse-exit%{
	writeln('in parse-exit: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%union%{
	//in SVT defintion: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
	nVal: integer;
	pchVal: pchar;
%}

%location%{
	//in location type definiton: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
	firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
%}

%pvar-decl%{
	//writeln('in parsevar-decl: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}
%pvar-init%{
	writeln('in parsevar-init: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}');
%}

%formal-param%{var n: integer
//in formal-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}
%actual-param%{n
//in actual-param: `$$ `$0 `$12 `$<nVal>$ `$<nVal>3 `%} `@4 `@$ `%}
%}

%token<pchVal> NUM
%token<pchVal> CID

%type<nVal> Symbols

%%

[[:digit:]]+	begin
		getmem(yylval.pchVal, yyleng + 1);
		strlcopy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] := #0;

		result := NUM;
		exit;
	end;
	
[[:cidf:]][[:cids:]]*	begin
		getmem(yylval.pchVal, yyleng + 1);
		strlcopy(yylval.pchVal, yytext, yyleng);
		yylval.pchVal[yyleng] := #0;

		result := CID;
		exit;
	end;
.|\n

%%

Start: Symbols
	;
Symbols: Symbols CID	%{
		n := n + 1;
		writeln('`$2 is a C-style ID, its value is ', $2);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	| Symbols NUM	%{
		$$ := $$ + 1;
		writeln('`$2 is a number, its value is ', $2);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	| CID		%{
		n := 1;
		writeln('`$1 is a C-style ID, its value is ', $1);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	| NUM		%{
		$$ := 1;
		writeln('`$1 is a number, its value is ', $1);
		writeln('`$$ is used to count number of numbers, and `$$ is ', $$);
	%}
	;

%%

<</templ>>

<<templ "testexe-esc-char-inaction-template">>
program testexe;

{$APPTYPE CONSOLE}
{$H+}

uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

var
	ncnt: integer;

begin
<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	ncnt := 0;
	<<prefix/>>parse(ncnt);
	
<<after_buffer_usage/>>

end.
<</templ>>


<<templ "script-empty-sect-2">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/

%header%{

{$H-}

uses SysUtils, StrUtils;
var
	s_pfile: ^text = nil;
function myinput: integer;
%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ writeln(#9#9, $1); %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ := $1; %}
	| Number Digit	%{ $$ := $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ := 0; %}
	| '1'		%{ $$ := 1; %}
	| '2'		%{ $$ := 2; %}
	| '3'		%{ $$ := 3; %}
	| '4'		%{ $$ := 4; %}
	| '5'		%{ $$ := 5; %}
	| '6'		%{ $$ := 6; %}
	| '7'		%{ $$ := 7; %}
	| '8'		%{ $$ := 8; %}
	| '9'		%{ $$ := 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
%%

function myinput: integer;
var
	c: char;
begin

	if s_pfile = nil then begin
		myinput := 0;
		exit;
	end;

	read(s_pfile^, c);

	if c = PAS_EOF__ then myinput := 0
	else myinput := ord(c);

end;

<</templ>>

<<templ "testexe-script-empty-sect-2">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_myinput/>>
	<<prefix/>>setlex(myinput);
	<<prefix/>>parse();
	
	if (s_pfile <> nil ) and (s_pfile <> @input) then
	begin
		closefile(s_pfile^);
		dispose(s_pfile);
	end;
end.

<</templ>>

<<templ "script-only-3-sections">>

/*************************************************************************
feature to test: scannerless parser (section 2 of script is empty)
	 	 without user-code section
**************************************************************************/
%header%{

{$H-}

uses SysUtils, StrUtils;
var
	s_pfile: ^text = nil;

function myinput: integer;
%}

%{


function myinput: integer;
var
	c: char;
begin

	if s_pfile = nil then begin
		myinput := 0;
		exit;
	end;

	read(s_pfile^, c);

	if c = PAS_EOF then myinput := 0
	else myinput := ord(c);

end;

%}

%start Lines

%type<nVal> Digit Number

%%
%%

Lines: Lines Line
	|
	;

Line:	Number		%{ writeln(#9#9, $1); %}
	| error Space 	%{ yyerrok(); %}
	| Space
	;

Number: Digit		%{ $$ := $1; %}
	| Number Digit	%{ $$ := $1 * 10 + $2; %}
	;

Digit:	'0'		%{ $$ := 0; %}
	| '1'		%{ $$ := 1; %}
	| '2'		%{ $$ := 2; %}
	| '3'		%{ $$ := 3; %}
	| '4'		%{ $$ := 4; %}
	| '5'		%{ $$ := 5; %}
	| '6'		%{ $$ := 6; %}
	| '7'		%{ $$ := 7; %}
	| '8'		%{ $$ := 8; %}
	| '9'		%{ $$ := 9; %}
	;
Space:	' ' | '\t' | '\r' | '\v' | '\n'
	;
<</templ>>

<<templ "testexe-script-only-3-sections">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_myinput/>>
	<<prefix/>>setlex(myinput);
	<<prefix/>>parse();
	
	if (s_pfile <> nil ) and (s_pfile <> @input) then
	begin
		closefile(s_pfile^);
		dispose(s_pfile);
	end;
end.

<</templ>>


<<templ "script-empty-sect-3">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{

%}

%%
.|\n	write(yytext);
%%

<</templ>>

<<templ "testexe-script-empty-sect-3">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>lex;
	<<after_buffer_usage/>>
end.

<</templ>>

<<templ "script-dprec-rrc">>
/*
testing program: extract parentheses from expression, and convert them to brackets
	the purpose of this program is to show how to resolve reduce-reduce conflicts
	by %dprec
*/

%left '(' ')'
%%

[\(\)]		begin 
				result := ord(yytext[0]);
				exit;
			end;
			
\n			writeln;
.			write(yytext[0]);
%%

Program: PExpr %dprec 2 %{
		writeln('Done!');
		YYACCEPT;
	%}
	;
PExpr: PExpr PExpr %dprec 3
	| '(' 
	%{ write('['); %}
	PExpr ')' %{ write(']'); %}
	| %dprec 1
	;
%%

<</templ>>

<<templ "testexe-script-dprec-rrc">>
program testexe;

{$APPTYPE CONSOLE}


uses SysUtils,
	script in 'script.pas'; { parsing classes and routines }

<<main_var_decl/>>
<<local_var_decl/>>

begin
	<<before_buffer_init/>>
	if <<prefix/>><<buffer_init/>> <> 0 then begin
		writeln('Error: failed to initialize scanner.');
		halt(1);
	end;
	
	<<prefix/>>parse;
	<<after_buffer_usage/>>
end.

<</templ>>


<</templs>>

<<<----------top-level suite: / ---------->>>
<<suites make="subdir-makefile-template">>


<<<----------sub-suite: /lex-alone ---------->>>
<<suite "lex-alone" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/begin---------->>>
	<<suite "begin" make="subdir-makefile-template">>

<<<----case: /lex-alone/begin/case-insensitive---->>>
		<<case "case-insensitive" make="lex-only-makefile-template">>
			<<upgen_options>>-i<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: case-insensitive
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
	XYZs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
	XYZs := 0;
				<</init_code>>
				<<lex_section>>
abc		writeln(yytext, ' ---> `abc''');
		abcs := abcs + 1;
XYZ		writeln(yytext, ' ---> `XYZ''');
		XYZs := XYZs + 1;
.|\n	{ do nothing}
				<</lex_section>>
				<<after_init>>
	yylex;
	writeln('abc''s = ', abcs);
	writeln('XYZ''s = ', XYZs);
				<</after_init>>
			<</script>>
			
			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
ABCD
xyz1232
abcd
XYZJFSLK
			<</textfile>>
			<<textfile "result.out">>
ABC ---> `abc'
xyz ---> `XYZ'
abc ---> `abc'
XYZ ---> `XYZ'
abc's = 2
XYZ's = 2
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/case-insensitive---->>>


<<<----case: /lex-alone/begin/debug-option---->>>
		<<case "debug-option" make="lex-only-makefile-template">>
			<<upgen_options>>-d<</upgen_options>>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%x	SC1
				<</declare_section>>
				<<lex_section>>
\{	YYBEGIN(SC1);
<SC1>\}	YYBEGIN(INITIAL);

<*>abc	abcs := abcs + 1;
<*>.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
acde
ABCabc
{
aabc
cccabc

			<</textfile>>
			<<textfile "result.out">>
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`a'}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`d'}, rule at line: 95
.................... accept {`e'}, rule at line: 95
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`A'}, rule at line: 95
.................... accept {`B'}, rule at line: 95
.................... accept {`C'}, rule at line: 95
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`{'}, rule at line: 91
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`a'}, rule at line: 95
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`c'}, rule at line: 95
.................... accept {`abc'}, rule at line: 94
.................... accept unprintable-char{10}, rule at line: 95
.................... accept unprintable-char{10}, rule at line: 95
.................... EOF reached
.................... EOS reached
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/debug-option---->>>


<<<----case: /lex-alone/begin/entry-param---->>>
		<<case "entry-param" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test option: enable producing diagnosis information for pattern-matching
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%formal-param%{abc: integer; def: char %}
%actual-param%{abc, def %}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				
				<<local_decl_code>>
var
	nret: integer;
				<</local_decl_code>>
				<<after_init>>
	nret := yylex(0, #0);
	if nret = 0 then begin
		result := 0;
		exit;
	end;
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/entry-param---->>>

<<<----case: /lex-alone/begin/eol-lookahead---->>>
		<<case "eol-lookahead" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/* test operator '$' */
				<</desc>>

				<<lex_section>>
.+$		writeln('whole-text = "', yytext, '".');
		writeln('lookahead-text = "', pchar(yytext + sizeof(char) * yyleng), '".');
		yytext[yyleng] := #0;
		writeln('matched-text = "', yytext, '".');

\n		writeln('a newline is matched.');
				<</lex_section>>
				<<local_decl_code>>
var
	nret: integer;
				<</local_decl_code>>

				<<after_init>>
	nret := yylex;
	if nret = 0 then begin
		result := 0;
		exit;
	end;
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
/* test operator '$' */

%%

.+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
		yytext[yyleng] = '\0';
		fprintf(stdout, "matched-text = \"%s\".\n", yytext);

\n		fprintf(stdout, "a newline is matched.\n");

%%

/* empty */

%%

int main(int argc, char **argv) {

	if(argc < 2) {
		yylexfile(NULL, true);
	}
	else {
		if(yylexfile(argv[1], false)) {
			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
			return -1;
		}
	}

	return yylex();
}
			<</textfile>>
			<<textfile "result.out">>
whole-text = "/* test operator '$' */
".
lookahead-text = "
".
matched-text = "/* test operator '$' */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = ".+$		fprintf(stdout, "whole-text = \"%s\".\n", yytext);".
a newline is matched.
whole-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "lookahead-text = \"%s\".\n", &yytext[yyleng]);".
a newline is matched.
whole-text = "		yytext[yyleng] = '\0';
".
lookahead-text = "
".
matched-text = "		yytext[yyleng] = '\0';".
a newline is matched.
whole-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);
".
lookahead-text = "
".
matched-text = "		fprintf(stdout, "matched-text = \"%s\".\n", yytext);".
a newline is matched.
a newline is matched.
whole-text = "\n		fprintf(stdout, "a newline is matched.\n");
".
lookahead-text = "
".
matched-text = "\n		fprintf(stdout, "a newline is matched.\n");".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "/* empty */
".
lookahead-text = "
".
matched-text = "/* empty */".
a newline is matched.
a newline is matched.
whole-text = "%%
".
lookahead-text = "
".
matched-text = "%%".
a newline is matched.
a newline is matched.
whole-text = "int main(int argc, char **argv) {
".
lookahead-text = "
".
matched-text = "int main(int argc, char **argv) {".
a newline is matched.
a newline is matched.
whole-text = "	if(argc < 2) {
".
lookahead-text = "
".
matched-text = "	if(argc < 2) {".
a newline is matched.
whole-text = "		yylexfile(NULL, true);
".
lookahead-text = "
".
matched-text = "		yylexfile(NULL, true);".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
whole-text = "	else {
".
lookahead-text = "
".
matched-text = "	else {".
a newline is matched.
whole-text = "		if(yylexfile(argv[1], false)) {
".
lookahead-text = "
".
matched-text = "		if(yylexfile(argv[1], false)) {".
a newline is matched.
whole-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);
".
lookahead-text = "
".
matched-text = "			fprintf(stderr, "Error: failed to open file \'%s\'\n", argv[1]);".
a newline is matched.
whole-text = "			return -1;
".
lookahead-text = "
".
matched-text = "			return -1;".
a newline is matched.
whole-text = "		}
".
lookahead-text = "
".
matched-text = "		}".
a newline is matched.
whole-text = "	}
".
lookahead-text = "
".
matched-text = "	}".
a newline is matched.
a newline is matched.
whole-text = "	return yylex();
".
lookahead-text = "
".
matched-text = "	return yylex();".
a newline is matched.
whole-text = "}
".
lookahead-text = "
".
matched-text = "}".
a newline is matched.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eol-lookahead---->>>


<<<----case: /lex-alone/begin/eos-action---->>>
		<<case "eos-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined END-OF-FILE action
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%yywrap%{

	writeln('YYSTART = ', YYSTART());
	result := false;
%}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
YYSTART = 0
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/eos-action---->>>


<<<----case: /lex-alone/begin/lex-init-action---->>>
		<<case "lex-init-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined lex-init action, which is executed
	before pattern-matching
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<declare_section>>
%lex-init{

	writeln('Let''s get started');
%}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
Let's get started
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/lex-init-action---->>>


<<<----case: /lex-alone/begin/prematch-action---->>>
		<<case "prematch-action" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-defined prematch action, which is executed just before
	action corresponding matched pattern
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
	matches: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
	matches := 0;
				<</init_code>>

				<<declare_section>>
%pre-match{

	if strcomp(yytext, 'abc') = 0 then
		matches := matches + 1;

%}
				<</declare_section>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	
	writeln('number of "abc" is ', abcs);
	writeln('number of matches is ', matches);
				<</lex_section>>
				<<after_init>>
	yylex();
	if abcs = matches then
		writeln('abcs equals matches')
	else
		writeln('abcs is different from matches');
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
number of matches is 4
abcs equals matches
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/prematch-action---->>>


<<<----case: /lex-alone/begin/simplest---->>>
		<<case "simplest" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test simplest case to check basic features
*/
				<</desc>>
				<<global_decl_code>>
var
	abcs: integer;
				<</global_decl_code>>
				<<init_code>>
	abcs := 0;
				<</init_code>>
				<<lex_section>>
abc	abcs := abcs + 1;
.|\n	{ do nothing}
<<EOF>>	writeln('number of "abc" is ', abcs);
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
abc
abcd
abcdabcd
			<</textfile>>
			<<textfile "result.out">>
number of "abc" is 4
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/simplest---->>>


<<<----case: /lex-alone/begin/yyterminate---->>>
		<<case "yyterminate" make="lex-only-makefile-template">>
			<<script "lex-only-script-template">>
				<<desc>>/*
test user-interface: yyterminate
*/
				<</desc>>
				<<lex_section>>
q|Q		writeln;
		writeln('It is time to say goodbye.');	
		yyterminate();

.|\n	write(yytext);

<<EOF>>	writeln('Something wrong happened.');
				<</lex_section>>
				<<after_init>>
	yylex();
				<</after_init>>
			<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

			<<textfile "test.input">>
hello, yyterminate
no more to say
q
			<</textfile>>
			<<textfile "result.out">>
hello, yyterminate
no more to say

It is time to say goodbye.
			<</textfile>>
			<<textfile "result.err">>
			<</textfile>>
		<</case>>
<<<----case: /lex-alone/begin/yyterminate---->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/begin---------->>>


<<<----------sub-suite: /lex-alone/basic---------->>>
	<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /lex-alone/basic/action---->>>
		<<suite "action" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/action/ECHO---->>>
			<<case "ECHO" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: ECHO
*/
					<</desc>>
					<<declare_section>>
cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	writeln('Start scanning upgen script ...');
%}
					<</declare_section>>
					<<lex_section>>
int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); writeln('... keyword.');

{cid}		ECHO(); writeln('... identifier.');
{digit}		ECHO(); writeln('... number');
{punct}
.|\n
					<</lex_section>>
					<<after_init>>
		yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test built-in routines: ECHO
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*
digit	[[:digit:]]+
punct	[[:punct:]]

%lex-init%{
	cout << "Start scanning upgen script ..." << endl;
%}

%%

int 	|
void	|
if	|
return	|
NULL	|
using	|
#include	ECHO(); cout << "... keyword." << endl;

{cid}		ECHO(); cout << "... identifier." << endl;
{digit}		ECHO(); cout << "... number" << endl;
{punct}
.|\n

%%
				<</textfile>>
				<<textfile "result.out">>
Start scanning upgen script ...
test... identifier.
built... identifier.
in... identifier.
routines... identifier.
ECHO... identifier.
#include... keyword.
iostream... identifier.
using... keyword.
std... identifier.
cout... identifier.
using... keyword.
std... identifier.
endl... identifier.
cid... identifier.
cidf... identifier.
cids... identifier.
digit... identifier.
digit... identifier.
punct... identifier.
punct... identifier.
lex... identifier.
init... identifier.
cout... identifier.
Start... identifier.
scanning... identifier.
upgen... identifier.
script... identifier.
endl... identifier.
int... keyword.
void... keyword.
if... keyword.
return... keyword.
NULL... keyword.
using... keyword.
#include... keyword.
ECHO... identifier.
cout... identifier.
keyword... identifier.
endl... identifier.
cid... identifier.
ECHO... identifier.
cout... identifier.
identifier... identifier.
endl... identifier.
digit... identifier.
ECHO... identifier.
cout... identifier.
number... identifier.
endl... identifier.
punct... identifier.
n... identifier.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/ECHO---->>>


<<<----------case: /lex-alone/basic/action/yy_buffer---->>>
			<<case "yy_buffer" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yy_new_filebuf(file-name): buffer-object
	yy_push_buffer(buffer-object)
	yy_pop_buffer(): buffer-object
	yy_delete_buffer()
	yy_switch_buffer(buffer-object)
	yy_has_buffer(): false/true
	yy_current_buffer(): buffer-object
	yy_set_bol(false/true)
	yyinput(): char
*/
					<</desc>>
					<<global_decl_code>>
const
	MAX_BUF_NUM = 10;
	
var
	fnlist: array[0..MAX_BUF_NUM - 1] of pchar;
	cur_size: integer;
					<</global_decl_code>>
					<<init_code>>
	cur_size := 0;
					<</init_code>>
					<<declare_section>>
%lexvar-decl%{
var
	c, beg: integer;
	poldbuf, pnewbuf: YYPBUFFER;
	pch: pchar;
%}

fn	[^\\\/\*\r\n\t ]+
					<</declare_section>>
					<<lex_section>>
#include[ \t]*\<{fn}\>	begin

		repeat
			c := yyinput;
		until (c = END_OF_FILE) or (c = 10);

		yy_set_bol(true);

		if cur_size <  MAX_BUF_NUM then begin

			beg := 8;
			while yytext[beg] <> '<' do beg := beg + 1;
			beg := beg + 1;
			
			getmem(pch, (yyleng - beg) * sizeof(char));
			
			strlcopy(pch, pchar(yytext + sizeof(char) *beg), yyleng - beg - 1);
			beg := yyleng - beg - 1;
			pch[beg] := #0;

			pnewbuf := yy_new_filebuf(pch);
			if pnewbuf <> nil then begin
				poldbuf := yy_current_buffer();
				yy_push_buffer(pnewbuf);
				yy_push_buffer(poldbuf);
				fnlist[cur_size] := pch;
				cur_size := cur_size + 1;
			end
			else begin
				writeln('Warning: failed to open file `', pch, '''');
				freemem(pch);
				
			end;		
		end;
	end;

#open[ \t]*\<{fn}\>	begin

		repeat
			c := yyinput;
		until (c = END_OF_FILE) or (c = 10);
		if cur_size <  MAX_BUF_NUM then begin

			beg := 5;
			while yytext[beg] <> '<' do beg := beg + 1;
			beg := beg + 1;
			
			getmem(pch, (yyleng - beg) * sizeof(char));
			
			strlcopy(pch, pchar(yytext + sizeof(char) *beg), yyleng - beg - 1);
			beg := yyleng - beg - 1;
			pch[beg] := #0;
	
			pnewbuf := yy_new_filebuf(pch);
			if pnewbuf <> nil then begin
				yy_push_buffer(pnewbuf);
				fnlist[cur_size] := pch;
				cur_size := cur_size + 1;
				yy_set_bol(true);
			end
			else begin
				writeln('Warning: failed to open file `', pch, '''');
				freemem(pch);
			end;
				
		end;
   	end;

#overwrite[ \t]*\<{fn}\>	begin

		repeat
			c := yyinput;
		until (c = END_OF_FILE) or (c = 10);

		if cur_size <  MAX_BUF_NUM then begin

			beg := 5;
			while yytext[beg] <> '<' do beg := beg + 1;
			beg := beg + 1;
			
			getmem(pch, (yyleng - beg) * sizeof(char));
			
			strlcopy(pch, pchar(yytext + sizeof(char) *beg), yyleng - beg - 1);
			beg := yyleng - beg - 1;
			pch[beg] := #0;
	
			yy_delete_buffer();

			pnewbuf := yy_new_filebuf(pch);
			if pnewbuf <> nil then begin

				yy_push_buffer(pnewbuf);
				fnlist[cur_size] := pch;
				cur_size := cur_size + 1;
				yy_set_bol(true);
			end
			else begin
				writeln('Warning: failed to open file `', pch, '''');
				freemem(pch);;

			end;		
		end;
    end;
    
<<EOF>>		begin

		writeln;
		if yy_has_buffer() then begin

			yy_pop_buffer();
			yy_set_bol(true);
		end;
    end;
.|\n		write(yytext);
					<</lex_section>>
				
					<<local_decl_code>>
var
	i: integer;
					<</local_decl_code>>
					<<after_init>>
	yylex();
	for i := 0 to cur_size - 1 do

		freemem(fnlist[i]);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
******** test.input begin **********
#include<test1.input>
aaa
aaa
#open <test2.input>
aaa
******** test.input over ***********
				<</textfile>>
				<<textfile "test1.input">>
******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********
				<</textfile>>
				<<textfile "test2.input">>
******** test2.input begin **********
ccc
ccc
#overwrite<test3.input>
ccc
******** test2.input over ***********
				<</textfile>>
				<<textfile "test3.input">>
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********
				<</textfile>>
				<<textfile "result.out">>
******** test.input begin **********
aaa
aaa
******** test2.input begin **********
ccc
ccc
******** test3.input begin **********
ddd
ddd
ddd
******** test3.input over ***********

aaa
******** test.input over ***********

******** test1.input begin **********
bbb
bbb
bbb
******** test1.input over ***********

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yy_buffer---->>>


<<<----------case: /lex-alone/basic/action/yyinput---->>>
			<<case "yyinput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyinput(): char
	yyunput(char)
	yy_set_bol(false/true)
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%lvar-decl%{
var
	c: integer;
%}
					<</declare_section>>
					<<lex_section>>
"/*"	repeat
			c := yyinput;
			if c = END_OF_FILE then break;
			if chr(c) = '*' then begin
				c := yyinput;
				if (chr(c) = '/') or ( c = END_OF_FILE) then
					break;
				yyunput(chr(c));
			end;	
		until c = END_OF_FILE;

"//"	repeat
			c := yyinput;
		until (c = 10) or (c = END_OF_FILE);

		yy_set_bol(true);

^[ \t]+.*\n	write(yytext);
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
 just test for yyinput & yyunput
*/show me
 you can see me
 if there is not `beautiful life', then life is awful
//something wrong must be happened
/*
 
*************
/
Oops!
************/
 beautiful life
//***********************/
I am Prince of Darkness, so you can't see me
//************/**************/**********/
 and God will always be with you.
				<</textfile>>
				<<textfile "result.out">>
 you can see me
 if there is not `beautiful life', then life is awful
 beautiful life
 and God will always be with you.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyinput---->>>


<<<----------case: /lex-alone/basic/action/yyless---->>>
			<<case "yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines: 
	yyless(number-of-chars)
*/
					<</desc>>
					<<lex_section>>
"hello, world"	write(yytext); yyless(7);
"world"		write(yytext);
"Hi, guys"	write(yytext); yyless(4);
"guys"		write(yytext);
\n		writeln;
.

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
104 101 108 108 111 44 32 119 111 114 108 100 10 72 105 44 
32 103 117 121 115 10 10 -43 -116 58 -98 -119 88 -127 -96 15 
-47 82 -73 -50 -100 -62 -49 -8 79 -68 108 90 -112 -90 -3 124 
-80 37 32 -48 -52 -84 -93 64 -107 10 -110 66 -82 85 51 -42 
74 -72 36 38 -67 -123 92 119 -94 80 -40 -36 16 101 97 103 
47 12 -115 -113 105 114 -75 22 -57 -2 30 -12 3 -65 102 -121 
44 -22 -60 -44 -64 33 99 107 120 115 -104 55 28 77 -109 57 
83 69 98 42 -91 96 87 -106 65 11 41 94 126 8 29 -66 
-111 7 0 -39 95 113 48 61 -46 40 -18 100 123 -53 -99 -74 
49 1 -30 86 -5 45 -37 -85 89 34 -114 -10 24 116 -79 -89 
54 -23 60 62 76 -9 59 -117 -76 -95 31 127 -35 -17 68 -15 
84 -38 26 53 -54 -16 56 -105 78 110 -124 81 17 -19 -6 93 
-4 -78 -13 67 109 -83 117 122 91 -41 52 2 125 -97 -126 -25 
6 -24 70 -77 13 104 20 72 -1 -70 43 -103 46 -7 -108 -21 
-45 121 35 -31 39 -20 -26 25 -125 106 27 -81 -55 -92 19 -88 
-102 -61 -128 -120 -101 71 14 -51 -11 -59 -29 -28 -122 5 -71 -34 
73 4 -14 -69 -32 75 -87 18 -27 63 112 -58 23 -63 -56 111 
21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
hello, worldworld
Hi, guysguys


				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyless---->>>


<<<----------case: /lex-alone/basic/action/yymore--->>>
			<<case "yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>
/*
test built-in routines:
	yymore()
*/
					<</desc>>
					<<lex_section>>
"It\'s"		writeln(yytext); yymore();
"nice to"	writeln(yytext); yymore();
"see you!"	writeln(yytext); yymore();
" "		writeln('*'); yymore();
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
It's nice to see you!
None of these are available.
				<</textfile>>
				<<textfile "result.out">>
It's
*
It's nice to
*
It's nice to see you!
*
*
*
*
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yymore---->>>


<<<----------case: /lex-alone/basic/action/yyrestart--->>>
			<<case "yyrestart" make="lex-only-makefile-template">>
				<<EXTRA_DIST>>test1.input<</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyrestart()
*/
					<</desc>>
					<<global_decl_code>>
const
	MAX_OPEN_TIMES = 8;
var
	useFile: boolean;
	reopen_times: integer;
	pbuf: YYPBUFFER;
					<</global_decl_code>>
					<<init_code>>
	useFile := false;
	reopen_times := 0;
					<</init_code>>
					<<declare_section>>
%yywrap%{

	if not useFile then begin
		pbuf := yy_new_filebuf('test1.input');
		if pbuf = nil then begin
			writeln('failed to open `test1.input''');
			yyterminate();
		end
		else
			yy_switch_buffer(pbuf);
	end;
	useFile := true;
	result := false;
%}

%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
	
a	write(yytext); ncnt := ncnt + 1;

<<EOF>>	begin
		writeln;
		if useFile and (reopen_times < MAX_OPEN_TIMES) then begin

			reopen_times := reopen_times + 1;
			yyrestart();
			yy_set_bol(true);
		end;
	end;

.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln; writeln('a''s occurrences: ', ncnt);
	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
aa
				<</textfile>>
				<<textfile "test1.input">>
aa
				<</textfile>>
				<<textfile "result.out">>
aa
aa
aa
aa
aa
aa
aa
aa
aa

a's occurrences: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyrestart---->>>



<<<----------case: /lex-alone/basic/action/yysc_state--->>>
			<<case "yysc_state" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	YYSTART()
	yy_push_state(DFA-begin-state)
 	yy_pop_state()
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%x	sc1
%x	sc2
%x	sc3
%x	sc4
					<</declare_section>>
					<<lex_section>>
<INITIAL,sc1,sc2,sc3>"("	begin
		
		case YYSTART of
		INITIAL:	yy_push_state(sc1);
		sc1:	yy_push_state(sc2);
		sc2:	yy_push_state(sc3);
		sc3:	yy_push_state(sc4);
		end;
	end;

<sc1,sc2,sc3,sc4>")"	yy_pop_state();

<*>[[:space:]]+

<sc1>[^\(\)\r\n \t]+	
		writeln(#9, yytext);

<sc2>[^\(\)\r\n \t]+
		writeln(#9#9, yytext);

<sc3>[^\(\)\r\n \t]+
		writeln(#9#9#9, yytext);

<sc4>[^\(\)\r\n \t]+
		writeln(#9#9#9#9, yytext);

[^\(\)\n\r \t]+	
		writeln(yytext);

<*>.|\r?\n

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
	(define
		(right-branch
		tree)
		(cadr
		tree))
	(define
		(symbols
		tree)
		(if
			(leaf?
			tree)
			(list
				(symbol-leaf
				tree))
			(caddr tree)))
	(define
		(weight
		tree)
		(if
			(leaf?
			tree)
			(weight-leaf
			tree)
			(cadddr tree)))
				<</textfile>>
				<<textfile "result.out">>
	define
		right-branch
		tree
		cadr
		tree
	define
		symbols
		tree
		if
			leaf?
			tree
			list
				symbol-leaf
				tree
			caddr
			tree
	define
		weight
		tree
		if
			leaf?
			tree
			weight-leaf
			tree
			cadddr
			tree
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yysc_state---->>>


<<<----------case: /lex-alone/basic/action/yyunput--->>>
			<<case "yyunput" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test built-in routines:
	yyunput(char-to-put)
*/
					<</desc>>
					<<declare_section>>
%lex-init%{
	writeln('Play game of `Change Word''');
%}
					<</declare_section>>
					<<lex_section>>
bad	yyunput('d');
	yyunput('o');
	yyunput('o');
	yyunput('g');

ugly	yyunput('e');
	yyunput('t');
	yyunput('u');
	yyunput('c');

cruel	yyunput('d');
	yyunput('n');
	yyunput('i');
	yyunput('k');

lie	yyunput('h');
	yyunput('t');
	yyunput('u');
	yyunput('r');
	yyunput('t');

proud	yyunput('e');
	yyunput('l');
	yyunput('b');
	yyunput('m');
	yyunput('u');
	yyunput('h');

.|\n	write(yytext);

					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
Once upon a time, there is very bad, ugly guy. He is alway very cruel to people around him, and force himself to tell at leat a lie everyday. What's more, he is a very proud man.
				<</textfile>>
				<<textfile "result.out">>
Play game of `Change Word'
Once upon a time, there is very good, cute guy. He is alway very kind to people around him, and force himself to tell at leat a truth everyday. What's more, he is a very humble man.
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/action/yyunput---->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/action---->>>



<<<----------sub-suite: /lex-alone/basic/charset---->>>
		<<suite "charset" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/charset/charset-blank--->>>
			<<case "charset-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
[ \t]		ncnt := ncnt + 1;
[ \t]{5}	ncnt := ncnt + 10;
[ \t]+		ncnt := ncnt + yyleng * 3;

.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
 a a a a
					b
          c
				<</textfile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>
			<<case "charset-cesc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test set of characters:
	escape char in C language
*/
					<</desc>>
					<<global_decl_code>>
var
	ncnt: integer;
					<</global_decl_code>>
					<<init_code>>
	ncnt := 0;
					<</init_code>>
					<<declare_section>>
cesc1	[\0\?\\\"\'\a\b\f\n\r\t\v]
cesc2	\0|\?|\\|\"|\'|\a|\b|\f|\n|\r|\t|\v
cesc3	"\0"|"\?"|"\\"|"\""|"\'"|"\a"|"\b"|"\f"|"\n"|"\r"|"\t"|"\v"

					<</declare_section>>
					<<lex_section>>
{cesc1}		ncnt := ncnt + 1;
{cesc2}{5}	ncnt := ncnt + 10;
{cesc3}+	ncnt := ncnt + yyleng * 3;
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
	writeln(ncnt);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
7 65 0 65 9 65 10 65 63 34 39 63 39 65 11 13 
11 13 92 92 92 92 13 34
				<</bytefile>>
				<<textfile "result.out">>
44
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-cesc--->>>


<<<----------case: /lex-alone/basic/charset/charset-concat--->>>
			<<case "charset-concat" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation:
	concat
*/
					<</desc>>
					<<declare_section>>
int	[\+\-]?([1-9][0-9]*|0)
hex	\\[Xx][0-9A-Fa-f][0-9A-Fa-f]
oct	\\[0-3][0-7][0-7]
real	{int}|{int}"\."[0-9]+
					<</declare_section>>
					<<lex_section>>
{int}	|
{hex}	|
{oct}	|
{real}	writeln(yytext);
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/+100 c-999 a7777
\xffe wiof\X33kis \\x4232 \XDCE
dd\001\777\888\999\aaa
43.90a 48.23b1233204.738429sfsj4332
				<</textfile>>
				<<textfile "result.out">>
+100
-999
7777
\xff
\X33
\x42
32
\XDC
\001
777
888
999
43.90
48.23
1233204.738429
4332
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-concat--->>>


<<<----------case: /lex-alone/basic/charset/charset-email--->>>
			<<case "charset-email" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze email address 
*/
					<</desc>>
					<<global_decl_code>>
var
	ncnt: integer;
					<</global_decl_code>>
					<<init_code>>
	ncnt := 0;
					<</init_code>>
					<<declare_section>>
/* name section */
nsect	[0-9A-Za-z\_\-]{1,}
/* name */
name	{nsect}("."{nsect})*
emaddr	{name}\@{name}
					<</declare_section>>
					<<lex_section>>
{emaddr}	writeln(yytext); ncnt := ncnt + 1;

.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	writeln(ncnt);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
somebody.upgen@robot.com
somebody.upgen@r@obot.com
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
				<</textfile>>
				<<textfile "result.out">>
somebody.upgen@robot.com
somebody.upgen@r
12345678.987654320.abcdefghijklmnopqrstuvwxyz.yyyyyyyyy@mccooooooooooooooo.orrrrrrrg
3
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-email--->>>


<<<----------case: /lex-alone/basic/charset/charset-hex--->>>
			<<case "charset-hex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning hexadecimal numbers
*/
					<</desc>>
					<<global_decl_code>>
var
	blanks: integer;
	spaces: integer;
	digits: integer;
	uppers: integer;
	lowers: integer;
	eofs: integer;
	nansis: integer;
					<</global_decl_code>>
					
					<<init_code>>
	blanks := 0;
	spaces := 0;
	digits := 0;
	uppers := 0;
	lowers := 0;
	eofs := 0;
	nansis := 0;
					<</init_code>>
					<<declare_section>>
blank	[\x09\x20]
space	[\x09-\x0D]
digit	[\x30-\x39]
upper	[\X41-\X5a]
lower	[\x61-\X7A]
eof	[\XFf]
nansi	[\X80-\xff]
					<</declare_section>>
					<<lex_section>>
{blank}		blanks := blanks + 1;
{space}		spaces := spaces + 1;
{digit}		digits := digits + 1;
{upper}		uppers := uppers + 1;
{lower}		lowers := lowers + 1;
{eof}		eofs := eofs + 1;
{nansi}		nansis := nansis + 1;
.|\n
					<</lex_section>>
					<<after_init>>
			yylex();
			writeln('blanks: ', blanks);
			writeln('spaces: ', spaces);
			writeln('digits: ', digits);
			writeln('uppers: ', uppers);
			writeln('lowers: ', lowers);
			writeln('eofs: ', eofs);
			writeln('nansis: ', nansis);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-43 -116 58 -98 -119 88 -127 -96 15 -47 82 -73 -50 -100 -62 -49 
-8 79 -68 108 90 -112 -90 -3 124 -80 37 32 -48 -52 -84 -93 
64 -107 10 -110 66 -82 85 51 -42 74 -72 36 38 -67 -123 92 
119 -94 80 -40 -36 16 101 97 103 47 12 -115 -113 105 114 -75 
22 -57 -2 30 -12 3 -65 102 -121 44 -22 -60 -44 -64 33 99 
107 120 115 -104 55 28 77 -109 57 83 69 98 42 -91 96 87 
-106 65 11 41 94 126 8 29 -66 -111 7 0 -39 95 113 48 
61 -46 40 -18 100 123 -53 -99 -74 49 1 -30 86 -5 45 -37 
-85 89 34 -114 -10 24 116 -79 -89 54 -23 60 62 76 -9 59 
-117 -76 -95 31 127 -35 -17 68 -15 84 -38 27 53 -54 -16 56 
-105 78 110 -124 81 17 -19 -6 93 -4 -78 -13 67 109 -83 117 
122 91 -41 52 2 125 -97 -126 -25 6 -24 70 -77 13 104 20 
72 -1 -70 43 -103 46 -7 -108 -21 -45 121 35 -31 39 -20 -26 
25 -125 106 27 -81 -55 -92 19 -88 -102 -61 -128 -120 -101 71 14 
-51 -11 -59 -29 -28 -122 5 -71 -34 73 4 -14 -69 -32 75 -87 
18 -27 63 112 -58 23 -63 -56 111 21 9 50 118 -33 -118 -86
				<</bytefile>>
				<<textfile "result.out">>
blanks: 2
spaces: 4
digits: 10
uppers: 26
lowers: 26
eofs: 1
nansis: 127
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-hex--->>>


<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>
			<<case "charset-ipaddress" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: concat, option, range
lexically analyze ip address 
*/
					<</desc>>
					
					<<global_decl_code>>
var
	selfs: integer;
	ipaddrs: integer;
					<</global_decl_code>>
					
					<<init_code>>
	selfs := 0;
	ipaddrs := 0;
					<</init_code>>

					<<declare_section>>
self	"127"\.0{1,3}\.0{1,3}\.(0?0)?1
ipsect	[01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5]
ipaddr	({ipsect})(\.({ipsect})){3}
					<</declare_section>>
					<<lex_section>>
{self}		selfs := selfs + 1;
			writeln('localhost ', selfs, ': ', yytext);
{ipaddr}	ipaddrs := ipaddrs + 1;
			writeln('ip ', ipaddrs, ': ', yytext);
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	writeln('localhosts: ', selfs);
	writeln('others: ', ipaddrs);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
localhost1: 127.0.0.1
localhost2: 127.000.000.001
localhost3: 127.0.00.001
ip1: 192.156.173.115
ip3: 0.0.0.1
ip4: 0.0.0.0
ip5: 255.255.255.255
ip6: 256.001.002.003
ip7: 128.a.9.3
ip8: 116.119.121.34
ip2: 99.77.88.10
				<</textfile>>
				<<textfile "result.out">>
localhost 1: 127.0.0.1
localhost 2: 127.000.000.001
localhost 3: 127.0.00.001
ip 1: 192.156.173.115
ip 2: 0.0.0.1
ip 3: 0.0.0.0
ip 4: 255.255.255.255
ip 5: 56.001.002.003
ip 6: 116.119.121.34
ip 7: 99.77.88.10
localhosts: 3
others: 7
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-ipaddress--->>>


<<<----------case: /lex-alone/basic/charset/charset-meta--->>>
			<<case "charset-meta" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
meta-char as escape char
*/
					<</desc>>
					<<global_decl_code>>
var
	meta1s, meta2s: integer;
	meta3s, meta4s: integer;
					<</global_decl_code>>
					<<init_code>>
	meta1s := 0;
 	meta2s := 0;
 	meta3s := 0;
 	meta4s := 0;
					<</init_code>>
					<<declare_section>>
meta1	[\%\(\)\[\]\{\}\<\>\|\<\>\:\$\^\/\*\+\,\;\.\?\-]
meta2	\%|\(|\)|\[|\]|\{|\}|\<|\>|\||\<|\>|\:|\$|\^|\/|\*|\+|\,|\;|\.|\?|\-
meta3	"\%"|"\("|"\)"|"\["|"\]"|"\{"|"\}"|"\<"|"\>"|"\|"|"\<"|"\>"|"\:"|"\$"|"\^"|"\/"|"\*"|"\+"|"\,"|"\;"|"\."|"\?"|"\-"
meta4	"%"|"("|")"|"["|"]"|"{"|"}"|"<"|">"|"|"|"<"|">"|":"|"$"|"^"|"/"|"*"|"+"|","|";"|"."|"?"|"-"

					<</declare_section>>
					<<lex_section>>
{meta1}		meta1s:= meta1s + 1; write(yytext);
{meta2}		meta2s:= meta2s + 1; write(yytext);
{meta3}		meta3s:= meta3s + 1; write(yytext);
{meta4}		meta4s:= meta4s + 1; write(yytext);
.|\n

					<</lex_section>>
					<<after_init>>
	yylex();
	writeln;
	writeln('meta1s = ', meta1s);
	writeln('meta2s = ', meta2s);
	writeln('meta3s = ', meta3s);
	writeln('meta4s = ', meta4s);
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
				<</textfile>>
				<<textfile "result.out">>
:$^*+,;.?-(]{>|>:$^/*+)[]{}|<^/;.?-%()[]{
meta1s = 41
meta2s = 0
meta3s = 0
meta4s = 0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-meta--->>>



<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>
			<<case "charset-normal-esc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset : escape char
normal char as escape char
*/
					<</desc>>
					<<global_decl_code>>
var
	norm2: integer;
	norm3: integer;
	norm4: integer;
	norm5: integer;
					<</global_decl_code>>
					<<init_code>>
	norm2 := 0;
	norm3 := 0;
	norm4 := 0;
	norm5 := 0;	
					<</init_code>>
					<<declare_section>>

norm1	\\[A-Zc-eg-mo-qsuw-z_\#\&\=\@\`\~]
norm2	"\A"|"\B"|"\C"|"\D"|"\E"|"\F"|"\G"|"\H"|"\I"|"\J"|"\K"|"\L"|"\M"|"\N"|"\O"|"\P"|"\Q"|"\R"|"\S"|"\T"|"\U"|"\V"|"\W"|"\X"|"\Y"|"\Z"|"\c"|"\d"|"\e"|"\g"|"\h"|"\i"|"\j"|"\k"|"\l"|"\m"|"\o"|"\p"|"\q"|"\s"|"\u"|"\w"|"\x"|"\y"|"\z"|"\_"|"\#"|"\&"|"\="|"\@"|"\`"|"\~"
norm3	"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z"|"c"|"d"|"e"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"o"|"p"|"q"|"s"|"u"|"w"|"x"|"y"|"z"|"_"|"#"|"&"|"="|"@"|"`"|"~"
norm4	\A|\B|\C|\D|\E|\F|\G|\H|\I|\J|\K|\L|\M|\N|\O|\P|\Q|\R|\S|\T|\U|\V|\W|\X|\Y|\Z|\c|\d|\e|\g|\h|\i|\j|\k|\l|\m|\o|\p|\q|\s|\u|\w|\x|\y|\z|\_|\#|\&|\=|\@|\`|\~
norm5	A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|c|d|e|g|h|i|j|k|l|m|o|p|q|s|u|w|x|y|z|_|#|&|=|@|`|~

					<</declare_section>>
					<<lex_section>>
{norm2}		norm2 := norm2 + 1; write(yytext);
{norm3}		norm3 := norm3 + 1; write(yytext);
{norm4}		norm4 := norm4 + 1; write(yytext);
{norm5}		norm5 := norm5 + 1; write(yytext);
.|\n
					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	yylex();
	writeln;
	writeln('norm2:', norm2);
	writeln('norm3:', norm3);
	writeln('norm4:', norm4);
	writeln('norm5:', norm5);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
8 -43 -30 120 -90 29 110 54 120 -14 -67 8 -80 -94 97 23 
105 -21 -111 8 65 -77 98 125 0 22 -102 27 71 -77 -10 80 
-120 -40 -56 46 -11 54 100 109 40 33 118 -40 -61 -41 -17 45 
-62 -128 53 3 51 -104 -127 52 -82 27 79 -11 -50 69 69 86 
29 13 -123 19 67 -23 -128 107 11 -10 67 -50 -50 50 -5 -112 
-78 49 -108 -26 -55 21 27 119 48 105 108 -2 -82 -78 84 -53 
-65 -39 -34 3 -61 95 110 -50 85 -78 -100 35 -28 -104 -76 -105 
-55 72 125 -110 93 -105 9 -115 0 117 -117 -82 39 -33 121 -25 
-71 88 -22 124 -73 88 74 12 10 -26 48 -17 126 -28 -122 71 
44 3 -39 -119 -102 -30 22 -102 88 -95 72 127 -128 -63 102 57 
25 80 -75 -48 -87
				<</bytefile>>
				<<textfile "result.out">>
xxiAGPdmOEEVCkCwilT_U#HuyXXJ~GXHP
norm2:33
norm3:0
norm4:0
norm5:0
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-normal-esc--->>>


<<<----------case: /lex-alone/basic/charset/charset-oct--->>>
			<<case "charset-oct" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test scanning octal numbers
*/
					<</desc>>
					
					<<global_decl_code>>
var
	digits: integer;
	uppers: integer;
	lowers: integer;
	eofs: integer;
	nansis: integer;
	
	strd: string;
	stru: string;
	strl: string;
					<</global_decl_code>>
					<<init_code>>
					
	digits := 0;
	uppers := 0;
	lowers := 0;
	eofs := 0;
	nansis := 0;
	strd := '';
	stru := '';
	strl := '';
					<</init_code>>
					<<declare_section>>
digit	[\060-\071]
upper	[\101-\132]
lower	[\141-\172]
eof		[\377]
nansi	[\200-\377]
					<</declare_section>>
					<<lex_section>>
{digit}		digits := digits + 1; strd := strd + yytext;
{upper}		uppers := uppers + 1; stru := stru + yytext;
{lower}		lowers := lowers + 1; strl := strl + yytext;
{eof}		eofs := eofs + 1;
{nansi}		nansis := nansis + 1;
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	yylex();
	writeln;
	writeln('digits: ', strd, ' ', digits, ' in total.');
	writeln('uppers: ', stru, ' ', uppers, ' in total.');
	writeln('lowers: ', strl, ' ', lowers, ' in total.');
	writeln('eofs: ', eofs);
	writeln('nansis: ', nansis);

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
127 120 -93 -30 32 116 -64 2 -87 120 62 116 95 68 68 83 
-51 88 9 -21 -77 25 65 0 -69 -42 -115 -29 -74 127 -34 53 
-9 -127 24 23 -10 -40 25 -97 81 87 19 -80 -100 87 4 105 
-81 13 84 98 39 -106 98 -30 108 -16 -59 34 111 -92 88 102 
37 112 125 27 72 -105 -69 -103 -18 -50 74 -118 38 78 -12 -43 
91 72 56 -126 -34 -102 100 74 -118 42 109 -7 -50 -59 95 -13 
53 -35 15 125 116 -54 23 98 -104 97 -19 -66 -81 -31 -108 10 
41 -52 -115 8 102 -15 82 -15 27 -65 -22 -23 -124 74 -35 -71 
39 -20 55 -101 -74 78 -3 78 -81 -22 13 94 -53 -95 104 -11 
109 -11 -3 -45 -25 79 -60 2 15 -81 -20 -109 -7 -55 77 32 
-75 -124 -69 107 -46 -72 -71 -127 -93 -58 -33 110 103 71 99 -44 
61 96 -88 36 -80 108 38 -65 27 18 82 20 -37 -97 52 -112 
35 -17 -5 -11 -88 -75 118 75 123 85 -71 -29 -99 29 -73 -38 
125 95 -2 45 -52 36 -20 -25 55 63 -4 18 -34 48 -93 2 
32 -98 -9 -56 83 110 19 -49 -61 -52 -78 96 -23 105 58 103 
-55 56 -108 -107 93 -127 124 -108 -64 120 -90 -98 -87 73 -96 -55 
-24 -104 -111 59 6 -92 10 -55 112 -68 42 90 38 100 -63 -17 
-99 85 -124 -6 -42 0 -114 -106 121 52 53 34 126 -43 -21 102 
109 124 -95 115 32 -84 61 -112 104 103 -22 -114 -53 -85 125 104 
1 1 98 -41 2 -16 110 123 37 -93 -99 -93 120 -120 9 -26 
4 -86 89 36 86 -106 -76 -65 -3 -97 77 -55 74 -53 49 75 
-52 -108 35 -50 -124 -111 73 -87 52 -26 76 -84 110 85 -110 114 
0 -20 -106 86 -126 75 21 -128 -22 99 73 52 46 122 -128 -6 
14 -93 -55 -109 52 18 60 104 -7 -119 20 103 -34 -89 -38 -34 
-109 112 53 21 -69 74 -107 -91 -83 -34 -38 -37 89 90 -42 103 
-3 -97 -6 49 -79 55 -103 -86 -64 -83 18 -98 84 -20 125 -25 
92 -78 -3 24 -4 -110 -67 -86 113 -105 -123 -54 -15 91 49 -18 
-6 44 31 -84 99 -72 86 35 102 104 -63 -70 84 62 -94 -79 
-16 -97 -55 -19 49 -122 -105 -94 30 28 108 15 120 -98 -2 114 
-54 29 30 45 -42 117 80 60 -35 17 -10 50 80 -104 -29 64 
55 -84 45 105 50 -60 11 80 -31 120 96 89 22 94 -53 -32 
123 -22 13 81 95 93 -115 60 110 -124 110 -66 28 81 
				<</bytefile>>
				<<textfile "result.out">>

digits: 5857470845144451711272 22 in total.
uppers: DDSXAQWWTXHJNHJRJNNOMGRKUSIZUYVMJKILUVKIJYZTVTPPPYQQ 52 in total.
lowers: xtxtibblofpdmtbafhmkngclvnigxpdyfmshghbnxnrczhgpgqcfhlxruixnn 61 in total.
eofs: 0
nansis: 257
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-oct--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>
			<<case "charset-posix-alnum" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alnum
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

alnum	[[:alnum:]]

					<</declare_section>>
					<<lex_section>>
{alnum}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{alnum}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{alnum}+	ncnt := ncnt + yyleng * 3; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-37 -96 60 -108 -49 -92 47 -81 -7 75 -102 -11 50 -112 -35 6 
104 -75 -88 109 -98 34 -54 49 -114 102 97 -67 -20 -46 56 -100 
118 64 24 -13 -128 36 -79 120 -59 89 42 51 -66 18 -47 68 
-60 43 -70 127 57 -74 -34 53 -50 -68 22 115 29 76 17 -40 
15 112 -76 96 -87 0 122 -12 -9 -17 65 -124 -15 -110 8 41 
114 78 46 98 -39 -83 86 119 -14 -78 -5 101 -57 -71 38 -89 
-27 -52 -117 87 -120 63 117 13 25 100 -122 69 83 27 40 -44 
59 -62 -73 91 80 31 -106 -103 -21 -51 -82 -94 -36 99 -25 -1 
-104 58 -126 55 -4 -109 14 -63 33 -18 11 -118 -64 -41 -99 72 
-33 -16 27 -84 110 113 45 -90 10 48 -72 37 92 93 1 77 
-45 -121 62 -86 -95 -6 -42 -125 -69 -65 -113 52 -111 16 -31 -107 
-38 70 121 81 106 108 103 85 123 90 82 54 73 -3 -115 -26 
-55 105 -8 88 -85 107 94 -2 124 74 -127 -105 12 116 -80 44 
23 -43 -32 67 -28 19 -24 -97 95 -119 30 21 126 79 -48 -53 
39 71 125 2 -77 4 9 20 35 -10 -22 5 -23 32 7 -29 
-30 -61 -93 61 -56 111 -58 -91 3 -19 84 66 -116 -123 -101 28
				<</bytefile>>
				<<textfile "result.out">>
K +1
2 +1
h +1
m +1
1 +1
fa +4
8 +1
v +1
x +1
Y +1
3 +1
D +1
9 +1
5 +1
s +1
L +1
p +1
z +1
A +1
rN +4
b +1
Vw +4
e +1
W +1
u +1
d +1
ES +4
P +1
c +1
7 +1
H +1
nq +4
0 +1
M +1
4 +1
FyQjlgU +21
ZR6I +12
i +1
X +1
k +1
J +1
t +1
C +1
O +1
G +1
o +1
TB +4
96
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alnum--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>
			<<case "charset-posix-alpha" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - alpha
*/
					<</desc>>
					<<declare_section>>
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]

%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
					<</declare_section>>
					<<lex_section>>
{alpha}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{alpha}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{alpha}+	ncnt := ncnt + yyleng * 3; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>


					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
96 -34 -73 -66 -14 56 39 -45 -43 111 120 -56 67 -86 6 89 
106 -94 13 87 -28 84 45 16 110 36 117 15 102 -122 -78 -109 
-20 22 -72 58 94 23 -59 12 126 66 -62 28 -19 -26 -91 -67 
107 -89 59 -44 -92 -93 52 103 -83 -33 -75 -104 -102 7 63 55 
74 79 -16 -63 -12 35 100 40 121 71 70 -127 -90 -55 61 -23 
3 0 -96 5 80 57 43 -70 -69 -9 -111 -52 34 77 24 69 
-11 90 14 91 33 -21 41 27 92 29 -82 47 -58 -35 73 86 
46 98 37 -107 95 -37 118 119 10 72 122 123 124 125 25 127 
-128 75 -126 -125 -124 -123 105 -121 -120 -119 -118 -117 -116 -115 -114 -113 
-112 97 -110 31 -108 115 -106 -105 50 -103 60 -101 -100 -99 -98 -97 
82 -95 17 53 54 112 76 49 -88 -87 18 -85 -84 83 114 -81 
-80 -79 30 -77 -76 116 -74 2 104 -71 19 88 -68 48 21 -65 
-64 113 42 -61 -60 38 108 -57 11 93 -54 -53 99 -51 -50 -49 
-48 -47 -46 78 51 8 -42 -41 -40 -39 -38 27 -36 109 1 85 
-32 -31 -30 -29 20 -27 64 -25 -24 65 -22 101 32 44 -18 -17 
9 -15 4 -13 68 81 -10 62 -8 -7 -6 -5 -4 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
ox +4
C +1
Yj +4
W +1
T +1
n +1
u +1
f +1
B +1
k +1
g +1
JO +4
d +1
yGF +9
P +1
M +1
E +1
Z +1
IV +4
b +1
vw +4
Hz +4
K +1
i +1
a +1
s +1
R +1
pL +4
Sr +4
t +1
h +1
X +1
q +1
l +1
c +1
N +1
m +1
U +1
A +1
e +1
DQ +4
76
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-alpha--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>
			<<case "charset-posix-blank" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - blank
*/

					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}
blank	[[:blank:]]
					<</declare_section>>
					<<lex_section>>
{blank}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{blank}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{blank}+	ncnt := ncnt + yyleng * 3; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
80 -104 -125 -100 -42 84 120 -57 -58 40 -114 6 -1 115 10 -28 
16 -74 -62 -12 -7 -75 65 47 -90 -76 2 -67 54 -65 -69 88 
-96 -95 34 17 -101 68 15 -18 0 46 -91 -36 -107 96 -120 -92 
123 -97 -127 75 126 43 -117 116 111 71 -21 -20 94 41 -38 86 
95 30 44 124 11 39 114 -43 102 19 -13 -121 106 28 98 -32 
-17 105 69 63 1 13 -25 -31 -30 -82 77 -81 74 -24 90 85 
49 -109 -94 103 55 27 -79 -122 -16 83 -23 7 127 -88 -11 42 
-80 -68 76 -110 93 -2 -48 51 104 25 -106 -85 59 61 67 -59 
-70 8 -34 73 -124 60 -33 112 -78 -14 18 64 -123 -54 -93 35 
122 113 5 -66 -51 101 78 -9 107 -113 20 27 -84 57 92 -47 
-8 -116 -45 -98 50 22 33 -22 -72 -118 4 -126 -44 87 -87 -111 
56 -71 66 14 81 -37 125 -29 29 32 -52 -61 -99 23 9 89 
3 -40 -49 -119 -39 119 58 -102 31 121 100 -50 -63 52 72 62 
79 24 -77 -56 -103 -83 -108 108 37 53 -89 -64 97 91 -46 -26 
-19 -112 -86 99 -35 38 118 109 48 -27 -15 -128 36 70 -115 -105 
82 -55 -41 45 21 110 -10 -60 -53 -73 -6 -5 -4 -3 117 12 
				<</bytefile>>
				<<textfile "result.out">>
  +1
	 +1
2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-blank--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>
			<<case "charset-posix-cid" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - cid
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{cidf}{cids}*		writeln(yytext); ncnt := ncnt + 1;
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test posix charset - cid
*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

cidf	[[:cidf:]]
cids	[[:cids:]]

%%

{cidf}{cids}*		cout << yytext << endl; ++ncnt;
.|\n

%%

int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
posix
charset
cid
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
cidf
cidf
cids
cids
cidf
cids
cout
yytext
endl
ncnt
n
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
48
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-cid--->>>




<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>
			<<case "charset-posix-digit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - digit
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

digit	[[:digit:]]
xdigt	[[:xdigit:]]
lower	[[:lower:]]
upper	[[:upper:]]
alnum	[[:alnum:]]
alpha	[[:alpha:]]
graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{digit}		ncnt := ncnt + 1; writeln(yytext, ' +1');
{digit}{2}	ncnt := ncnt + 4; writeln(yytext, ' +4');
{digit}+	ncnt := ncnt + 3 * yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
105 -64 -121 -114 -94 -25 -51 16 54 -50 33 28 -75 -58 84 -61 
-14 -91 123 -69 86 93 22 110 -74 65 14 85 -6 -78 9 55 
114 94 29 42 64 -92 -48 -49 90 60 -77 -100 -111 111 -102 8 
49 -2 126 -47 -79 122 -19 124 40 70 -43 -30 98 20 -93 -105 
-104 -83 3 27 -82 45 127 -10 51 -36 -117 27 -76 -26 7 79 
32 56 -95 -97 -120 102 74 -106 5 88 66 -20 -66 91 53 -41 
6 25 106 118 121 41 17 -88 -57 96 -23 43 -12 -67 -54 -60 
83 30 -112 -70 67 0 39 44 -42 -98 -17 68 -34 1 -128 -16 
-55 -52 97 -53 35 -56 -81 -5 -37 -115 -119 -90 107 -18 81 61 
47 -87 58 13 72 -35 -96 104 -109 -116 -38 34 117 31 108 69 
-80 2 -108 95 -32 115 36 -28 -84 -118 -8 -1 -24 -113 82 -124 
120 -11 52 -73 18 113 -39 87 -68 92 -123 80 -62 -107 -33 -9 
-71 -63 24 -21 77 -45 -13 100 -27 -7 -72 112 -29 89 76 59 
-122 99 -127 116 109 -89 -85 62 57 15 -110 63 10 38 -3 4 
119 -59 21 -40 73 125 78 -65 12 19 -4 -103 -125 37 -101 103 
-126 -86 11 23 75 101 46 -22 50 -44 -15 -31 48 -46 71 -99
				<</bytefile>>
				<<textfile "result.out">>
6 +1
7 +1
1 +1
3 +1
8 +1
5 +1
4 +1
9 +1
2 +1
0 +1
10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-digit--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>
			<<case "charset-posix-graph" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - graph
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

graph	[[:graph:]]
print	[[:print:]]
blank	[[:blank:]]
punct	[[:punct:]]
space	[[:space:]]
cntrl	[[:cntrl:]]
cidf	[[:cidf:]]
cids	[[:cids:]]
					<</declare_section>>
					<<lex_section>>
{graph}		ncnt := ncnt + 1;
			nchars := nchars + 1;
			writeln(yytext, ' +1');
{graph}{2}	ncnt := ncnt + 4;
			nchars := nchars + 2;
			writeln(yytext, ' +4');
{graph}+	ncnt := ncnt + 3 * yyleng;
			nchars := nchars + yyleng;
			writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>

					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-100 -54 -41 127 91 -15 40 -14 -78 -22 95 -102 -111 -52 -43 -88 
-89 -12 99 103 94 48 -44 74 -29 -113 -36 -94 -103 71 -55 -83 
72 77 114 -116 -26 3 -71 38 -39 -120 -118 98 52 23 -4 -73 
-80 -31 -87 56 2 106 109 -99 89 -112 -59 -70 -119 29 90 -1 
66 115 -33 19 79 104 -79 -86 9 82 69 -96 33 119 17 51 
-34 -121 -25 -35 101 -75 121 5 -108 -17 -24 108 -127 -47 -48 120 
-122 84 105 -93 -64 43 -37 -62 -60 -77 -13 -11 50 68 -38 86 
73 -72 122 -61 -65 -23 41 123 14 62 25 12 10 -95 -82 18 
57 -51 -30 111 53 -97 110 15 -49 83 -2 67 64 31 -3 45 
-85 -28 92 -42 -101 30 -27 55 42 -92 118 -128 -91 16 60 -90 
96 59 -66 39 -18 -21 28 7 4 -32 -63 80 -67 -123 37 -76 
-40 -74 21 27 -7 -6 -126 107 102 -117 -109 -115 81 76 27 113 
32 88 1 -53 -125 -58 -9 -110 0 -68 -19 6 -69 -57 54 124 
70 -114 -105 -10 44 -8 126 63 8 75 20 49 -124 11 22 125 
-5 61 -45 58 87 78 -50 -84 46 93 -16 85 -46 97 24 47 
117 116 65 -20 100 13 34 36 -98 -81 112 35 -107 -106 -104 -56 
				<</bytefile>>
				<<textfile "result.out">>
[ +1
( +1
_ +1
cg^0 +12
J +1
G +1
HMr +9
& +1
b4 +4
8 +1
jm +4
Y +1
Z +1
Bs +4
Oh +4
RE +4
!w +4
3 +1
e +1
y +1
l +1
x +1
Ti +4
+ +1
2D +4
VI +4
z +1
){ +4
> +1
9 +1
o5 +4
n +1
S +1
C@ +4
- +1
\ +1
7* +4
v +1
< +1
`; +4
' +1
P +1
% +1
kf +4
QL +4
q +1
X +1
6|F +9
, +1
~? +4
K +1
1 +1
} +1
= +1
:WN +9
.] +4
U +1
a +1
/utA +12
d +1
"$ +4
p# +4
168 94
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-graph--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>
			<<case "charset-posix-lower" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - lower
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
lower	[[:lower:]]

%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}
					<</declare_section>>
					<<lex_section>>
{lower}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{lower}{2}	ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{lower}+	ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-81 -95 86 58 -122 -116 -14 -27 110 -63 0 -105 19 16 -69 -39 
49 -60 -79 14 -15 -33 8 43 112 -128 -88 -62 -89 -67 88 -20 
62 -46 -2 -23 74 -101 -10 10 -28 40 -55 18 -61 106 -85 126 
-92 101 -47 -26 -48 -34 -86 -87 -3 66 123 47 118 -64 117 56 
-16 57 3 73 79 99 -125 82 59 6 -51 17 55 -112 68 -19 
32 28 11 67 36 115 -83 69 13 127 -74 -107 -96 98 -66 -77 
24 2 90 -108 114 -102 -73 7 -98 9 64 -12 29 72 -41 -40 
52 -123 -113 -109 -49 21 89 38 -1 108 -118 92 33 95 -6 105 
-24 -5 -13 -103 12 65 -94 -22 -35 54 -4 103 100 -38 -59 -111 
25 -21 35 34 -84 -18 -93 27 63 -32 -68 -78 84 5 -100 -58 
30 -25 85 -117 27 75 87 22 20 31 122 125 -124 4 94 -8 
-57 -50 -110 -104 83 78 -99 1 -75 -17 -56 51 -71 91 53 -80 
-127 -42 -29 111 -106 -31 61 107 -11 71 46 23 77 15 -44 -7 
-114 42 -65 119 48 -90 -30 -126 80 81 41 -9 -43 93 97 104 
50 39 116 -120 102 -76 121 120 -52 -97 -119 44 -121 -70 -82 96 
70 -53 -91 -72 37 -36 45 113 -115 109 -37 60 -54 76 124 -45 
				<</bytefile>>
				<<textfile "result.out">>
n +1
p +1
j +1
e +1
v +1
u +1
c +1
s +1
b +1
r +1
l +1
i +1
gd +4
z +1
o +1
k +1
w +1
ah +4
t +1
f +1
yx +4
q +1
m +1
32 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-lower--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>
			<<case "charset-posix-print" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - print
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

print	[[:print:]]
					<</declare_section>>
					<<lex_section>>

{print}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{print}{2}	ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{print}+	ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
45 -115 61 96 -10 -11 -86 -118 -92 -2 62 114 -70 52 53 58 
124 -28 27 -45 21 -105 95 -44 -25 123 46 79 54 -93 -124 -89 
31 51 -3 -22 -24 110 -94 -74 -12 36 19 -23 4 -59 -56 102 
10 -119 70 72 -96 -110 -5 68 -36 -127 0 -98 126 -112 -123 90 
108 35 -6 60 -34 -126 38 -68 -15 127 44 -82 -72 -9 94 -35 
105 -16 100 -113 -32 -27 103 48 -63 32 -4 -17 91 -47 -54 -128 
65 -95 -29 37 -40 -26 101 -99 13 97 -21 -43 116 -53 -57 49 
-90 1 14 88 -71 -33 16 -73 104 3 80 93 -108 -101 -78 84 
-8 89 111 20 122 98 29 28 -42 85 -61 117 -31 -116 18 22 
119 30 33 -103 -81 12 9 42 47 -121 27 -13 74 -100 -107 -97 
-49 78 -39 -18 -76 -104 67 120 77 109 -83 -120 17 -60 -41 15 
-65 -19 -102 107 -20 -7 -88 -1 81 63 -62 -77 -80 34 -106 -87 
83 -69 -111 -14 75 8 -64 71 64 -50 106 -55 -38 -91 -46 25 
-52 2 -85 121 -51 39 87 -79 57 125 24 -114 -58 -66 -30 41 
86 7 118 -125 -122 23 55 92 -75 40 43 113 -67 -109 -84 56 
11 59 99 76 112 73 -48 82 5 6 50 66 -117 69 -37 115 
				<</bytefile>>
				<<textfile "result.out">>
- +1
=` +4
>r +4
45:| +12
_ +1
{.O6 +12
3 +1
n +1
$ +1
f +1
FH +4
D +1
~ +1
Zl# +9
< +1
& +1
, +1
^ +1
i +1
d +1
g0 +4
  +1
[ +1
A +1
% +1
e +1
a +1
t +1
1 +1
X +1
h +1
P] +4
T +1
Yo +4
zb +4
U +1
u +1
w +1
! +1
*/ +4
J +1
N +1
CxMm +12
k +1
Q? +4
" +1
S +1
K +1
G@ +4
j +1
y +1
'W +4
9} +4
)V +4
v +1
7\ +4
(+q +9
8 +1
;cLpI +15
R +1
2B +4
E +1
s +1
171 95
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-print--->>>




<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>
			<<case "charset-posix-space" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - space
*/
					<</desc>>
					<<declare_section>>

%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

space	[[:space:]]
					<</declare_section>>
					<<lex_section>>
{space}			ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{space}{2}		ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{space}+		ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
111 -113 11 107 -106 2 -51 76 -112 -119 102 -121 -122 27 -47 77 
-109 32 3 -64 44 25 -9 -31 33 17 69 51 31 -99 67 1 
-1 97 -44 -85 -3 61 -62 78 -65 -111 -83 112 -38 -126 -21 43 
-84 84 56 48 -63 113 -79 68 16 6 -29 39 -59 123 71 41 
-37 4 42 -34 95 86 14 91 19 85 -8 45 -71 -90 -98 89 
10 -32 62 -58 -80 23 74 -43 118 98 -86 126 63 -35 -10 66 
109 -13 -127 72 46 -94 -19 58 -102 -81 122 -11 -55 121 83 117 
-72 116 -114 101 -16 9 53 -5 -69 -15 -95 -50 52 -117 -33 -66 
-49 -92 124 -115 99 28 -7 108 -110 0 -2 -107 -77 55 -18 94 
-78 88 12 7 -4 37 -74 -24 22 -46 -52 64 15 -89 8 103 
-30 -45 -97 114 -101 -96 -20 -26 -128 -36 -57 18 5 -48 -40 79 
-22 -91 13 29 -104 100 73 -108 -88 70 75 -6 -53 57 -73 93 
-76 92 -123 80 105 -75 21 81 -67 -103 -42 82 -125 -68 -17 -120 
115 59 87 -124 120 90 -28 -27 106 24 96 -14 119 30 26 60 
-118 47 -82 -25 110 104 -70 49 65 -56 20 34 -61 -105 50 -23 
-93 -60 40 35 54 38 125 127 -100 -41 -87 36 -39 -54 -12 -116 
				<</bytefile>>
				<<bytefile "result.out">>
11 32 43 49 10 32 32 43 49 10 10 32 43 49 10 9 
32 43 49 10 12 32 43 49 10 13 32 43 49 10 54 32 
54 10
				<</bytefile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-space--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>
			<<case "charset-posix-upper" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - upper
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

upper	[[:upper:]]
					<</declare_section>>
					<<lex_section>>
{upper}			ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{upper}{2}		ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{upper}+		ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
-34 -84 -47 -124 91 80 -37 87 -104 48 74 -16 -126 -61 1 -62 
-67 58 102 34 32 -33 110 65 -102 85 75 124 -77 -125 122 -25 
7 -118 28 -13 70 -15 107 83 104 13 -65 27 49 42 46 10 
-23 69 90 101 -4 -80 5 -95 -49 120 119 62 15 23 66 67 
44 45 -53 20 -127 12 24 60 76 99 -20 57 59 -121 30 -123 
93 -103 29 -5 -31 -113 -41 118 72 21 0 -98 -22 54 73 -101 
-63 100 43 -6 -99 113 97 -10 38 -97 -40 17 11 -71 71 36 
-17 82 -26 -35 86 121 4 64 98 -114 -78 -46 -105 -30 94 -57 
117 63 25 22 -94 39 -119 -11 40 78 -106 -86 -54 111 95 18 
123 77 -39 89 52 -91 -115 -109 127 -48 50 33 -120 -100 79 68 
126 55 -9 2 -68 -107 -90 -89 -88 -87 -117 -85 14 -83 -82 -81 
53 -79 -122 19 -76 -75 -74 -73 -72 109 -70 -69 -92 16 -66 61 
-64 96 51 41 -60 -59 -58 8 -56 -55 -116 88 -52 -51 -50 56 
81 -93 -112 -45 -44 -43 -42 116 106 -110 -38 6 -36 115 -128 27 
-32 84 125 -29 -28 -27 114 31 -24 9 92 -21 47 -19 -18 112 
108 37 -14 35 -12 -111 103 3 -8 -7 -96 105 -108 -3 -2 -1 
				<</bytefile>>
				<<textfile "result.out">>
P +1
W +1
J +1
A +1
UK +4
F +1
S +1
EZ +4
BC +4
L +1
H +1
I +1
G +1
R +1
V +1
N +1
M +1
Y +1
OD +4
X +1
Q +1
T +1
34 26
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-upper--->>>


<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>
			<<case "charset-posix-xdigit" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test posix charset - xdigit
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

xdigt	[[:xdigit:]]
					<</declare_section>>
					<<lex_section>>

{xdigt}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{xdigt}{2}	ncnt := ncnt + 4; nchars := nchars + 2; writeln(yytext, ' +4');
{xdigt}+	ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<bytefile "test.input">>
121 -78 -90 74 45 -59 -107 80 -96 112 78 -54 -113 -84 56 -63 
-73 9 -79 10 8 -8 42 69 111 104 118 57 -88 117 95 -87 
-81 38 -40 70 85 54 -67 -121 -37 -45 32 44 127 -60 -19 22 
40 -46 109 -122 3 -68 29 43 99 90 -98 -76 -117 -125 -4 61 
-111 53 -62 31 123 2 -39 68 -126 103 86 -118 11 -24 114 -72 
50 115 27 -14 18 -53 94 -77 -103 126 13 -31 -23 72 -22 -42 
89 -16 -34 -94 63 -70 -66 75 -12 -51 -100 -85 -35 60 5 28 
-115 -120 65 -30 79 98 -128 -97 -92 -1 6 113 -36 -102 -29 15 
119 37 -6 105 27 -61 36 19 25 21 39 -91 -114 110 -21 91 
-112 30 24 67 34 35 -38 1 -9 58 -11 -93 -26 -17 -3 -20 
4 73 17 66 -104 -7 -47 -32 -127 0 -2 64 -65 -50 -74 -110 
-123 106 -105 -124 83 33 52 122 -15 -108 102 100 -75 88 125 107 
-95 -10 -5 51 -58 93 97 49 71 -116 108 -44 23 -71 124 -101 
82 62 46 -82 -86 14 55 -41 47 76 12 77 101 48 -64 59 
-55 116 87 -13 7 -119 -52 20 81 -28 92 -99 -33 -56 -49 -69 
-48 -109 -106 -89 41 -80 -27 120 -25 96 -57 -83 84 16 -43 -18 
				<</bytefile>>
				<<textfile "result.out">>
8 +1
E +1
9 +1
F +1
6 +1
c +1
5 +1
D +1
2 +1
A +1
b +1
C +1
B +1
4 +1
fd +4
3 +1
a1 +4
7 +1
e0 +4
28 22
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-posix-xdigit--->>>


<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>
			<<case "charset-single-a" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
Test charset set has only a single char
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var ncnt, nchars: integer %}
%actual-param%{ ncnt, nchars %}

aset	[a]
					<</declare_section>>
					<<lex_section>>
{aset}		ncnt := ncnt + 1; nchars := nchars + 1; writeln(yytext, ' +1');
{aset}{2,5}	ncnt := ncnt + 2 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 2);
{aset}+		ncnt := ncnt + 3 * yyleng; nchars := nchars + yyleng; writeln(yytext, ' +', yyleng * 3);
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
	nchars: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
	nchars := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt, nchars);
	writeln(ncnt, ' ', nchars);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abbbbbbaaaaaaaaaabbaaaaaaaaabbbbbbaaaaaaaabaaaaaaaaaaaaaaabbbaaaaaaaabbaaaaabbbaaabaabbaaaabbbaaabbabbbaabbbbb
				<</textfile>>
				<<textfile "result.out">>
a +1
aaaaaaaaaa +30
aaaaaaaaa +27
aaaaaaaa +24
aaaaaaaaaaaaaaa +45
aaaaaaaa +24
aaaaa +10
aaa +6
aa +4
aaaa +8
aaa +6
a +1
aa +4
190 71
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/charset/charset-single-a--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/charset---------->>>



<<<----------sub-suite: /lex-alone/basic/lookahead---->>>
		<<suite "lookahead" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>
			<<case "lookahead-mixture" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore, yyless, yyunput
*/
					<</desc>>
					<<lex_section>>
"hell"			
"hello"(\,?" ")?	writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);
			yymore();

"seat"			writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);
			yyless(1);
			yyunput('b');

"beat"			writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);

"seat"/tle		writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);
			yyless(1);
			yyunput('b');

"beat"/tle		writeln;
			writeln('whole-text = ', yytext);	
			writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
			writeln('valid-text = ', yytext);

.|\n			write(yytext);
					<</lex_section>>

					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
seat-eh, hello, seattle
				<</textfile>>
				<<textfile "result.out">>

whole-text = seat
lookahead-text = 
valid-text = seat

whole-text = beat
lookahead-text = 
valid-text = beat
-eh, 
whole-text = hello, 
lookahead-text = 
valid-text = hello, 

whole-text = hello, seattle
lookahead-text = tle
valid-text = hello, seattle
bello, 
whole-text = seattle
lookahead-text = tle
valid-text = seattle

whole-text = beattle
lookahead-text = tle
valid-text = beattle
tle
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-mixture--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>
			<<case "lookahead-multiple" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/
					<</desc>>

					<<global_decl_code>>
var
	lineno: integer;
	bla: boolean;
					<</global_decl_code>>
					<<init_code>>
	lineno := 1;
	bla := false;
					<</init_code>>
					<<declare_section>>

cid	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	yyleng := yyleng - 1;
			while (yytext[yyleng] = #32) or (yytext[yyleng] = #9) do
				yyleng := yyleng - 1;

			yyleng := yyleng + 1;
			yytext[yyleng] := #0;
			bla := true;
			writeln('k', lineno, ':', yytext);	
if		|
else		|
return		|
#include		writeln('t', lineno, ':', yytext); 
.			if bla then	writeln(yytext);
			bla := false;
\n			lineno := lineno + 1;
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test lookahead: multiple rules contain trailing context symbol ('/')
*/

%{

#include <iostream>
using std::cout;
using std::endl;
%}

cid	[[:cidf:]][[:cids:]]*

%%
	int lineno = 1;
	bool bla = false;

if[\t ]*/"("	|
else[\t ]*/"{"	|
return/[ \t]	|
#include[\t ]*/"<"	for(--yyleng; yytext[yyleng] == ' ' || yytext[yyleng] == '\t'; --yyleng) {
				
			}
			++yyleng;
			yytext[yyleng] = '\0';
			bla = true;
			cout << "k" << lineno << ":" << yytext << endl;	
if		|
else		|
return		|
#include		cout << "t" << lineno << ":" << yytext << endl; 
.			if(bla) {
				cout << yytext << endl;
			}
			bla = false;
\n			++lineno;
%%
/*do nothing */

int main(int argc, char **argv) {

	if(0 != yylex(NULL)) {
		
		return -1;
	}
	else {
		return 0;
	}
}
				<</textfile>>
				<<textfile "result.out">>
k7:#include
<
t18:if
t19:else
t20:return
t21:#include
t28:if
t29:else
k30:return
	
t31:#include
k32:if
(
k42:if
(
k44:return
 
k46:else
{
k47:return
 
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-multiple--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>
			<<case "lookahead-single" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test basic functionality of lookahead feature
*/
					<</desc>>

					<<global_decl_code>>
var
	abcs: integer;
					<</global_decl_code>>
					<<init_code>>
	abcs := 0;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
abc/d	abcs := abcs + 1;
	writeln('whole-text = ', yytext);	
	writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
	yytext[yyleng] := #0;
	writeln('valid-text = ', yytext);

abc
.|\n	write(yytext);

<<EOF>>	writeln('number of "abc/d" is ', abcs);
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abcd
abc
babcd
babc
				<</textfile>>
				<<textfile "result.out">>
whole-text = abcd
lookahead-text = d
valid-text = abc
d

bwhole-text = abcd
lookahead-text = d
valid-text = abc
d
b
number of "abc/d" is 2
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-single--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>
			<<case "lookahead-yyless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yyless
*/
					<</desc>>

					<<global_decl_code>>
var
	bla: boolean;
					<</global_decl_code>>
					<<init_code>>
	bla := false;
					<</init_code>>
					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
gabcde/f	writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		yyless(1);
		bla := true;

abc/d		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		yyless(1);
		bla := true;

b/c		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;

abc		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := false;

.|\n	if bla then	writeln(yytext);
		bla := false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
gabcdefg
				<</textfile>>
				<<textfile "result.out">>
whole-text = gabcdef
lookahead-text = f
valid-text = gabcde
whole-text = abcd
lookahead-text = d
valid-text = abc
whole-text = bc
lookahead-text = c
valid-text = b
c
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yyless--->>>


<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>
			<<case "lookahead-yymore" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test lookahead: lookahead rule work together with yymore
*/
					<</desc>>

					<<global_decl_code>>
var
	bla: boolean;
					<</global_decl_code>>
					<<init_code>>
	bla := false;
					<</init_code>>

					<<declare_section>>
					<</declare_section>>
					<<lex_section>>
Hello\,\040/world\!	begin	
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;
		yymore();
	end;
world\!			begin	
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := false;
	end;
Michael/" "Jodan	begin	
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;
		yymore();
	end;
" "Jodan		begin
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := false;
	end;

Jackson"--"/King" of "R"&"R	begin
		writeln('whole-text = ', yytext);	
		writeln('lookahead-text = ', pchar(yytext + sizeof(char) * yyleng));
		yytext[yyleng] := #0;
		writeln('valid-text = ', yytext);
		bla := true;
	end;

.|\n	if bla then writeln(yytext);
		bla := false;

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
Hello, world!
Michael Jodan
Jackson--King of R&R
abc
				<</textfile>>
				<<textfile "result.out">>
whole-text = Hello, world!
lookahead-text = world!
valid-text = Hello, 
whole-text = Hello, world!
lookahead-text = 
valid-text = Hello, world!
whole-text = Michael Jodan
lookahead-text =  Jodan
valid-text = Michael
whole-text = Michael Jodan
lookahead-text = 
valid-text = Michael Jodan
whole-text = Jackson--King of R&R
lookahead-text = King of R&R
valid-text = Jackson--
K
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/lookahead/lookahead-yymore--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/lookahead---->>>


<<<----------sub-suite: /lex-alone/basic/option---->>>
		<<suite "option" make="subdir-makefile-template">>


<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>
			<<case "lex-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: duplicated option

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%option debug=1
%option debug=yes
%option debug="yes"
					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>
				
			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>
				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-duplicated--->>>


<<<----------case: /lex-alone/basic/option/lex-option1--->>>
			<<case "lex-option1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test option setting
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*
					<</declare_section>>
					<<lex_section>>
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	begin
		writeln(yytext);
		ncnt := ncnt + 1;
	end;
.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test option setting
*/
%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{ int &ncnt %}
%actual-param%{ ncnt %}

%option debug=3
%option debug1 5
%option verbose off
%option detail=on
%option just-test yes
%option you-are-joking true
%option file-path="~/upgen/"
%option file-name no-title.c.cpp
id	[[:cidf:]][[:cids:]]*

%%
\+
\-
\*
\/
[0-9]+
\=
[Aa][Dd]{2}
[Ss][Uu][Bb]

[Mm][Uu][Ll]

[Dd][Ii][Vv]

{id}
	{
		cout << yytext << endl;
		++ncnt;
	}
.|\n

%%
int main(int argc, char **argv) {
	
	int ncnt = 0;
	int nret = yylex(NULL, ncnt);
	cout << ncnt << endl;

	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
test
option
setting
include
iostream
using
std
cout
using
std
endl
formal
param
int
ncnt
actual
param
ncnt
option
debug
option
debug1
option
verbose
off
option
detail
on
option
just
test
yes
option
you
are
joking
true
option
file
path
upgen
option
file
name
no
title
c
cpp
id
cidf
cids
Aa
Dd
Ss
Uu
Bb
Mm
Uu
Ll
Dd
Ii
Vv
id
cout
yytext
endl
ncnt
n
int
main
int
argc
char
argv
int
ncnt
int
nret
yylex
NULL
ncnt
cout
ncnt
endl
return
nret
86
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-option1--->>>


<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>
			<<case "lex-unsupported" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test ulex options: unsupported options
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%array
%pointer
%8bit
%case-insentitive

					<</declare_section>>
					<<lex_section>>
.|\n
					<</lex_section>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
				<</textfile>>
				<<textfile "result.out">>
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/option/lex-unsupported--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/option---->>>


<<<----------sub-suite: /lex-alone/basic/reop---->>>
		<<suite "reop" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>
			<<case "charset-plus" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexical analyse float number in C
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var ints, floats: integer %}
%actual-param%{ ints, floats %}

int		[\+\-]?[0-9]+
basic		{int}(\.[0-9]+)?
float		{basic}([EFef]{int})?
					<</declare_section>>
					<<lex_section>>
{int}
		writeln(yytext);
		ints := ints + 1;
{float}

		writeln(yytext);

		floats := floats + 1;
.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	ni: integer;
	nf: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ni := 0;
	nf := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ni, nf);
	writeln('number of integer: ', ni);
	writeln('number of float: ', nf);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
123
39999999900000000000E
234.5Fa3423
23f4.5
566666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
39999999900000000000
234.5
3423
23f4
5
566666
3
45e0
3
4.5
6E8
4E34
5
6E8
0.00000000000f000034
00000000.9f000034
9.7F34
9
7F3
4
number of integer: 10
number of float: 11
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-plus--->>>

<<<----------case: /lex-alone/basic/reop/charset-range--->>>
			<<case "charset-range" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: range

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var cnt1, cnt2, cnt3, cnt4: integer %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

eq4a	a{4}
lt3b	b{,3}
gt2c	c{2,}
d2t5	d{2,5}
					<</declare_section>>
					<<lex_section>>

{eq4a}		cnt1 := cnt1 + 1; writeln(yytext, ' --> match {eq4a}');
{lt3b}		cnt2 := cnt2 + 1; writeln(yytext, ' --> match {lt3b}');
{gt2c}		cnt3 := cnt3 + 1; writeln(yytext, ' --> match {gt2c}');
{d2t5}		cnt4 := cnt4 + 1; writeln(yytext, ' --> match {d2t5}');
.|\n
<<EOF>>		writeln('end of file reached.');
					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt1: integer;
	ncnt2: integer;
	ncnt3: integer;
	ncnt4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt1 := 0;
	ncnt2 :=0;
	ncnt3 := 0;
	ncnt4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex( ncnt1, ncnt2, ncnt3, ncnt4);
	writeln('aaa: ', ncnt1);
	writeln('-bbb: ', ncnt2);
	writeln('cc-: ', ncnt3);
	writeln('dd-ddddd: ', ncnt4);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
.aaaddd.........aaaadddddddd.......aaaaaabbabbbbbbbbbbbbbbbaaaaaaaaabdddddddddd.......................................ddd................ccccccccccddddddddddddddddddddddddddddddaaaaaaabbbbbbbbbbbbbbbbdddd..ddddddd...............ddddd...ccccdddddddddddddddddddddddcccccccdbbbbbbbbbbcccccccccccccccccccccccdddd...aaaaaaaaaacccccccccddddddddddddbbbbbbbbbcccccc........aaaaaaaaa.........aaaddd......ddd......bbbbbbbbbbcccccccccccddd......aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadddddddddd.ccccccdddddddddddddddddddddddcccccccccddddddddddddaabbbbbbbbbbbbbbbbbbbbbbdddddd........................ccccccddddd
				<</textfile>>
				<<textfile "result.out">>
ddd --> match {d2t5}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddd --> match {d2t5}
aaaa --> match {eq4a}
bb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
b --> match {lt3b}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
cccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
aaaa --> match {eq4a}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
dddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
ddddd --> match {d2t5}
cccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccc --> match {gt2c}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccccccccccccccc --> match {gt2c}
dddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
cccccc --> match {gt2c}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddd --> match {d2t5}
ddd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ccccccccccc --> match {gt2c}
ddd --> match {d2t5}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
aaaa --> match {eq4a}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
ddd --> match {d2t5}
ccccccccc --> match {gt2c}
ddddd --> match {d2t5}
ddddd --> match {d2t5}
dd --> match {d2t5}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
bbb --> match {lt3b}
b --> match {lt3b}
ddddd --> match {d2t5}
cccccc --> match {gt2c}
ddddd --> match {d2t5}
end of file reached.
aaa: 22
-bbb: 32
cc-: 10
dd-ddddd: 40
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-range--->>>

<<<----------case: /lex-alone/basic/reop/charset-star--->>>
			<<case "charset-star" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: star & option
lexically analyse real number in PASCAL
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

/* unsigned positve integer */
nonzero		[1-9][0-9]*
/* natural number */
natural		0|{nonzero}
/* mantissa */
mant		[0-9]*[1-9]
/* basic representation of real number*/
basic		[\+\-]?{natural}(\.{mant})?
/* scientific representatio of real number */
/*scient		{basic}[Ee][\+\-]{nonzero}*/
/* pascal real number */
preal		{basic}([Ee][\+\-]?{nonzero})?
					<</declare_section>>
					<<lex_section>>

{preal}		begin
		writeln(yytext);
		ncnt := ncnt + 1;
		end;

.|\n
					<</lex_section>>
					
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln(ncnt);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
123
234.5ea3423
23e4.5
566a666e.3
45e0.3
4.5.6E8
4E34.5EF6E8
9.7F34
9.sda7F3bn4
ert
				<</textfile>>
				<<textfile "result.out">>
123
234.5
3423
23e4
5
566
666
3
45
0.3
4.5
6E8
4E34
5
6E8
9.7
34
9
7
3
4
21
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-star--->>>

<<<----------case: /lex-alone/basic/reop/charset-union--->>>
			<<case "charset-union" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test charset operation: union
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var cnt1, cnt2, cnt3, cnt4: integer %}
%actual-param%{ cnt1, cnt2, cnt3, cnt4 %}

int	(\+|\-)?((0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*|0)
hex	\\(X|x)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)
oct	\\(0|1|2|3)(0|1|2|3|4|5|6|7)(0|1|2|3|4|5|6|7)
real	{int}(\.(0|1|2|3|4|5|6|7|8|9)(1|2|3|4|5|6|7|8|9)*)?
					<</declare_section>>
					<<lex_section>>

{int}		cnt1 := cnt1 + 1;
		writeln(yytext);
{hex}		cnt2 := cnt2 + 1;
		writeln(yytext);
{oct}		cnt3 := cnt3 + 1;
		writeln(yytext);
{real}		cnt4 := cnt4 + 1;
		writeln(yytext);
.|\n
					<</lex_section>>

					<<local_decl_code>>
var
	ncnt1: integer;
	ncnt2: integer;
	ncnt3: integer;
	ncnt4: integer;
	nret: integer;
					<</local_decl_code>>
					
					<<before_init>>
	ncnt1 := 0;
	ncnt2 := 0;
	ncnt3 := 0;
	ncnt4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt1, ncnt2, ncnt3, ncnt4);
	writeln('int: ', ncnt1);
	writeln('hex: ', ncnt2);
	writeln('oct: ', ncnt3);
	writeln('real: ', ncnt4);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
\X3289f
434.3300.342.43423.9324.4320
\580523
\2347843
tfghui90ioik568io
00.00.00.00.00.00.090000
00x9000

				<</textfile>>
				<<textfile "result.out">>
\X32
89
434.33
0
0.342
43423.9324
432
0
58
0523
\234
7843
9
0
568
0
0.0
0.0
0.0
0.0
0.0
0.09
0
0
0
0
0
0
9
0
0
0
int: 21
hex: 1
oct: 1
real: 9
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/reop/charset-union--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/reop---->>>


<<<----------sub-suite: /lex-alone/basic/rule---->>>
		<<suite "rule" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>
			<<case "rule-bol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test bol(beginning of line) flag
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{var bols, nbols: integer%}
%actual-param%{bols, nbols%}
					<</declare_section>>
					<<lex_section>>
^"#include"	
		writeln(yytext, ' => matched ^"#include"');
		bols := bols + 1;
	
"#include"	
		writeln(yytext, ' => matched "#include"');
		nbols := nbols + 1;
	
"#import"	
		writeln(yytext, ' => matched "#import"');
		nbols := nbols + 1;
	
^"#if"		
		writeln(yytext, ' => matched ^"#if"');
		bols := bols + 1;
	
"#if"		
		writeln(yytext, ' => matched "#if"');
		nbols := nbols + 1;
	
"#cond"		
		writeln(yytext, ' => matched "#cond"');
		nbols := nbols + 1;
	
.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('at_bol: ', n1);
	writeln('not_at_bol: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
/*
test regular expression: bol flag is set

Sample:
#include
 #include
#import
	#import
#if #if
#cond
#cond

*/

%{
#include <iostream>
using std::cout;
using std::endl;
%}

%formal-param%{int &bols, int &nbols%}
%actual-param%{bols, nbols%}

%%
^"#include"	{
		cout << yytext << " => matched ^\"#include\"" << endl;
		++bols;
	}
"#include"	{
		cout << yytext << " => matched \"#include\"" << endl;
		++nbols;
	}
"#import"	{
		cout << yytext << " => matched \"#import\"" << endl;
		++nbols;
	}
^"#if"		{
		cout << yytext << " => matched ^\"#if\"" << endl;
		++bols;
	}
"#if"		{
		cout << yytext << " => matched \"#if\"" << endl;
		++nbols;
	}
"#cond"		{
		cout << yytext << " => matched \"#cond\"" << endl;
		++nbols;
	}
.|\n

%%

int main(int argc, char **argv) {

	int n1 = 0, n2 = 0;
	int nret = yylex(NULL, n1, n2);
	
	cout << "at_bol: " << n1 << endl 
	     << "not_at_bol: " << n2 << endl;
	return nret;
}
				<</textfile>>
				<<textfile "result.out">>
#include => matched ^"#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched ^"#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
#include => matched ^"#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#include => matched "#include"
#import => matched "#import"
#import => matched "#import"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#if => matched "#if"
#cond => matched "#cond"
#cond => matched "#cond"
at_bol: 3
not_at_bol: 18
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>
			<<case "rule-bol-sc-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 1
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var _as, bs: integer%}
%actual-param%{ _as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	_as := _as +  2; writeln(yytext, ' => matched `^a''');
a	_as := _as + 1; writeln(yytext, ' => matched `a''');
^b	bs := bs + 2; writeln(yytext, ' => matched `^b''');
b	bs := bs + 1; writeln(yytext, ' => matched `b''');

.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abc		2	1
actual bonus	5	2
beta		6	4
beattles	7	6
business man	8	8
blog address	9	10
as useful tool	11	10

				<</textfile>>
				<<textfile "result.out">>
a => matched `^a'
b => matched `b'
a => matched `^a'
a => matched `a'
b => matched `b'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
b => matched `^b'
a => matched `a'
a => matched `^a'
a's: 11
b's: 10
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>
			<<case "rule-bol-sc-2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 2
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var _as, bs: integer%}
%actual-param%{ _as, bs %}

					<</declare_section>>
					<<lex_section>>
^a	_as := _as +  2; writeln(yytext, ' => matched `^a''');
a	_as := _as + 1; writeln(yytext, ' => matched `a''');
b	bs := bs + 1; writeln(yytext, ' => matched `b''');
^bb	bs := bs + 4; writeln(yytext, ' => matched `^bb''');

.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('a''s: ', n1);
	     writeln('b''s: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
bbcc...aaa	3	4
aa		6	4
bbbbbb		6	12
cccaacccc	8	12
aaaaaaaa	17	12
...bbcbbb	17	17
ccaaa		20	17
aaax		24	17
xaaa		27	17
...aa		29	17
bbabjjabaa	33	23
bababa		36	26
a......aa	40	26
aa		43	26
aaabbb		47	29
				<</textfile>>
				<<textfile "result.out">>
bb => matched `^bb'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
bb => matched `^bb'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
b => matched `b'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
a => matched `a'
bb => matched `^bb'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
b => matched `b'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `^a'
a => matched `a'
a => matched `a'
b => matched `b'
b => matched `b'
b => matched `b'
a's: 47
b's: 29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-2--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>
			<<case "rule-bol-sc-3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, bs, cs, ds, es, fs, gs: integer%}
%actual-param%{ _as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>

a|b		if yytext[0] = 'a' then begin

			_as := _as + 1;
			yy_push_state(asc);
		end
		else begin
			bs := bs + 1;
			yy_push_state(bsc);
		end;
		
<*>[cd]		case yytext[0] of
				'c': cs := cs +  2;
				else  ds := ds + 2;
			end;

<asc,bsc>[abce]	case yytext[0] of
					'a': _as := _as +  3;
					'b': bs := bs + 3;
					'c': cs := cs +  3;
					else  es := es + 3;
				end;
				
<asc>f		fs := fs + 4;
<bsc>[fg]	if yytext[0] = 'f' then
				fs := fs + 5
			else begin
				gs := gs + 5;
			end;
			
<asc>aa		yy_pop_state(); _as := _as +  6;
<bsc>bb		yy_pop_state(); bs := bs + 6;
<*>.|\n

					<</lex_section>>
					
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	n5: integer;
	n6: integer;
	n7: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
	n5 := 0;
	n6 := 0;
	n7 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n2, n3, n4, n5, n6, n7);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);
	writeln('c''s: ', n3);
	writeln('d''s: ', n4);
	writeln('e''s: ', n5);
	writeln('f''s: ', n6);
	writeln('g''s: ', n7);

	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			7	0	0	0	0	0	0
a			8	0	0	0	0	0	0
	ggggg		8	0	0	0	0	0	0
	cccc		8	0	8	0	0	0	0
	ddddd		8	0	8	10	0	0	0
	fffff		8	0	8	10	0	20	0
aa			14	0	8	10	0	20	0
a			15	0	8	10	0	20	0
aa			21	0	8	10	0	20	0
a			22	0	8	10	0	20	0
	bbbbbbb		22	21	8	10	0	20	0
	ddddddddd	22	21	8	28	0	20	0
	ee		22	21	8	28	6	20	0
aa			28	21	8	28	6	20	0
a			29	21	8	28	6	20	0
aa			35	21	8	28	6	20	0
a			36	21	8	28	6	20	0
aa			42	21	8	28	6	20	0
b			42	22	8	28	6	20	0
bb			42	28	8	28	6	20	0
b			42	29	8	28	6	20	0
bb			42	35	8	28	6	20	0
b			42	36	8	28	6	20	0
bb			42	42	8	28	6	20	0
b			42	43	8	28	6	20	0
bb			42	49	8	28	6	20	0
b			42	50	8	28	6	20	0
bb			42	56	8	28	6	20	0
b			42	57	8	28	6	20	0
	ggggg..........	42	57	8	28	6	20	25
	g		42	57	8	28	6	20	30
	a		45	57	8	28	6	20	30
	ddddddd		45	57	8	42	6	20	30
	eeeee		45	57	8	42	21	20	30
	f		45	57	8	42	21	25	30
	eeeeeeeee	45	57	8	42	48	25	30
	ffff		45	57	8	42	48	45	30
	aaaaaaa		66	57	8	42	48	45	30
bb			66	63	8	42	48	45	30
b			66	64	8	42	48	45	30
bb			66	70	8	42	48	45	30
b			66	71	8	42	48	45	30
	cccccccc	66	71	24	42	48	45	30
	ddddd....	66	71	24	52	48	45	30
bb			66	77	24	52	48	45	30
a			67	77	24	52	48	45	30
	a		70	77	24	52	48	45	30
	cccc		70	77	32	52	48	45	30
	ddddd		70	77	32	62	48	45	30
	ffffff		70	77	32	62	48	69	30
	gggggg		70	77	32	62	48	69	30
	ddddd		70	77	32	72	48	69	30
	e		70	77	32	72	51	69	30
	ffggggg		70	77	32	72	51	77	30
	ee		70	77	32	72	57	77	30
	b		70	80	32	72	57	77	30
	dddd		70	80	32	80	57	77	30
	eeee		70	80	32	80	69	77	30
				<</textfile>>
				<<textfile "result.out">>
a's: 70
b's: 80
c's: 32
d's: 80
e's: 69
f's: 77
g's: 30
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-3--->>>

<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>
			<<case "rule-bol-sc-4" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
combination of bol flag and start-conditions: case 4
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, bs, cs, ds, es, fs, gs: integer%}
%actual-param%{ _as, bs, cs, ds, es, fs, gs %}

%x	asc
%x	bsc

					<</declare_section>>
					<<lex_section>>

\{|\[		case yytext[0] of
				'{': YYBEGIN(asc);
				else  YYBEGIN(bsc);
			end;

<asc>^[abcdefg]	case yytext[0] of
		'a': _as := _as - 1;
		'b': bs := bs - 1;
		'c': cs := cs - 1;
		'd': ds := ds - 1;
		'e': es := es - 1;
		'f': fs := fs - 1;
		else gs := gs - 1;
		end;

<asc>[abcdefg]	case yytext[0] of
		'a': _as := _as + 1;
		'b': bs := bs + 1;
		'c': cs := cs + 1;
		'd': ds := ds + 1;
		'e': es := es + 1;
		'f': fs := fs + 1;
		else gs := gs + 1;
		end;

<bsc>^[abcdefg]	case yytext[0] of
		'a': _as := _as - 2;
		'b': bs := bs - 2;
		'c': cs := cs - 2;
		'd': ds := ds - 2;
		'e': es := es - 2;
		'f': fs := fs - 2;
		else  gs := gs - 2;
		end;
<bsc>[abcdefg]	case yytext[0] of
		'a': _as := _as +  2;
		'b': bs := bs + 2;
		'c': cs := cs + 2;
		'd': ds := ds + 2;
		'e': es := es + 2;
		'f': fs := fs + 2;
		else  gs := gs + 2;
		end;
<asc>\}		YYBEGIN(INITIAL);
<bsc>\]		YYBEGIN(INITIAL);

<*>^[abcdefg]	case yytext[0] of
		'a': _as := _as - 3;
		'b': bs := bs - 3;
		'c': cs := cs - 3;
		'd': ds := ds - 3;
		'e': es := es - 3;
		'f': fs := fs - 3;
		else  gs := gs - 3;
		end;
<*>[abcdefg]	case yytext[0] of
		'a': _as := _as +  3;
		'b': bs := bs + 3;
		'c': cs := cs +  3;
		'd': ds := ds + 3;
		'e': es := es + 3;
		'f': fs := fs + 3;
		else  gs := gs + 3;
		end;

^[abcdefg]	case yytext[0] of
		'a': _as := _as - 1000;
		'b': bs := bs - 1000;
		'c': cs := cs - 1000;
		'd': ds := ds - 1000;
		'e': es := es - 1000;
		'f': fs := fs - 1000;
		else  gs := gs - 1000;
		end;
[abcdefg]	case yytext[0] of
		'a': _as := _as +  1000;
		'b': bs := bs + 1000;
		'c': cs := cs +  1000;
		'd': ds := ds + 1000;
		'e': es := es + 1000;
		'f': fs := fs + 1000;
		else  gs := gs + 1000;
		end;
<*>.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	n5: integer;
	n6: integer;
	n7: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
	n5 := 0;
	n6 := 0;
	n7 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3, n4, n5, n6, n7);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);
	writeln('c''s: ', n3);
	writeln('d''s: ', n4);
	writeln('e''s: ', n5);
	writeln('f''s: ', n6);
	writeln('g''s: ', n7);

	if nret <> 0 then begin
		result := nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{			1	2	3	4	5	6	7	
........a		1	0	0	0	0	0	0
aa			1	0	0	0	0	0	0
a			0	0	0	0	0	0	0
	ggggg		0	0	0	0	0	0	5
cccc			0	0	2	0	0	0	5
	ddddd		0	0	2	5	0	0	5
	fffff		0	0	2	5	0	5	5
aa			0	0	2	5	0	5	5
a	aaa		2	0	2	5	0	5	5
aa	aaa		5	0	2	5	0	5	5
aa			5	0	2	5	0	5	5
bbb	bbb		5	4	2	5	0	5	5
ddd	dddd		5	4	2	10	0	5	5
ee	ee		5	4	2	10	2	5	5
aa	a		6	4	2	10	2	5	5
a			5	4	2	10	2	5	5
aa	aaa		8	4	2	10	2	5	5
a	a		8	4	2	10	2	5	5
}
[
aa			8	4	2	10	2	5	5
b			8	2	2	10	2	5	5
bb			8	2	2	10	2	5	5
b			8	0	2	10	2	5	5
bb			8	0	2	10	2	5	5
b			8	-2	2	10	2	5	5
bb			8	-2	2	10	2	5	5
b			8	-4	2	10	2	5	5
bb			8	-4	2	10	2	5	5
b			8	-6	2	10	2	5	5
bb			8	-6	2	10	2	5	5
b			8	-8	2	10	2	5	5
	ggggg..........	8	-8	2	10	2	5	15		
	a		10	-8	2	10	2	5	15
a			8	-8	2	16	2	5	15
	ddd		8	-8	2	16	2	5	15
	eeeee		8	-8	2	16	12	5	15
	f		8	-8	2	16	12	7	15
	ee		8	-8	2	16	16	7	15
	ffff		8	-8	2	16	16	15	15
	aaaaaaa		22	-8	2	16	16	15	15
bb			22	-8	2	16	16	15	15
b			22	-10	2	16	16	15	15
bb			22	-10	2	16	16	15	15
b			22	-12	2	16	16	15	15
	cccccccc	22	-12	18	16	16	15	15
	ddddd....	22	-12	18	26	16	15	15
bb			22	-12	18	26	16	15	15
a			20	-12	18	26	16	15	15
	a		22	-12	18	26	16	15	15
	cccc		22	-12	26	26	16	15	15
	ddddd		22	-12	26	36	16	15	15
	ffffff		22	-12	26	36	16	27	15
	ggg		22	-12	26	36	16	27	21
	ddddd		22	-12	26	46	16	27	21
	e		22	-12	26	46	18	27	21
	ffggggg		22	-12	26	46	18	31	31
	ee		22	-12	26	46	22	31	31
	b		22	-10	26	46	22	31	31
	dddd		22	-10	26	54	22	31	31
	eeee		22	-10	26	54	30	31	31
]

	eeeeeeeeee	22	-10	26	54	60	31	31
	eeeeeeeeee	22	-10	26	54	90	31	31
	eeeeeeeeee	22	-10	26	54	120	31	31
b			22	-13	26	54	120	31	31
b			22	-16	26	54	120	31	31
b			22	-19	26	54	120	31	31
b			22	-22	26	54	120	31	31
b			22	-25	26	54	120	31	31
b			22	-28	26	54	120	31	31
bgggggggggggggggggggg	22	-31	26	54	120	31	91
bgggggggggggggggggggg	22	-34	26	54	120	31	151
bgggggggggggggggggggg	22	-37	26	54	120	31	211
				<</textfile>>
				<<textfile "result.out">>
a's: 22
b's: -37
c's: 26
d's: 54
e's: 120
f's: 31
g's: 211
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-bol-sc-4--->>>

<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>
			<<case "rule-eof-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE <<EOF>>
*/
					<</desc>>
					<<global_decl_code>>
var
	current_sc: integer;
					<</global_decl_code>>
					
					<<init_code>>
	current_sc := 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, bs, cs, eofs: integer%}
%actual-param%{ _as, bs, cs, eofs %}

%x	asc
%s	bsc
%x	csc

					<</declare_section>>
					<<lex_section>>
<*><<EOF>>		eofs := eofs + 1;
a			YYBEGIN(asc); current_sc := 1;
b			YYBEGIN(bsc); current_sc := 2;
c			YYBEGIN(csc); current_sc := 3;
<asc,bsc,csc>[abc]	case yytext[0] of
			'a': begin
				if current_sc = 1 then begin
					YYBEGIN(INITIAL);
					current_sc := 0;
				end
				else
					_as := _as +  2;
				end;
			'b': begin
				if current_sc = 2 then begin
					YYBEGIN(INITIAL);
					current_sc := 0;
				end
				else
					bs := bs + 2;
				end;
			else begin
				if current_sc = 3 then begin
					YYBEGIN(INITIAL);
					current_sc := 0;
				end
				else
					cs := cs +  2;
				end;
			end;
			
<*>.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	eofs: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	eofs := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n2, n3, eofs);
	writeln('a''s: ', n1);
	writeln('b''s: ', n2);
	writeln('c''s: ', n3);
	writeln('eof''s: ', eofs);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
abba	 0 2 0
accca    0 2 3
baaaaaab 6 2 3
cbbbc    6 5 3
bccb     6 5 5
baaaab   105 5
accca    105 8
cccbbbbc 109 8
bccb     10910
aba      101010
				<</textfile>>
				<<textfile "result.out">>
a's: 20
b's: 20
c's: 20
eof's: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eof-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>
			<<case "rule-eol-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression
special RE $
*/

					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var lines: integer%}
%actual-param%{ lines %}
					<</declare_section>>
					<<lex_section>>
\.$	lines := lines + 1;
.|\n

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1);
	writeln('lines: ', n1);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
In the time since the 1986 edition of this book, the world of compiler design
has changed significantly. Programming languages have evolved to present new
compilation problems. Computer architectures offer a variety of resources of
which the compiler designer must take advantage. Perhaps most interestingly,
the venerable technology of code optimization has found use outside compilers.
It is now used in tools that find bugs in software, and most importantly, find		1
security holes in existing code. And much of the "front-end" technology -
grammars, regular expressions, parsers, and syntax-directed translators - are
still in wide use.
Thus, our philosophy from previous versions of the book has not changed.
We recognize that few readers will build, or even maintain, a compiler for a		2/3
major programming language. Yet the models, theory, and algorithms associated
with a compiler can be applied to a wide range of problems in software
design and software development . We therefore emphasize problems that are
most commonly encountered in designing a language processor, regardless of
the source language or target machine.
Use of the Book										4
It takes at least two quarters or even two semesters to cover all or most of the
material in this book. It is common to cover the first half in an undergraduate
course and the second half of the book - stressing code optimization - in
a second course at the graduate or mezzanine level. Here is an outline of the
chapters:
Chapter 1 contains motivational material and also presents some background
issues in computer architecture and programming-language principles.
Chapter 2 develops a miniature compiler and introduces many of the important		5
concepts, which are then developed in later chapters. The compiler itself
appears in the appendix.
Chapter 3 covers lexical analysis, regular expressions, finite-state machines, and	6
scanner-generator tools. This material is fundamental to text-processing of all
sorts.
											7
Chapter 4 covers the major parsing methods, top-down (recursive-descent , LL)
and bottom-up (LR and its variant s) .
Chapter 5 introduces the principal ideas in syntax-directed definitions and		8
syntax-directed translations.
Chapter 6 takes the theory of Chapter 5 and shows how to use it to generate		9
intermediate code for a typical programming language.
Chapter 7 covers run-time environment s, especially management of the run-time		10
stack and garbage collection.
Chapter 8 is on object-code generation. It covers construction of basic blocks,		11
generation of code from expressions and basic blocks, and register-allocation
techniques.
Chapter 9 introduces the technology of code optimization, including flow graphs,	12
data-flow frameworks, and iterative algorithms for solving these fr ameworks .
Chapter 10 covers instruction-level optimization. The emphasis is on the extraction	13
of parallelism from small sequences of instructions and scheduling them
on single processors that can do more than one thing at once.
Chapter 11 talks about larger-scale parallelism detection and exploitation. Here,	14
the emphasis is on numeric codes that have many tight loops that range over
multidimensional arrays.
Chapter 12 is on interprocedural analysis. It covers pointer analy sis, aliasing,	15
and data-flow analysis that takes into account the sequence of procedure calls
that reach a given point in the code.
Courses fr om material in this book have been taught at Columbia, Harvard,		16
and Stanford. At Columbia, a senior/first-year graduate course on programming
languages and translators has been regularly offered using material fr om
the first eight chapters. A highlight of this course is a semester-long project
in which students work in small teams to create and implement a little language
of their own design. The student-created languages have covered diverse
application domains including quantum computation, music synthesis, computer
graphics, gaming, matrix operations and many other areas. Students use
compiler-comp onent generators such as ANTLR, Lex, and Yacc and the syntaxdirected
translation techniques discussed in chapters two and five to build their
compilers. A follow-on graduate course has fo cused on material in Chapters 9
through 12, emphasizing code generation and optimization for contemporary
machines including network processors and multiprocessor architectures.
At Stanford, a one-quarter introductory course covers roughly the material		17
in Chapters 1 through 8, although there is an introduction to global code
optimization fr om Chapter 9. The second compiler course covers Chapters 9
through 12, plus the more advanced material on garbage collection from Chapter
7. Students use a locally developed , Java- based system called Joeq for
implementing data-flow analysis algorithms.
											18
The reader should possess some "computer-science sophistication," including
at least a second course on programming, and courses in data structures and
discrete mathematics. Knowledge of several different programming languages
is useful.
Exercises										19
The book contains extensive exercises, with some for almost every section. We
indicate harder exercises or parts of exercises with an exclamation point. The
hardest exercises have a double exclamation point.
Gradiance. On-Line Homeworks								20
A feature of the new edition is that there is an accompanying set of on-line
homeworks using a technology developed by Gradiance Corp. Instructors may
assign these homeworks to their class, or students not enrolled in a class may
enroll in an "omnibus class" that allows them to do the homeworks as a tutorial
(without an instructor-created class) . Gradiance questions look like ordinary
questions, but your solutions are sampled. If you make an incorrect choice you
are given specific advice or feedback to help you correct your solution. If your
instructor permits, you are allowed to try again, until you get a perfect score.
A subscription to the Gradiance service is offered with all new copies of this		21
text sold in North America. For more information, visit the Addison-Wesley
web site www . aw . com/gradiance or send email tocomput ing@aw . com.
Support on the World Wide Web								22
The book's home page is
dragonbook . stanford . edu
Here, you will find errata as we learn of them, and backup materials. We hope
to make available the notes for each offering of compiler-related courses as we
teach them, including homeworks, solutions, and exams. We also plan to post
descriptions of important compilers written by their implementers.
											23
				<</textfile>>
				<<textfile "result.out">>
lines: 23
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-eol-1--->>>

<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>
			<<case "rule-mcall-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: macro call
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
dec	[0-9]
hex	[0-9A-Fa-f]
sign	[\+\-]

%formal-param%{ var decs, hexes, signs: integer%}
%actual-param%{ decs, hexes, signs%}

					<</declare_section>>
					<<lex_section>>
{dec}+			decs := decs + 1;	writeln(yytext, ' [dec]');
{hex}+			hexes := hexes + 1; writeln(yytext, ' [hex]');
{sign}?({dec}+|{hex}+)	signs := signs + 1; writeln(yytext, ' [sign]');
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln('dec''s: ', n1);
	writeln('hex''s: ', n2);
	writeln('sign''s: ', n3);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
b7809
+-45fb
date: 1999.12.31
date: 2010.01.01
time: 23:59:59
time: 01:00:00
money: $999,999.99
phone: 0086-010-12345678
zip-code: 100233
sample text1
.0000-9990*&*$*&@%&ghf892efs
hello world on the earth
hi world in the universe
no more sample

				<</textfile>>
				<<textfile "result.out">>
b7809 [hex]
-45fb [sign]
da [hex]
e [hex]
1999 [dec]
12 [dec]
31 [dec]
da [hex]
e [hex]
2010 [dec]
01 [dec]
01 [dec]
e [hex]
23 [dec]
59 [dec]
59 [dec]
e [hex]
01 [dec]
00 [dec]
00 [dec]
e [hex]
999 [dec]
999 [dec]
99 [dec]
e [hex]
0086 [dec]
-010 [sign]
-12345678 [sign]
-c [sign]
de [hex]
100233 [dec]
a [hex]
e [hex]
e [hex]
1 [dec]
0000 [dec]
-9990 [sign]
f892ef [hex]
e [hex]
d [hex]
e [hex]
ea [hex]
d [hex]
e [hex]
e [hex]
e [hex]
e [hex]
a [hex]
e [hex]
dec's: 19
hex's: 25
sign's: 5
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-mcall-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>
			<<case "rule-multipattern-1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: multi REs share same action
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var goods, bads: integer%}
%actual-param%{ goods, bads %}
					<</declare_section>>
					<<lex_section>>
"good"		|
"great"		|
"terrific"	|
"nice"		|
"awesome"	goods := goods + 1;

"horrible"	|
"terrible"	|
"nightmare"	|
"disastrous"	bads := bads + 1;
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2);
	writeln('good-words: ', n1);
	writeln('bad-words: ', n2);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
<--- XDICT英汉辞典 --->
good
[gud]
n. 善行,好处,利益
a. 好的,优良的,上等的,愉快的,有益的,好心的,慈善的
<--- 朗道英漢字典5.0 --->
good
*[gud]
n. 善行, 好處, 利益
a. 好的, 優良的, 上等的, 愉快的, 有益的, 好心的, 慈善的, 虔誠的
【經】 貨物; 好的
相關詞組:
  for good
  for good or for evil
  good and
  good for
  hold good for
  in good time
  make good
  to the good
  good-bye
  say good-bye to sb
  as good as
<--- stardict1.3英汉辞典 --->
good
[gud]
n. 善行,好处;
a. 好的,优良的,上等的;
<--- 牛津現代英漢雙解詞典 --->
good
/ gUd; ^Jd/ adj (better / 5betE(r); `bZtL/, best /best; bZst/)  1 of high quality; of an acceptable standard; satisfactory 好的; 優質的; 符合標準的; 令人滿意的: a good lecture, performance, harvest 好的演講、 表演、 收成 * good pronunciation, behaviour, eyesight 好的發音、 行為、 視力 * a good (eg sharp) knife 快的刀 * Is the light good enough to take photographs? 光線適合照相嗎? * The car has very good brakes. 這輛汽車的剎車很靈. * Her English is very good. 她的英語很好.  2 (a) ~ (at sth) (often used with names of occupations or with ns derived from vs 常與職業名稱或動詞派生的名詞連用) able to perform satisfactorily; competent 表現令人滿意的; 有能力的: a good teacher, hairdresser, poet, etc 優秀的教師、 理發師、 詩人等 * good at mathematics, languages, describing things 擅長數學、 語言、 敘事 * a good loser, ie one who doesn't complain when he loses 輸得起的人. (b) [pred 作表語] ~ with sth/sb capable when using, dealing with, etc sth/sb 善於使用某物、 處事、 待人或用人: good with one's hands, eg able to draw, make things, etc 手巧（如會畫、 會做東西等） * He's very good with children, ie can look after them well, amuse them, etc. 他很會照看孩子.  3 (a) morally acceptable; virtuous 有道德的; 高尚的: a good deed 合乎道德的行為 * try to lead a good life 努力過高尚的生活. (b) (esp of a child) well-behaved （尤指兒童）守規矩的, 乖的: Try to be a good girl. 要做個乖女孩.  4 ~ (to sb) willing to help others; kind 樂於助人的; 好心的; 仁慈的: You were a good girl to help in the shop. 你幫店裡幹活兒, 是個好姑娘. * He was very good to me when I was ill. 我生病時他幫了我的大忙. * Would you be good enough to carry this for me? 勞駕給我拿著這個行嗎?  5 pleasant; agreeable; welcome 快樂的; 愉快的; 隨和的; 令人喜悅的: The firm has had good times and bad times. 這公司經歷過順境和逆境. * What good weather we're having! 天氣多好哇! * Have you heard the good news about my award? 你聽到我獲獎的好消息了嗎? * It's good to be home again. 重返家園, 令人快慰.  6 (of food) fit to be eaten; not yet rotting or rotten （指食物）適合食用的, 未腐敗的: good eggs, fruit, etc 新鮮的雞蛋、 水果等 * Separate the good meat from the bad. 把鮮肉和腐肉分開.  7 [usu attrib 通常作定語] not diseased; healthy; strong 無病的; 健康的; 強健的: good teeth and bones 健康的牙齒和骨骼 * Would you speak into my good ear, I can't hear in the other one. 請對著我這只沒毛病的耳朵說, 那只耳朵聽不見.  8 (of money) not fake or false; genuine （指錢）非偽造的, 真的: This note is counterfeit, but that one's good. 這張鈔票是假的, 那張是真的. * (fig 比喻) I gave good money for that camera, and it turned out to be worthless. 我買那架照相機可真花了一大筆錢, 結果卻不能用.  9 [attrib 作定語] (of clothes, etc) used only for more formal or important occasions （指衣服等）僅用於莊重的或重要的場合的: My one good suit is at the cleaner's. 我那套講究的衣服還在洗衣店裡呢. * Wear your good clothes to go to church. 要穿上像樣的衣服去做禮拜.  10 [attrib 作定語] thorough; complete; sound 徹底的; 完全的; 著實的: give sb a good beating, scolding, telling-off, etc 給某人一頓痛打、 痛罵、 痛斥等 * go for a good long walk 好好地散散步 * We had a good laugh at that. 那件事情叫我們笑個痛快.  11 [usu attrib 通常作定語] amusing 有趣的; 好玩的: a good story, joke, etc 有趣的故事、 笑話等 * `That's a good one!' she said, laughing loudly. ‵這個真有意思!′她大笑著說.  12 ~ (for sb/sth) beneficial; wholesome 有益的; 有益健康的: the good (ie clean, refreshing) mountain air 山中清新的空氣 * Is this kind of food good for me? 這種食物對我身體有益嗎? * Sunshine is good for your plants. 你的花草要多曬太陽. * This cream is good for (ie soothes and heals) burns. 這種油膏治燒傷和燙傷很管事兒.  13 ~ (for sth/to do sth) suitable; appropriate 適合的; 相宜的: a good time for buying a house/to buy a house 買房子的適當時機 * This beach is good for swimming but bad for surfing. 這個海濱適於遊泳而不適於沖浪. * She would be good for the job. 她做這工作很合適.  14 ~ for sth (a) (of a person or his credit) such that he will be able to repay (a sum lent) （指人或其信貸）有償還（借款）能力的: He/His credit is good for 5000. 他[憑他信用]可獲貸款5000英鎊. (b) having the necessary energy, fitness, durability, etc 有必要的精力、 健康條件、 忍耐力等的: You're good for (ie will live) a few years yet. 你還能活幾年呢. * This car's good for many more miles. 這輛汽車還能行駛很多英裡. (c) valid for sth 有效的: The return half of the ticket is good for three months. 回程票三個月內有效.  15 (used in greetings 用於問候): Good morning/afternoon/evening! 你好!  16 (fml 文) (used as a polite, but more often patronizing, form of address or description 用作敬稱或客氣的描述, 但多含屈尊俯就之意): my good sir, man, friend, etc 我的好先生、 好人、 好朋友等 * How is your good lady (ie your wife) ? 尊夫人好嗎?  17 [attrib 作定語] (used as a form of praise 用作讚語): Good old Fred! 忠厚的弗雷德! * Good man! That's just what I wanted. 好心人! 那正是我想要的.  18 [attrib 作定語] (used in exclamations 用於感嘆句): Good Heavens! 天哪! * Good God! 上帝呀!  19 (with a與a連用) [attrib 作定語] (a) great in number, quantity, etc （數目、 數量等）很大的, 很多的: a good many people 很多人 * We've come a good (ie long) way/distance. 我們是遠道而來的. (b) (used with expressions of measurement, quantity, etc 與表示量度、 數量等的短語連用) not less than; rather more than 不少於; 稍多於: We waited for a good hour. 我們足足等了一小時. * It's a good three miles to the station. 離車站至少三英裡. * She ate a good half of the cake. 那個蛋糕她整整吃了一半.  20 (idm 習語) as good as almost; practically 幾乎; 實際上: He as good as said I'm a liar, ie suggested that I was a liar without actually using the word `liar'. 他無異於說我撒謊（只是未用‵撒謊′一詞罷了. * The matter is as good as settled. 這事等於解決了. good and... (infml 口) completely 完全; 徹底: I won't go until I'm good and ready. 我完全準備好了才去. a good `few a considerable number (of); several 相當多（的）; 幾個: `How many came?' `A good few.' ‵來了多少?′‵很不少.′ * There are still a good few empty seats. 還有好幾個空位子. ,good for `sb, `you, `them, etc (infml 口) (used when congratulating sb 用以祝賀某人) sb, etc did well 某人幹得好: She passed the exam? Good for her! 她考試及格了? 真行! (For other idioms containing good, see entries for other major words in each idiom 查閱其他含有good一詞的習語, 見該習語中含有其他主要詞的詞條, 如 (as) good as gold => gold; in good time => time1.)

adv (US infml 口) well 好好地: Now, you listen to me good! 喂, 你好好聽我說!

/ gUd; ^Jd/ n  1 [U] that which is morally right or acceptable 有道德的事; 善: the difference between good and evil 善惡之分 * Is religion always a force for good? 宗教一向是誨人從善的力量嗎?  2 [U] that which gives benefit, profit, advantage, etc 好處、 利益、 益處等: work for the good of one's country 為國家利益工作 * I'm giving you this advice for your own good. 我勸你是為你好. * Do social workers do a lot of good? 社會工作者的貢獻大嗎? Cf 參看 do-gooder (do1).  3 the good [pl v] virtuous people 高尚的人: a gathering of the good and the great 賢人偉人薈萃.  4 (idm 習語) be no/not much/any/some `good (doing sth) be of no, not much, etc value 沒有、 沒什麼...好處: It's no good (my) talking to him. （我）同他談沒有用. * Was his advice ever any good? 他的建議有什麼價值嗎? * This gadget isn't much good. 這小機械沒什麼用處. * What good is it asking her? 問她有什麼好處? do (sb) `good benefit sb 有益於（某人）: Eat more fruit: it will do you good. 多吃水果, 對你有好處. * This cough medicine tastes nice but it doesn't do much good, ie isn't very effective. 這咳嗽藥不難吃, 但作用不大. * (usu ironic 通常作反語) Much good may it do you, ie You won't get much benefit from it. 但願對你大有好處（其實對你沒什麼好處）. for `good (and `all) permanently; finally 永久; 永遠; 決定性地: She says that she's leaving the country for good, ie intending never to return to it. 她說她要永遠離開這個國家. to the `good (used to describe sb's financial state) in credit （用以記述某人的財務狀況）盈余: We are 500 to the good, ie We have 500 more than we had. 我們盈余500英鎊. up to no `good (infml 口) doing sth wrong, mischievous, etc 做壞事; 淘氣; 惡作劇: Where's that naughty child now? I'm sure he'll be up to no good wherever he is. 那調皮孩子哪兒去了? 我看, 他到哪兒也做不出好事來.
<--- WordNet --->
good
good
     adj 1: having desirable or positive qualities especially those
            suitable for a thing specified; "good news from the
            hospital"; "a good report card"; "when she was good
            she was very very good"; "a good knife is one good for
            cutting"; "this stump will make a good picnic table";
            "a good check"; "a good joke"; "a good exterior
            paint"; "a good secretary"; "a good dress for the
            office" [ant: {bad}]
     2: having the normally expected amount; "gives full measure";
        "gives good measure"; "a good mile from here" [syn: {full}]
     3: morally admirable [ant: {evil}]
     4: deserving of esteem and respect; "all respectable companies
        give guarantees"; "ruined the family's good name" [syn: {estimable},
         {honorable}, {respectable}]
     5: promoting or enhancing well-being; "an arms limitation
        agreement beneficial to all countries"; "the beneficial
        effects of a temperate climate"; "the experience was good
        for her" [syn: {beneficial}]
     6: superior to the average; "in fine spirits"; "a fine
        student"; "made good grades"; "morale was good"; "had good
        weather for the parade" [syn: {fine}]
     7: agreeable or pleasing; "we all had a good time"; "good
        manners"
     8: of moral excellence; "a genuinely good person"; "a just
        cause"; "an upright and respectable man"; "the life of the
        nation is secure only while the nation is honest,
        truthful, and virtuous"- Frederick Douglass [syn: {just},
        {upright}, {virtuous}]
     9: having or showing knowledge and skill and aptitude; "adept
        in handicrafts"; "an adept juggler"; "an expert job"; "a
        good mechanic"; "a practiced marksman"; "a proficient
        engineer"; "a lesser-known but no less skillful composer";
        "the effect was achieved by skillful retouching" [syn: {adept},
         {expert}, {practiced}, {proficient}, {skillful}, {skilful}]
     10: thorough; "had a good workout"; "gave the house a good
         cleaning"
     11: with or in a close or intimate relationship; "a good
         friend"; "my sisters and brothers are near and dear"
         [syn: {dear}, {near}]
     12: having or showing or arising from a desire to promote the
         welfare or happiness of others; "his benevolent smile";
         "a benevolent nature" [syn: {benevolent}] [ant: {malevolent}]
     13: financially sound; "a good investment"; "a secure
         investment" [syn: {dependable}, {safe}, {secure}]
     14: most suitable or right for a particular purpose; "a good
         time to plant tomatoes"; "the right time to act"; "the
         time is ripe for great sociological changes" [syn: {right},
          {ripe}]
     15: resulting favorably; "its a good thing that I wasn't there";
         "it is good that you stayed"; "it is well that no one saw
         you"; "all's well that ends well" [syn: {well(p)}]
     16: exerting force or influence; "the law is effective
         immediately"; "a warranty good for two years"; "the law
         is already in effect (or in force)" [syn: {effective}, {in
         effect(p)}, {in force(p)}]
     17: feeling healthy and free of aches and pains; "I feel good"
         [syn: {good(p)}]
     18: capable of pleasing; "good looks"
     19: appealing to the mind; "good music"; "a serious book" [syn:
         {serious}]
     20: in excellent physical condition; "good teeth"; "I still have
         one good leg"; "a sound mind in a sound body" [syn: {sound}]
     21: tending to promote physical well-being; beneficial to
         health; "beneficial effects of a balanced diet"; "a good
         night's sleep"; "the salutary influence of pure air"
         [syn: {beneficial}, {salutary}]
     22: not forged; "a good dollar bill"
     23: not left to spoil; "the meat is still good" [syn: {unspoiled},
          {unspoilt}]
     24: generally admired; "good taste"
     [also: {better}, {best}]

good
     n 1: benefit; "for your own good"; "what's the good of worrying?"
     2: moral excellence or admirableness; "there is much good to be
        found in people" [syn: {goodness}] [ant: {evil}, {evil}]
     3: that which is good or valuable or useful; "weigh the good
        against the bad"; "among the highest goods of all are
        happiness and self-realization" [syn: {goodness}] [ant: {bad},
         {bad}]
     [also: {better}, {best}]

good
     adv 1: (often used as a combining form) in a good or proper or
            satisfactory manner or to a high standard (`good' is a
            nonstandard dialectal variant for `well'); "the
            children behaved well"; "a task well done"; "the party
            went well"; "he slept well"; "a well-argued thesis";
            "a well-planned party"; "the baby can walk pretty
            good" [syn: {well}] [ant: {ill}]
     2: in a complete and thorough manner (`good' is sometimes used
        informally for `thoroughly'); "he was soundly defeated";
        "we beat him good" [syn: {thoroughly}, {soundly}]
     [also: {better}, {best}]
<--- CDICT5英漢辭典 --->
good
[gUd;ɡud]
< good >
[基本字彙]
((縮)) gd., G, G.
<<形容詞>>
bet.ter, best
1 好的
  a good experience 一個好的經驗
  good news from the hospital 來自醫院的好消息
2 a. 上等的
     a good exterior paint 上等的油漆
     a good joke 上乘的笑話
  b. 符合理想的; 適合的
     Is this a good dress for the party? 這件衣服適合這個宴會嗎?
3 a. 未腐壞的
     The milk is still good. 牛奶還沒有壞掉
  b. 情況極好的; 健全的
     a good tooth 健康的牙齒
4 a. 優秀的
     a good student 優秀的學生
  b. (指美國政府) 肉類分級的其中一級 (介於標準級與精選級之間)
5 a. (品質) 優良的
     a good books 好書
  b. 辨識力佳的
     good taste 好的鑑賞力
6 值得尊敬的; 尊貴的
  ruined the family's good name 破壞家族尊貴的名聲
7 吸引人的; 俊美的
  good looks 姣好的面貌
8 有益健康的
  a good night's rest 有益健康的夜間休息
9 能勝任的; 老練的
  a good machinist 技術老練的機械師
10 完整的; 徹底的
   a good workout 完整的測驗
11 a. 可信賴的
     a good investment 一項可信賴的投資
   b. 正當的
     a good reason 正當的理由
   c. 真品的; 真正的
     a good dollar bill 真正的一元鈔票
12 a. 有效力的
     a warranty good for two years 二年有效的保證
     a driver's license that is still good 依然有效的駕駛執照
   b. 可以繼續的
     I'm good for another round of golf. 我還可以再打一場高爾夫球
13 a. 有能力付的; 付得起的
     Is she good for the money that you lent her? 她還得起你借給她的錢嗎?
   b. 能引人…的
     He is always good for a laugh. 他總能引人發笑
14 a. 充足的; 很多的
     a good income 收入相當不錯
   b. 豐富的
     a good table 豐盛的一餐
15 充分的
   It is a good mile from here. 從這裡去足足有一英哩的路程
16 a. 快樂的; 愉快的
     had a good time at the party 在舞會上玩得很愉快
   b. 適合的; 方便的
     good weather 合適的天氣
     a good omen 一個好的預兆
17 a. 品行端正的; 正直的
     a good person 正直的人
   b. 善良的; 仁慈的
     a good soul 善良的人
     a good heart 慈悲心腸
   c. 忠誠的; 忠實的
     a good Republican 忠誠的共和黨黨員
18 a. 行為良好的; 守規矩的
     a good child 守規矩的小孩
   b. 有禮貌的; 合宜的
     good manners 合宜的舉止
19『運動』場內球
   The first serve was wide, but the second was good. 第一球發得太遠了, 第二球就發得剛好
20 (用於感嘆句, 表示驚訝、驚愕)
   Good heavens! 老天啊!
   Good grief! 真可悲啊!
<<名詞>>
1 a. 好東西
  b. 長處; 優點
2 福利; 利益
  for the common good 為了大眾的利益
3 善; 善良; 美德
  There is much good to be found in people. 在人們身上可以找到很多的美德
4 (常作 goods)
  a. 商品; 貨品
     frozen goods 冷凍食品
  b. 財產; 動產
  c. (與單數或複數動詞連用) 布料
5 (常作 goods)
  ((俚語)) 罪證
  tried to get the goods on the crook 設法得到犯罪者的罪證
<<副詞>>
((口語)) 順利地; 好地
<<慣用語>>
as good as
和…一樣; 幾乎等於
as good as new  幾乎和新的一樣
for good
永遠地; 永久地
I'm moving to Europe for good. 我要搬到歐洲長住
good and
((口語)) 非常地; 完全地
I'll do it when I am good and ready. 當我完全準備好時, 我就會去做
no good
((口語))
1 沒有價值的
2 無益的; 沒用的
  It's no good arguing with them. 和他們爭辯是沒有用的
to the good
1 有利的; 方便的
2 有盈餘的
  ended up to the good 結果賺錢了


<--- XDICT英汉辞典 --->
great
[greit]
a. 大的,非常的,主要的,重大的,崇高的,大写的,强烈的,伟大的
ad. 顺利地
<--- 朗道英漢字典5.0 --->
great
*[greit]
a. 大的, 非常的, 主要的, 重大的, 崇高的, 偉大的
ad. 順利地, 得意地
n. 全部, 大人物, 大師
相關詞組:
  in great detail
  great at
  great on
  great with
  a great many
  a great deal
<--- stardict1.3英汉辞典 --->
great
[greit]
a. 大的,非常的,主要的;
ad. 顺利地,得意地;
<--- 牛津現代英漢雙解詞典 --->
great
/ greIt; ^ret/ adj (-er, -est)  1 (a) [attrib 作定語] well above average in size, extent or quantity 大的; 巨大的; 非常的; 很多的: The great ship sank below the waves. 巨輪在滾滾浪濤中沉沒. * a great expanse of forest 廣闊的森林 * dive to a great depth 潛到極深處 * all creatures great and small 大大小小的生物 * A great crowd had turned up. 來了一大群人. * People had turned up in great numbers. 來了成批的人. * The great majority (of people) (ie Most people) approve. 大多數人讚成. (b) far away in space or time 距離遙遠的; 時間久遠的: He lives a great distance away. 他住得很遠. * That was a great while ago. 那是很久以前的事了. (c) [usu attrib 通常作定語] exceptional in degree or intensity; considerable （程度或強度）異乎尋常的; 格外的; 相當的: of great value, importance, relevance, significance, etc 價值、 重要性、 關系、 意義等頗大的 * He described it in great detail. 他描述得相當詳細. * Take great care to do it properly. 要格外用心地把這事做好. * You have my greatest (ie very great) sympathy. 我非常同情你. * be in great demand, ie much wanted 需求甚大. (d) in a very good state of health, morale or well-being; fine 健康的; 精神好的; 安寧的; 平安的; 好的: I feel great today! 我今天覺得精神好極了! * in great form, ie very fit and active 精力充沛 * in great spirits, ie very cheerful 心情很愉快. (e) [attrib 作定語] with very good or bad effects 有極好的或極壞的效果的: It's a great relief to know you're safe. 知你平安無事才放下心來. * You've been a great help. 你幫了大忙. * the greatest disaster that has ever befallen us. 我們遭受的最嚴重的災難. =>Usage at big 用法見big.  2 (a) of remarkable ability or quality; outstanding 偉大的; 傑出的: a great man, artist, musician, etc 偉人、 偉大的藝術家、 偉大的音樂家 * her great deeds 她的偉大事跡 * No one would deny that Beethoven's symphonies are great masterpieces. 人人都認為貝多芬的交響樂是偉大的傑作. * the world's greatest novelist 世界最傑出的小說家. (b) [attrib 作定語] of high rank or status 級別高的; 地位高的: a great lady 貴婦人 * the great powers, ie important and powerful countries 強國 * Alexander the Great 亞歷山大大帝. (c) (infml 口) very remarkable; splendid 非常的; 非凡的; 出眾的; 絕妙的; 了不起的: He's great! 他真了不起! * She's the greatest! 她真是不得了! * It's great that you can come! 你能來太好了! * What a great party! 這聚會真棒! * He scored a great goal. 他射入的一球真絕. (d) (infml 口) ~ (to do sth) very enjoyable or satisfactory 非常愉快的; 令人滿意的: We had a great time in Majorca. 我們在馬霍卡玩兒得真痛快. * It's great to know you! 認識您很高興! * It's great to have met you! 與您會面令人十分愉快!  3 (a) ~ for sth (infml 口) very suitable for sth; ideal or useful for sth 對某事物極適合的; 對某事物理想的或有用的: This little gadget's great for opening tins. 這小玩意兒開罐頭挺好用. * These are great shoes for muddy weather. 這種鞋在雨天泥濘的地上走最合適. (b) [pred 作表語] ~ at sth (infml 口) clever or skilful at sth 擅長某事; 精於某事: She's great at tennis, chess, etc. 她對網球、 象棋什麼的都擅長. (c) (ironic 反語) (used to express exasperation, scorn, etc 用以表示惱怒、 憤怒、 輕蔑、 嘲笑等): Oh great, I've missed the bus again! 真倒霉, 我又沒趕上公共汽車! * You've been a great help, you have! 你可幫大忙了, 幫倒忙!  4 [attrib 作定語] (a) important; noteworthy重要的; 顯著的; 值得注意的: The princess was getting married, and everyone was in town for the great occasion. 公主那時即將成婚, 人人都在首都等待這一盛典. * As the great moment approached, she grew more and more nervous. 她因那重要時刻漸近而越來越緊張. (b) unequalled; excellent 無比的; 無雙的; 極好的: She had a great chance/opportunity, but she let it slip. 她曾有個絕好的機會, 但沒抓住. (c) the great the most important 最重要的: The great advantage of this metal is that it doesn't rust. 這種金屬最大的優點是不生鏽.  5 [attrib 作定語] fully deserving the name of; beyond the ordinary 名符其實的; 真正的; 不一般的; 不尋常的: We are great friends. 我們是真正的朋友. * I've never been a great reader, ie I do not read much. 我讀書不多. * He's a great one for complaining, ie He constantly complains. 他是個抱怨大王（他總抱怨）.  6 [attrib 作定語] (infml 口) (used to intensify another adj of size, etc 用以加強表示體積等另一形容詞的詞義) very 非常; 很: What a great big idiot! 純粹的大傻瓜! * You great fat pig! 你這大肥豬! * That's a great thick slice of cake! 那是一大塊蛋糕哇!  7 [attrib 作定語] (used to name the larger of two types, species, etc 用以指稱兩類、 兩種生物等之較大者): the great auk, ie contrasted with the little auk 大海雀（與小海雀相對）.  8 (added to words for relatives beginning with grand- to show a further stage in relationship 冠於以grand-起首的表示親屬的詞之前, 以示更高或更低一輩的親屬關系): one's ,great-`grandfather, ie one's father's or mother's grandfather 某人之曾祖父（或外曾祖父） * one's ,great-`grandson, ie the grandson of one's son or daughter 某人的曾孫. =>App 8 見附錄8.  9 (dated infml 舊, 口) (in exclamations of surprise 用於驚嘆句中): Great Scott! 哎呀! * Great heavens! 天哪!  10 (idm 習語) be no great shakes (infml 口) not be very good, efficient, suitable, etc 並非很好; 不太有效; 不怎麼適合; 沒什麼了不起: She's no great shakes as an actress. 她不是什麼名角兒. going great guns (infml 口) proceeding vigorously and successfully 順利; 成功. a good/great deal => deal2. great and small rich and poor, powerful and weak, etc 貧富、 強弱等: Everyone, great and small, is affected by these changes. 所有的人, 無論高低貴賤都受這些變革的影響. make great/rapid strides => stride. of great price very valuable 很有價值的; 很貴重的. your need is greater than mine => need.

n  1 (usu pl 通常作復數) (infml 口) person of outstanding ability 高手; 名家: one of boxing's all-time greats 一位空前的拳擊高手.  2 the great [pl v] great(2) people 大人物; 顯要人物; 要人: a fashionable affair attended by all the great and the good, ie important and influential people 顯要人物都出席的社交盛事.

NOTE ON USAGE 用法: Britain or Great Britain (GB)consists of the geographical areas of England, Scotland and Wales. 不列顛或大不列顛（GB）由英格蘭、 蘇格蘭和威爾士的地域組成. It is often also used to refer to the political state, officially called the United Kingdom of Great Britain and Northern Ireland and usually abbreviated to the United Kingdom or the UK. 這一名稱也常用以表示行政上的國家, 官方稱為大不列顛及北愛爾蘭聯合王國, 通常簡稱為聯合王國或UK. *The British Isles are the islands of Britain and Ireland. 不列顛群島包括不列顛和愛爾蘭等島嶼. There is no noun in British English commonly used to refer to the nationality of the people of Britain; instead the adjective is used 在英式英語中沒有表示英國人國籍的通用名詞而用形容詞: She's British. 她是英國人. * The British are said to have an unusual sense of humour. 據說英國人有一種特殊的幽默感. Britisher is used in American English. *Britisher 用於美式英語. Briton is found in newspaper, etc reports of incidents concerning British people and in statistical information. *Briton 見於報刊等涉及英國人的報道及統計資料. It is also used of the early inhabitants of Britain *Briton也用以指不列顛早期的居民: 10 Britons in hijacked plane 被劫持飛機上的10個英國人 * According to the latest surveys many Britons suffer from heart disease. 據最近調查顯示, 許多英國人患心臟病. *  the ancient Britons 古代不列顛人.
<--- WordNet --->
great
great
     adj 1: relatively large in size or number or extent; larger than
            others of its kind; "a great juicy steak"; "a great
            multitude"; "the great auk"; "a great old oak"; "a
            great ocean liner"; "a great delay"
     2: more than usual; "great expectations"; "great worry"
     3: (used of persons) standing above others in character or
        attainment or reputation; "our distinguished professor";
        "an eminent scholar"; "a great statesman" [syn: {distinguished},
         {eminent}]
     4: of major significance or importance; "a great work of art";
        "Einstein was one of the outstanding figures of the 20th
        century" [syn: {outstanding}]
     5: remarkable or out of the ordinary in degree or magnitude or
        effect; "a great crisis"; "had a great stake in the
        outcome"
     6: very good; "he did a bully job"; "a neat sports car"; "had a
        great time at the party"; "you look simply smashing" [syn:
         {bang-up}, {bully}, {corking}, {cracking}, {dandy}, {groovy},
         {keen}, {neat}, {nifty}, {not bad(p)}, {peachy}, {slap-up},
         {swell}, {smashing}]
     7: uppercase; "capital A"; "great A"; "many medieval
        manuscripts are in majuscule script" [syn: {capital}, {majuscule}]
     8: marked by active interest and enthusiasm; "an avid sports
        fan"; "a great walker"; "an eager beaver" [syn: {avid}, {eager},
         {zealous}]
     9: in an advanced stage of pregnancy; "was big with child";
        "was great with child" [syn: {big(p)}, {enceinte}, {expectant},
         {gravid}, {great(p)}, {large(p)}, {heavy(p)}, {with
        child(p)}]
<--- CDICT5英漢辭典 --->
great
[gret;ɡreit]
< great >
[基本字彙]
<<形容詞>>
great.er, great.est
1 (尺寸) 大的
2 巨大的
3 (數量) 大的
  A great throng awaited us. 大批的群眾等著我們
4 (時間、距離) 廣闊的
  a great delay 延遲很久
5 (程度上) 顯著的
  a great crisis 大災難
6 意義非凡的; 非常重要的
  a great work of art 偉大的藝術品
7 主要的
  the great house on the estate 在地產上主要的房屋
8 (品質、品德) 傑出的, 崇高的, 偉大的
  "For he was great, ere foutune made him so." (John Dryden)他天生是個偉大的人物
9 有力的; 有影響力的
  one of the great nations of the West 西方的強權國家之一
10 卓越的; 超群的
   a great leader 卓越的領袖
11 有威嚴的; 貴族的
12 ((口語)) 狂熱的
   a great lover of music 音樂的愛好者
13 ((口語)) 擅長的
   great at algebra 擅長代數
14 ((口語)) 極佳的; 一流的
   We had a great time at the dance. 我們在舞會上玩得很盡興
15 (常用於複合字) (表示輩份)
   a great-granddaughter 曾孫女
16 ((古語)) 懷孕的
<<名詞>>
1 (pl. greats, great) 偉大的人物
  a composer considered among the greats 被認定為大師級的作曲家
2『音樂』
  a. (管樂器的) 分節
  b. (其他樂器) 類似的分節
<<副詞>>
((口語)) 很好地
got along great with the teacher 和這位老師相處融洽
<<副詞>>
greatly
<<名詞>>
greatness


<--- XDICT英汉辞典 --->
terrific
[tәˊrifik]
a. 非常的,极端的,可怕的
<--- 朗道英漢字典5.0 --->
terrific
*[tә'rifik]
a. 非常好的, 極端的, 可怕的
相關詞組:
  at a terrific speed
<--- stardict1.3英汉辞典 --->
terrific
[tәˊrifik]
a. 非常的,极端的,可怕的;
<--- 牛津現代英漢雙解詞典 --->
terrific
/ tE5rIfIk; tE`rIfIk/ adj (infml 口)  1 very great; extreme 很大的; 極端的: a terrific storm 狂風暴雨 *driving at a terrific speed 以極高的速度駕駛.  2 excellent; wonderful 極好的; 了不起的: doing a terrific job 幹得很棒 * The view was terrific. 景色美極了.
<--- WordNet --->
terrific
terrific
     adj 1: very great or intense; "a terrific noise"; "a terrific
            thunderstorm storm"; "fought a terrific battle"
     2: extraordinarily good; used especially as intensifiers; "a
        fantastic trip to the Orient"; "the film was fantastic!";
        "a howling success"; "a marvelous collection of rare
        books"; "had a rattling conversation about politics"; "a
        tremendous achievement" [syn: {fantastic}, {howling(a)}, {marvelous},
         {marvellous}, {rattling(a)}, {tremendous}, {wonderful}, {wondrous}]
     3: causing extreme terror; "a terrifying wail" [syn: {terrifying}]
<--- CDICT5英漢辭典 --->
terrific
[tәˋrIfIk;tәˊrifik]
< ter.rif.ic >
<<形容詞>>
more ter.rif.ic ; most ter.rif.ic
1 非常厲害的, 驚人的, 非同小可的
2 很棒的, 極好的, 絕妙的
2 可怕的, 恐怖的; 嚇人的
<<名詞>>
ter.rif.ic.ness
<<副詞>>
ter.rif.i.cal.ly


<--- XDICT英汉辞典 --->
nice
[nais]
a. 美好的,和蔼的,正派的,体贴的,精密的,细微的,挑剔的,拘泥的
<--- 朗道英漢字典5.0 --->
nice
*[nais]
a. 美好的, 和藹的, 正派的, 做得好的, 精密的, 細微的, 挑剔的, 謹慎的
相關詞組:
  be nice to sb
<--- stardict1.3英汉辞典 --->
nice
[ˊnais]
a. 美好的,体贴的,精密的;
<--- 牛津現代英漢雙解詞典 --->
nice
/ naIs; naIs/ adj (-r, -st)  1 (a) pleasant; agreeable 好的; 令人愉快的; 宜人的: a nice person, smile, taste, remark 令人愉快的人、 微笑、 味道、 言語 * a nice day 美好的一天 * nice weather 好天氣 * a nice little girl 可愛的姑娘 * That tastes nice! 味道挺好! * We had a nice time at the beach. 我們在海濱時開心極了. * It's not nice to pick your nose. 挖鼻孔很不雅觀. (b) ~ (to sb) kind; friendly 親切的; 友好的: Try to be nice to my father when he visits. 我父親到這裡來時盡量對他好些. Cf 參看 nasty.  2 (ironic 反語) bad; unpleasant 壞的; 令人不愉快的: This is a nice mess you've got us into! 你把我們弄到了這種地步! * That's a nice thing to say! 這種好話能說得出口!  3 needing precision and care; fine; subtle 需精確和慎重的; 細微的; 微妙的: a nice distinction 細微的區別 * a nice point of law, ie one that may be difficult to decide 法律上難以決定之處 * nice (ie very slight) shades of meaning 意義的細微差別.  4 (a) hard to please; having refined tastes 難以取悅的; 講究的: too nice in one's dress 衣著過分講究. (b) (usu in negative expressions 通常用於否定用語) respectable; scrupulous 體面的; 高尚的; 謹慎的; 細致的: She's not too nice in her business methods. 她的經營方法不敢恭維.  5 (idm 習語) nice and (used before adjs 用於形容詞之前) (infml approv 口, 褒) agreeably 宜人地: nice and warm by the fire 在火邊暖烘烘的 * nice and cool in the woods 森林裡涼爽宜人. good/nice work => work1. nice work if you can get it (saying 諺) (used to express envy of what sb has been lucky or clever enough to get or do 因某人幸運或聰明而得到或得以做某事物, 用此語表達羨慕或忌妒之意).
<--- WordNet --->
nice
nice
     adj 1: pleasant or pleasing or agreeable in nature or appearance;
            "what a nice fellow you are and we all thought you so
            nasty"- George Meredith; "nice manners"; "a nice
            dress"; "a nice face"; "a nice day"; "had a nice time
            at the party"; "the corn and tomatoes are nice today"
            [ant: {nasty}]
     2: socially or conventionally correct; refined or virtuous;
        "from a decent family"; "a nice girl" [syn: {decent}]
     3: done with delicacy and skill; "a nice bit of craft"; "a job
        requiring nice measurements with a micrometer"; "a nice
        shot" [syn: {skillful}]
     4: excessively fastidious and easily disgusted; "too nice about
        his food to take to camp cooking"; "so squeamish he would
        only touch the toilet handle with his elbow" [syn: {dainty},
         {overnice}, {prissy}, {squeamish}]
     5: noting distinctions with nicety; "a discriminating interior
        designer"; "a nice sense of color"; "a nice point in the
        argument" [syn: {discriminate}]
     6: exhibiting courtesy and politeness; "a nice gesture" [syn: {courteous},
         {gracious}]
<--- CDICT5英漢辭典 --->
nice
[naIs;nais | nis;niːs]
< nice >
[基本字彙]
<<形容詞>>
nic.er, nic.est
1 愉快的; 宜人的
  had a nice time 愉快的時光
2 外表美好的; 優美的
  a nice dress 漂亮的衣服
  a nice face 美麗的臉蛋
3 優雅的
  a nice gesture 優雅的姿勢
4 高尚的; 值得尊敬的
5 過份講究的; 難侍候的
6 精確的; 敏感的
  a nice distinction 精確的差別
  a nice sense of style 對風尚很敏感
7 精細的
  a nice bit of craft 精細的手工藝品
8 (與 and 連用, 用作加強語氣)
  nice and warm 溫暖而舒適
9『廢』
  a. 放肆的; 浪蕩的
  b. 佯裝羞澀的; 顯得嬌羞的
     "Ere... / The nice Morn on th' Indian steep, / From her cabin'd loop-hole peep." (John Milton) 在那時… / 印地安峭壁嬌羞的晨曦, / 窺視她的房間
<<副詞>>
nicely
<<名詞>>
niceness

< Nice >
<<名詞>>
『地名』尼斯

<--- XDICT英汉辞典 --->
awesome
[ˊɒːsәm]
a. 引起敬畏的,可怕的
<--- 朗道英漢字典5.0 --->
awesome
*['ɒ:sәm]
a. 引起敬畏的, 可怕的
<--- stardict1.3英汉辞典 --->
awesome

a. 引起敬畏的,可怕的;
<--- 牛津現代英漢雙解詞典 --->
awesome
/ -sEm; -sEm/ adj causing awe 使人敬畏的; 使人驚懼的: His strength was awesome. 他的力量大得怕人.
<--- WordNet --->
awesome
awesome
     adj : inspiring awe or admiration or wonder; "New York is an
           amazing city"; "the Grand Canyon is an awe-inspiring
           sight"; "the awesome complexity of the universe"; "this
           sea, whose gently awful stirrings seem to speak of some
           hidden soul beneath"- Melville; "Westminster Hall's
           awing majesty, so vast, so high, so silent" [syn: {amazing},
            {awe-inspiring}, {awful}, {awing}]
<--- CDICT5英漢辭典 --->
awesome
[ˋɒsәm;ˊɒːsәm]
< awe.some >
<<形容詞>>
1 可怕的, 有威嚴的, 令人敬畏的
2 表示敬畏的, 感到恭敬的
<<副詞>>
awe.some.ly
<<名詞>>
awe.some.ness

<--- XDICT英汉辞典 --->
horrible
[ˊhɑːәbl]
a. 可怕的,极可憎的,极可厌的
<--- 朗道英漢字典5.0 --->
horrible
*['hɒrәbl]
a. 可怕的, 遭透的, 極討厭的
<--- stardict1.3英汉辞典 --->
horrible
[ˊhɒrәbl]
a. 可怕的,极可憎的,极可厌的;
<--- 牛津現代英漢雙解詞典 --->
horrible
/ 5hCrEbl; ?@ 5hR:r-; `hRrEbl/ adj  1 causing horror 可怕的; 令人恐懼的: a horrible crime, nightmare, death 駭人聽聞的罪行、 叫人心驚膽顫的惡夢、 令人恐懼的死亡.  2 (infml 口) very unpleasant 令人極不愉快的: horrible weather, food, people 糟糕的天氣、 難吃的食物、 極不友好的人 * It tastes horrible. 這味道很不好. * Don't be so horrible (to me). 別那麼（讓我）討厭. 
<--- WordNet --->
horrible
horrible
     adj : provoking horror; "an atrocious automobile accident"; "a
           frightful crime of decapitation"; "an alarming, even
           horrifying, picture"; "war is beyond all words
           horrible"- Winston Churchill; "an ugly wound" [syn: {atrocious},
            {frightful}, {horrifying}, {ugly}]
<--- CDICT5英漢辭典 --->
horrible
[ˋhɒrәbL,ˋhɑr-;ˊhɒrәbl]
< hor.ri.ble >
<<形容詞>>
1 毛骨悚然的; 可怕的
  "War is beyond all words horrible." (Winston S. Churchill)戰爭的可怕非筆墨所能描述
2 令人討厭的; 不愉快的
<<名詞>>
horri.ble.ness
<<副詞>>
horri.bly


<--- XDICT英汉辞典 --->
terrible
[ˊterәbl]
a. 可怕的,可怖的,骇人的,令人敬畏的;极度的;极坏的,很糟的;极妙的
<--- 朗道英漢字典5.0 --->
terrible
*['terәbl]
a. 可怕的, 令人恐懼的, 極壞的
<--- stardict1.3英汉辞典 --->
terrible
[ˊterәbl]
a. 可怕的,令人恐惧的,极坏的;
<--- 牛津現代英漢雙解詞典 --->
terrible
/ 5terEbl; `tZrEbl/ adj  1 causing great fear ordistress; appalling 可怕的; 使人苦惱的; 駭人的: a terriblewar, accident, murder 可怕的戰爭、 事故、 謀殺案.  2 hard to bear; extreme 難以忍受的; 極端的: terrible toothache 難以忍受的牙疼 * The heat was terrible. 熱得受不了.  3 (infml 口) very bad 極壞的; 很糟的: I'm terrible at tennis. 我打網球打得很不好. * What a terrible meal! 這頓飯糟透了! * He's a terrible bore. 他這人討厭極了.
<--- WordNet --->
terrible
terrible
     adj 1: causing fear or dread or terror; "the awful war"; "an awful
            risk"; "dire news"; "a career or vengeance so direful
            that London was shocked"; "the dread presence of the
            headmaster"; "polio is no longer the dreaded disease
            it once was"; "a dreadful storm"; "a fearful howling";
            "horrendous explosions shook the city"; "a terrible
            curse" [syn: {awful}, {dire}, {direful}, {dread(a)}, {dreaded},
             {dreadful}, {fearful}, {fearsome}, {frightening}, {horrendous},
             {horrific}]
     2: exceptionally bad or displeasing; "atrocious taste";
        "abominable workmanship"; "an awful voice"; "dreadful
        manners"; "a painful performance"; "terrible handwriting";
        "an unspeakable odor came sweeping into the room" [syn: {atrocious},
         {abominable}, {awful}, {dreadful}, {painful}, {unspeakable}]
     3: intensely or extremely bad or unpleasant in degree or
        quality; "severe pain"; "a severe case of flu"; "a
        terrible cough"; "under wicked fire from the enemy's
        guns"; "a wicked cough" [syn: {severe}, {wicked}]
     4: extremely distressing; "fearful slum conditions"; "a
        frightful mistake"; "suffered terrible thirst" [syn: {fearful},
         {frightful}]
<--- CDICT5英漢辭典 --->
terrible
[ˋtєrәbL;ˊterәbl]
< ter.ri.ble >
[常用字]
<<形容詞>>
1 可怕的; 駭人的
  a terrible bolt of lightning 可怖的閃電
  a terrible curse 可怕的詛咒
2 艱鉅的
  terrible responsibilities 艱鉅的責任
3 極端的; 非常的
  "the life for which he had paid so terrible a price" (Leslie Fiedler)他的生活負擔很重
4 a. 極壞的
     had a terrible time at the party 舞會上很不愉快的時光
  b.令人討厭的
     terrible hypocrisy 令人討厭的虛偽行為
<<名詞>>
terri.ble.ness
<<副詞>>
terri.bly


<--- XDICT英汉辞典 --->
nightmare
[ˊnaitmєә]
n. 梦魇,恶梦,可怕的经验
<--- 朗道英漢字典5.0 --->
nightmare
*['naitmєә]
n. 夢魘, 惡夢, 可怕的事物(或情景、人物)
【醫】 夢魘, 惡夢
<--- stardict1.3英汉辞典 --->
nightmare
[ˊnaitmєә]
n. 梦魇,恶梦,可怕的经验;
<--- 牛津現代英漢雙解詞典 --->
nightmare
n  1 frightening dream 惡夢; 夢魘: I have nightmares about falling off a cliff. 我作惡夢夢見從懸崖上摔下來了.  2 (infml 口) very frightening or unpleasantexperience 非常可怕的或不愉快的經歷: Driving during the blizzard was a nightmare. 在暴風雪中開車真嚇人. 
<--- WordNet --->
nightmare
nightmare
     n 1: a situation resembling a terrifying dream [syn: {incubus}]
     2: a terrifying or deeply upsetting dream
<--- CDICT5英漢辭典 --->
nightmare
[ˋnaItˏmєr;ˊnaitmєә]
< night.mare >
<<名詞>>
1 惡夢; 夢魘
2 令人極度沮喪的經驗 (事件)
3 睡魔
  困擾人睡眠使生惡夢的惡魔
<<形容詞>>
nightmar.ish
<<副詞>>
nightmarish.ly
<<名詞>>
nightmarish.ness


<--- XDICT英汉辞典 --->
disastrous
[diˊzɑːstrәs]
a. 损失惨重的,悲伤的
<--- 朗道英漢字典5.0 --->
disastrous
*[di'zɑ:strәs]
a. 損失慘重的, 悲傷的
<--- stardict1.3英汉辞典 --->
disastrous
[diˊzɑːstrәs]
a. 损失惨重的,悲伤的;
<--- 牛津現代英漢雙解詞典 --->
disastrous
/ dI5zB:strEs; ?@ -z5As-; dIz`AstrEs/ adj being or causing a disaster 災難性的; 造成災害的; 失敗的: disastrous floods 災難性的洪水 * a defeat that was disastrous to the country 給國家帶來災難的一場敗仗 * Buying this house was a disastrous step: it's going to have a main road built behind it. 買下這所房子是一大失策, 因為房後就要建一條公路了. 
<--- WordNet --->
disastrous
disastrous
     adj : (of events) having extremely unfortunate or dire
           consequences; bringing ruin; "the stock market crashed
           on Black Friday"; "a calamitous defeat"; "the battle
           was a disastrous end to a disastrous campaign"; "such
           doctrines, if true, would be absolutely fatal to my
           theory"- Charles Darwin; "it is fatal to enter any war
           without the will to win it"- Douglas MacArthur; "a
           fateful error" [syn: {black}, {calamitous}, {fatal}, {fateful}]
<--- CDICT5英漢辭典 --->
disastrous
[dIzˋæstrәs;diˊzɑːstrәs]
< dis.as.trous >
<<形容詞>>
1 災害的; 悲慘的
2 糟糕的, 可怕的
  a disastrous report card 很糟糕的成績單
<<副詞>>
dis.astrous.ly
<<名詞>>
dis.astrous.ness

good: 225
great: 125
terrific: 16
nice: 59
awesome: 10

horrible: 14
terrible: 24
nightmare: 11
disastrous: 14

436/63
				<</textfile>>
				<<textfile "result.out">>
good-words: 435
bad-words: 63
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-multipattern-1--->>>


<<<----------case: /lex-alone/basic/rule/rule-useless--->>>
			<<case "rule-useless" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test regular expression: useless expression
*/
					<</desc>>
					<<declare_section>>
%formal-param%{ var lowers, uppers, digits: integer %}
%actual-param%{ lowers, uppers, digits %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			lowers := lowers + 1;
B			uppers := uppers + 1;
<*>[[:alnum:]]		if isdigit(yytext[0]) then
				digits := digits + 1
			else if islower(yytext[0]) then
				lowers := lowers + 1
			else
				uppers := uppers + 1;
<asc>[[:upper:]]	uppers := uppers + 2;
<bsc>[[:lower:]]	lowers := lowers + 2;
<asc>[[:digit:]]	digits := digits + 2;
.|\n
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex( n1, n2, n3);
	writeln('lower''s: ', n1);
	writeln('upper''s: ', n2);
	writeln('digit''s: ', n3);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
eeeeeeeeee8888hh22222222hh5555555FFFF..........hhh.hhheeeh55555555hffffffffGG..........FFFFFhDDDDDDDDDhCCCCCfffffccchhhhhddddddddddddhhGGGGGGGGGGh222hh......hhhbbbbh2222hheeeeehhhhhfaaaaaeeeeeecccccc....haaaaaaaaaaaah2222222333333333hhGGGGGGGGhh3333333333hffff888888888hhddddddd000000000heeebbbbbbbbb8888888hhhhCCCCCCCCCBBBBhBBBBBBBBBBhhccccchhhhhhbbbb00333333ggghDaaaaa00000CCCCCCCCCChhhhhBBCCCCCCCfh3555555555eeehbbbbbbbbbbhccccchhFFFFFFFFhh333hh00000hFFFFFFFFFF44444dddDDDDDDDh55554444444444hhhhDD00000fBBBBhfffffbbhEEEEhhhhhh3333hhh..5555555555h000bbbbbbbbb...EEEEEEEEddh5558h........CCCCCCChhh.......hhBBBBBBhaaahCCCCCCCCCGGGGGGGG00000000000000022222h5555hh..........heeeeeeeeeehhaaaaaaaaahgggggggggaaaaaaaggggh000h222ffffffheeeeeeeeeh55555555h..hh0000000
332/159/215
				<</textfile>>
				<<textfile "result.out">>
lower's: 332
upper's: 159
digit's: 215
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/rule/rule-useless--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/rule---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond---------->>>
		<<suite "startcond" make="subdir-makefile-template">>

<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>
			<<case "startcond-duplicated" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition: duplicated SC

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var ncnt: integer %}
%actual-param%{ ncnt %}

%x asc
%s asc

					<</declare_section>>
					<<lex_section>>
"{"			YYBEGIN(asc);
<asc>"}"	YYBEGIN(INITIAL);
<asc>a		ncnt := ncnt + 1; write(yytext);
a		ncnt := ncnt + 2; write(yytext);
<*>\n		writeln;
<asc>.		write('_');
.

					<</lex_section>>
					<<local_decl_code>>
var
	ncnt: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	ncnt := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(ncnt);
	writeln; writeln(ncnt);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{sfkiwegfsafa;adska
9348ejfsdjfklaeijofsedaiojdfasijoafiajoiwafo9ijwef320ewfokSAlL
349aew0ifjofl;Sao9pjgvdsnAO9WFMDSOPAAEGDASSODPL;AOPAalaomfaopfkd;klasdfjkfeiwjofkdscmx ,        P2309824390EDWPKOCSMLZX,. D
OPAKFPOAOPAF[al;pafkasdflergjvkldmldsfa[pw4e-=3240r5i0=-ew]pdsv;l  /.CX v,psidjkiewroas[dlc;fmkioopwer[]al;aerpwdsl
}
ajfdslowpef
oepwfasfl;sdfwepfas'
				<</textfile>>
				<<textfile "result.out">>
_________a_a_a___a
_____________a________a_____a____a__a____a____________________
___a___________a____________________________________a_a___a________a_______________________________________________________
_____________a___a__a_________________a______________________________________________a__________________a__a_______

a
aa

29
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-duplicated--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>
			<<case "startcond-exclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, _as2, bs, bs2: integer%}
%actual-param%{ _as, _as2, bs, bs2 %}

%x isc

					<</declare_section>>
					<<lex_section>>
\{		YYBEGIN(isc); write(yytext);
<isc>\}		YYBEGIN(INITIAL); write(yytext);
a		_as := _as + 1; write(yytext);
<isc>b		bs2 := bs2 + 1; write(yytext);
b		bs := bs + 1; write(yytext);
<*>a		_as2 := _as2 + 1; write(yytext);
<isc>.		write('_');
<*>\n		writeln;
.		write('*');
					<</lex_section>>

					<<local_decl_code>>
var
	n1: integer;
	n11: integer;
	n2: integer;
	n21: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n11 := 0;
	n2 := 0;
	n21 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n11, n2, n21);
	writeln('a''s: ', n1, ' at INITIAL');
	writeln('a''s: ', n11, ' at isc');
	writeln('b''s: ', n2, ' at INITIAL');
	writeln('b''s: ', n21, ' at isc');

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
bb~~bbbbbb~aa~aaaaaaaaaaa~~}}}}}}}}}~cccccaaa}}}}~bbbbbb~}~~aaaaabbbbbbbb~~~~cccccccccaaa{{{{{{{{{{aaaaaa~cccccccccc~..........~....bbb~~.~~ccccccc~aaaaaaaaacccccc~~{{{{{{{~~~ccccccc~{{{{{{}}}}}}}}}}~~~~bb~{{{{{cccccccccc}}}}}}{{{aaaaa~{{{{{{}}}}c~cccc~bbbaaaaaaa..........~aaaaaaa~~}}}}}}}}}}~~
.: 25
a: 58
b: 30
{: 37
}: 44
c: 59
~: 42

				<</textfile>>
				<<textfile "result.out">>
bb**bbbbbb*aa*aaaaaaaaaaa*****************aaa*****bbbbbb****aaaaabbbbbbbb*************aaa{_________aaaaaa___________________________bbb_____________aaaaaaaaa________________________________}*************bb*{______________}*****{__aaaaa_______}**********bbbaaaaaaa***********aaaaaaa**************
*****
a****
b****
{____
}****
*****
*****

a's: 39 at INITIAL
a's: 20 at isc
b's: 28 at INITIAL
b's: 3 at isc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive1--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>
			<<case "startcond-exclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%formal-param%{ var n1, n2, n3: integer %}
%actual-param%{ n1, n2, n3 %}

%x bsc
%x csc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		write(yytext);
<INITIAL,csc>\{		yy_push_state(bsc); write(yytext);
<INITIAL,bsc>\[		yy_push_state(csc); write(yytext);
<bsc>\}			yy_pop_state(); write(yytext);
<csc>\]			yy_pop_state(); write(yytext);
<bsc,csc>[\}\]]		write(yytext);
a				n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
.				write('*');
<bsc>.			write('-');
<csc>.			write('_');
<*>\n			writeln;

					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln('a''s: ', n1, ' at INITIAL');
	writeln('a''s: ', n2, ' at bsc');
	writeln('a''s: ', n3, ' at csc');


	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
************aaaaaaaaaa*************************[_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]*{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

a's: 10 at INITIAL
a's: 18 at bsc
a's: 1 at csc
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive2--->>>


<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>
			<<case "startcond-exclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test exclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3, n4: integer %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%x csc
%x dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		write(yytext);
\{		YYBEGIN(bsc); write(yytext);
<bsc>\{		YYBEGIN(csc); write(yytext);
<csc>\{		YYBEGIN(dsc); write(yytext);
<dsc>\}		YYBEGIN(csc); write(yytext);
<csc>\}		YYBEGIN(bsc); write(yytext);
<bsc>\}		YYBEGIN(INITIAL); write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
<dsc>a			n4 := n4 + 1; write(yytext);
.				write('*');
<bsc>.			write('-');
<csc>.			write('_');
<dsc>.			write('+');
<*>\n			writeln;
					<</lex_section>>

					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n2, n3, n4);
	writeln('SC0: ', n1);
	writeln('SC1: ', n2);
	writeln('SC2: ', n3);
	writeln('SC3: ', n4);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}***********{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}**{{{+aaaaaaaa+aa+++++}}}***{{{++aaaaa}}}******************{{{++++++++++++++}}}******{{{++++++++++++++}}}*************************aaaaaaa*****{{{++}}}************aaaaaaaa***********aaaaaaa{{{+++++++++++++++++++++++++}}}***{{{+++++++++++++++++++++++++}}}**{{{++++++++++++}}}*****aa*********aa******************{{{++++++++++++++}}}*********************aaaaaaa**************aaaaa*aaaaaaaa**a{{{+++++aa+++++++++}}}********
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 49
SC1: 10
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-exclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>
			<<case "startcond-inclusive1" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 1
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var _as, _as2, bs, bs2: integer%}
%actual-param%{ _as, _as2, bs, bs2 %}

%s isc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+	write(yytext);
\{		YYBEGIN(isc); write(yytext);
<isc>\}		YYBEGIN(INITIAL); write(yytext);
a		_as := _as + 1; write(yytext);
b		bs := bs + 1; write(yytext);
<isc>b		bs2 := bs2 + 1; write(yytext);
<*>a		_as2 := _as2 + 1; write(yytext);
.		write('*');
<isc>.		write('_');
<*>\n		writeln;
					<</lex_section>>


					<<local_decl_code>>
var
	n1: integer;
	n11: integer;
	n2: integer;
	n21: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n11 := 0;
	n2 := 0;
	n21 := 0;
					<</before_init>>

					<<after_init>>
	nret := yylex(n1, n11, n2, n21);
	writeln('SC0-a: ', n1);
	writeln('SC1-a: ', n11);
	writeln('SC0-b: ', n2);
	writeln('SC1-b: ', n21);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;

					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
aaaaa}}}}}}}}~bbbbbbbbbb{{{~{{{{{{{{~~~aaaaaaaaaa}}}}}}}}}}}}}}~~~~~~........~{{{{{{{{{~bbbbaaaaaaaaa~{{bbbbbb~b~~~~{c~~}}}~~~{{{~}}}}b~aaaaaaaaa{{{{{{{{bbbbbbbbc~}}}}}}~}}}}}}.~~aaaaaaaaaa{{{{{{{{{{~}}}}}}~~cccccc~~}}}}}}}a
.: 9
a: 19
a: 25
{: 18
}: 16
{: 26
}: 38
b: 10
b: 20
c: 8
~: 35

				<</textfile>>
				<<textfile "result.out">>
aaaaa}}}}}}}}*bbbbbbbbbb{______________aaaaaaaaaa}}}}}}}}}}}}}}***************{_________bbbbaaaaaaaaa___bbbbbb_b________}}}***{___}}}}b*aaaaaaaaa{_______bbbbbbbb__}}}}}}*}}}}}}***aaaaaaaaaa{__________}}}}}}**********}}}}}}}a
***9
a**19
a**25
{__18
}**16
{__26
}**38
b**10
b**20
***8
***35

SC0-a: 27
SC1-a: 19
SC0-b: 13
SC1-b: 19
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive1--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>
			<<case "startcond-inclusive2" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 2
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3: integer%}
%actual-param%{ n1, n2, n3 %}

%s bsc
%s csc

					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		write(yytext);
[\}\]]			write(yytext);
<INITIAL,csc>\{		yy_push_state(bsc); write(yytext);
<INITIAL,bsc>\[		yy_push_state(csc); write(yytext);
<bsc>\}			yy_pop_state(); write(yytext);
<csc>\]			yy_pop_state(); write(yytext);
<bsc,csc>[\}\]]		write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
.			write('*');
<bsc>.			write('-');
<csc>.			write('_');
<*>\n			writeln;
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln('SC0-a: ', n1);
	writeln('SC1-a: ', n2);
	writeln('SC2-a: ', n3);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
BBBBBBBB~]]~aaaaaaaaaa........~~~BBBBBB~]]]]]]][[[[[~[[[~}}}}}}}}}}~[[[~bbbbbbbbb}{~~~~[[[[[...~[[[[[[[[[[~~}DDDDDDDD~]]]]]]]~DDDDDDDDDD~{BBBBBB~bbb~{~~ccccccc~~c~~]]]]]]]]]{{AAAAAAAA~accccccccc~[[[[[[~]]]]~~]]]{{{{~~}}}}}}}}{{{{{{cccccc~{{{{{{}}}}}}~~}}}~~~bbbbbbbbb}}}~{{{{{{{~~~{{{{{{{aaaaa[[[[[[[[........~~]]]]]~{{{{{{~}}}BBBBBBBBB]]{{{{{{{{{{.....]]]]]~aaaaa~aaaaaaa~~{{{{{{{{{{{{{{{{{{]]]]]]]]]][[[[[[[[[[[[[[[[}}}~{{{{~[[[[
.: 24
a: 28
b: 21
A: 8
B: 29
c: 23
D: 18
{: 44
}: 4
[: 27
]: 24
{: 29
}: 34
[: 33
]: 30
~: 55

				<</textfile>>
				<<textfile "result.out">>
*********]]*aaaaaaaaaa******************]]]]]]][_________}}}}}}}}}}______________}{----[____________________}_________]]]]]]]---------------------------------------]]]]]]]]]-----------a----------[______]]]]--]]]------}}}}}}}}{------------------}}}}}}__}}}____________}}}_{----------------aaaaa[_________________]]]]]--------}}}_________]]{--------------]]]]]-aaaaa-aaaaaaa--------------------]]]]]]]]]][_______________}}}_{----[___
___24
a__28
___21
___8
___29
___23
___18
{--44
}__4
___27
]--24
---29
}__34
___33
]--30
---55

SC0-a: 10
SC1-a: 18
SC2-a: 1
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive2--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>
			<<case "startcond-inclusive3" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive start-condition
	case 3
*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3, n4: integer %}
%actual-param%{ n1, n2, n3, n4 %}


%s bsc
%s csc
%s dsc
					<</declare_section>>
					<<lex_section>>
<*>[[:digit:]]+		write(yytext);
[\{\}]		YYBEGIN(bsc); write(yytext);
<bsc>\{		YYBEGIN(csc); write(yytext);
<csc>\{		YYBEGIN(dsc); write(yytext);
<dsc>\}		YYBEGIN(csc); write(yytext);
<csc>\}		YYBEGIN(bsc); write(yytext);
<bsc>\}		YYBEGIN(INITIAL); write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
<dsc>a			n4 := n4 + 1; write(yytext);
.			write('*');
<bsc>.			write('-');
<csc>.			write('_');
<dsc>.			write('+');
<*>\n			writeln;
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3, n4);
	writeln('SC0: ', n1);
	writeln('SC1: ', n2);
	writeln('SC2: ', n3);
	writeln('SC3: ', n4);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inclusive3--->>>

<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>
			<<case "startcond-inex" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test inclusive & exclusive start-condition

*/
					<</desc>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>

%formal-param%{ var n1, n2, n3, n4: integer %}
%actual-param%{ n1, n2, n3, n4 %}


%x bsc
%s csc
%s dsc

					<</declare_section>>
					<<lex_section>>

<*>[[:digit:]]+		write(yytext);
[\{\}]		YYBEGIN(bsc); write(yytext);
<bsc>\{		YYBEGIN(csc); write(yytext);
<csc>\{		YYBEGIN(dsc); write(yytext);
<dsc>\}		YYBEGIN(csc); write(yytext);
<csc>\}		YYBEGIN(bsc); write(yytext);
<bsc>\}		YYBEGIN(INITIAL); write(yytext);
a			n1 := n1 + 1; write(yytext);
<bsc>a			n2 := n2 + 1; write(yytext);
<csc>a			n3 := n3 + 1; write(yytext);
<dsc>a			n4 := n4 + 1; write(yytext);
.			write('*');
<bsc>.		write('-');
<csc>.		write('_');
<dsc>.		write('+');
<*>\n		writeln;
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	n4: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
	n4 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3, n4);
	writeln('SC0: ', n1);
	writeln('SC1: ', n2);
	writeln('SC2: ', n3);
	writeln('SC3: ', n4);

	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
{}}}}}~cc~~~~{~~aaaaaaaaaa~~~~~~~~}{{{{{{{{{{~~~c~bbbbbbbbbb~..........~~{{{{{{{{{{~aaaaaaaaaa}}}}}{{{{aaaaaaaa~aa{{{{~}}}}}}{{{{{aaaaa}}}}}}}}}}}}}}}}}}}~~{{{{{{{{~~~~{{{~~}}}}}}}}~{{{{{{{{{{{{{{{{~}}}}}}}}}}ccccc}}}}}}}}}}}}~aaaaaaa~~~~~{{{{{}}}}}}~~}}}}}}~aaaaaaaa}}}}}}}}}}~aaaaaaa{{{{{{{~~~ccc.........bbbbb~}}}}}}{{{{{{~ccccccccccccccccccc~~}}}}}{{{{~~{{{{{{{{{}}}}}}~~aa}}}}}}}}}aa}..........~~~~~~~{{{{{{{{{{{{{{{{{}}}}~~}}}}}}}}}}........aaaaaaa~}}~~.........aaaaa~aaaaaaaa~~a{{{{{{{~aa{{{{{{{{~}}}}}}}~~..
.: 48
a: 43
a: 41
{: 66
}: 88
{: 59
}: 50
b: 15
c: 30
~: 75

				<</textfile>>
				<<textfile "result.out">>
{}}}}}*******{--aaaaaaaaaa--------}{{{++++++++++++++++++++++++++++++++++++++++++++++aaaaaaaaaa}}}}}{{{+aaaaaaaa+aa+++++}}}}}}{{+++aaaaa}}}}}}}}}}}}}}}}}}}**{{{++++++++++++++}}}}}}}}-{{+++++++++++++++}}}}}}}}}}-----}}}}}}}}}}}}-aaaaaaa-----{{+++}}}}}}--}}}}}}-aaaaaaaa}}}}}}}}}}-aaaaaaa{{++++++++++++++++++++++++++}}}}}}{{++++++++++++++++++++++++++}}}}}{{{++++++++++++}}}}}}--aa}}}}}}}}}aa}-----------------{{+++++++++++++++}}}}--}}}}}}}}}}--------aaaaaaa-}}-----------aaaaa-aaaaaaaa--a{{++++++aa+++++++++}}}}}}}****
***48
a**43
a**41
{--66
}**88
{--59
}**50
***15
***30
***75

SC0: 4
SC1: 55
SC2: 0
SC3: 27
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-inex--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond---------->>>


<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>
		<<suite "startcond-refer" make="subdir-makefile-template">>
<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-alleof--->>>
			<<case "startcond-refer-alleof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
every start-condition has its own EOF-rule
*/
					<</desc>>
					
					<<global_decl_code>>
var
	pcchFileName: array[0..2] of pchar = (
		'test1.input',
		'test2.input',
		nil);
	fIndex: integer = 0;
	pbuf: YYPBUFFER;
					<</global_decl_code>>
					<<init_code>>
	fIndex := 0;
					<</init_code>>
					<<declare_section>>
%x	asc
%x	bsc
%x	csc
					<</declare_section>>
					<<lex_section>>
a		YYBEGIN(asc);
b		YYBEGIN(bsc);
c		YYBEGIN(csc);
<asc>a		YYBEGIN(INITIAL);
<bsc>b		YYBEGIN(INITIAL);
<csc>c		YYBEGIN(INITIAL);
<<EOF>>
			writeln('File end at SC-INITIAL: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<asc><<EOF>>
			writeln('File end at SC-asc: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<bsc><<EOF>>
			writeln('File end at SC-bsc: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<csc><<EOF>>
			writeln('File end at SC-csc: ', YYSTART());
			if fIndex < 2 then begin

				yy_delete_buffer();
				pbuf := yy_new_filebuf(pcchFileName[fIndex]);
				if pbuf = nil then begin
					
					writeln('failed to open buffer');
					yyterminate();
				end
				else begin
					yy_switch_buffer(pbuf);
					fIndex := fIndex + 1;
					YYBEGIN(INITIAL);
					yy_set_bol(true);
				end;
			end;

<*>.|\n

					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
dddddddddeccccccccccc...aaaaaadbbbbbbbbbaaaaaaaccccccceeeebbbbbbbbbeeeeccaaaaaaaecccccccceeeeeeeeeeeeeccccaaaaaaaaaaeeedddaaaaaaaddddeedddddddeddddddddebbbbbbb...dddde...aaaaaaaaaaeeeaaaaaaaaaeddddddddbbbbbbbbbbee.....bbbbbbbbbeeaaaaaaa
.: 14
a: 63
b: 44
c: 32
d: 44
e: 39

				<</textfile>>
				<<textfile "test1.input">>
aaaaaadddddddddeeeee..eeedddddddeeddddddddbbbbbdddddddeddddbbbddeeeebbaaaaaaaaeeacccccebbbbbbcccccccccbbbbbbbeccceaaaaaaaa
.: 2
a: 23
b: 23
c: 17
d: 37
e: 20

				<</textfile>>
				<<textfile "test2.input">>
aaaaaaaee..a.........bbbbbedddddddddedddeeeaaaaddeeeeedddecccccaaeeeebbbbbeccccceeebbbddddcccceddbdee..........ddccccccccccebbbbbbaaaaaaaaaaeeddddddcccccebbbbbbedddedccccccccccccccccdddddddddd........eee....dddddeeeeeeeeee......ebbbbeeeedddddddddebbbbbbbbbbaaaaaaabbbbbbcccccceee
.: 39
a: 31
b: 46
c: 51
d: 60
e: 52

				<</textfile>>
				<<textfile "result.out">>
File end at SC-asc: 2
File end at SC-bsc: 4
File end at SC-bsc: 4
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-alleof--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-allsc--->>>
			<<case "startcond-refer-allsc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
special start-condition <*>
*/
					<</desc>>
					<<global_decl_code>>
var
	c1: integer;
	c2: integer;
					<</global_decl_code>>
					<<init_code>>
	c1 := 0;
	c2 := 0;
					<</init_code>>
					<<declare_section>>

%formal-param%{ var beta, betb, others: integer %}
%actual-param%{ beta, betb, others %}

%x	asc
%x	bsc
					<</declare_section>>
					<<lex_section>>
a			YYBEGIN(asc);
			write('{');
			c1 := 0;
			others := others + 1;
			
b			YYBEGIN(bsc);
			write('[');
			c2 := 0;
			others := others + 1;
			
<asc>a		YYBEGIN(INITIAL);
			write('}');
			beta := beta + c1;
			others := others + 1;
			
<bsc>b		YYBEGIN(INITIAL);
			write(']');
			beta := beta + c2;
			others := others + 1;

<asc>[[:graph:]] 	c1 := c1 + 1;
					write(yytext);
			
<bsc>[[:graph:]]	c2 := c2 + 1;
					write(yytext);
<*>.			write('_');
				others := others + 1;
				
<*>\n			writeln;

<*><<EOF>>		others := others + c1;
				others := others + c2;
				
					<</lex_section>>
					<<local_decl_code>>
var
	n1: integer;
	n2: integer;
	n3: integer;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	n1 := 0;
	n2 := 0;
	n3 := 0;
					<</before_init>>
					<<after_init>>
	nret := yylex(n1, n2, n3);
	writeln;
	writeln('chars between a''s: ', n1);
	writeln('chars between b''s: ', n2);
	writeln('others: ', n3);
	writeln('total: ', n1 + n2 + n3);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
bbedddcccccccecccccccccccccceaeeddddddddeeedddddddddd.ddde.......eeeaaebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142

				<</textfile>>
				<<textfile "result.out">>
[]___________________________{eeddddddddeeedddddddddd.ddde.......eee}{ebeccccccccdddddddddeebbbbbbbbbddeeebbbbbeccccccddddddeeccccccceeeeee
142


chars between a's: 38
chars between b's: 0
others: 104
total: 142
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-allsc--->>>

<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-multisc--->>>
			<<case "startcond-refer-multisc" make="lex-only-makefile-template">>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
refer multi start-condition
*/

					<</desc>>
					<<init_code>>
					<</init_code>>
					<<declare_section>>

%formal-param%{ var qstr, mstr: string; var bexpr: boolean %}
%actual-param%{ qstr, mstr, bexpr %}

%x	qstr_sc
%x	expr_sc
					<</declare_section>>
					<<lex_section>>

\"						yy_push_state(qstr_sc); bexpr := false;
<qstr_sc>\`					yy_push_state(expr_sc); bexpr := true;
<expr_sc,qstr_sc>\$[[:cidf:]][[:cids:]]*	if bexpr then mstr := mstr + yytext else qstr := qstr + yytext;			 
<expr_sc,qstr_sc>[\+\-\*\/\(\)\[\]\{\}]		if bexpr then mstr := mstr + yytext else qstr := qstr + yytext;
<expr_sc>\`					yy_pop_state(); bexpr := false; mstr := mstr + #10;
<qstr_sc>\"					yy_pop_state(); qstr := qstr + #10;
<expr_sc,qstr_sc,expr_sc>.			if bexpr then mstr := mstr + yytext else qstr := qstr + yytext;

<*>.|\n
					<</lex_section>>
					
					<<local_decl_code>>
var
	qstr: string;
	mstr: string;
	b: boolean;
	nret: integer;
					<</local_decl_code>>
					<<before_init>>
	qstr := '';
	mstr := '';
	b := false;
					<</before_init>>
					<<after_init>>
	nret := yylex(qstr, mstr, b);

	writeln('qstr: ', qstr);
	writeln('mstr: ', mstr);
	if nret <> 0 then begin
		result:= nret;
		exit;
	end;
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
"if test `expr n1 * n2` != 0 then both n1 and n2 are not zero else either n1 or n2 are zero"
print_msg("for your information `echo $msg`")    
print "done"

				<</textfile>>
				<<textfile "result.out">>
qstr: if test  != 0 then both n1 and n2 are not zero else either n1 or n2 are zero
for your information 
done

mstr: expr n1 * n2
echo $msg

				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-multisc--->>>


<<<----------case: /lex-alone/basic/startcond-refer/startcond-refer-someeof--->>>
			<<case "startcond-refer-someeof" make="lex-only-makefile-template">>
				<<EXTRA_DIST>> test1.input test2.input test3.input <</EXTRA_DIST>>
				<<script "lex-only-script-template">>
					<<desc>>/*
test start-condition reference
some start-conditions have own EOF-rule
*/

					<</desc>>
					<<global_decl_code>>
const
	IDX_ASC = 0;
	IDX_BSC = 1;
	IDX_CSC = 2;
	IDX_DSC = 3;
var
	ppchFileName: array[0..3] of pchar = (
		'test1.input',
		'test2.input',
		'test3.input',
		nil);
					<</global_decl_code>>
					<<init_code>>

					<</init_code>>
					<<declare_section>>
%lvar-decl%{
	i: integer;
	pbuf: YYPBUFFER;
%}

%yywrap%{
	result := false; 
%}

%x	asc
%x	bsc
%x	csc
%x	dsc
					<</declare_section>>
					<<lex_section>>

a	YYBEGIN(asc); writeln(yytext);
b	YYBEGIN(bsc); writeln(yytext);
c	YYBEGIN(csc); writeln(yytext);
d	YYBEGIN(dsc); writeln(yytext);
<asc>a	YYBEGIN(INITIAL);
<bsc>b	YYBEGIN(INITIAL);
<csc>c	YYBEGIN(INITIAL);
<dsc>d	YYBEGIN(INITIAL);
<asc><<EOF>>	begin
			writeln('File end at SC-asc: ', YYSTART());
			yy_delete_buffer();
			for i := 2 downto 0 do begin
				pbuf := yy_new_filebuf(ppchFileName[i]);
				if pbuf = nil then begin

					writeln('failed to open buffer');
					yyterminate();
					break;
				end
				else begin
					yy_push_buffer(pbuf);
				end;
			end;
			YYBEGIN(INITIAL);
		end;
<*><<EOF>>		begin
			case YYSTART() of
			bsc: writeln('File end at SC-bsc: ', YYSTART());
			csc: writeln('File end at SC-csc: ', YYSTART());
			dsc: writeln('File end at SC-dsc: ', YYSTART());
			end;
			yy_delete_buffer();
			YYBEGIN(INITIAL);
		end;

<*>.|\n
					<</lex_section>>
					<<before_init>>

					<</before_init>>
					<<after_init>>
	yylex();
					<</after_init>>
				<</script>>

			<<ufile "testexe.pas" "testexe-lex-only-script-template">>
			<</ufile>>

				<<textfile "test.input">>
a
				<</textfile>>
				<<textfile "test1.input">>
b
				<</textfile>>
				<<textfile "test2.input">>
c
				<</textfile>>
				<<textfile "test3.input">>
d
				<</textfile>>
				<<textfile "result.out">>
a
File end at SC-asc: 2
b
File end at SC-bsc: 4
c
File end at SC-csc: 6
d
File end at SC-dsc: 8
				<</textfile>>
				<<textfile "result.err">>
				<</textfile>>
			<</case>>
<<<----------case: /lex-alone/basic/startcond/startcond-refer-someeof--->>>

		<</suite>>
<<<----------sub-suite: /lex-alone/basic/startcond-refer---------->>>

	<</suite>>
<<<----------sub-suite: /lex-alone/basic---------->>>

<</suite>>
<<<----------sub-suite: /lex-alone ---------->>>



<<<----------sub-suite: /invoke ---------------->>>
<<suite "invoke" make="subdir-makefile-template">>
<<<----------case: /invoke/default----------------->>>
	<<case "default" make="invoke-make-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	default options
		-o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
ans = 		0
ans = 		1024
ans = 		1024
Error: at 25:1; description: yy is unset variable.
yy = 		1024
yy = 		1024
Error: at 28:1; description: goodbye is unset variable.
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
	<<<----------case: /invoke/default----------------->>>

<<<----------case: /invoke/option-t----------------->>>
	<<case "option-t" make="invoke-make-stdout-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -t to redirect code output to stdout
		-t
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
ans = 		0
ans = 		1024
ans = 		1024
Error: at 25:1; description: yy is unset variable.
yy = 		1024
yy = 		1024
Error: at 28:1; description: goodbye is unset variable.
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-t----------------->>>


<<<----------case: /invoke/option-a----------------->>>
	<<case "option-a" make="invoke-make-template">>
		<<upgen_options>>-al<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -a
		-a -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-a----------------->>>


<<<----------case: /invoke/option-d1----------------->>>
	<<case "option-d1" make="invoke-make-template">>
		<<upgen_options>>-d -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d to enable producing diagnosis information
	for pattern-matching
		-d -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
.................... accept {`sub'}, rule at line: 744
.................... accept {`='}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`2'}, rule at line: 727
.................... accept {`-'}, rule at line: 750
.................... accept {`-'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`-'}, rule at line: 750
.................... accept {`+'}, rule at line: 750
.................... accept {`4'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`4'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`-'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`4'}, rule at line: 727
.................... accept {`^'}, rule at line: 750
.................... accept {`3'}, rule at line: 727
.................... accept unprintable-char{10}, rule at line: 750
sub = 		-7748934
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`%'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`1011'}, rule at line: 727
.................... accept unprintable-char{10}, rule at line: 750
ans = 		-630
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept unprintable-char{10}, rule at line: 750
sub = 		-620
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`9'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`216'}, rule at line: 727
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`24'}, rule at line: 727
.................... accept unprintable-char{10}, rule at line: 750
sub = 		-600
.................... accept {`sup'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`('}, rule at line: 750
.................... accept {`sub'}, rule at line: 744
.................... accept {` '}, rule at line: 755
.................... accept {`^'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`3'}, rule at line: 727
.................... accept {`)'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
.................... accept unprintable-char{10}, rule at line: 750
sup = 		342857
.................... accept {`list'}, rule at line: 740
.................... accept unprintable-char{10}, rule at line: 750
ans = 		-630
sub = 		-600
sup = 		342857
.................... accept {`clear'}, rule at line: 736
.................... accept unprintable-char{10}, rule at line: 750
.................... accept {`sup'}, rule at line: 744
.................... accept {`?'}, rule at line: 750
Error: at 8:1; description: sup is unset variable.
.................... accept unprintable-char{10}, rule at line: 750
.................... accept {`quit'}, rule at line: 732
.................... accept unprintable-char{10}, rule at line: 750
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1----------------->>>

<<<----------case: /invoke/option-D2----------------->>>
	<<case "option-D2" make="invoke-make-template">>
		<<upgen_options>>-D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -D to enable producing diagnosis information
	for parsing
		-D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 759.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 862.
Next symbol is -
Shift -, go to state 28
Next symbol is -
Shift -, go to state 12
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 862.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 895.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
Next symbol is +
Shift +, go to state 11
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 862.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 900.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 911.
Next symbol is %
Shift %, go to state 31
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 847.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 769.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is /
Shift /, go to state 30
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
Next symbol is (
Shift (, go to state 14
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 911.
Next symbol is ^
Shift ^, go to state 32
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 862.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 904.
Next symbol is /
Shift /, go to state 30
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 911.
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is LIST
Shift LIST, go to state 9
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 803.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is CLEAR
Shift CLEAR, go to state 8
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 799.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is VARI
Shift VARI, go to state 7
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 786.
Next symbol is ?
Shift ?, go to state 34
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 786.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
Next symbol is QUIT
Shift QUIT, go to state 10
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 811.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-D2----------------->>>

<<<----------case: /invoke/option-d1D2----------------->>>
	<<case "option-d1D2" make="invoke-make-template">>
		<<upgen_options>>-d -D -l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -d[debug-level] -D[debug-level] to enable producing diagnosis information
	for pattern-matching and parsing
		-d -D -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 759.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`-'}, rule at line: 750
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 862.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 750
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`-'}, rule at line: 750
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 862.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 895.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 750
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`-'}, rule at line: 750
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 862.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 900.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 862.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`%'}, rule at line: 750
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 911.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 755
.................... accept {`1011'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 908.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 847.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 769.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 755
.................... accept {`31'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 755
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 911.
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 755
.................... accept {`9'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 755
.................... accept {`216'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 908.
.................... accept {` '}, rule at line: 755
.................... accept {`*'}, rule at line: 750
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 755
.................... accept {`24'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 908.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sup'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 755
.................... accept {`='}, rule at line: 750
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 776.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 755
.................... accept {`('}, rule at line: 750
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 911.
.................... accept {` '}, rule at line: 755
.................... accept {`^'}, rule at line: 750
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 755
.................... accept {`3'}, rule at line: 727
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 908.
.................... accept {`)'}, rule at line: 750
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 862.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 904.
.................... accept {` '}, rule at line: 755
.................... accept {`/'}, rule at line: 750
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 755
.................... accept {`ans'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 911.
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 834.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 776.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`list'}, rule at line: 740
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 803.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`clear'}, rule at line: 736
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 799.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`sup'}, rule at line: 744
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 750
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 786.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 786.
Reduce action: Program Line => Program, go to state 2 by rule at 762.
.................... accept {`quit'}, rule at line: 732
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 750
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 811.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-d1D2----------------->>>

<<<----------case: /invoke/option-i----------------->>>
	<<case "option-i" make="invoke-make-template">>
		<<upgen_options>>-il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -i so that pattern will be matched case-insensitively
		-i -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-i----------------->>>

<<<----------case: /invoke/option-l----------------->>>
	<<case "option-l" make="invoke-make-template">>
<<<<-------<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using option -l to disable location computation
		-l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-l----------------->>>


<<<----------case: /invoke/option-m----------------->>>
	<<case "option-m" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using option -m to disable generating pattern-matching program
		-m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-m----------------->>>

<<<----------case: /invoke/option-p----------------->>>
	<<case "option-p" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using option -p to disable generating pattern-matching program
		-p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
<<prefix>>yy<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-p----------------->>>

<<<----------case: /invoke/option-decl-file----------------->>>
	<<case "option-decl-file" make="invoke-make-template">>
		<<upgen_options>>-Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		-H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-decl-file----------------->>>


<<<----------case: /invoke/option-sspec----------------->>>
	<<case "option-sspec" make="invoke-make-template">>
		<<upgen_options>>-l<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -s to specify language SPEC to generate code
		-s pas -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-sspec----------------->>>


<<<----------case: /invoke/option-S----------------->>>
	<<case "option-S" make="invoke-make-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -S to enable default action in pattern-matching
		-S -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-S----------------->>>


<<<----------case: /invoke/option-v----------------->>>
	<<case "option-v" make="invoke-make-template">>
		<<upgen_options>>-lv<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -v to report details on automations
		-v -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-v----------------->>>


<<<----------case: /invoke/option-cmp-d1m----------------->>>
	<<case "option-cmp-d1m" make="invoke-make-template">>
		<<upgen_options>>-d -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>

		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1m----------------->>>


<<<----------case: /invoke/option-cmp-d1p----------------->>>
	<<case "option-cmp-d1p" make="invoke-make-template">>
		<<upgen_options>>-d -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
.................... accept {`EOF'}, rule at line: 22
identifier: EOF
.................... accept {`['}, rule at line: 26
undefined symbol `['
.................... accept {`0'}, rule at line: 18
number: 0
.................... accept {`-'}, rule at line: 24
operator: -
.................... accept {`9'}, rule at line: 18
number: 9
.................... accept {`]'}, rule at line: 26
undefined symbol `]'
.................... accept {`+'}, rule at line: 24
operator: +
.................... accept {`quit'}, rule at line: 19
keyword: quit
.................... accept {`-'}, rule at line: 24
operator: -
.................... accept {`clear'}, rule at line: 20
keyword: clear
.................... accept {`{'}, rule at line: 26
undefined symbol `{'
.................... accept {`var'}, rule at line: 22
identifier: var
.................... accept {`}'}, rule at line: 26
undefined symbol `}'
.................... accept {`list'}, rule at line: 21
keyword: list
.................... accept {`+'}, rule at line: 24
operator: +
.................... accept {`-'}, rule at line: 24
operator: -
.................... accept {`*'}, rule at line: 24
operator: *
.................... accept {`/'}, rule at line: 24
operator: /
.................... accept {`%'}, rule at line: 24
operator: %
.................... accept {`^'}, rule at line: 24
operator: ^
.................... accept {`='}, rule at line: 24
operator: =
.................... accept {`('}, rule at line: 24
operator: (
.................... accept {`)'}, rule at line: 24
operator: )
.................... accept {`?'}, rule at line: 24
operator: ?
.................... accept unprintable-char{10}, rule at line: 25
new line encountered.
.................... accept {`\'}, rule at line: 26
undefined symbol `\'
.................... accept {`n'}, rule at line: 22
identifier: n
.................... accept unprintable-char{10}, rule at line: 25
new line encountered.
.................... accept {`.'}, rule at line: 26
undefined symbol `.'
.................... accept unprintable-char{10}, rule at line: 25
new line encountered.
.................... accept {EOF}, rule at line: 28
Good-bye!
.................... EOS reached
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>

	<</case>>
<<<----------case: /invoke/option-cmp-d1p----------------->>>


<<<----------case: /invoke/option-cmp-D2p----------------->>>
	<<case "option-cmp-D2p" make="invoke-make-template">>
		<<upgen_options>>-D -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-D -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-D2p----------------->>>


<<<----------case: /invoke/option-cmp-d1D2H----------------->>>
	<<case "option-cmp-d1D2H" make="invoke-make-template">>
		<<upgen_options>>-d -D -Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -H -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 758.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 861.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 749
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 861.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 894.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 749
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 861.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 899.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`%'}, rule at line: 749
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 910.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 754
.................... accept {`1011'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 846.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 768.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 754
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {` '}, rule at line: 754
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 754
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 754
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 754
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {` '}, rule at line: 754
.................... accept {`*'}, rule at line: 749
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 754
.................... accept {`9'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept {`/'}, rule at line: 749
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 754
.................... accept {`216'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {` '}, rule at line: 754
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 754
.................... accept {`24'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 754
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 754
.................... accept {`('}, rule at line: 749
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 910.
.................... accept {` '}, rule at line: 754
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 754
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`)'}, rule at line: 749
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 861.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 903.
.................... accept {` '}, rule at line: 754
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 754
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 910.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`list'}, rule at line: 739
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 802.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`clear'}, rule at line: 735
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 798.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 749
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 785.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 785.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`quit'}, rule at line: 731
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 810.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2H----------------->>>

<<<----------case: /invoke/option-cmp-d1D2l----------------->>>
	<<case "option-cmp-d1D2l" make="invoke-make-template">>
		<<upgen_options>>-d -D<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -l -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 757.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`-'}, rule at line: 748
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 856.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 748
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`-'}, rule at line: 748
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 856.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 889.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 822.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 748
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`-'}, rule at line: 748
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 856.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 894.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 822.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 856.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 856.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 822.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`%'}, rule at line: 748
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 905.
Next symbol is %
Shift %, go to state 31
.................... accept {` '}, rule at line: 753
.................... accept {`1011'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 902.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 842.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 767.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 753
.................... accept {`ans'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 905.
.................... accept {` '}, rule at line: 753
.................... accept {`/'}, rule at line: 748
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 753
.................... accept {`31'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept {`*'}, rule at line: 748
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 830.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 753
.................... accept {`31'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 753
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 905.
.................... accept {` '}, rule at line: 753
.................... accept {`*'}, rule at line: 748
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 753
.................... accept {`9'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept {`/'}, rule at line: 748
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 826.
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 753
.................... accept {`216'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 902.
.................... accept {` '}, rule at line: 753
.................... accept {`*'}, rule at line: 748
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 830.
Next symbol is *
Shift *, go to state 29
.................... accept {` '}, rule at line: 753
.................... accept {`24'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 902.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 826.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sup'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {` '}, rule at line: 753
.................... accept {`='}, rule at line: 748
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 774.
Next symbol is =
Shift =, go to state 33
.................... accept {` '}, rule at line: 753
.................... accept {`('}, rule at line: 748
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 905.
.................... accept {` '}, rule at line: 753
.................... accept {`^'}, rule at line: 748
Next symbol is ^
Shift ^, go to state 32
.................... accept {` '}, rule at line: 753
.................... accept {`3'}, rule at line: 725
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 902.
.................... accept {`)'}, rule at line: 748
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 856.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 898.
.................... accept {` '}, rule at line: 753
.................... accept {`/'}, rule at line: 748
Next symbol is /
Shift /, go to state 30
.................... accept {` '}, rule at line: 753
.................... accept {`ans'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 905.
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 830.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 774.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`list'}, rule at line: 738
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 800.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`clear'}, rule at line: 734
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 796.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`sup'}, rule at line: 742
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 748
Next symbol is ?
Error: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 784.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 784.
Reduce action: Program Line => Program, go to state 2 by rule at 760.
.................... accept {`quit'}, rule at line: 730
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 748
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 808.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2l----------------->>>

<<<----------case: /invoke/option-cmp-d1D2S----------------->>>
	<<case "option-cmp-d1D2S" make="invoke-make-template">>
		<<upgen_options>>-d -D -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-d -D -S -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
Reduce action: => Program, go to state 2 by rule at 758.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 42 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`2'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 42 by rule at 861.
Next symbol is -
Shift -, go to state 28
.................... accept {`-'}, rule at line: 749
Next symbol is -
Shift -, go to state 12
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 24 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 24 by rule at 861.
Next symbol is -
Reduce action: - Expr => Expr, go to state 37 by rule at 894.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`+'}, rule at line: 749
Next symbol is +
Shift +, go to state 11
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 22 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`-'}, rule at line: 749
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is -
Reduce action: Expr ^ Expr => Expr, go to state 22 by rule at 861.
Next symbol is -
Reduce action: + Expr => Expr, go to state 37 by rule at 899.
Next symbol is -
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is -
Shift -, go to state 28
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 37 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`4'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 41 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr ^ Expr => Expr, go to state 37 by rule at 861.
Next symbol is unprintable-char{10}
Reduce action: Expr - Expr => Expr, go to state 42 by rule at 825.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-7748934
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`%'}, rule at line: 749
Next symbol is %
Reduce action: VARI => Expr, go to state 15 by rule at 910.
Next symbol is %
Shift %, go to state 31
.................... accept {`1011'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 40 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr % Expr => Expr, go to state 15 by rule at 846.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 26
ans = 		-630
Reduce action: Expr unprintable-char{10} => Line, go to state 4 by rule at 768.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {`31'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-620
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 42 by rule at 910.
.................... accept {`*'}, rule at line: 749
Next symbol is *
Shift *, go to state 29
.................... accept {`9'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept {`/'}, rule at line: 749
Next symbol is /
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is /
Shift /, go to state 30
.................... accept {`216'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 39 by rule at 907.
.................... accept {`*'}, rule at line: 749
Next symbol is *
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is *
Shift *, go to state 29
.................... accept {`24'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 38 by rule at 907.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr * Expr => Expr, go to state 42 by rule at 829.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sub = 		-600
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`='}, rule at line: 749
Next symbol is =
Reduce action: => @@1, go to state 17 by rule at 775.
Next symbol is =
Shift =, go to state 33
.................... accept {`('}, rule at line: 749
Next symbol is (
Shift (, go to state 14
.................... accept {`sub'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 25 by rule at 910.
.................... accept {`^'}, rule at line: 749
Next symbol is ^
Shift ^, go to state 32
.................... accept {`3'}, rule at line: 726
Next symbol is NUM
Shift NUM, go to state 6
Reduce action: NUM => Expr, go to state 41 by rule at 907.
.................... accept {`)'}, rule at line: 749
Next symbol is )
Reduce action: Expr ^ Expr => Expr, go to state 25 by rule at 861.
Next symbol is )
Shift ), go to state 35
Reduce action: ( Expr ) => Expr, go to state 42 by rule at 903.
.................... accept {`/'}, rule at line: 749
Next symbol is /
Shift /, go to state 30
.................... accept {`ans'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 23
Reduce action: VARI => Expr, go to state 39 by rule at 910.
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Reduce action: Expr / Expr => Expr, go to state 42 by rule at 833.
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 44
sup = 		342857
Reduce action: VARI @@1 = Expr unprintable-char{10} => Line, go to state 4 by rule at 775.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`list'}, rule at line: 739
Next symbol is LIST
Shift LIST, go to state 9
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 20
ans = 		-630
sub = 		-600
sup = 		342857
Reduce action: LIST unprintable-char{10} => Line, go to state 4 by rule at 802.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`clear'}, rule at line: 735
Next symbol is CLEAR
Shift CLEAR, go to state 8
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 19
Reduce action: CLEAR unprintable-char{10} => Line, go to state 4 by rule at 798.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`sup'}, rule at line: 743
Next symbol is VARI
Shift VARI, go to state 7
.................... accept {`?'}, rule at line: 749
Next symbol is ?
Error: at 8:1; description: sup is unset variable.
Reduce action: => @@2, go to state 18 by rule at 785.
Next symbol is ?
Shift ?, go to state 34
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 43
Reduce action: VARI @@2 ? unprintable-char{10} => Line, go to state 4 by rule at 785.
Reduce action: Program Line => Program, go to state 2 by rule at 761.
.................... accept {`quit'}, rule at line: 731
Next symbol is QUIT
Shift QUIT, go to state 10
.................... accept unprintable-char{10}, rule at line: 749
Next symbol is unprintable-char{10}
Shift unprintable-char{10}, go to state 21
Reduce action: QUIT unprintable-char{10} => Line, go to state 4 by rule at 810.
Clearup : Pop up unprintable-char{10}
Clearup : Pop up QUIT
Clearup : Pop up Program
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-d1D2S----------------->>>

<<<----------case: /invoke/option-cmp-lS----------------->>>
	<<case "option-cmp-lS" make="invoke-make-template">>
		<<upgen_options>>-S<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -l -o FILE
*/
			<</desc>>

		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lS----------------->>>


<<<----------case: /invoke/option-cmp-St----------------->>>
	<<case "option-cmp-St" make="invoke-make-stdout-template">>
		<<upgen_options>>-lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -t
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
s = 1
m = 60 * s
h = 60 ^ 2 * s
d = h * 24
y = 365 * d
list
z = 365 * 24 * 60 ^ 2
y = z / y
dd = z / (30 * 4 + 31 * 7 + 1 * 28)
mm = z / 365 / 24 /60
hh = (z / 365) / 24
x = mm ^ s ^ hh ^ s
list
w = 365 / 7
wm = (365 + 1) % 7
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
mm?
list
y/(dd-d)
m/(h/m-60)
clear
ans?
2^2^2^2/2^2^2/2^2
ans?
yy?
yy=ans
yy?
goodbye!
list
quit
		<</textfile>>
		<<textfile "result.out">>
s = 		1
m = 		60
h = 		3600
d = 		86400
y = 		31536000
ans = 		0
d = 		86400
h = 		3600
m = 		60
s = 		1
y = 		31536000
z = 		31536000
y = 		1
dd = 		86400
mm = 		60
hh = 		3600
x = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
x = 		60
y = 		1
z = 		31536000
w = 		52
wm = 		2
sub = 		-7748934
mm = 		60
ans = 		0
d = 		86400
dd = 		86400
h = 		3600
hh = 		3600
m = 		60
mm = 		60
s = 		1
sub = 		-7748934
w = 		52
wm = 		2
x = 		60
y = 		1
z = 		31536000
Error: at 19: 3; description: divided by zero!!
Error: at 20: 3; description: divided by zero!!
ans = 		0
ans = 		1024
ans = 		1024
Error: at 25:1; description: yy is unset variable.
yy = 		1024
yy = 		1024
Error: at 28:1; description: goodbye is unset variable.
ans = 		1024
yy = 		1024
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-St----------------->>>


<<<----------case: /invoke/option-cmp-aS----------------->>>
	<<case "option-cmp-aS" make="invoke-make-template">>
		<<upgen_options>>-a -lS<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-a -S -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-aS----------------->>>


<<<----------case: /invoke/option-cmp-pS----------------->>>
	<<case "option-cmp-pS" make="invoke-make-template">>
		<<upgen_options>>-S -lp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -p -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
number: 0
operator: -
number: 9
operator: +
keyword: quit
operator: -
keyword: clear
identifier: var
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
identifier: n
new line encountered.
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-pS----------------->>>


<<<----------case: /invoke/option-cmp-mS----------------->>>
	<<case "option-cmp-mS" make="invoke-make-template">>
		<<upgen_options>>-S -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mS----------------->>>


<<<----------case: /invoke/option-cmp-HS----------------->>>
	<<case "option-cmp-HS" make="invoke-make-template">>
		<<upgen_options>>-S -Hl<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -H -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HS----------------->>>

<<<----------case: /invoke/option-cmp-iS----------------->>>
	<<case "option-cmp-iS" make="invoke-make-template">>
		<<upgen_options>>-S -il<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-S -i -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
SUB = ans / 31 * 31 
Sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
LIST
cLear
Sup?
quiT
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
SUB = 		-620
Sub = 		-7748928
sup = 		2100269
SUB = 		-620
Sub = 		-7748928
ans = 		-630
sub = 		-7748934
sup = 		2100269
Error: at 8:1; description: Sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iS----------------->>>

<<<----------case: /invoke/option-cmp-HsC++----------------->>>
	<<case "option-cmp-HsC++" make="invoke-make-template">>
		<<upgen_options>>-lH<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using option -H to generate declaration file
		and option -s to specify the programming language to generate code
		-H -s pas -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HsC++----------------->>>


<<<----------case: /invoke/option-cmp-Hm----------------->>>
	<<case "option-cmp-Hm" make="invoke-make-template">>
		<<upgen_options>>-Hlm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hm----------------->>>

<<<----------case: /invoke/option-cmp-lm----------------->>>
	<<case "option-cmp-lm" make="invoke-make-template">>
		<<upgen_options>>-m<</upgen_options>>
		<<script "invoke-myscanner-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lm----------------->>>

<<<----------case: /invoke/option-cmp-mp----------------->>>
	<<case "option-cmp-mp" make="make-no-exec">>
		<<upgen_options>>-p -lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-p -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Warning: No code generated for script `script.upg',
since both pattern-matching and parsing program generation disabled.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mp----------------->>>

<<<----------case: /invoke/option-cmp-msC++----------------->>>
	<<case "option-cmp-msC++" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s pas -m -o FILE
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++----------------->>>

<<<----------case: /invoke/option-cmp-msC++t----------------->>>
	<<case "option-cmp-msC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s pas -m -t
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-msC++t----------------->>>

<<<----------case: /invoke/option-cmp-Hp----------------->>>
	<<case "option-cmp-Hp" make="invoke-make-template">>
		<<upgen_options>>-Hlp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hp----------------->>>

<<<----------case: /invoke/option-cmp-Hlp----------------->>>
	<<case "option-cmp-Hlp" make="invoke-make-template">>
		<<upgen_options>>-Hp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -l -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quit-clear{var}list+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quit
operator: -
keyword: clear
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: list
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hlp----------------->>>

<<<----------case: /invoke/option-cmp-Hip----------------->>>
	<<case "option-cmp-Hip" make="invoke-make-template">>
		<<upgen_options>>-Hilp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -o FILE
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quIT
operator: -
keyword: CLEar
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-Hip----------------->>>

<<<----------case: /invoke/option-cmp-ipt----------------->>>
	<<case "option-cmp-ipt" make="invoke-make-stdout-template">>
		<<upgen_options>>-ilp<</upgen_options>>
		<<script "invoke-noparser-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -i -p -t
*/
			<</desc>>
<<default_action>>.				writeln('undefined symbol `', yytext[0], '''');
<</default_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-noparser-template">>
		<</ufile>>
		<<textfile "test.input">>
EOF[0-9]+quIT-CLEar{var}lIST+-*/%^=()?
\n
.
		<</textfile>>
		<<textfile "result.out">>
identifier: EOF
undefined symbol `['
number: 0
operator: -
number: 9
undefined symbol `]'
operator: +
keyword: quIT
operator: -
keyword: CLEar
undefined symbol `{'
identifier: var
undefined symbol `}'
keyword: lIST
operator: +
operator: -
operator: *
operator: /
operator: %
operator: ^
operator: =
operator: (
operator: )
operator: ?
new line encountered.
undefined symbol `\'
identifier: n
new line encountered.
undefined symbol `.'
new line encountered.
Good-bye!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-ipt----------------->>>

<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>
	<<case "option-cmp-HPzzCMD" make="invoke-make-template">>
		<<upgen_options>>-HlP zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzzCMD----------------->>>

<<<----------case: /invoke/option-cmp-HPzz----------------->>>
	<<case "option-cmp-HPzz" make="invoke-make-template">>
		<<upgen_options>>-Hl -P xx<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-H -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-HPzz----------------->>>

<<<----------case: /invoke/option-cmp-iPzz----------------->>>
	<<case "option-cmp-iPzz" make="invoke-make-template">>
		<<upgen_options>>-il -P xx<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options
		-i -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sUb = Sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
lISt
CLEAR
CLear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
Error: at 4:7; description: Sub is unset variable.
sup = 		378298
ans = 		-630
sub = 		-620
sup = 		378298
Error: at 9:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-iPzz----------------->>>

<<<----------case: /invoke/option-cmp-lPzz----------------->>>
	<<case "option-cmp-lPzz" make="invoke-make-template">>
		<<upgen_options>>-P xx<</upgen_options>>
		<<script "invoke-noloc-template">>
			<<desc>>/*
invoking test:
	using compound options
		-l -P xx -o FILE
	but this option in script set prefix to be `zz',
	hence option in commandline is simply ignored.
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lPzz----------------->>>

<<<----------case: /invoke/option-cmp-mPzz----------------->>>
	<<case "option-cmp-mPzz" make="invoke-make-template">>
		<<upgen_options>>-lm -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-m -P zz FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzz----------------->>>

<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>
	<<case "option-cmp-PzzsC++" make="invoke-make-template">>
		<<upgen_options>>-l -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-s pas -P zz -o FILE
*/
			<</desc>>
<<default_action>>.<</default_action>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzsC++----------------->>>

<<<----------case: /invoke/option-cmp-PzzS----------------->>>
	<<case "option-cmp-PzzS" make="invoke-make-template">>
		<<upgen_options>>-lS -P zz<</upgen_options>>
		<<script "invoke-full-template">>
			<<desc>>/*
invoking test:
	using compound options:
		-S-P zz -o FILE
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 8:1; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-PzzS----------------->>>

<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>
	<<case "option-cmp-mPzzsC++t" make="invoke-make-stdout-template">>
		<<upgen_options>>-lm -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-s pas -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzzsC++t----------------->>>

<<<----------case: /invoke/option-cmp-mPzztv----------------->>>
	<<case "option-cmp-mPzztv" make="invoke-make-stdout-template">>
		<<upgen_options>>-lmv -P zz<</upgen_options>>
		<<script "invoke-myscanner-template">>
			<<desc>>/*
invoking test:
	using compound options
		-v -m -P zz -t
*/
			<</desc>>
<<option_prefix>>%option prefix=zz<</option_prefix>>
<<prefix>>zz<</prefix>>
		<</script>>
		<<ufile "testexe.pas" "testexe-invoke-myscanner-template">>
<<prefix>>zz<</prefix>>
		<</ufile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
ans = 		-630
sub = 		-620
sub = 		-600
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-mPzztv----------------->>>

<<<----------case: /invoke/option-cmp-lex+parse----------------->>>
	<<case "option-cmp-lex+parse" make="invoke-make-lex-parse-template">>
		<<parser_options>>-H -m<</parser_options>>
		<<scanner_options>>-p -P zz<</scanner_options>>
		<<script "invoke-parser-only-template">>
			<<desc>>/*
features to test: put scanner generated by upgen and parser generated by upgen together
this is parser part.
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-myscanner-template">>
		<</ufile>>
		<<textfile "scanner.upg">>
/***********************************************************************
	program sample : put scanner generated by upgen
			 and parser generated by upgen together
	this is only scanning program.
************************************************************************/
%{
uses SysUtils, StrUtils,
	script { parsing classes and routines };

%}

/* name of variable */
var		[A-Z_a-z][A-Z_a-z0-9]*


%%

[0-9]+				yylval.nVal := strtoint(yytext);
					result := NUM;
					exit;
"quit"				result := QUIT;
					exit;
"clear"				result := CLEAR;
					exit;
"list"				result := LIST;
					exit;
{var}				s_strVarName := string(yytext);
					result := VARI;
					exit;
[\+\-\*\/\%\^\=\(\)\?\n]	result := ord(yytext[0]);
					 exit;

.				writeln('undefined symbol `', yytext[0], '''');

%%

%%

		<</textfile>>
		<<textfile "test.input">>
sub=2^2^2^2--3^3^3-+4^4^3-3^4^3
sub % 1011
sub = ans / 31 * 31 
sub = sub * 9 / 216 * 24
sup = (sub ^ 3) / ans
list
clear
sup?
quit
		<</textfile>>
		<<textfile "result.out">>
sub = 		-7748934
undefined symbol ` '
undefined symbol ` '
ans = 		-630
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
sub = 		-620
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
sub = 		-600
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
undefined symbol ` '
sup = 		342857
ans = 		-630
sub = 		-600
sup = 		342857
Error: at 0:0; description: sup is unset variable.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/option-cmp-lex+parse----------------->>>

<</suite>>
<<<----------sub-suite: /invoke ---------------->>>

<<<----------sub-suite: /empty ---------------->>>
<<suite "empty" make="subdir-makefile-template">>

<<<----------case: /invoke/empty/empty-file----------------->>>
	<<case "empty-file" make="make-no-exec">>
		<<textfile "script.upg">>
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 1:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-file----------------->>>

<<<----------sub-suite: /empty ---------------->>>

<<<----------case: /invoke/empty/only-comments----------------->>>
	<<case "only-comments" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: content of script is empty except comments
*/
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 4:1.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-comments----------------->>>

<<<----------case: /invoke/empty/empty-sect-2----------------->>>
	<<case "empty-sect-2" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-empty-sect-2">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-empty-sect-2">>
		<</ufile>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
Error: syntax error at 0:0.
		900001
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-2----------------->>>


<<<----------case: /invoke/empty/only-2-sections----------------->>>
	<<case "only-2-sections" make="make-no-exec">>
		<<textfile "script.upg">>
/*
feature to test: script contains only 2 sections
*/
%%
.		/* do nothing */
		<</textfile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: syntax error at 6:0.
Warning: No code generated for script `script.upg', be sure it is legal script.
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-2-sections----------------->>>

<<<----------case: /invoke/empty/only-3-sections----------------->>>
	<<case "only-3-sections" make="invoke-make-template">>
		<<upgen_options>>-lm<</upgen_options>>
		<<script "script-only-3-sections">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-only-3-sections">>
		<</ufile>>
		<<textfile "test.input">>
33 90 34
0x120
900001
		<</textfile>>
		<<textfile "result.out">>
		33
		90
		34
Error: syntax error at 0:0.
		900001
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/only-3-sections----------------->>>

<<<----------case: /invoke/empty/empty-sect-3----------------->>>
	<<case "empty-sect-3" make="invoke-make-template">>
		<<upgen_options>>-lp<</upgen_options>>
		<<script "script-empty-sect-3">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-empty-sect-3">>
		<</ufile>>
		<<textfile "test.input">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner.');
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	write(yytext);
%%

		<</textfile>>
		<<textfile "result.out">>
/*
feature to test: section 3 is empty, and no user-code section
*/
%{
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;


<<filebuf_decl/>>
int yylex(void);

int main(int argc, char **argv) {
<<before_buffer_init/>>
	if(<<buffer_init/>>) {
		cerr << "Error: failed to initialize scanner.');
		return -1;
	}

	yylex();
<<after_buffer_usage/>>
	return 0;
}

%}

%%
.|\n	write(yytext);
%%

		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /invoke/empty/empty-sect-3----------------->>>

<</suite>>
<<<----------sub-suite: /empty ---------------->>>

<<<----------sub-suite: /basic ---------------->>>
<<suite "basic" make="subdir-makefile-template">>

<<<----------sub-suite: /basic/declare ---------------->>>
	<<suite "declare" make="subdir-makefile-template">>

<<<----------case: /basic/declare/def-header----------------->>>
	<<case "def-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple definition headers
*/
			<</desc>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/def-header----------------->>>


<<<----------case: /basic/declare/decl-header----------------->>>
	<<case "decl-header" make="basic-make-template">>
		<<script "basic-parentheses-template">>
			<<desc>>/*
feature to test: multiple declaration headers
*/
			<</desc>>
			<<declare_section>>

%header%{
{ declaration header 1 }
<<filebuf_decl/>>
%}

%header%{
{ declaration header 2}
procedure showAccept;
%}

%{
{ definition header }
procedure showAccept;
begin
	writeln('This text is accepted by parenthese extracter.');
end;
%}

			<</declare_section>>
			<<accept_action>>
showAccept;
			<</accept_action>>
		<</script>>
		<<ufile "testexe.pas" "testexe-template">>
		<</ufile>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[[]]
[[[[[[]]]]][[[[]]]]]
[[]
[][[]]
[][[]]
]
This text is accepted by parenthese extracter.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/decl-header----------------->>>


<<<----------case: /basic/declare/svt-decl-01----------------->>>
	<<case "svt-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: using %union to declare semantic value type
*/
			<</desc>>

			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}

%union%{
	case boolean of
	true: (nVal: integer);
	false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location%{
	firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
	sentenceNo: integer;
%}
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-01----------------->>>


<<<----------case: /basic/declare/svt-decl-02----------------->>>
	<<case "svt-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define svt-to-be union in definition header
			and declare it as semantic value type by %union 
*/
			<</desc>>

			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;

	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location%{
	firstLine: integer;
	firstColumn: integer;
	lastLine: integer;
	lastColumn: integer;
	sentenceNo: integer;
%}
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-02----------------->>>

<<<----------case: /basic/declare/svt-decl-03----------------->>>
	<<case "svt-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 1
*/
			<</desc>>

			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	

	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;
			<</location_code>>

			<<union_decl>>
%union mysvt_t
%union%{
	nVal: integer;
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-03----------------->>>

<<<----------case: /basic/declare/svt-decl-04----------------->>>
	<<case "svt-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of semantic value type
			 of case 2
*/
			<</desc>>
			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;

type
	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>

			<<union_decl>>
%union%{
	case boolean of
	true: (nVal: integer);
	false: (nPair: npair_t);
%}

%union%{
	nVal: integer;
%}
			<</union_decl>>
			<<location_decl>>
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
%}

%union mysvt_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/svt-decl-04----------------->>>

<<<----------case: /basic/declare/loc-decl-01----------------->>>
	<<case "loc-decl-01" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: define location-to-be struct in definition header
			and declare it as location type by %location 
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}
%union%{
	case boolean of
	true: (nVal: integer);
	false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location myloc_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-01----------------->>>

<<<----------case: /basic/declare/loc-decl-02----------------->>>
	<<case "loc-decl-02" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 1
*/
			<</desc>>

			<<union_code>>
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;

type
	mysvt_t = record
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
	end;
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;
			<</location_code>>

			<<union_decl>>
%union mysvt_t
			<</union_decl>>
			<<location_decl>>
%location myloc_t
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
%}
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-02----------------->>>

<<<----------case: /basic/declare/loc-decl-03----------------->>>
	<<case "loc-decl-03" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 2
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
type
	myloc_t = record
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
	end;

	illegal_loc_t = record
		firstLine: integer;
		lastLine: integer;
	end;
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}

%union%{
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
%}

%location illegal_loc_t
			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-03----------------->>>

<<<----------case: /basic/declare/loc-decl-04----------------->>>
	<<case "loc-decl-04" make="basic-make-template">>
		<<script "basic-sentinfo-template">>
			<<desc>>/*
	feature to test: duplicate declaration of location type
			 of case 3
*/
			<</desc>>
			<<union_code>>
			<</union_code>>
			<<location_code>>
			<</location_code>>

			<<union_decl>>
%header%{
type
	npair_t = record
		wordCounter: integer;
		charCounter: integer;
	end;
	
%}

%union%{
		case boolean of
		true: (nVal: integer);
		false: (nPair: npair_t);
%}
			<</union_decl>>
			<<location_decl>>
%location%{
		firstLine: integer;
		firstColumn: integer;
		lastLine: integer;
		lastColumn: integer;
		sentenceNo: integer;
%}
%location%{
	firstLine: integer;
	lastLine: integer;
%}
%location int

			<</location_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-sentinfo-template">>
		<</ufile>>
		<<textfile "test.input">>
I am programming enthusiast. And I want to program all my life. Is it incredible for you?
Yes, I think so, I think so.
In fact, I think you are quite mad, strongheaded, over-conceited.
		<</textfile>>
		<<textfile "result.out">>
S1	4 words;	28 characters.
S2	8 words;	35 characters.
S3	5 words;	26 characters.
S4	7 words;	29 characters.
S5	10 words;	66 characters.
Words: 34
Chars: 185
Sents: 6
Lines: 3
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/loc-decl-04----------------->>>

<<<----------case: /basic/declare/parse-param-01----------------->>>
	<<case "parse-param-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param 
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-01----------------->>>

<<<----------case: /basic/declare/parse-param-02----------------->>>
	<<case "parse-param-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare parameters for yyparse 
			by %formal-param and %actual-param,
			but declare more than once
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}

/* if it were to use this declaration, Pascal compiler would have complained */
%formal-param%{illegal_declaration: integer%}
%actual-param%{illegal_variable%}
			<</parse_param>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
		
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-param-02----------------->>>


<<<----------case: /basic/declare/destructor-01----------------->>>
	<<case "destructor-01" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 1: destructor specified by symbol
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard head: ', $$);
	stack_pop();
%} TagHead

%destructor%{
	writeln('discard head: ', $$);
%} '('

%destructor%{
	writeln('discard tail: ', $$);
%} ')'
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard head: tables
discard head: table
discard head: table
discard head: body
discard head: html
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-01----------------->>>


<<<----------case: /basic/declare/destructor-02----------------->>>
	<<case "destructor-02" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 2: destructor for untagged symbols
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard undefined symbol.');
%} <>
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-02----------------->>>

<<<----------case: /basic/declare/destructor-03----------------->>>
	<<case "destructor-03" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 3: destructor specified by semantic value type
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard tag: ', $$, '.');
%} <pchval>

%destructor%{
	writeln('discard at level: ', $$, '.');
%} <level>
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>

<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard tag: tables.
discard at level: 4.
discard tag: table.
discard at level: 3.
discard tag: table.
discard at level: 2.
discard tag: body.
discard at level: 1.
discard tag: html.
discard at level: 0.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-03----------------->>>


<<<----------case: /basic/declare/destructor-04----------------->>>
	<<case "destructor-04" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: different kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard head: ', $$, '.');
	stack_pop();
%} TagHead

%destructor%{
	writeln('discard head: ', $$, '.');
%} '('

%destructor%{
	writeln('discard tag: ', $$, '.');
%} <pchval>

%destructor%{
	writeln('discard at level: ', $$, '.');
%} <level>
			<</destructor>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>

<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-04----------------->>>


<<<----------case: /basic/declare/destructor-05----------------->>>
	<<case "destructor-05" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare destructors by %destructor
			case 4: all kinds of destructors mixed together
*/
			<</desc>>

			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

			<<destructor>>
/* destructor declarations */
%destructor%{
	writeln('discard head: ', $$, '.');
	stack_pop();
%} TagHead

%destructor%{
	writeln('discard head: ', $$, '.');
%} '('

%destructor%{
	writeln('discard tag: ', $$, '.');
%} <pchval>

%destructor%{
	writeln('discard at level: ', $$, '.');
%} <level>

%destructor%{
	writeln('discard undefined symbol.');
%} <>
			<</destructor>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
<tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
				<tables>
Error: syntax error at 2:9.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard undefined symbol.
discard head: tables.
discard at level: 4.
discard head: table.
discard at level: 3.
discard head: table.
discard at level: 2.
discard head: body.
discard at level: 1.
discard head: html.
discard at level: 0.
max depth: 5	number of parenthese: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/destructor-05----------------->>>

<<<----------case: /basic/declare/parsevar-decl----------------->>>
	<<case "parsevar-decl" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare local variables in yyparse 
			by %parsevar-decl
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
var
	tpl: triple_t;
%}
%parsevar-init%{
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
%}
			<</parsevar_decl>>

			<<exprs_action>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-decl----------------->>>

<<<----------case: /basic/declare/parsevar-init----------------->>>
	<<case "parsevar-init" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: initialize local variables in yyparse 
			by %parsevar-init
*/
			<</desc>>

			<<parsevar_decl>>
%parsevar-decl%{
	tpl: triple_t;
%}
			<</parsevar_decl>>

			<<parsevar_init>>
%parsevar-init%{
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
%}
			<</parsevar_init>>

			<<exprs_action>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</exprs_action>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
		<</ufile>>
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parsevar-init----------------->>>

<<<----------case: /basic/declare/start-symbol----------------->>>
	<<case "start-symbol" make="basic-make-template">>
		<<script "basic-tagchecker-template">>
			<<desc>>/*
	feature to test: declare start symbol by %start
*/
			<</desc>>
			<<start_symbol>>
%start SText
			<</start_symbol>>
			<<parse_param>>
/* parameters for yyparse */
%formal-param%{var tpl: triple_t%}
%actual-param%{tpl%}
			<</parse_param>>

		<</script>>
		
		<<ufile "testexe.pas" "testexe-basic-tagchecker-template">>
			
<<local_var_decl>>
var
	tpl: triple_t;
<</local_var_decl>>
		<<before_yyparse>>
	tpl.maxdep := 0;
	tpl.curdep := 0;
	tpl.pairnum := 0;
			<</before_yyparse>>

			<<yyparse_param>>tpl<</yyparse_param>>

			<<after_yyparse>>
	writeln('max depth: ', tpl.maxdep, #9'number of parenthese: ', tpl.pairnum);
			<</after_yyparse>>
		<</ufile>>
		
		<<textfile "test.input">>
<html><body><table><table>
</tables></table></table></body></html>
		<</textfile>>
		<<textfile "result.out">>
<html>
	<body>
		<table>
			<table>
Error: syntax error at 2:1.
			</table>
		</table>
	</body>
</html>
Tag checking passed.
Input text is accepted by tag-check grammar.
max depth: 4	number of parenthese: 4
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/start-symbol----------------->>>

<<<----------case: /basic/declare/dprec-rrc----------------->>>
	<<case "dprec-rrc" make="basic-make-template">>
		<<script "script-dprec-rrc">>
		<</script>>
		<<ufile "testexe.pas" "testexe-script-dprec-rrc">>
		<</ufile>>
		<<textfile "test.input">>
(func a b (sub c d))
(+ (* a (/ b (^ c (* (% d e) f)))) (sin (cos (tan (exp x)))))
(define myfun (a b)
	(cond a) ((display a))
	(else) ((display b))
)
		<</textfile>>
		<<textfile "result.out">>
[func a b [sub c d]]
[+ [* a [/ b [^ c [* [% d e] f]]]] [sin [cos [tan [exp x]]]]]
[define myfun [a b]
	[cond a] [[display a]]
	[else] [[display b]]
]
Done!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/dprec-rrc----------------->>>

<<<----------case: /basic/declare/lex-init-action----------------->>>
	<<case "lex-init-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare lex initialization action by %lex-init
*/
			<</desc>>
			<<init_code>>
var
// integer counter
	ic: integer = 0;
// real(excluding integer) counter
	rc: integer = 0;
// operator counter
	oc: integer = 0;
// number of matched pattern
	mc: integer = 0;
// discarded symbols;
	dc: integer = 0;
			<</init_code>>
			<<lex_init>>
%lex-init%{ writeln('start scanning...');%}
			<</lex_init>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
start scanning...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
start scanning...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lex-init-action----------------->>>


<<<----------case: /basic/declare/pre-match-action----------------->>>
	<<case "pre-match-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare pre-match action (just ahead of any lexical action)
			 by %pre-match
*/
			<</desc>>
			<<init_code>>
var
// integer counter
	ic: integer = 0;
// real(excluding integer) counter
	rc: integer = 0;
// operator counter
	oc: integer = 0;
// number of matched pattern
	mc: integer = 0;
// discarded symbols;
	dc: integer = 0;
			<</init_code>>
			<<pre_match>>
%pre-match%{ if yyleng > 0 then mc := mc + 1; %}
			<</pre_match>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 54
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 83
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/pre-match-action----------------->>>


<<<----------case: /basic/declare/lexvar-decl----------------->>>
	<<case "lexvar-decl" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare local variables for yylex by %lexvar-decl or %lvar-decl
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
var
// integer counter
	ic: integer;
// real(excluding integer) counter
	rc: integer;
// operator counter
	oc: integer;
// number of matched pattern
	mc: integer;
// discarded symbols;
	dc: integer;
%}
%lvar-init%{
		ic := 0;
		rc := 0;
		oc := 0;
		mc := 0;
		dc := 0;
%}
			<</lvar_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-decl----------------->>>


<<<----------case: /basic/declare/lexvar-init----------------->>>
	<<case "lexvar-init" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: initialize local variables for yylex by %lexvar-init or %lvar-init
*/
			<</desc>>
			<<lvar_decl>>
%lvar-decl%{
var
// integer counter
	ic: integer;
// real(excluding integer) counter
	rc: integer;
// operator counter
	oc: integer;
// number of matched pattern
	mc: integer;
// discarded symbols;
	dc: integer;
%}
			<</lvar_decl>>

			<<lvar_init>>
%lvar-init%{ ic := 0; rc := 0; oc := 0; mc := 0; dc := 0; %}
			<</lvar_init>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 0
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexvar-init----------------->>>

<<<----------case: /basic/declare/yywrap-action----------------->>>
	<<case "yywrap-action" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: declare yywrap action by %yywrap
*/
			<</desc>>
			<<init_code>>
var
// integer counter
	ic: integer = 0;
// real(excluding integer) counter
	rc: integer = 0;
// operator counter
	oc: integer = 0;
// number of matched pattern
	mc: integer = 0;
// discarded symbols;
	dc: integer = 0;
			<</init_code>>
			<<yywrap>>
%yywrap%{
	writeln('file switching ...');
	result := false;
%}
			<</yywrap>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 0
file switching ...
number of integers: 13
number of reals: 5
number of operators: 9
number of discarded symbols: 27
number of matched patterns: 0
file switching ...
number of integers: 16
number of reals: 11
number of operators: 14
number of discarded symbols: 42
number of matched patterns: 0
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/yywrap-action----------------->>>

<<<----------case: /basic/declare/lexical-actions----------------->>>
	<<case "lexical-actions" make="basic-make-template">>
		<<script "basic-extr-numopr-template">>
			<<desc>>/*
	feature to test: using %lex-init %pre-match
			%lexvar-decl %lexvar-init %yywrap
*/
			<</desc>>
<<lvar_decl>>
%lvar-decl%{
var
// integer counter
	ic: integer;
// real(excluding integer) counter
	rc: integer;
// operator counter
	oc: integer;
// number of matched pattern
	mc: integer;
// discarded symbols;
	dc: integer;
%}
<</lvar_decl>>

<<lvar_init>>
%lvar-init%{ ic := 0; rc := 0; oc := 0; mc := 0; dc := 0; %}
<</lvar_init>>

<<lex_init>>
%lex-init%{ writeln('start scanning...');%}
<</lex_init>>

<<pre_match>>
%pre-match%{ if yyleng > 0 then mc := mc + 1; %}
<</pre_match>>

<<yywrap>>
%yywrap%{
	if yy_has_buffer then begin
		writeln('file switching ...');
		result := false;
	end;
%}
<</yywrap>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-extr-numopr-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
2.817 ^ 3
3.1415926 / 2
+00.618 * 0.618
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907 =
		<</textfile>>
		<<textfile "result.out">>
start scanning...
file switching ...
number of integers: 6
number of reals: 4
number of operators: 3
number of discarded symbols: 11
number of matched patterns: 24
start scanning...
file switching ...
number of integers: 7
number of reals: 1
number of operators: 6
number of discarded symbols: 16
number of matched patterns: 30
start scanning...
file switching ...
number of integers: 3
number of reals: 6
number of operators: 5
number of discarded symbols: 15
number of matched patterns: 29
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/lexical-actions----------------->>>


<<<----------case: /basic/declare/token-decl-01----------------->>>
	<<case "token-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 1
*/
			<</desc>>
			<<token_decl>>
%token '+' '-'
%token '*' '/'
%token '^'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-01----------------->>>

<<<----------case: /basic/declare/token-decl-02----------------->>>
	<<case "token-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 2
*/
			<</desc>>
			<<token_decl>>
%token '\+' '\-'
%token '\*' '\/'
%token '\^'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-02----------------->>>

<<<----------case: /basic/declare/token-decl-03----------------->>>
	<<case "token-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2b' '\x2d'
/* '*' '/' */
%token '\x2a' '\x2f'
/* '^' */
%token '\x5e'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-03----------------->>>

<<<----------case: /basic/declare/token-decl-04----------------->>>
	<<case "token-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\X2B' '\X2D'
/* '*' '/' */
%token '\X2A' '\X2F'
/* '^' */
%token '\X5E'
			<</token_decl>>
		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-04----------------->>>


<<<----------case: /basic/declare/token-decl-05----------------->>>
	<<case "token-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\x2B' '\X2d'
/* '*' '/' */
%token '\X2a' '\x2F'
/* '^' */
%token '\X5E'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-05----------------->>>


<<<----------case: /basic/declare/token-decl-06----------------->>>
	<<case "token-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare tokens by %token
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%token '\053' '\055'
/* '*' '/' */
%token '\052' '\057'
/* '^' */
%token '\136'
			<</token_decl>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
		       -64.0000[REAL]
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/token-decl-06----------------->>>


<<<----------case: /basic/declare/type-decl----------------->>>
	<<case "type-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare types(also called non-terminals) in grammar
			by %type
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<type_decl>>
%type<nVal> Lines Task
			<</type_decl>>

			<<other_decl>>
%destructor%{
	writeln($$, ' lines included in this task.');
%} Task
			<</other_decl>>

			<<type_action_0>>
$$ := $1;
			<</type_action_0>>
			<<type_action_1>>
$$ := $1 + 1;
			<</type_action_1>>
			<<type_action_2>>
$$ := 0;
			<</type_action_2>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
14 lines included in this task.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/type-decl----------------->>>


<<<----------case: /basic/declare/left-decl-01----------------->>>
	<<case "left-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 1
*/
			<</desc>>
			<<token_decl>>
%left '+' '-'
%left '*' '/'
%left '^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-01----------------->>>

<<<----------case: /basic/declare/left-decl-02----------------->>>
	<<case "left-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 2
*/
			<</desc>>
			<<token_decl>>
%left '\+' '\-'
%left '\*' '\/'
%left '\^'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-02----------------->>>

<<<----------case: /basic/declare/left-decl-03----------------->>>
	<<case "left-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%left '\x5e'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-03----------------->>>

<<<----------case: /basic/declare/left-decl-04----------------->>>
	<<case "left-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-04----------------->>>


<<<----------case: /basic/declare/left-decl-05----------------->>>
	<<case "left-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%left '\X5E'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-05----------------->>>


<<<----------case: /basic/declare/left-decl-06----------------->>>
	<<case "left-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %left
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%left '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%left '\136'
%left SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
		         0.5236[REAL]
10-3-5-9
		-7[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5Error: domain error, x is negative while y is non-integer.

3/3/3/3/3
		0[INT]
3-3-3-3-3-3
		-12[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/left-decl-06----------------->>>


<<<----------case: /basic/declare/right-decl-01----------------->>>
	<<case "right-decl-01" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 1
*/
			<</desc>>
			<<token_decl>>
%right '+' '-'
%right '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-01----------------->>>

<<<----------case: /basic/declare/right-decl-02----------------->>>
	<<case "right-decl-02" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 2
*/
			<</desc>>
			<<token_decl>>
%right '\+' '\-'
%right '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-02----------------->>>

<<<----------case: /basic/declare/right-decl-03----------------->>>
	<<case "right-decl-03" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2b' '\x2d'
/* '*' '/' */
%right '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-03----------------->>>

<<<----------case: /basic/declare/right-decl-04----------------->>>
	<<case "right-decl-04" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\X2B' '\X2D'
/* '*' '/' */
%right '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-04----------------->>>


<<<----------case: /basic/declare/right-decl-05----------------->>>
	<<case "right-decl-05" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\x2B' '\X2d'
/* '*' '/' */
%right '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-05----------------->>>


<<<----------case: /basic/declare/right-decl-06----------------->>>
	<<case "right-decl-06" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %right
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%right '\053' '\055'
/* '*' '/' */
%right '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/right-decl-06----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>
	<<case "nonassoc-decl-01" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 1
*/
			<</desc>>
			<<token_decl>>
%nonassoc '+' '-'
%left '*' '/'
%right '^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-01----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>
	<<case "nonassoc-decl-02" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: disable associativity by %nonassoc
		case 2
*/
			<</desc>>
			<<token_decl>>
%nonassoc '\+' '\-'
%left '\*' '\/'
%right '\^'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-02----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>
	<<case "nonassoc-decl-03" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 3
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2b' '\x2d'
/* '*' '/' */
%left '\x2a' '\x2f'
/* '^' */
%right '\x5e'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-03----------------->>>

<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>
	<<case "nonassoc-decl-04" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 4
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\X2B' '\X2D'
/* '*' '/' */
%left '\X2A' '\X2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-04----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>
	<<case "nonassoc-decl-05" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 5
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\x2B' '\X2d'
/* '*' '/' */
%left '\X2a' '\x2F'
/* '^' */
%right '\X5E'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-05----------------->>>


<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>
	<<case "nonassoc-decl-06" make="make-no-exec">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: resolve shift/reduce conflicts by %nonassoc
		case 6
*/
			<</desc>>
			<<token_decl>>
/* '+' '-' */
%nonassoc '\053' '\055'
/* '*' '/' */
%left '\052' '\057'
/* '^' */
%right '\136'
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
Error: associativity of the symbol `'+'' is forbidden.
Error: associativity of the symbol `'-'' is forbidden.
conflicts: 4 shift/reduce.
Error: No code generated for script `script.upg', due to some errors.
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/nonassoc-decl-06----------------->>>


<<<----------case: /basic/declare/parse-init-decl----------------->>>
	<<case "parse-init-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's initialization action by %parse-init,
			which is performed immediate before yyparse is ready to parsing 
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_init>>
%parse-init%{
	writeln('Let''s get down to work.');
	errors := 0;
%}
			<</parse_init>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
Let's get down to work.
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-init-decl----------------->>>


<<<----------case: /basic/declare/parse-exit-decl----------------->>>
	<<case "parse-exit-decl" make="basic-make-template">>
		<<script "basic-fdc-template">>
			<<desc>>/*
	feature to test: declare yyparse's exit action by %parse-exit,
			which is performed immediate before return from yyparse
*/
			<</desc>>
			<<token_decl>>
%right SIGN
			<</token_decl>>

<<prec_refer>>%prec SIGN<</prec_refer>>

			<<parse_exit>>
%parse-exit%{
	if errors > 0 then
		writeln(errors, ' errors occurred.');
	writeln('Well done! Thank you for your excellent work, Mr. Parser.');
%}
			<</parse_exit>>

		<</script>>
		<<ufile "testexe.pas" "testexe-basic-fdc-template">>
		<</ufile>>
		<<textfile "test.input">>
#open "test1.input"
#open "test2.input"
60.0 * 59.99 * 365.26
33 / 2.0
59.27 * 23.99
+7 - 25
		<</textfile>>
		<<textfile "test1.input">>
0+1+3+5
3.1415926 / 2 / 3
10-3-5-9
		<</textfile>>
		<<textfile "test2.input">>
0.6268 - -34
77 + 917
3670 + 643 + 12 + 907
-16^1.5
3/3/3/3/3
3-3-3-3-3-3
12/45*(34-13*(5 -7))/35
		<</textfile>>
		<<textfile "result.out">>
0+1+3+5
		9[INT]
3.1415926 / 2 / 3
Error: divided by zero!
10-3-5-9
		3[INT]
0.6268 - -34
		        34.6268[REAL]
77 + 917
		994[INT]
3670 + 643 + 12 + 907
		5232[INT]
-16^1.5
Error: domain error, x is negative while y is non-integer.
3/3/3/3/3
		3[INT]
3-3-3-3-3-3
		0[INT]
12/45*(34-13*(5 -7))/35
		0[INT]
60.0 * 59.99 * 365.26
		   1314716.8440[REAL]
33 / 2.0
		        16.5000[REAL]
59.27 * 23.99
		      1421.8873[REAL]
+7 - 25
		-18[INT]
2 errors occurred.
Well done! Thank you for your excellent work, Mr. Parser.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/declare/parse-exit-decl----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/declare ---------------->>>


<<<----------sub-suite: /basic/interface -------------->>>
	<<suite  "interface" make="subdir-makefile-template">>


<<<----------case: /basic/interface/buffer-stack----------------->>>
	<<case "buffer-stack" make="basic-make-template">>
		<<script "interface-bstack-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-bstack-template">>
		<</ufile>>

		<<textfile "test.input">>
***************************************
test lcase number test1
lcase> open "cur?*************************
in lcase
abcdefg
close hijklm"
cur?
number> open 'cur?************************
in number
1234567
pop
89'
cur?
test1> open `test1.input`
pop
closing can not be executed, because of popping action
close
text ignored
		<</textfile>>

		<<textfile "test1.input">>
cur?**************************
in test1 test2 ucase
test2> open `test2.input`
cur?
ucase> open "cur?************************
ABCDEF
pop
XYZ"

******************test yy_push_buffer***********************
test2> push `test2.input`
******************test yy_push_buffer***********************
test3> push `test3.input`

pop
abortion can not executed, because of popping action
 
abort
		<</textfile>>

		<<textfile "test2.input">>
cur?**************************
in test2 chinese test3
chinese> open "
测试文本
close
此处文本应该看不见Over"
test3> open `test3.input`
close
test ignored
		<</textfile>>

		<<textfile "test3.input">>
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
		<</textfile>>

		<<textfile "result.out">>
***************************************
test lcase number test1
current buffer: lcase
*************************
in lcase
abcdefg
closing buffer lcase ...
switching to buffer test ...

current buffer: test

current buffer: number
************************
in number
1234567
popping buffer number ...
switching to buffer test ...

current buffer: test

current buffer: test1
**************************
in test1 test2 ucase
current buffer: test2
**************************
in test2 chinese test3

测试文本
closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

current buffer: test1

current buffer: ucase
************************
ABCDEF
popping buffer ucase ...
switching to buffer test1 ...


******************test yy_push_buffer***********************
current buffer: test2
**************************
in test2 chinese test3

测试文本
closing buffer chinese ...
switching to buffer test2 ...

current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.

closing buffer test2 ...
switching to buffer test1 ...

******************test yy_push_buffer***********************
current buffer: test3
*********************************
in test3.input cbuffer
current buffer: cbuffer
*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
closing buffer cbuffer ...
switching to buffer test3 ...

restarting buffer test3 ...
cur?*********************************
in test3.input cbuffer
cbuffer> open 'cur?*********************************
beautiful mind is the one that can forget things quickly.
specially painful experience.
close
no more comments'
restart
buffer `test3' is coming.
buffer `test3' is abort to leave.


popping buffer test1 ...
switching to buffer test ...

popping buffer test ...
All buffers closed.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/buffer-stack----------------->>>

<<<----------case: /basic/interface/ECHO----------------->>>
	<<case "ECHO" make="basic-make-template">>
		<<script "interface-echo-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-echo-template">>
		<</ufile>>

		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/ECHO----------------->>>


<<<----------case: /basic/interface/get-bol----------------->>>
	<<case "get-bol" make="basic-make-template">>
		<<script "interface-getbol-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-getbol-template">>
		<</ufile>>
		<<textfile "test.input">>
01	0x01
02	0x02
03	0x03
04	0x04
05	0x05
06	0x06
07	0x07
08	0x08
09	0x09
10	0x10
		<</textfile>>

		<<textfile "result.out">>
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/get-bol----------------->>>


<<<----------case: /basic/interface/line-editor----------------->>>
	<<case "line-editor" make="basic-make-template">>
		<<script "interface-line-editor-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-line-editor-template">>
		<</ufile>>

		<<textfile "test.input">>
Just e!01image!01ine, what is goning to be link!02ke if you are travelling in the outer space.!!no useful
Simply beatui!03utiful, yes that must &be very @-05good.
Hey&, wait a minute@01 it's simply &too good @02 be true. Please &stop, @04 dreaming&!&!&!
		<</textfile>>

		<<textfile "result.out">>
Just imagine, what is goning to be like if you are travelling in the outer space.
Simply beautiful, yes that must be very very good.
Hey, wait a minute, it's simply too good to be true. Please stop, stop dreaming!!!
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/line-editor----------------->>>


<<<----------case: /basic/interface/loc2----------------->>>
	<<case "loc2" make="basic-make-template">>
		<<script "interface-loc2-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-loc2-template">>
		<</ufile>>

		<<textfile "test.input">>
#location_head
%$103
%%$$205
%%%$$$307
%%%%$$$$409
%%%%%$$$$$511
%%%%%%$$$$$$613
%%%%%%%$$$$$$$715
%%%%%%%%$$$$$$$$817

%a02%a06$a10
%%%%$$$$b09
%%%%$$$c08
%%%%$$d07
%%%%$$$$$%%%$%%%$$%%%$%%$$$$$$$e32
#location_tail


#location_head
%	109 %%		125 %%%			149 %%%%				189 %%%%%					1d7 %%%%%%						1j3 %%%%%%%							1p7 %%%%%%%%								1w9  %1x5%1x9	1y5 %%%%				1C5 %%%%			1F7 %%%%		1I1 %%%%	1J7
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#location_tail


#location_head
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#location_tail



tab=8

#tab_replace 0
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#tab_replace

tab?

#line_replace 1
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#line_replace




#orignal 2
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%					%%%	%%%		%%%	%%							ec9
#orignal



#orignal 3
%	109
%%		217
%%%			325
%%%%				433
%%%%%					541
%%%%%%						649
%%%%%%%							757
%%%%%%%%								873

%a02%a06	a17
%%%%				b33
%%%%			c25
%%%%		d17
%%%%	e09
#orignal

		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
after reseting, line: 1	col: 1
begin scanning tab_replace section by referrence 0
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning tab_replace section is over
begin comparing location(size 15) 0 and its referrence(size 15)
tabsize = 8
after reseting, line: 1	col: 1
begin scanning line_replace section by referrence 1
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning line_replace section is over
begin comparing location(size 15) 1 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 2
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 2 and its referrence(size 15)
after reseting, line: 1	col: 1
begin scanning orignal section by referrence 3
before putback, line: 16	col: 1
after putback, line: 1	col: 1
scanning orignal section is over
begin comparing location(size 15) 3 and its referrence(size 15)
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc2----------------->>>

<<<----------case: /basic/interface/loc1----------------->>>
	<<case "loc1" make="basic-make-template">>
		<<script "interface-location-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-location-template">>
		<</ufile>>
		
		<<textfile "test.input">>
tab=8
<test1.input>	217
301 305 309	317		333 337  342   348    355     363	373
tab=6
<test2.input>	519
601 605 609	613		625 629  634   640    647     655	661
		<</textfile>>

		<<textfile "test1.input">>
tab?
 202 206  211	217			229	233
tab=1	307
 402 406  411	415			421	425	
		<</textfile>>

		<<textfile "test2.input">>
tab=3
   204	210	216			228 232
tab?	307
		<</textfile>>

		<<textfile "result.out">>
tabsize is 8 now
file `test1.input` is open.
tabsize = 4
tabsize is 1 now
file closed.
tabsize is 6 now
file `test2.input` is open.
tabsize is 3 now
tabsize = 3
file closed.
file closed.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/loc1----------------->>>



<<<----------case: /basic/interface/yyerror----------------->>>
	<<case "yyerror" make="basic-make-template">>
		<<script "interface-yyerror-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-interface-yyerror-template">>
		<</ufile>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9

		<</textfile>>

		<<textfile "result.out">>
Redirect to my error-handler ---- Error: syntax error at 1:7.
Redirect to my error-handler ---- Error: syntax error at 2:1.
Redirect to my error-handler ---- Error: syntax error at 3:1.
Redirect to my error-handler ---- Error: syntax error at 4:1.
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/yyerror----------------->>>


<<<----------case: /basic/interface/esc-char-inaction----------------->>>
	<<case "esc-char-inaction" make="basic-make-template">>
		<<script "esc-char-inaction-template">>
		<</script>>
		<<ufile "testexe.pas" "testexe-esc-char-inaction-template">>
		<</ufile>>

		<<textfile "test.input">>
1 2 3 begin ...
add 1, 2
sub 2 10
div 10 9
end
well done!

		<</textfile>>

		<<textfile "result.out">>
in parsevar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$1 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 1
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 2
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 3
$$ is used to count number of numbers, and $$ is 3
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is begin
$$ is used to count number of numbers, and $$ is 3
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is add
$$ is used to count number of numbers, and $$ is 3
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 1
$$ is used to count number of numbers, and $$ is 4
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 5
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is sub
$$ is used to count number of numbers, and $$ is 5
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 2
$$ is used to count number of numbers, and $$ is 6
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 7
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is div
$$ is used to count number of numbers, and $$ is 7
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 10
$$ is used to count number of numbers, and $$ is 8
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a number, its value is 9
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is end
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is well
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
$2 is a C-style ID, its value is done
$$ is used to count number of numbers, and $$ is 9
in lexvar-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in lex-init: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in yywrap: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in pre-match: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in destruct<>: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
in parse-exit: $$ $0 $12 $<nVal>$ $<nVal>3 %} @4 @$ %}
		<</textfile>>
		<<textfile "result.err">>
		<</textfile>>
	<</case>>
<<<----------case: /basic/interface/esc-char-inaction----------------->>>

	<</suite>>
<<<----------sub-suite: /basic/interface -------------->>>


<</suite>>
<<<----------sub-suite: /basic ---------------->>>


<</suites>>
<<<----------top-suite: /-------------------->>>

<<conf make="config-template">>
<<version>>0.50.101<</version>>
<<email>>upgen.tools@yahoo.com<</email>>
<<diff>>diff<</diff>>
<</conf>>

